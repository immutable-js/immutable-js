{"version":3,"sources":["../../../node_modules/browser-pack/_prelude.js","../../../dist/immutable.js","../../../node_modules/base64-js/index.js","../../../node_modules/buffer/index.js","../../../node_modules/ieee754/index.js","../../../node_modules/marked/lib/marked.js","../../../node_modules/process/browser.js","../../../node_modules/react-router/modules/actions/LocationActions.js","../../../node_modules/react-router/modules/behaviors/ImitateBrowserBehavior.js","../../../node_modules/react-router/modules/behaviors/ScrollToTopBehavior.js","../../../node_modules/react-router/modules/components/DefaultRoute.js","../../../node_modules/react-router/modules/components/Link.js","../../../node_modules/react-router/modules/components/NotFoundRoute.js","../../../node_modules/react-router/modules/components/Redirect.js","../../../node_modules/react-router/modules/components/Route.js","../../../node_modules/react-router/modules/components/RouteHandler.js","../../../node_modules/react-router/modules/index.js","../../../node_modules/react-router/modules/locations/HashLocation.js","../../../node_modules/react-router/modules/locations/HistoryLocation.js","../../../node_modules/react-router/modules/locations/RefreshLocation.js","../../../node_modules/react-router/modules/mixins/FakeNode.js","../../../node_modules/react-router/modules/mixins/Navigation.js","../../../node_modules/react-router/modules/mixins/NavigationContext.js","../../../node_modules/react-router/modules/mixins/RouteHandler.js","../../../node_modules/react-router/modules/mixins/Scrolling.js","../../../node_modules/react-router/modules/mixins/State.js","../../../node_modules/react-router/modules/mixins/StateContext.js","../../../node_modules/react-router/modules/utils/Cancellation.js","../../../node_modules/react-router/modules/utils/History.js","../../../node_modules/react-router/modules/utils/Path.js","../../../node_modules/react-router/modules/utils/Promise.js","../../../node_modules/react-router/modules/utils/PropTypes.js","../../../node_modules/react-router/modules/utils/Redirect.js","../../../node_modules/react-router/modules/utils/Transition.js","../../../node_modules/react-router/modules/utils/createRouter.js","../../../node_modules/react-router/modules/utils/createRoutesFromChildren.js","../../../node_modules/react-router/modules/utils/getWindowScrollPosition.js","../../../node_modules/react-router/modules/utils/reversedArray.js","../../../node_modules/react-router/modules/utils/runRouter.js","../../../node_modules/react-router/modules/utils/supportsHistory.js","../../../node_modules/react-router/node_modules/qs/index.js","../../../node_modules/react-router/node_modules/qs/lib/index.js","../../../node_modules/react-router/node_modules/qs/lib/parse.js","../../../node_modules/react-router/node_modules/qs/lib/stringify.js","../../../node_modules/react-router/node_modules/qs/lib/utils.js","../../../node_modules/react-router/node_modules/when/lib/Promise.js","../../../node_modules/react-router/node_modules/when/lib/Queue.js","../../../node_modules/react-router/node_modules/when/lib/Scheduler.js","../../../node_modules/react-router/node_modules/when/lib/async.js","../../../node_modules/react-router/node_modules/when/lib/makePromise.js","../../../node_modules/react/lib/CSSCore.js","../../../node_modules/react/lib/ExecutionEnvironment.js","../../../node_modules/react/lib/Object.assign.js","../../../node_modules/react/lib/ReactTransitionEvents.js","../../../node_modules/react/lib/cx.js","../../../node_modules/react/lib/emptyFunction.js","../../../node_modules/react/lib/invariant.js","../../../node_modules/react/lib/warning.js","../../../package.json","../../generated/immutable.d.json","../../lib/TypeKind.js","../../lib/collectMemberGroups.js","../../lib/getTypeDefs.js","../../lib/markdown.js","../../lib/markdownDocs.js","../../lib/prism.js","../../lib/runkit-embed.js","src/Defs.js","src/DocHeader.js","src/DocOverview.js","src/DocSearch.js","src/MarkDown.js","src/MemberDoc.js","src/PageDataMixin.js","src/SideBar.js","src/TypeDocumentation.js","src/index.js","src/isMobile.js","../src/Logo.js","../src/SVGSet.js","../../../resources/immutable-global.js","../../../resources/react-global.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/tLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5xBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtIA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/rBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9XA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9IA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACbA;AACA;;;;;ACDA;AACA","file":"../bundle.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/**\n * MIT License\n * \n * Copyright (c) 2014-present, Lee Byron and other contributors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Immutable = {}));\n}(this, (function (exports) { 'use strict';\n\n  var DELETE = 'delete';\n\n  // Constants describing the size of trie nodes.\n  var SHIFT = 5; // Resulted in best performance after ______?\n  var SIZE = 1 << SHIFT;\n  var MASK = SIZE - 1;\n\n  // A consistent shared value representing \"not set\" which equals nothing other\n  // than itself, and nothing that could be provided externally.\n  var NOT_SET = {};\n\n  // Boolean references, Rough equivalent of `bool &`.\n  function MakeRef() {\n    return { value: false };\n  }\n\n  function SetRef(ref) {\n    if (ref) {\n      ref.value = true;\n    }\n  }\n\n  // A function which returns a value representing an \"owner\" for transient writes\n  // to tries. The return value will only ever equal itself, and will not equal\n  // the return of any subsequent call of this function.\n  function OwnerID() {}\n\n  function ensureSize(iter) {\n    if (iter.size === undefined) {\n      iter.size = iter.__iterate(returnTrue);\n    }\n    return iter.size;\n  }\n\n  function wrapIndex(iter, index) {\n    // This implements \"is array index\" which the ECMAString spec defines as:\n    //\n    //     A String property name P is an array index if and only if\n    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n    //     to 2^321.\n    //\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n    if (typeof index !== 'number') {\n      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n      if ('' + uint32Index !== index || uint32Index === 4294967295) {\n        return NaN;\n      }\n      index = uint32Index;\n    }\n    return index < 0 ? ensureSize(iter) + index : index;\n  }\n\n  function returnTrue() {\n    return true;\n  }\n\n  function wholeSlice(begin, end, size) {\n    return (\n      ((begin === 0 && !isNeg(begin)) ||\n        (size !== undefined && begin <= -size)) &&\n      (end === undefined || (size !== undefined && end >= size))\n    );\n  }\n\n  function resolveBegin(begin, size) {\n    return resolveIndex(begin, size, 0);\n  }\n\n  function resolveEnd(end, size) {\n    return resolveIndex(end, size, size);\n  }\n\n  function resolveIndex(index, size, defaultIndex) {\n    // Sanitize indices using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    return index === undefined\n      ? defaultIndex\n      : isNeg(index)\n      ? size === Infinity\n        ? size\n        : Math.max(0, size + index) | 0\n      : size === undefined || size === index\n      ? index\n      : Math.min(size, index) | 0;\n  }\n\n  function isNeg(value) {\n    // Account for -0 which is negative, but not less than 0.\n    return value < 0 || (value === 0 && 1 / value === -Infinity);\n  }\n\n  var IS_COLLECTION_SYMBOL = '@@__IMMUTABLE_ITERABLE__@@';\n\n  function isCollection(maybeCollection) {\n    return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);\n  }\n\n  var IS_KEYED_SYMBOL = '@@__IMMUTABLE_KEYED__@@';\n\n  function isKeyed(maybeKeyed) {\n    return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);\n  }\n\n  var IS_INDEXED_SYMBOL = '@@__IMMUTABLE_INDEXED__@@';\n\n  function isIndexed(maybeIndexed) {\n    return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);\n  }\n\n  function isAssociative(maybeAssociative) {\n    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n  }\n\n  var Collection = function Collection(value) {\n    return isCollection(value) ? value : Seq(value);\n  };\n\n  var KeyedCollection = /*@__PURE__*/(function (Collection) {\n    function KeyedCollection(value) {\n      return isKeyed(value) ? value : KeyedSeq(value);\n    }\n\n    if ( Collection ) KeyedCollection.__proto__ = Collection;\n    KeyedCollection.prototype = Object.create( Collection && Collection.prototype );\n    KeyedCollection.prototype.constructor = KeyedCollection;\n\n    return KeyedCollection;\n  }(Collection));\n\n  var IndexedCollection = /*@__PURE__*/(function (Collection) {\n    function IndexedCollection(value) {\n      return isIndexed(value) ? value : IndexedSeq(value);\n    }\n\n    if ( Collection ) IndexedCollection.__proto__ = Collection;\n    IndexedCollection.prototype = Object.create( Collection && Collection.prototype );\n    IndexedCollection.prototype.constructor = IndexedCollection;\n\n    return IndexedCollection;\n  }(Collection));\n\n  var SetCollection = /*@__PURE__*/(function (Collection) {\n    function SetCollection(value) {\n      return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);\n    }\n\n    if ( Collection ) SetCollection.__proto__ = Collection;\n    SetCollection.prototype = Object.create( Collection && Collection.prototype );\n    SetCollection.prototype.constructor = SetCollection;\n\n    return SetCollection;\n  }(Collection));\n\n  Collection.Keyed = KeyedCollection;\n  Collection.Indexed = IndexedCollection;\n  Collection.Set = SetCollection;\n\n  var IS_SEQ_SYMBOL = '@@__IMMUTABLE_SEQ__@@';\n\n  function isSeq(maybeSeq) {\n    return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);\n  }\n\n  var IS_RECORD_SYMBOL = '@@__IMMUTABLE_RECORD__@@';\n\n  function isRecord(maybeRecord) {\n    return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);\n  }\n\n  function isImmutable(maybeImmutable) {\n    return isCollection(maybeImmutable) || isRecord(maybeImmutable);\n  }\n\n  var IS_ORDERED_SYMBOL = '@@__IMMUTABLE_ORDERED__@@';\n\n  function isOrdered(maybeOrdered) {\n    return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);\n  }\n\n  var ITERATE_KEYS = 0;\n  var ITERATE_VALUES = 1;\n  var ITERATE_ENTRIES = 2;\n\n  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\n  var Iterator = function Iterator(next) {\n    this.next = next;\n  };\n\n  Iterator.prototype.toString = function toString () {\n    return '[Iterator]';\n  };\n\n  Iterator.KEYS = ITERATE_KEYS;\n  Iterator.VALUES = ITERATE_VALUES;\n  Iterator.ENTRIES = ITERATE_ENTRIES;\n\n  Iterator.prototype.inspect = Iterator.prototype.toSource = function () {\n    return this.toString();\n  };\n  Iterator.prototype[ITERATOR_SYMBOL] = function () {\n    return this;\n  };\n\n  function iteratorValue(type, k, v, iteratorResult) {\n    var value = type === 0 ? k : type === 1 ? v : [k, v];\n    iteratorResult\n      ? (iteratorResult.value = value)\n      : (iteratorResult = {\n          value: value,\n          done: false,\n        });\n    return iteratorResult;\n  }\n\n  function iteratorDone() {\n    return { value: undefined, done: true };\n  }\n\n  function hasIterator(maybeIterable) {\n    return !!getIteratorFn(maybeIterable);\n  }\n\n  function isIterator(maybeIterator) {\n    return maybeIterator && typeof maybeIterator.next === 'function';\n  }\n\n  function getIterator(iterable) {\n    var iteratorFn = getIteratorFn(iterable);\n    return iteratorFn && iteratorFn.call(iterable);\n  }\n\n  function getIteratorFn(iterable) {\n    var iteratorFn =\n      iterable &&\n      ((REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n        iterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  function isArrayLike(value) {\n    if (Array.isArray(value) || typeof value === 'string') {\n      return true;\n    }\n\n    return (\n      value &&\n      typeof value === 'object' &&\n      Number.isInteger(value.length) &&\n      value.length >= 0 &&\n      (value.length === 0\n        ? // Only {length: 0} is considered Array-like.\n          Object.keys(value).length === 1\n        : // An object is only Array-like if it has a property where the last value\n          // in the array-like may be found (which could be undefined).\n          value.hasOwnProperty(value.length - 1))\n    );\n  }\n\n  var Seq = /*@__PURE__*/(function (Collection) {\n    function Seq(value) {\n      return value === null || value === undefined\n        ? emptySequence()\n        : isImmutable(value)\n        ? value.toSeq()\n        : seqFromValue(value);\n    }\n\n    if ( Collection ) Seq.__proto__ = Collection;\n    Seq.prototype = Object.create( Collection && Collection.prototype );\n    Seq.prototype.constructor = Seq;\n\n    Seq.prototype.toSeq = function toSeq () {\n      return this;\n    };\n\n    Seq.prototype.toString = function toString () {\n      return this.__toString('Seq {', '}');\n    };\n\n    Seq.prototype.cacheResult = function cacheResult () {\n      if (!this._cache && this.__iterateUncached) {\n        this._cache = this.entrySeq().toArray();\n        this.size = this._cache.length;\n      }\n      return this;\n    };\n\n    // abstract __iterateUncached(fn, reverse)\n\n    Seq.prototype.__iterate = function __iterate (fn, reverse) {\n      var cache = this._cache;\n      if (cache) {\n        var size = cache.length;\n        var i = 0;\n        while (i !== size) {\n          var entry = cache[reverse ? size - ++i : i++];\n          if (fn(entry[1], entry[0], this) === false) {\n            break;\n          }\n        }\n        return i;\n      }\n      return this.__iterateUncached(fn, reverse);\n    };\n\n    // abstract __iteratorUncached(type, reverse)\n\n    Seq.prototype.__iterator = function __iterator (type, reverse) {\n      var cache = this._cache;\n      if (cache) {\n        var size = cache.length;\n        var i = 0;\n        return new Iterator(function () {\n          if (i === size) {\n            return iteratorDone();\n          }\n          var entry = cache[reverse ? size - ++i : i++];\n          return iteratorValue(type, entry[0], entry[1]);\n        });\n      }\n      return this.__iteratorUncached(type, reverse);\n    };\n\n    return Seq;\n  }(Collection));\n\n  var KeyedSeq = /*@__PURE__*/(function (Seq) {\n    function KeyedSeq(value) {\n      return value === null || value === undefined\n        ? emptySequence().toKeyedSeq()\n        : isCollection(value)\n        ? isKeyed(value)\n          ? value.toSeq()\n          : value.fromEntrySeq()\n        : isRecord(value)\n        ? value.toSeq()\n        : keyedSeqFromValue(value);\n    }\n\n    if ( Seq ) KeyedSeq.__proto__ = Seq;\n    KeyedSeq.prototype = Object.create( Seq && Seq.prototype );\n    KeyedSeq.prototype.constructor = KeyedSeq;\n\n    KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq () {\n      return this;\n    };\n\n    return KeyedSeq;\n  }(Seq));\n\n  var IndexedSeq = /*@__PURE__*/(function (Seq) {\n    function IndexedSeq(value) {\n      return value === null || value === undefined\n        ? emptySequence()\n        : isCollection(value)\n        ? isKeyed(value)\n          ? value.entrySeq()\n          : value.toIndexedSeq()\n        : isRecord(value)\n        ? value.toSeq().entrySeq()\n        : indexedSeqFromValue(value);\n    }\n\n    if ( Seq ) IndexedSeq.__proto__ = Seq;\n    IndexedSeq.prototype = Object.create( Seq && Seq.prototype );\n    IndexedSeq.prototype.constructor = IndexedSeq;\n\n    IndexedSeq.of = function of (/*...values*/) {\n      return IndexedSeq(arguments);\n    };\n\n    IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq () {\n      return this;\n    };\n\n    IndexedSeq.prototype.toString = function toString () {\n      return this.__toString('Seq [', ']');\n    };\n\n    return IndexedSeq;\n  }(Seq));\n\n  var SetSeq = /*@__PURE__*/(function (Seq) {\n    function SetSeq(value) {\n      return (\n        isCollection(value) && !isAssociative(value) ? value : IndexedSeq(value)\n      ).toSetSeq();\n    }\n\n    if ( Seq ) SetSeq.__proto__ = Seq;\n    SetSeq.prototype = Object.create( Seq && Seq.prototype );\n    SetSeq.prototype.constructor = SetSeq;\n\n    SetSeq.of = function of (/*...values*/) {\n      return SetSeq(arguments);\n    };\n\n    SetSeq.prototype.toSetSeq = function toSetSeq () {\n      return this;\n    };\n\n    return SetSeq;\n  }(Seq));\n\n  Seq.isSeq = isSeq;\n  Seq.Keyed = KeyedSeq;\n  Seq.Set = SetSeq;\n  Seq.Indexed = IndexedSeq;\n\n  Seq.prototype[IS_SEQ_SYMBOL] = true;\n\n  // #pragma Root Sequences\n\n  var ArraySeq = /*@__PURE__*/(function (IndexedSeq) {\n    function ArraySeq(array) {\n      this._array = array;\n      this.size = array.length;\n    }\n\n    if ( IndexedSeq ) ArraySeq.__proto__ = IndexedSeq;\n    ArraySeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n    ArraySeq.prototype.constructor = ArraySeq;\n\n    ArraySeq.prototype.get = function get (index, notSetValue) {\n      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n    };\n\n    ArraySeq.prototype.__iterate = function __iterate (fn, reverse) {\n      var array = this._array;\n      var size = array.length;\n      var i = 0;\n      while (i !== size) {\n        var ii = reverse ? size - ++i : i++;\n        if (fn(array[ii], ii, this) === false) {\n          break;\n        }\n      }\n      return i;\n    };\n\n    ArraySeq.prototype.__iterator = function __iterator (type, reverse) {\n      var array = this._array;\n      var size = array.length;\n      var i = 0;\n      return new Iterator(function () {\n        if (i === size) {\n          return iteratorDone();\n        }\n        var ii = reverse ? size - ++i : i++;\n        return iteratorValue(type, ii, array[ii]);\n      });\n    };\n\n    return ArraySeq;\n  }(IndexedSeq));\n\n  var ObjectSeq = /*@__PURE__*/(function (KeyedSeq) {\n    function ObjectSeq(object) {\n      var keys = Object.keys(object);\n      this._object = object;\n      this._keys = keys;\n      this.size = keys.length;\n    }\n\n    if ( KeyedSeq ) ObjectSeq.__proto__ = KeyedSeq;\n    ObjectSeq.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );\n    ObjectSeq.prototype.constructor = ObjectSeq;\n\n    ObjectSeq.prototype.get = function get (key, notSetValue) {\n      if (notSetValue !== undefined && !this.has(key)) {\n        return notSetValue;\n      }\n      return this._object[key];\n    };\n\n    ObjectSeq.prototype.has = function has (key) {\n      return hasOwnProperty.call(this._object, key);\n    };\n\n    ObjectSeq.prototype.__iterate = function __iterate (fn, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var size = keys.length;\n      var i = 0;\n      while (i !== size) {\n        var key = keys[reverse ? size - ++i : i++];\n        if (fn(object[key], key, this) === false) {\n          break;\n        }\n      }\n      return i;\n    };\n\n    ObjectSeq.prototype.__iterator = function __iterator (type, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var size = keys.length;\n      var i = 0;\n      return new Iterator(function () {\n        if (i === size) {\n          return iteratorDone();\n        }\n        var key = keys[reverse ? size - ++i : i++];\n        return iteratorValue(type, key, object[key]);\n      });\n    };\n\n    return ObjectSeq;\n  }(KeyedSeq));\n  ObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;\n\n  var CollectionSeq = /*@__PURE__*/(function (IndexedSeq) {\n    function CollectionSeq(collection) {\n      this._collection = collection;\n      this.size = collection.length || collection.size;\n    }\n\n    if ( IndexedSeq ) CollectionSeq.__proto__ = IndexedSeq;\n    CollectionSeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n    CollectionSeq.prototype.constructor = CollectionSeq;\n\n    CollectionSeq.prototype.__iterateUncached = function __iterateUncached (fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var collection = this._collection;\n      var iterator = getIterator(collection);\n      var iterations = 0;\n      if (isIterator(iterator)) {\n        var step;\n        while (!(step = iterator.next()).done) {\n          if (fn(step.value, iterations++, this) === false) {\n            break;\n          }\n        }\n      }\n      return iterations;\n    };\n\n    CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached (type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var collection = this._collection;\n      var iterator = getIterator(collection);\n      if (!isIterator(iterator)) {\n        return new Iterator(iteratorDone);\n      }\n      var iterations = 0;\n      return new Iterator(function () {\n        var step = iterator.next();\n        return step.done ? step : iteratorValue(type, iterations++, step.value);\n      });\n    };\n\n    return CollectionSeq;\n  }(IndexedSeq));\n\n  // # pragma Helper functions\n\n  var EMPTY_SEQ;\n\n  function emptySequence() {\n    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n  }\n\n  function keyedSeqFromValue(value) {\n    var seq = Array.isArray(value)\n      ? new ArraySeq(value)\n      : hasIterator(value)\n      ? new CollectionSeq(value)\n      : undefined;\n    if (seq) {\n      return seq.fromEntrySeq();\n    }\n    if (typeof value === 'object') {\n      return new ObjectSeq(value);\n    }\n    throw new TypeError(\n      'Expected Array or collection object of [k, v] entries, or keyed object: ' +\n        value\n    );\n  }\n\n  function indexedSeqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n    if (seq) {\n      return seq;\n    }\n    throw new TypeError(\n      'Expected Array or collection object of values: ' + value\n    );\n  }\n\n  function seqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n    if (seq) {\n      return seq;\n    }\n    if (typeof value === 'object') {\n      return new ObjectSeq(value);\n    }\n    throw new TypeError(\n      'Expected Array or collection object of values, or keyed object: ' + value\n    );\n  }\n\n  function maybeIndexedSeqFromValue(value) {\n    return isArrayLike(value)\n      ? new ArraySeq(value)\n      : hasIterator(value)\n      ? new CollectionSeq(value)\n      : undefined;\n  }\n\n  var IS_MAP_SYMBOL = '@@__IMMUTABLE_MAP__@@';\n\n  function isMap(maybeMap) {\n    return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);\n  }\n\n  function isOrderedMap(maybeOrderedMap) {\n    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n  }\n\n  function isValueObject(maybeValue) {\n    return Boolean(\n      maybeValue &&\n        typeof maybeValue.equals === 'function' &&\n        typeof maybeValue.hashCode === 'function'\n    );\n  }\n\n  /**\n   * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n   *\n   * NaN is considered the same as NaN, however -0 and 0 are considered the same\n   * value, which is different from the algorithm described by\n   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n   *\n   * This is extended further to allow Objects to describe the values they\n   * represent, by way of `valueOf` or `equals` (and `hashCode`).\n   *\n   * Note: because of this extension, the key equality of Immutable.Map and the\n   * value equality of Immutable.Set will differ from ES6 Map and Set.\n   *\n   * ### Defining custom values\n   *\n   * The easiest way to describe the value an object represents is by implementing\n   * `valueOf`. For example, `Date` represents a value by returning a unix\n   * timestamp for `valueOf`:\n   *\n   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n   *     var date2 = new Date(1234567890000);\n   *     date1.valueOf(); // 1234567890000\n   *     assert( date1 !== date2 );\n   *     assert( Immutable.is( date1, date2 ) );\n   *\n   * Note: overriding `valueOf` may have other implications if you use this object\n   * where JavaScript expects a primitive, such as implicit string coercion.\n   *\n   * For more complex types, especially collections, implementing `valueOf` may\n   * not be performant. An alternative is to implement `equals` and `hashCode`.\n   *\n   * `equals` takes another object, presumably of similar type, and returns true\n   * if it is equal. Equality is symmetrical, so the same result should be\n   * returned if this and the argument are flipped.\n   *\n   *     assert( a.equals(b) === b.equals(a) );\n   *\n   * `hashCode` returns a 32bit integer number representing the object which will\n   * be used to determine how to store the value object in a Map or Set. You must\n   * provide both or neither methods, one must not exist without the other.\n   *\n   * Also, an important relationship between these methods must be upheld: if two\n   * values are equal, they *must* return the same hashCode. If the values are not\n   * equal, they might have the same hashCode; this is called a hash collision,\n   * and while undesirable for performance reasons, it is acceptable.\n   *\n   *     if (a.equals(b)) {\n   *       assert( a.hashCode() === b.hashCode() );\n   *     }\n   *\n   * All Immutable collections are Value Objects: they implement `equals()`\n   * and `hashCode()`.\n   */\n  function is(valueA, valueB) {\n    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n      return true;\n    }\n    if (!valueA || !valueB) {\n      return false;\n    }\n    if (\n      typeof valueA.valueOf === 'function' &&\n      typeof valueB.valueOf === 'function'\n    ) {\n      valueA = valueA.valueOf();\n      valueB = valueB.valueOf();\n      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n        return true;\n      }\n      if (!valueA || !valueB) {\n        return false;\n      }\n    }\n    return !!(\n      isValueObject(valueA) &&\n      isValueObject(valueB) &&\n      valueA.equals(valueB)\n    );\n  }\n\n  var imul =\n    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2\n      ? Math.imul\n      : function imul(a, b) {\n          a |= 0; // int\n          b |= 0; // int\n          var c = a & 0xffff;\n          var d = b & 0xffff;\n          // Shift by 0 fixes the sign on the high part.\n          return (c * d + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0)) | 0; // int\n        };\n\n  // v8 has an optimization for storing 31-bit signed numbers.\n  // Values which have either 00 or 11 as the high order bits qualify.\n  // This function drops the highest order bit in a signed number, maintaining\n  // the sign bit.\n  function smi(i32) {\n    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xbfffffff);\n  }\n\n  var defaultValueOf = Object.prototype.valueOf;\n\n  function hash(o) {\n    switch (typeof o) {\n      case 'boolean':\n        // The hash values for built-in constants are a 1 value for each 5-byte\n        // shift region expect for the first, which encodes the value. This\n        // reduces the odds of a hash collision for these common values.\n        return o ? 0x42108421 : 0x42108420;\n      case 'number':\n        return hashNumber(o);\n      case 'string':\n        return o.length > STRING_HASH_CACHE_MIN_STRLEN\n          ? cachedHashString(o)\n          : hashString(o);\n      case 'object':\n      case 'function':\n        if (o === null) {\n          return 0x42108422;\n        }\n        if (typeof o.hashCode === 'function') {\n          // Drop any high bits from accidentally long hash codes.\n          return smi(o.hashCode(o));\n        }\n        if (o.valueOf !== defaultValueOf && typeof o.valueOf === 'function') {\n          o = o.valueOf(o);\n        }\n        return hashJSObj(o);\n      case 'undefined':\n        return 0x42108423;\n      default:\n        if (typeof o.toString === 'function') {\n          return hashString(o.toString());\n        }\n        throw new Error('Value type ' + typeof o + ' cannot be hashed.');\n    }\n  }\n\n  // Compress arbitrarily large numbers into smi hashes.\n  function hashNumber(n) {\n    if (n !== n || n === Infinity) {\n      return 0;\n    }\n    var hash = n | 0;\n    if (hash !== n) {\n      hash ^= n * 0xffffffff;\n    }\n    while (n > 0xffffffff) {\n      n /= 0xffffffff;\n      hash ^= n;\n    }\n    return smi(hash);\n  }\n\n  function cachedHashString(string) {\n    var hashed = stringHashCache[string];\n    if (hashed === undefined) {\n      hashed = hashString(string);\n      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n        STRING_HASH_CACHE_SIZE = 0;\n        stringHashCache = {};\n      }\n      STRING_HASH_CACHE_SIZE++;\n      stringHashCache[string] = hashed;\n    }\n    return hashed;\n  }\n\n  // http://jsperf.com/hashing-strings\n  function hashString(string) {\n    // This is the hash from JVM\n    // The hash code for a string is computed as\n    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n    // where s[i] is the ith character of the string and n is the length of\n    // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n    // (exclusive) by dropping high bits.\n    var hashed = 0;\n    for (var ii = 0; ii < string.length; ii++) {\n      hashed = (31 * hashed + string.charCodeAt(ii)) | 0;\n    }\n    return smi(hashed);\n  }\n\n  function hashJSObj(obj) {\n    var hashed;\n    if (usingWeakMap) {\n      hashed = weakMap.get(obj);\n      if (hashed !== undefined) {\n        return hashed;\n      }\n    }\n\n    hashed = obj[UID_HASH_KEY];\n    if (hashed !== undefined) {\n      return hashed;\n    }\n\n    if (!canDefineProperty) {\n      hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n      if (hashed !== undefined) {\n        return hashed;\n      }\n\n      hashed = getIENodeHash(obj);\n      if (hashed !== undefined) {\n        return hashed;\n      }\n    }\n\n    hashed = ++objHashUID;\n    if (objHashUID & 0x40000000) {\n      objHashUID = 0;\n    }\n\n    if (usingWeakMap) {\n      weakMap.set(obj, hashed);\n    } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n      throw new Error('Non-extensible objects are not allowed as keys.');\n    } else if (canDefineProperty) {\n      Object.defineProperty(obj, UID_HASH_KEY, {\n        enumerable: false,\n        configurable: false,\n        writable: false,\n        value: hashed,\n      });\n    } else if (\n      obj.propertyIsEnumerable !== undefined &&\n      obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable\n    ) {\n      // Since we can't define a non-enumerable property on the object\n      // we'll hijack one of the less-used non-enumerable properties to\n      // save our hash on it. Since this is a function it will not show up in\n      // `JSON.stringify` which is what we want.\n      obj.propertyIsEnumerable = function () {\n        return this.constructor.prototype.propertyIsEnumerable.apply(\n          this,\n          arguments\n        );\n      };\n      obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;\n    } else if (obj.nodeType !== undefined) {\n      // At this point we couldn't get the IE `uniqueID` to use as a hash\n      // and we couldn't use a non-enumerable property to exploit the\n      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n      // itself.\n      obj[UID_HASH_KEY] = hashed;\n    } else {\n      throw new Error('Unable to set a non-enumerable property on object.');\n    }\n\n    return hashed;\n  }\n\n  // Get references to ES5 object methods.\n  var isExtensible = Object.isExtensible;\n\n  // True if Object.defineProperty works as expected. IE8 fails this test.\n  var canDefineProperty = (function () {\n    try {\n      Object.defineProperty({}, '@', {});\n      return true;\n    } catch (e) {\n      return false;\n    }\n  })();\n\n  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n  // and avoid memory leaks from the IE cloneNode bug.\n  function getIENodeHash(node) {\n    if (node && node.nodeType > 0) {\n      switch (node.nodeType) {\n        case 1: // Element\n          return node.uniqueID;\n        case 9: // Document\n          return node.documentElement && node.documentElement.uniqueID;\n      }\n    }\n  }\n\n  // If possible, use a WeakMap.\n  var usingWeakMap = typeof WeakMap === 'function';\n  var weakMap;\n  if (usingWeakMap) {\n    weakMap = new WeakMap();\n  }\n\n  var objHashUID = 0;\n\n  var UID_HASH_KEY = '__immutablehash__';\n  if (typeof Symbol === 'function') {\n    UID_HASH_KEY = Symbol(UID_HASH_KEY);\n  }\n\n  var STRING_HASH_CACHE_MIN_STRLEN = 16;\n  var STRING_HASH_CACHE_MAX_SIZE = 255;\n  var STRING_HASH_CACHE_SIZE = 0;\n  var stringHashCache = {};\n\n  var ToKeyedSequence = /*@__PURE__*/(function (KeyedSeq) {\n    function ToKeyedSequence(indexed, useKeys) {\n      this._iter = indexed;\n      this._useKeys = useKeys;\n      this.size = indexed.size;\n    }\n\n    if ( KeyedSeq ) ToKeyedSequence.__proto__ = KeyedSeq;\n    ToKeyedSequence.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );\n    ToKeyedSequence.prototype.constructor = ToKeyedSequence;\n\n    ToKeyedSequence.prototype.get = function get (key, notSetValue) {\n      return this._iter.get(key, notSetValue);\n    };\n\n    ToKeyedSequence.prototype.has = function has (key) {\n      return this._iter.has(key);\n    };\n\n    ToKeyedSequence.prototype.valueSeq = function valueSeq () {\n      return this._iter.valueSeq();\n    };\n\n    ToKeyedSequence.prototype.reverse = function reverse () {\n      var this$1 = this;\n\n      var reversedSequence = reverseFactory(this, true);\n      if (!this._useKeys) {\n        reversedSequence.valueSeq = function () { return this$1._iter.toSeq().reverse(); };\n      }\n      return reversedSequence;\n    };\n\n    ToKeyedSequence.prototype.map = function map (mapper, context) {\n      var this$1 = this;\n\n      var mappedSequence = mapFactory(this, mapper, context);\n      if (!this._useKeys) {\n        mappedSequence.valueSeq = function () { return this$1._iter.toSeq().map(mapper, context); };\n      }\n      return mappedSequence;\n    };\n\n    ToKeyedSequence.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      return this._iter.__iterate(function (v, k) { return fn(v, k, this$1); }, reverse);\n    };\n\n    ToKeyedSequence.prototype.__iterator = function __iterator (type, reverse) {\n      return this._iter.__iterator(type, reverse);\n    };\n\n    return ToKeyedSequence;\n  }(KeyedSeq));\n  ToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;\n\n  var ToIndexedSequence = /*@__PURE__*/(function (IndexedSeq) {\n    function ToIndexedSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    if ( IndexedSeq ) ToIndexedSequence.__proto__ = IndexedSeq;\n    ToIndexedSequence.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n    ToIndexedSequence.prototype.constructor = ToIndexedSequence;\n\n    ToIndexedSequence.prototype.includes = function includes (value) {\n      return this._iter.includes(value);\n    };\n\n    ToIndexedSequence.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      var i = 0;\n      reverse && ensureSize(this);\n      return this._iter.__iterate(\n        function (v) { return fn(v, reverse ? this$1.size - ++i : i++, this$1); },\n        reverse\n      );\n    };\n\n    ToIndexedSequence.prototype.__iterator = function __iterator (type, reverse) {\n      var this$1 = this;\n\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var i = 0;\n      reverse && ensureSize(this);\n      return new Iterator(function () {\n        var step = iterator.next();\n        return step.done\n          ? step\n          : iteratorValue(\n              type,\n              reverse ? this$1.size - ++i : i++,\n              step.value,\n              step\n            );\n      });\n    };\n\n    return ToIndexedSequence;\n  }(IndexedSeq));\n\n  var ToSetSequence = /*@__PURE__*/(function (SetSeq) {\n    function ToSetSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    if ( SetSeq ) ToSetSequence.__proto__ = SetSeq;\n    ToSetSequence.prototype = Object.create( SetSeq && SetSeq.prototype );\n    ToSetSequence.prototype.constructor = ToSetSequence;\n\n    ToSetSequence.prototype.has = function has (key) {\n      return this._iter.includes(key);\n    };\n\n    ToSetSequence.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      return this._iter.__iterate(function (v) { return fn(v, v, this$1); }, reverse);\n    };\n\n    ToSetSequence.prototype.__iterator = function __iterator (type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function () {\n        var step = iterator.next();\n        return step.done\n          ? step\n          : iteratorValue(type, step.value, step.value, step);\n      });\n    };\n\n    return ToSetSequence;\n  }(SetSeq));\n\n  var FromEntriesSequence = /*@__PURE__*/(function (KeyedSeq) {\n    function FromEntriesSequence(entries) {\n      this._iter = entries;\n      this.size = entries.size;\n    }\n\n    if ( KeyedSeq ) FromEntriesSequence.__proto__ = KeyedSeq;\n    FromEntriesSequence.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );\n    FromEntriesSequence.prototype.constructor = FromEntriesSequence;\n\n    FromEntriesSequence.prototype.entrySeq = function entrySeq () {\n      return this._iter.toSeq();\n    };\n\n    FromEntriesSequence.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      return this._iter.__iterate(function (entry) {\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedCollection = isCollection(entry);\n          return fn(\n            indexedCollection ? entry.get(1) : entry[1],\n            indexedCollection ? entry.get(0) : entry[0],\n            this$1\n          );\n        }\n      }, reverse);\n    };\n\n    FromEntriesSequence.prototype.__iterator = function __iterator (type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function () {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          // Check if entry exists first so array access doesn't throw for holes\n          // in the parent iteration.\n          if (entry) {\n            validateEntry(entry);\n            var indexedCollection = isCollection(entry);\n            return iteratorValue(\n              type,\n              indexedCollection ? entry.get(0) : entry[0],\n              indexedCollection ? entry.get(1) : entry[1],\n              step\n            );\n          }\n        }\n      });\n    };\n\n    return FromEntriesSequence;\n  }(KeyedSeq));\n\n  ToIndexedSequence.prototype.cacheResult =\n    ToKeyedSequence.prototype.cacheResult =\n    ToSetSequence.prototype.cacheResult =\n    FromEntriesSequence.prototype.cacheResult =\n      cacheResultThrough;\n\n  function flipFactory(collection) {\n    var flipSequence = makeSequence(collection);\n    flipSequence._iter = collection;\n    flipSequence.size = collection.size;\n    flipSequence.flip = function () { return collection; };\n    flipSequence.reverse = function () {\n      var reversedSequence = collection.reverse.apply(this); // super.reverse()\n      reversedSequence.flip = function () { return collection.reverse(); };\n      return reversedSequence;\n    };\n    flipSequence.has = function (key) { return collection.includes(key); };\n    flipSequence.includes = function (key) { return collection.has(key); };\n    flipSequence.cacheResult = cacheResultThrough;\n    flipSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      return collection.__iterate(function (v, k) { return fn(k, v, this$1) !== false; }, reverse);\n    };\n    flipSequence.__iteratorUncached = function (type, reverse) {\n      if (type === ITERATE_ENTRIES) {\n        var iterator = collection.__iterator(type, reverse);\n        return new Iterator(function () {\n          var step = iterator.next();\n          if (!step.done) {\n            var k = step.value[0];\n            step.value[0] = step.value[1];\n            step.value[1] = k;\n          }\n          return step;\n        });\n      }\n      return collection.__iterator(\n        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n        reverse\n      );\n    };\n    return flipSequence;\n  }\n\n  function mapFactory(collection, mapper, context) {\n    var mappedSequence = makeSequence(collection);\n    mappedSequence.size = collection.size;\n    mappedSequence.has = function (key) { return collection.has(key); };\n    mappedSequence.get = function (key, notSetValue) {\n      var v = collection.get(key, NOT_SET);\n      return v === NOT_SET\n        ? notSetValue\n        : mapper.call(context, v, key, collection);\n    };\n    mappedSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      return collection.__iterate(\n        function (v, k, c) { return fn(mapper.call(context, v, k, c), k, this$1) !== false; },\n        reverse\n      );\n    };\n    mappedSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n      return new Iterator(function () {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var key = entry[0];\n        return iteratorValue(\n          type,\n          key,\n          mapper.call(context, entry[1], key, collection),\n          step\n        );\n      });\n    };\n    return mappedSequence;\n  }\n\n  function reverseFactory(collection, useKeys) {\n    var this$1 = this;\n\n    var reversedSequence = makeSequence(collection);\n    reversedSequence._iter = collection;\n    reversedSequence.size = collection.size;\n    reversedSequence.reverse = function () { return collection; };\n    if (collection.flip) {\n      reversedSequence.flip = function () {\n        var flipSequence = flipFactory(collection);\n        flipSequence.reverse = function () { return collection.flip(); };\n        return flipSequence;\n      };\n    }\n    reversedSequence.get = function (key, notSetValue) { return collection.get(useKeys ? key : -1 - key, notSetValue); };\n    reversedSequence.has = function (key) { return collection.has(useKeys ? key : -1 - key); };\n    reversedSequence.includes = function (value) { return collection.includes(value); };\n    reversedSequence.cacheResult = cacheResultThrough;\n    reversedSequence.__iterate = function (fn, reverse) {\n      var this$1 = this;\n\n      var i = 0;\n      reverse && ensureSize(collection);\n      return collection.__iterate(\n        function (v, k) { return fn(v, useKeys ? k : reverse ? this$1.size - ++i : i++, this$1); },\n        !reverse\n      );\n    };\n    reversedSequence.__iterator = function (type, reverse) {\n      var i = 0;\n      reverse && ensureSize(collection);\n      var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);\n      return new Iterator(function () {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        return iteratorValue(\n          type,\n          useKeys ? entry[0] : reverse ? this$1.size - ++i : i++,\n          entry[1],\n          step\n        );\n      });\n    };\n    return reversedSequence;\n  }\n\n  function filterFactory(collection, predicate, context, useKeys) {\n    var filterSequence = makeSequence(collection);\n    if (useKeys) {\n      filterSequence.has = function (key) {\n        var v = collection.get(key, NOT_SET);\n        return v !== NOT_SET && !!predicate.call(context, v, key, collection);\n      };\n      filterSequence.get = function (key, notSetValue) {\n        var v = collection.get(key, NOT_SET);\n        return v !== NOT_SET && predicate.call(context, v, key, collection)\n          ? v\n          : notSetValue;\n      };\n    }\n    filterSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      var iterations = 0;\n      collection.__iterate(function (v, k, c) {\n        if (predicate.call(context, v, k, c)) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$1);\n        }\n      }, reverse);\n      return iterations;\n    };\n    filterSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n      var iterations = 0;\n      return new Iterator(function () {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          var key = entry[0];\n          var value = entry[1];\n          if (predicate.call(context, value, key, collection)) {\n            return iteratorValue(type, useKeys ? key : iterations++, value, step);\n          }\n        }\n      });\n    };\n    return filterSequence;\n  }\n\n  function countByFactory(collection, grouper, context) {\n    var groups = Map().asMutable();\n    collection.__iterate(function (v, k) {\n      groups.update(grouper.call(context, v, k, collection), 0, function (a) { return a + 1; });\n    });\n    return groups.asImmutable();\n  }\n\n  function groupByFactory(collection, grouper, context) {\n    var isKeyedIter = isKeyed(collection);\n    var groups = (isOrdered(collection) ? OrderedMap() : Map()).asMutable();\n    collection.__iterate(function (v, k) {\n      groups.update(\n        grouper.call(context, v, k, collection),\n        function (a) { return ((a = a || []), a.push(isKeyedIter ? [k, v] : v), a); }\n      );\n    });\n    var coerce = collectionClass(collection);\n    return groups.map(function (arr) { return reify(collection, coerce(arr)); }).asImmutable();\n  }\n\n  function sliceFactory(collection, begin, end, useKeys) {\n    var originalSize = collection.size;\n\n    if (wholeSlice(begin, end, originalSize)) {\n      return collection;\n    }\n\n    var resolvedBegin = resolveBegin(begin, originalSize);\n    var resolvedEnd = resolveEnd(end, originalSize);\n\n    // begin or end will be NaN if they were provided as negative numbers and\n    // this collection's size is unknown. In that case, cache first so there is\n    // a known size and these do not resolve to NaN.\n    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n      return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);\n    }\n\n    // Note: resolvedEnd is undefined when the original sequence's length is\n    // unknown and this slice did not supply an end and should contain all\n    // elements after resolvedBegin.\n    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n    var resolvedSize = resolvedEnd - resolvedBegin;\n    var sliceSize;\n    if (resolvedSize === resolvedSize) {\n      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n    }\n\n    var sliceSeq = makeSequence(collection);\n\n    // If collection.size is undefined, the size of the realized sliceSeq is\n    // unknown at this point unless the number of items to slice is 0\n    sliceSeq.size =\n      sliceSize === 0 ? sliceSize : (collection.size && sliceSize) || undefined;\n\n    if (!useKeys && isSeq(collection) && sliceSize >= 0) {\n      sliceSeq.get = function (index, notSetValue) {\n        index = wrapIndex(this, index);\n        return index >= 0 && index < sliceSize\n          ? collection.get(index + resolvedBegin, notSetValue)\n          : notSetValue;\n      };\n    }\n\n    sliceSeq.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      if (sliceSize === 0) {\n        return 0;\n      }\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var skipped = 0;\n      var isSkipping = true;\n      var iterations = 0;\n      collection.__iterate(function (v, k) {\n        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n          iterations++;\n          return (\n            fn(v, useKeys ? k : iterations - 1, this$1) !== false &&\n            iterations !== sliceSize\n          );\n        }\n      });\n      return iterations;\n    };\n\n    sliceSeq.__iteratorUncached = function (type, reverse) {\n      if (sliceSize !== 0 && reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      // Don't bother instantiating parent iterator if taking 0.\n      if (sliceSize === 0) {\n        return new Iterator(iteratorDone);\n      }\n      var iterator = collection.__iterator(type, reverse);\n      var skipped = 0;\n      var iterations = 0;\n      return new Iterator(function () {\n        while (skipped++ < resolvedBegin) {\n          iterator.next();\n        }\n        if (++iterations > sliceSize) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (useKeys || type === ITERATE_VALUES || step.done) {\n          return step;\n        }\n        if (type === ITERATE_KEYS) {\n          return iteratorValue(type, iterations - 1, undefined, step);\n        }\n        return iteratorValue(type, iterations - 1, step.value[1], step);\n      });\n    };\n\n    return sliceSeq;\n  }\n\n  function takeWhileFactory(collection, predicate, context) {\n    var takeSequence = makeSequence(collection);\n    takeSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterations = 0;\n      collection.__iterate(\n        function (v, k, c) { return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1); }\n      );\n      return iterations;\n    };\n    takeSequence.__iteratorUncached = function (type, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n      var iterating = true;\n      return new Iterator(function () {\n        if (!iterating) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var k = entry[0];\n        var v = entry[1];\n        if (!predicate.call(context, v, k, this$1)) {\n          iterating = false;\n          return iteratorDone();\n        }\n        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n      });\n    };\n    return takeSequence;\n  }\n\n  function skipWhileFactory(collection, predicate, context, useKeys) {\n    var skipSequence = makeSequence(collection);\n    skipSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var isSkipping = true;\n      var iterations = 0;\n      collection.__iterate(function (v, k, c) {\n        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$1);\n        }\n      });\n      return iterations;\n    };\n    skipSequence.__iteratorUncached = function (type, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n      var skipping = true;\n      var iterations = 0;\n      return new Iterator(function () {\n        var step;\n        var k;\n        var v;\n        do {\n          step = iterator.next();\n          if (step.done) {\n            if (useKeys || type === ITERATE_VALUES) {\n              return step;\n            }\n            if (type === ITERATE_KEYS) {\n              return iteratorValue(type, iterations++, undefined, step);\n            }\n            return iteratorValue(type, iterations++, step.value[1], step);\n          }\n          var entry = step.value;\n          k = entry[0];\n          v = entry[1];\n          skipping && (skipping = predicate.call(context, v, k, this$1));\n        } while (skipping);\n        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n      });\n    };\n    return skipSequence;\n  }\n\n  function concatFactory(collection, values) {\n    var isKeyedCollection = isKeyed(collection);\n    var iters = [collection]\n      .concat(values)\n      .map(function (v) {\n        if (!isCollection(v)) {\n          v = isKeyedCollection\n            ? keyedSeqFromValue(v)\n            : indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n        } else if (isKeyedCollection) {\n          v = KeyedCollection(v);\n        }\n        return v;\n      })\n      .filter(function (v) { return v.size !== 0; });\n\n    if (iters.length === 0) {\n      return collection;\n    }\n\n    if (iters.length === 1) {\n      var singleton = iters[0];\n      if (\n        singleton === collection ||\n        (isKeyedCollection && isKeyed(singleton)) ||\n        (isIndexed(collection) && isIndexed(singleton))\n      ) {\n        return singleton;\n      }\n    }\n\n    var concatSeq = new ArraySeq(iters);\n    if (isKeyedCollection) {\n      concatSeq = concatSeq.toKeyedSeq();\n    } else if (!isIndexed(collection)) {\n      concatSeq = concatSeq.toSetSeq();\n    }\n    concatSeq = concatSeq.flatten(true);\n    concatSeq.size = iters.reduce(function (sum, seq) {\n      if (sum !== undefined) {\n        var size = seq.size;\n        if (size !== undefined) {\n          return sum + size;\n        }\n      }\n    }, 0);\n    return concatSeq;\n  }\n\n  function flattenFactory(collection, depth, useKeys) {\n    var flatSequence = makeSequence(collection);\n    flatSequence.__iterateUncached = function (fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterations = 0;\n      var stopped = false;\n      function flatDeep(iter, currentDepth) {\n        iter.__iterate(function (v, k) {\n          if ((!depth || currentDepth < depth) && isCollection(v)) {\n            flatDeep(v, currentDepth + 1);\n          } else {\n            iterations++;\n            if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {\n              stopped = true;\n            }\n          }\n          return !stopped;\n        }, reverse);\n      }\n      flatDeep(collection, 0);\n      return iterations;\n    };\n    flatSequence.__iteratorUncached = function (type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = collection.__iterator(type, reverse);\n      var stack = [];\n      var iterations = 0;\n      return new Iterator(function () {\n        while (iterator) {\n          var step = iterator.next();\n          if (step.done !== false) {\n            iterator = stack.pop();\n            continue;\n          }\n          var v = step.value;\n          if (type === ITERATE_ENTRIES) {\n            v = v[1];\n          }\n          if ((!depth || stack.length < depth) && isCollection(v)) {\n            stack.push(iterator);\n            iterator = v.__iterator(type, reverse);\n          } else {\n            return useKeys ? step : iteratorValue(type, iterations++, v, step);\n          }\n        }\n        return iteratorDone();\n      });\n    };\n    return flatSequence;\n  }\n\n  function flatMapFactory(collection, mapper, context) {\n    var coerce = collectionClass(collection);\n    return collection\n      .toSeq()\n      .map(function (v, k) { return coerce(mapper.call(context, v, k, collection)); })\n      .flatten(true);\n  }\n\n  function interposeFactory(collection, separator) {\n    var interposedSequence = makeSequence(collection);\n    interposedSequence.size = collection.size && collection.size * 2 - 1;\n    interposedSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      var iterations = 0;\n      collection.__iterate(\n        function (v) { return (!iterations || fn(separator, iterations++, this$1) !== false) &&\n          fn(v, iterations++, this$1) !== false; },\n        reverse\n      );\n      return iterations;\n    };\n    interposedSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = collection.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      var step;\n      return new Iterator(function () {\n        if (!step || iterations % 2) {\n          step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n        }\n        return iterations % 2\n          ? iteratorValue(type, iterations++, separator)\n          : iteratorValue(type, iterations++, step.value, step);\n      });\n    };\n    return interposedSequence;\n  }\n\n  function sortFactory(collection, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    var isKeyedCollection = isKeyed(collection);\n    var index = 0;\n    var entries = collection\n      .toSeq()\n      .map(function (v, k) { return [k, v, index++, mapper ? mapper(v, k, collection) : v]; })\n      .valueSeq()\n      .toArray();\n    entries\n      .sort(function (a, b) { return comparator(a[3], b[3]) || a[2] - b[2]; })\n      .forEach(\n        isKeyedCollection\n          ? function (v, i) {\n              entries[i].length = 2;\n            }\n          : function (v, i) {\n              entries[i] = v[1];\n            }\n      );\n    return isKeyedCollection\n      ? KeyedSeq(entries)\n      : isIndexed(collection)\n      ? IndexedSeq(entries)\n      : SetSeq(entries);\n  }\n\n  function maxFactory(collection, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    if (mapper) {\n      var entry = collection\n        .toSeq()\n        .map(function (v, k) { return [v, mapper(v, k, collection)]; })\n        .reduce(function (a, b) { return (maxCompare(comparator, a[1], b[1]) ? b : a); });\n      return entry && entry[0];\n    }\n    return collection.reduce(function (a, b) { return (maxCompare(comparator, a, b) ? b : a); });\n  }\n\n  function maxCompare(comparator, a, b) {\n    var comp = comparator(b, a);\n    // b is considered the new max if the comparator declares them equal, but\n    // they are not equal and b is in fact a nullish value.\n    return (\n      (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) ||\n      comp > 0\n    );\n  }\n\n  function zipWithFactory(keyIter, zipper, iters, zipAll) {\n    var zipSequence = makeSequence(keyIter);\n    var sizes = new ArraySeq(iters).map(function (i) { return i.size; });\n    zipSequence.size = zipAll ? sizes.max() : sizes.min();\n    // Note: this a generic base implementation of __iterate in terms of\n    // __iterator which may be more generically useful in the future.\n    zipSequence.__iterate = function (fn, reverse) {\n      /* generic:\n      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        iterations++;\n        if (fn(step.value[1], step.value[0], this) === false) {\n          break;\n        }\n      }\n      return iterations;\n      */\n      // indexed:\n      var iterator = this.__iterator(ITERATE_VALUES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        if (fn(step.value, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n    zipSequence.__iteratorUncached = function (type, reverse) {\n      var iterators = iters.map(\n        function (i) { return ((i = Collection(i)), getIterator(reverse ? i.reverse() : i)); }\n      );\n      var iterations = 0;\n      var isDone = false;\n      return new Iterator(function () {\n        var steps;\n        if (!isDone) {\n          steps = iterators.map(function (i) { return i.next(); });\n          isDone = zipAll ? steps.every(function (s) { return s.done; }) : steps.some(function (s) { return s.done; });\n        }\n        if (isDone) {\n          return iteratorDone();\n        }\n        return iteratorValue(\n          type,\n          iterations++,\n          zipper.apply(\n            null,\n            steps.map(function (s) { return s.value; })\n          )\n        );\n      });\n    };\n    return zipSequence;\n  }\n\n  // #pragma Helper Functions\n\n  function reify(iter, seq) {\n    return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);\n  }\n\n  function validateEntry(entry) {\n    if (entry !== Object(entry)) {\n      throw new TypeError('Expected [K, V] tuple: ' + entry);\n    }\n  }\n\n  function collectionClass(collection) {\n    return isKeyed(collection)\n      ? KeyedCollection\n      : isIndexed(collection)\n      ? IndexedCollection\n      : SetCollection;\n  }\n\n  function makeSequence(collection) {\n    return Object.create(\n      (isKeyed(collection)\n        ? KeyedSeq\n        : isIndexed(collection)\n        ? IndexedSeq\n        : SetSeq\n      ).prototype\n    );\n  }\n\n  function cacheResultThrough() {\n    if (this._iter.cacheResult) {\n      this._iter.cacheResult();\n      this.size = this._iter.size;\n      return this;\n    }\n    return Seq.prototype.cacheResult.call(this);\n  }\n\n  function defaultComparator(a, b) {\n    if (a === undefined && b === undefined) {\n      return 0;\n    }\n\n    if (a === undefined) {\n      return 1;\n    }\n\n    if (b === undefined) {\n      return -1;\n    }\n\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n\n  function arrCopy(arr, offset) {\n    offset = offset || 0;\n    var len = Math.max(0, arr.length - offset);\n    var newArr = new Array(len);\n    for (var ii = 0; ii < len; ii++) {\n      newArr[ii] = arr[ii + offset];\n    }\n    return newArr;\n  }\n\n  function invariant(condition, error) {\n    if (!condition) { throw new Error(error); }\n  }\n\n  function assertNotInfinite(size) {\n    invariant(\n      size !== Infinity,\n      'Cannot perform this action with an infinite size.'\n    );\n  }\n\n  function coerceKeyPath(keyPath) {\n    if (isArrayLike(keyPath) && typeof keyPath !== 'string') {\n      return keyPath;\n    }\n    if (isOrdered(keyPath)) {\n      return keyPath.toArray();\n    }\n    throw new TypeError(\n      'Invalid keyPath: expected Ordered Collection or Array: ' + keyPath\n    );\n  }\n\n  function isPlainObj(value) {\n    return (\n      value &&\n      (typeof value.constructor !== 'function' ||\n        value.constructor.name === 'Object')\n    );\n  }\n\n  /**\n   * Returns true if the value is a potentially-persistent data structure, either\n   * provided by Immutable.js or a plain Array or Object.\n   */\n  function isDataStructure(value) {\n    return (\n      typeof value === 'object' &&\n      (isImmutable(value) || Array.isArray(value) || isPlainObj(value))\n    );\n  }\n\n  function quoteString(value) {\n    try {\n      return typeof value === 'string' ? JSON.stringify(value) : String(value);\n    } catch (_ignoreError) {\n      return JSON.stringify(value);\n    }\n  }\n\n  function has(collection, key) {\n    return isImmutable(collection)\n      ? collection.has(key)\n      : isDataStructure(collection) && hasOwnProperty.call(collection, key);\n  }\n\n  function get(collection, key, notSetValue) {\n    return isImmutable(collection)\n      ? collection.get(key, notSetValue)\n      : !has(collection, key)\n      ? notSetValue\n      : typeof collection.get === 'function'\n      ? collection.get(key)\n      : collection[key];\n  }\n\n  function shallowCopy(from) {\n    if (Array.isArray(from)) {\n      return arrCopy(from);\n    }\n    var to = {};\n    for (var key in from) {\n      if (hasOwnProperty.call(from, key)) {\n        to[key] = from[key];\n      }\n    }\n    return to;\n  }\n\n  function remove(collection, key) {\n    if (!isDataStructure(collection)) {\n      throw new TypeError(\n        'Cannot update non-data-structure value: ' + collection\n      );\n    }\n    if (isImmutable(collection)) {\n      if (!collection.remove) {\n        throw new TypeError(\n          'Cannot update immutable value without .remove() method: ' + collection\n        );\n      }\n      return collection.remove(key);\n    }\n    if (!hasOwnProperty.call(collection, key)) {\n      return collection;\n    }\n    var collectionCopy = shallowCopy(collection);\n    if (Array.isArray(collectionCopy)) {\n      collectionCopy.splice(key, 1);\n    } else {\n      delete collectionCopy[key];\n    }\n    return collectionCopy;\n  }\n\n  function set(collection, key, value) {\n    if (!isDataStructure(collection)) {\n      throw new TypeError(\n        'Cannot update non-data-structure value: ' + collection\n      );\n    }\n    if (isImmutable(collection)) {\n      if (!collection.set) {\n        throw new TypeError(\n          'Cannot update immutable value without .set() method: ' + collection\n        );\n      }\n      return collection.set(key, value);\n    }\n    if (hasOwnProperty.call(collection, key) && value === collection[key]) {\n      return collection;\n    }\n    var collectionCopy = shallowCopy(collection);\n    collectionCopy[key] = value;\n    return collectionCopy;\n  }\n\n  function updateIn(collection, keyPath, notSetValue, updater) {\n    if (!updater) {\n      updater = notSetValue;\n      notSetValue = undefined;\n    }\n    var updatedValue = updateInDeeply(\n      isImmutable(collection),\n      collection,\n      coerceKeyPath(keyPath),\n      0,\n      notSetValue,\n      updater\n    );\n    return updatedValue === NOT_SET ? notSetValue : updatedValue;\n  }\n\n  function updateInDeeply(\n    inImmutable,\n    existing,\n    keyPath,\n    i,\n    notSetValue,\n    updater\n  ) {\n    var wasNotSet = existing === NOT_SET;\n    if (i === keyPath.length) {\n      var existingValue = wasNotSet ? notSetValue : existing;\n      var newValue = updater(existingValue);\n      return newValue === existingValue ? existing : newValue;\n    }\n    if (!wasNotSet && !isDataStructure(existing)) {\n      throw new TypeError(\n        'Cannot update within non-data-structure value in path [' +\n          keyPath.slice(0, i).map(quoteString) +\n          ']: ' +\n          existing\n      );\n    }\n    var key = keyPath[i];\n    var nextExisting = wasNotSet ? NOT_SET : get(existing, key, NOT_SET);\n    var nextUpdated = updateInDeeply(\n      nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting),\n      nextExisting,\n      keyPath,\n      i + 1,\n      notSetValue,\n      updater\n    );\n    return nextUpdated === nextExisting\n      ? existing\n      : nextUpdated === NOT_SET\n      ? remove(existing, key)\n      : set(\n          wasNotSet ? (inImmutable ? emptyMap() : {}) : existing,\n          key,\n          nextUpdated\n        );\n  }\n\n  function setIn(collection, keyPath, value) {\n    return updateIn(collection, keyPath, NOT_SET, function () { return value; });\n  }\n\n  function setIn$1(keyPath, v) {\n    return setIn(this, keyPath, v);\n  }\n\n  function removeIn(collection, keyPath) {\n    return updateIn(collection, keyPath, function () { return NOT_SET; });\n  }\n\n  function deleteIn(keyPath) {\n    return removeIn(this, keyPath);\n  }\n\n  function update(collection, key, notSetValue, updater) {\n    return updateIn(collection, [key], notSetValue, updater);\n  }\n\n  function update$1(key, notSetValue, updater) {\n    return arguments.length === 1\n      ? key(this)\n      : update(this, key, notSetValue, updater);\n  }\n\n  function updateIn$1(keyPath, notSetValue, updater) {\n    return updateIn(this, keyPath, notSetValue, updater);\n  }\n\n  function merge() {\n    var iters = [], len = arguments.length;\n    while ( len-- ) iters[ len ] = arguments[ len ];\n\n    return mergeIntoKeyedWith(this, iters);\n  }\n\n  function mergeWith(merger) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    if (typeof merger !== 'function') {\n      throw new TypeError('Invalid merger function: ' + merger);\n    }\n    return mergeIntoKeyedWith(this, iters, merger);\n  }\n\n  function mergeIntoKeyedWith(collection, collections, merger) {\n    var iters = [];\n    for (var ii = 0; ii < collections.length; ii++) {\n      var collection$1 = KeyedCollection(collections[ii]);\n      if (collection$1.size !== 0) {\n        iters.push(collection$1);\n      }\n    }\n    if (iters.length === 0) {\n      return collection;\n    }\n    if (\n      collection.toSeq().size === 0 &&\n      !collection.__ownerID &&\n      iters.length === 1\n    ) {\n      return collection.constructor(iters[0]);\n    }\n    return collection.withMutations(function (collection) {\n      var mergeIntoCollection = merger\n        ? function (value, key) {\n            update(collection, key, NOT_SET, function (oldVal) { return oldVal === NOT_SET ? value : merger(oldVal, value, key); }\n            );\n          }\n        : function (value, key) {\n            collection.set(key, value);\n          };\n      for (var ii = 0; ii < iters.length; ii++) {\n        iters[ii].forEach(mergeIntoCollection);\n      }\n    });\n  }\n\n  function merge$1(collection) {\n    var sources = [], len = arguments.length - 1;\n    while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n    return mergeWithSources(collection, sources);\n  }\n\n  function mergeWith$1(merger, collection) {\n    var sources = [], len = arguments.length - 2;\n    while ( len-- > 0 ) sources[ len ] = arguments[ len + 2 ];\n\n    return mergeWithSources(collection, sources, merger);\n  }\n\n  function mergeDeep(collection) {\n    var sources = [], len = arguments.length - 1;\n    while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n    return mergeDeepWithSources(collection, sources);\n  }\n\n  function mergeDeepWith(merger, collection) {\n    var sources = [], len = arguments.length - 2;\n    while ( len-- > 0 ) sources[ len ] = arguments[ len + 2 ];\n\n    return mergeDeepWithSources(collection, sources, merger);\n  }\n\n  function mergeDeepWithSources(collection, sources, merger) {\n    return mergeWithSources(collection, sources, deepMergerWith(merger));\n  }\n\n  function mergeWithSources(collection, sources, merger) {\n    if (!isDataStructure(collection)) {\n      throw new TypeError(\n        'Cannot merge into non-data-structure value: ' + collection\n      );\n    }\n    if (isImmutable(collection)) {\n      return typeof merger === 'function' && collection.mergeWith\n        ? collection.mergeWith.apply(collection, [ merger ].concat( sources ))\n        : collection.merge\n        ? collection.merge.apply(collection, sources)\n        : collection.concat.apply(collection, sources);\n    }\n    var isArray = Array.isArray(collection);\n    var merged = collection;\n    var Collection = isArray ? IndexedCollection : KeyedCollection;\n    var mergeItem = isArray\n      ? function (value) {\n          // Copy on write\n          if (merged === collection) {\n            merged = shallowCopy(merged);\n          }\n          merged.push(value);\n        }\n      : function (value, key) {\n          var hasVal = hasOwnProperty.call(merged, key);\n          var nextVal =\n            hasVal && merger ? merger(merged[key], value, key) : value;\n          if (!hasVal || nextVal !== merged[key]) {\n            // Copy on write\n            if (merged === collection) {\n              merged = shallowCopy(merged);\n            }\n            merged[key] = nextVal;\n          }\n        };\n    for (var i = 0; i < sources.length; i++) {\n      Collection(sources[i]).forEach(mergeItem);\n    }\n    return merged;\n  }\n\n  function deepMergerWith(merger) {\n    function deepMerger(oldValue, newValue, key) {\n      return isDataStructure(oldValue) && isDataStructure(newValue)\n        ? mergeWithSources(oldValue, [newValue], deepMerger)\n        : merger\n        ? merger(oldValue, newValue, key)\n        : newValue;\n    }\n    return deepMerger;\n  }\n\n  function mergeDeep$1() {\n    var iters = [], len = arguments.length;\n    while ( len-- ) iters[ len ] = arguments[ len ];\n\n    return mergeDeepWithSources(this, iters);\n  }\n\n  function mergeDeepWith$1(merger) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return mergeDeepWithSources(this, iters, merger);\n  }\n\n  function mergeIn(keyPath) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return updateIn(this, keyPath, emptyMap(), function (m) { return mergeWithSources(m, iters); });\n  }\n\n  function mergeDeepIn(keyPath) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return updateIn(this, keyPath, emptyMap(), function (m) { return mergeDeepWithSources(m, iters); }\n    );\n  }\n\n  function withMutations(fn) {\n    var mutable = this.asMutable();\n    fn(mutable);\n    return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n  }\n\n  function asMutable() {\n    return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n  }\n\n  function asImmutable() {\n    return this.__ensureOwner();\n  }\n\n  function wasAltered() {\n    return this.__altered;\n  }\n\n  var Map = /*@__PURE__*/(function (KeyedCollection) {\n    function Map(value) {\n      return value === null || value === undefined\n        ? emptyMap()\n        : isMap(value) && !isOrdered(value)\n        ? value\n        : emptyMap().withMutations(function (map) {\n            var iter = KeyedCollection(value);\n            assertNotInfinite(iter.size);\n            iter.forEach(function (v, k) { return map.set(k, v); });\n          });\n    }\n\n    if ( KeyedCollection ) Map.__proto__ = KeyedCollection;\n    Map.prototype = Object.create( KeyedCollection && KeyedCollection.prototype );\n    Map.prototype.constructor = Map;\n\n    Map.of = function of () {\n      var keyValues = [], len = arguments.length;\n      while ( len-- ) keyValues[ len ] = arguments[ len ];\n\n      return emptyMap().withMutations(function (map) {\n        for (var i = 0; i < keyValues.length; i += 2) {\n          if (i + 1 >= keyValues.length) {\n            throw new Error('Missing value for key: ' + keyValues[i]);\n          }\n          map.set(keyValues[i], keyValues[i + 1]);\n        }\n      });\n    };\n\n    Map.prototype.toString = function toString () {\n      return this.__toString('Map {', '}');\n    };\n\n    // @pragma Access\n\n    Map.prototype.get = function get (k, notSetValue) {\n      return this._root\n        ? this._root.get(0, undefined, k, notSetValue)\n        : notSetValue;\n    };\n\n    // @pragma Modification\n\n    Map.prototype.set = function set (k, v) {\n      return updateMap(this, k, v);\n    };\n\n    Map.prototype.remove = function remove (k) {\n      return updateMap(this, k, NOT_SET);\n    };\n\n    Map.prototype.deleteAll = function deleteAll (keys) {\n      var collection = Collection(keys);\n\n      if (collection.size === 0) {\n        return this;\n      }\n\n      return this.withMutations(function (map) {\n        collection.forEach(function (key) { return map.remove(key); });\n      });\n    };\n\n    Map.prototype.clear = function clear () {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._root = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyMap();\n    };\n\n    // @pragma Composition\n\n    Map.prototype.sort = function sort (comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator));\n    };\n\n    Map.prototype.sortBy = function sortBy (mapper, comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator, mapper));\n    };\n\n    Map.prototype.map = function map (mapper, context) {\n      return this.withMutations(function (map) {\n        map.forEach(function (value, key) {\n          map.set(key, mapper.call(context, value, key, map));\n        });\n      });\n    };\n\n    // @pragma Mutability\n\n    Map.prototype.__iterator = function __iterator (type, reverse) {\n      return new MapIterator(this, type, reverse);\n    };\n\n    Map.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      var iterations = 0;\n      this._root &&\n        this._root.iterate(function (entry) {\n          iterations++;\n          return fn(entry[1], entry[0], this$1);\n        }, reverse);\n      return iterations;\n    };\n\n    Map.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        if (this.size === 0) {\n          return emptyMap();\n        }\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeMap(this.size, this._root, ownerID, this.__hash);\n    };\n\n    return Map;\n  }(KeyedCollection));\n\n  Map.isMap = isMap;\n\n  var MapPrototype = Map.prototype;\n  MapPrototype[IS_MAP_SYMBOL] = true;\n  MapPrototype[DELETE] = MapPrototype.remove;\n  MapPrototype.removeAll = MapPrototype.deleteAll;\n  MapPrototype.setIn = setIn$1;\n  MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;\n  MapPrototype.update = update$1;\n  MapPrototype.updateIn = updateIn$1;\n  MapPrototype.merge = MapPrototype.concat = merge;\n  MapPrototype.mergeWith = mergeWith;\n  MapPrototype.mergeDeep = mergeDeep$1;\n  MapPrototype.mergeDeepWith = mergeDeepWith$1;\n  MapPrototype.mergeIn = mergeIn;\n  MapPrototype.mergeDeepIn = mergeDeepIn;\n  MapPrototype.withMutations = withMutations;\n  MapPrototype.wasAltered = wasAltered;\n  MapPrototype.asImmutable = asImmutable;\n  MapPrototype['@@transducer/init'] = MapPrototype.asMutable = asMutable;\n  MapPrototype['@@transducer/step'] = function (result, arr) {\n    return result.set(arr[0], arr[1]);\n  };\n  MapPrototype['@@transducer/result'] = function (obj) {\n    return obj.asImmutable();\n  };\n\n  // #pragma Trie Nodes\n\n  var ArrayMapNode = function ArrayMapNode(ownerID, entries) {\n    this.ownerID = ownerID;\n    this.entries = entries;\n  };\n\n  ArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n    var entries = this.entries;\n    for (var ii = 0, len = entries.length; ii < len; ii++) {\n      if (is(key, entries[ii][0])) {\n        return entries[ii][1];\n      }\n    }\n    return notSetValue;\n  };\n\n  ArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    var removed = value === NOT_SET;\n\n    var entries = this.entries;\n    var idx = 0;\n    var len = entries.length;\n    for (; idx < len; idx++) {\n      if (is(key, entries[idx][0])) {\n        break;\n      }\n    }\n    var exists = idx < len;\n\n    if (exists ? entries[idx][1] === value : removed) {\n      return this;\n    }\n\n    SetRef(didAlter);\n    (removed || !exists) && SetRef(didChangeSize);\n\n    if (removed && entries.length === 1) {\n      return; // undefined\n    }\n\n    if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n      return createNodes(ownerID, entries, key, value);\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newEntries = isEditable ? entries : arrCopy(entries);\n\n    if (exists) {\n      if (removed) {\n        idx === len - 1\n          ? newEntries.pop()\n          : (newEntries[idx] = newEntries.pop());\n      } else {\n        newEntries[idx] = [key, value];\n      }\n    } else {\n      newEntries.push([key, value]);\n    }\n\n    if (isEditable) {\n      this.entries = newEntries;\n      return this;\n    }\n\n    return new ArrayMapNode(ownerID, newEntries);\n  };\n\n  var BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {\n    this.ownerID = ownerID;\n    this.bitmap = bitmap;\n    this.nodes = nodes;\n  };\n\n  BitmapIndexedNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n    var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);\n    var bitmap = this.bitmap;\n    return (bitmap & bit) === 0\n      ? notSetValue\n      : this.nodes[popCount(bitmap & (bit - 1))].get(\n          shift + SHIFT,\n          keyHash,\n          key,\n          notSetValue\n        );\n  };\n\n  BitmapIndexedNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n    var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n    var bit = 1 << keyHashFrag;\n    var bitmap = this.bitmap;\n    var exists = (bitmap & bit) !== 0;\n\n    if (!exists && value === NOT_SET) {\n      return this;\n    }\n\n    var idx = popCount(bitmap & (bit - 1));\n    var nodes = this.nodes;\n    var node = exists ? nodes[idx] : undefined;\n    var newNode = updateNode(\n      node,\n      ownerID,\n      shift + SHIFT,\n      keyHash,\n      key,\n      value,\n      didChangeSize,\n      didAlter\n    );\n\n    if (newNode === node) {\n      return this;\n    }\n\n    if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n      return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n    }\n\n    if (\n      exists &&\n      !newNode &&\n      nodes.length === 2 &&\n      isLeafNode(nodes[idx ^ 1])\n    ) {\n      return nodes[idx ^ 1];\n    }\n\n    if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n      return newNode;\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newBitmap = exists ? (newNode ? bitmap : bitmap ^ bit) : bitmap | bit;\n    var newNodes = exists\n      ? newNode\n        ? setAt(nodes, idx, newNode, isEditable)\n        : spliceOut(nodes, idx, isEditable)\n      : spliceIn(nodes, idx, newNode, isEditable);\n\n    if (isEditable) {\n      this.bitmap = newBitmap;\n      this.nodes = newNodes;\n      return this;\n    }\n\n    return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n  };\n\n  var HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {\n    this.ownerID = ownerID;\n    this.count = count;\n    this.nodes = nodes;\n  };\n\n  HashArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n    var node = this.nodes[idx];\n    return node\n      ? node.get(shift + SHIFT, keyHash, key, notSetValue)\n      : notSetValue;\n  };\n\n  HashArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n    var removed = value === NOT_SET;\n    var nodes = this.nodes;\n    var node = nodes[idx];\n\n    if (removed && !node) {\n      return this;\n    }\n\n    var newNode = updateNode(\n      node,\n      ownerID,\n      shift + SHIFT,\n      keyHash,\n      key,\n      value,\n      didChangeSize,\n      didAlter\n    );\n    if (newNode === node) {\n      return this;\n    }\n\n    var newCount = this.count;\n    if (!node) {\n      newCount++;\n    } else if (!newNode) {\n      newCount--;\n      if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n        return packNodes(ownerID, nodes, newCount, idx);\n      }\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newNodes = setAt(nodes, idx, newNode, isEditable);\n\n    if (isEditable) {\n      this.count = newCount;\n      this.nodes = newNodes;\n      return this;\n    }\n\n    return new HashArrayMapNode(ownerID, newCount, newNodes);\n  };\n\n  var HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {\n    this.ownerID = ownerID;\n    this.keyHash = keyHash;\n    this.entries = entries;\n  };\n\n  HashCollisionNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n    var entries = this.entries;\n    for (var ii = 0, len = entries.length; ii < len; ii++) {\n      if (is(key, entries[ii][0])) {\n        return entries[ii][1];\n      }\n    }\n    return notSetValue;\n  };\n\n  HashCollisionNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n\n    var removed = value === NOT_SET;\n\n    if (keyHash !== this.keyHash) {\n      if (removed) {\n        return this;\n      }\n      SetRef(didAlter);\n      SetRef(didChangeSize);\n      return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n    }\n\n    var entries = this.entries;\n    var idx = 0;\n    var len = entries.length;\n    for (; idx < len; idx++) {\n      if (is(key, entries[idx][0])) {\n        break;\n      }\n    }\n    var exists = idx < len;\n\n    if (exists ? entries[idx][1] === value : removed) {\n      return this;\n    }\n\n    SetRef(didAlter);\n    (removed || !exists) && SetRef(didChangeSize);\n\n    if (removed && len === 2) {\n      return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newEntries = isEditable ? entries : arrCopy(entries);\n\n    if (exists) {\n      if (removed) {\n        idx === len - 1\n          ? newEntries.pop()\n          : (newEntries[idx] = newEntries.pop());\n      } else {\n        newEntries[idx] = [key, value];\n      }\n    } else {\n      newEntries.push([key, value]);\n    }\n\n    if (isEditable) {\n      this.entries = newEntries;\n      return this;\n    }\n\n    return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n  };\n\n  var ValueNode = function ValueNode(ownerID, keyHash, entry) {\n    this.ownerID = ownerID;\n    this.keyHash = keyHash;\n    this.entry = entry;\n  };\n\n  ValueNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n    return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n  };\n\n  ValueNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    var removed = value === NOT_SET;\n    var keyMatch = is(key, this.entry[0]);\n    if (keyMatch ? value === this.entry[1] : removed) {\n      return this;\n    }\n\n    SetRef(didAlter);\n\n    if (removed) {\n      SetRef(didChangeSize);\n      return; // undefined\n    }\n\n    if (keyMatch) {\n      if (ownerID && ownerID === this.ownerID) {\n        this.entry[1] = value;\n        return this;\n      }\n      return new ValueNode(ownerID, this.keyHash, [key, value]);\n    }\n\n    SetRef(didChangeSize);\n    return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n  };\n\n  // #pragma Iterators\n\n  ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate =\n    function (fn, reverse) {\n      var entries = this.entries;\n      for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n        if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n          return false;\n        }\n      }\n    };\n\n  BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate =\n    function (fn, reverse) {\n      var nodes = this.nodes;\n      for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n        var node = nodes[reverse ? maxIndex - ii : ii];\n        if (node && node.iterate(fn, reverse) === false) {\n          return false;\n        }\n      }\n    };\n\n  // eslint-disable-next-line no-unused-vars\n  ValueNode.prototype.iterate = function (fn, reverse) {\n    return fn(this.entry);\n  };\n\n  var MapIterator = /*@__PURE__*/(function (Iterator) {\n    function MapIterator(map, type, reverse) {\n      this._type = type;\n      this._reverse = reverse;\n      this._stack = map._root && mapIteratorFrame(map._root);\n    }\n\n    if ( Iterator ) MapIterator.__proto__ = Iterator;\n    MapIterator.prototype = Object.create( Iterator && Iterator.prototype );\n    MapIterator.prototype.constructor = MapIterator;\n\n    MapIterator.prototype.next = function next () {\n      var type = this._type;\n      var stack = this._stack;\n      while (stack) {\n        var node = stack.node;\n        var index = stack.index++;\n        var maxIndex = (void 0);\n        if (node.entry) {\n          if (index === 0) {\n            return mapIteratorValue(type, node.entry);\n          }\n        } else if (node.entries) {\n          maxIndex = node.entries.length - 1;\n          if (index <= maxIndex) {\n            return mapIteratorValue(\n              type,\n              node.entries[this._reverse ? maxIndex - index : index]\n            );\n          }\n        } else {\n          maxIndex = node.nodes.length - 1;\n          if (index <= maxIndex) {\n            var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n            if (subNode) {\n              if (subNode.entry) {\n                return mapIteratorValue(type, subNode.entry);\n              }\n              stack = this._stack = mapIteratorFrame(subNode, stack);\n            }\n            continue;\n          }\n        }\n        stack = this._stack = this._stack.__prev;\n      }\n      return iteratorDone();\n    };\n\n    return MapIterator;\n  }(Iterator));\n\n  function mapIteratorValue(type, entry) {\n    return iteratorValue(type, entry[0], entry[1]);\n  }\n\n  function mapIteratorFrame(node, prev) {\n    return {\n      node: node,\n      index: 0,\n      __prev: prev,\n    };\n  }\n\n  function makeMap(size, root, ownerID, hash) {\n    var map = Object.create(MapPrototype);\n    map.size = size;\n    map._root = root;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_MAP;\n  function emptyMap() {\n    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n  }\n\n  function updateMap(map, k, v) {\n    var newRoot;\n    var newSize;\n    if (!map._root) {\n      if (v === NOT_SET) {\n        return map;\n      }\n      newSize = 1;\n      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n    } else {\n      var didChangeSize = MakeRef();\n      var didAlter = MakeRef();\n      newRoot = updateNode(\n        map._root,\n        map.__ownerID,\n        0,\n        undefined,\n        k,\n        v,\n        didChangeSize,\n        didAlter\n      );\n      if (!didAlter.value) {\n        return map;\n      }\n      newSize = map.size + (didChangeSize.value ? (v === NOT_SET ? -1 : 1) : 0);\n    }\n    if (map.__ownerID) {\n      map.size = newSize;\n      map._root = newRoot;\n      map.__hash = undefined;\n      map.__altered = true;\n      return map;\n    }\n    return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n  }\n\n  function updateNode(\n    node,\n    ownerID,\n    shift,\n    keyHash,\n    key,\n    value,\n    didChangeSize,\n    didAlter\n  ) {\n    if (!node) {\n      if (value === NOT_SET) {\n        return node;\n      }\n      SetRef(didAlter);\n      SetRef(didChangeSize);\n      return new ValueNode(ownerID, keyHash, [key, value]);\n    }\n    return node.update(\n      ownerID,\n      shift,\n      keyHash,\n      key,\n      value,\n      didChangeSize,\n      didAlter\n    );\n  }\n\n  function isLeafNode(node) {\n    return (\n      node.constructor === ValueNode || node.constructor === HashCollisionNode\n    );\n  }\n\n  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n    if (node.keyHash === keyHash) {\n      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n    }\n\n    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\n    var newNode;\n    var nodes =\n      idx1 === idx2\n        ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)]\n        : ((newNode = new ValueNode(ownerID, keyHash, entry)),\n          idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\n    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n  }\n\n  function createNodes(ownerID, entries, key, value) {\n    if (!ownerID) {\n      ownerID = new OwnerID();\n    }\n    var node = new ValueNode(ownerID, hash(key), [key, value]);\n    for (var ii = 0; ii < entries.length; ii++) {\n      var entry = entries[ii];\n      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n    }\n    return node;\n  }\n\n  function packNodes(ownerID, nodes, count, excluding) {\n    var bitmap = 0;\n    var packedII = 0;\n    var packedNodes = new Array(count);\n    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n      var node = nodes[ii];\n      if (node !== undefined && ii !== excluding) {\n        bitmap |= bit;\n        packedNodes[packedII++] = node;\n      }\n    }\n    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n  }\n\n  function expandNodes(ownerID, nodes, bitmap, including, node) {\n    var count = 0;\n    var expandedNodes = new Array(SIZE);\n    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n    }\n    expandedNodes[including] = node;\n    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n  }\n\n  function popCount(x) {\n    x -= (x >> 1) & 0x55555555;\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    x = (x + (x >> 4)) & 0x0f0f0f0f;\n    x += x >> 8;\n    x += x >> 16;\n    return x & 0x7f;\n  }\n\n  function setAt(array, idx, val, canEdit) {\n    var newArray = canEdit ? array : arrCopy(array);\n    newArray[idx] = val;\n    return newArray;\n  }\n\n  function spliceIn(array, idx, val, canEdit) {\n    var newLen = array.length + 1;\n    if (canEdit && idx + 1 === newLen) {\n      array[idx] = val;\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        newArray[ii] = val;\n        after = -1;\n      } else {\n        newArray[ii] = array[ii + after];\n      }\n    }\n    return newArray;\n  }\n\n  function spliceOut(array, idx, canEdit) {\n    var newLen = array.length - 1;\n    if (canEdit && idx === newLen) {\n      array.pop();\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        after = 1;\n      }\n      newArray[ii] = array[ii + after];\n    }\n    return newArray;\n  }\n\n  var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\n  var IS_LIST_SYMBOL = '@@__IMMUTABLE_LIST__@@';\n\n  function isList(maybeList) {\n    return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);\n  }\n\n  var List = /*@__PURE__*/(function (IndexedCollection) {\n    function List(value) {\n      var empty = emptyList();\n      if (value === null || value === undefined) {\n        return empty;\n      }\n      if (isList(value)) {\n        return value;\n      }\n      var iter = IndexedCollection(value);\n      var size = iter.size;\n      if (size === 0) {\n        return empty;\n      }\n      assertNotInfinite(size);\n      if (size > 0 && size < SIZE) {\n        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n      }\n      return empty.withMutations(function (list) {\n        list.setSize(size);\n        iter.forEach(function (v, i) { return list.set(i, v); });\n      });\n    }\n\n    if ( IndexedCollection ) List.__proto__ = IndexedCollection;\n    List.prototype = Object.create( IndexedCollection && IndexedCollection.prototype );\n    List.prototype.constructor = List;\n\n    List.of = function of (/*...values*/) {\n      return this(arguments);\n    };\n\n    List.prototype.toString = function toString () {\n      return this.__toString('List [', ']');\n    };\n\n    // @pragma Access\n\n    List.prototype.get = function get (index, notSetValue) {\n      index = wrapIndex(this, index);\n      if (index >= 0 && index < this.size) {\n        index += this._origin;\n        var node = listNodeFor(this, index);\n        return node && node.array[index & MASK];\n      }\n      return notSetValue;\n    };\n\n    // @pragma Modification\n\n    List.prototype.set = function set (index, value) {\n      return updateList(this, index, value);\n    };\n\n    List.prototype.remove = function remove (index) {\n      return !this.has(index)\n        ? this\n        : index === 0\n        ? this.shift()\n        : index === this.size - 1\n        ? this.pop()\n        : this.splice(index, 1);\n    };\n\n    List.prototype.insert = function insert (index, value) {\n      return this.splice(index, 0, value);\n    };\n\n    List.prototype.clear = function clear () {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = this._origin = this._capacity = 0;\n        this._level = SHIFT;\n        this._root = this._tail = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyList();\n    };\n\n    List.prototype.push = function push (/*...values*/) {\n      var values = arguments;\n      var oldSize = this.size;\n      return this.withMutations(function (list) {\n        setListBounds(list, 0, oldSize + values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(oldSize + ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.pop = function pop () {\n      return setListBounds(this, 0, -1);\n    };\n\n    List.prototype.unshift = function unshift (/*...values*/) {\n      var values = arguments;\n      return this.withMutations(function (list) {\n        setListBounds(list, -values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.shift = function shift () {\n      return setListBounds(this, 1);\n    };\n\n    // @pragma Composition\n\n    List.prototype.concat = function concat (/*...collections*/) {\n      var arguments$1 = arguments;\n\n      var seqs = [];\n      for (var i = 0; i < arguments.length; i++) {\n        var argument = arguments$1[i];\n        var seq = IndexedCollection(\n          typeof argument !== 'string' && hasIterator(argument)\n            ? argument\n            : [argument]\n        );\n        if (seq.size !== 0) {\n          seqs.push(seq);\n        }\n      }\n      if (seqs.length === 0) {\n        return this;\n      }\n      if (this.size === 0 && !this.__ownerID && seqs.length === 1) {\n        return this.constructor(seqs[0]);\n      }\n      return this.withMutations(function (list) {\n        seqs.forEach(function (seq) { return seq.forEach(function (value) { return list.push(value); }); });\n      });\n    };\n\n    List.prototype.setSize = function setSize (size) {\n      return setListBounds(this, 0, size);\n    };\n\n    List.prototype.map = function map (mapper, context) {\n      var this$1 = this;\n\n      return this.withMutations(function (list) {\n        for (var i = 0; i < this$1.size; i++) {\n          list.set(i, mapper.call(context, list.get(i), i, list));\n        }\n      });\n    };\n\n    // @pragma Iteration\n\n    List.prototype.slice = function slice (begin, end) {\n      var size = this.size;\n      if (wholeSlice(begin, end, size)) {\n        return this;\n      }\n      return setListBounds(\n        this,\n        resolveBegin(begin, size),\n        resolveEnd(end, size)\n      );\n    };\n\n    List.prototype.__iterator = function __iterator (type, reverse) {\n      var index = reverse ? this.size : 0;\n      var values = iterateList(this, reverse);\n      return new Iterator(function () {\n        var value = values();\n        return value === DONE\n          ? iteratorDone()\n          : iteratorValue(type, reverse ? --index : index++, value);\n      });\n    };\n\n    List.prototype.__iterate = function __iterate (fn, reverse) {\n      var index = reverse ? this.size : 0;\n      var values = iterateList(this, reverse);\n      var value;\n      while ((value = values()) !== DONE) {\n        if (fn(value, reverse ? --index : index++, this) === false) {\n          break;\n        }\n      }\n      return index;\n    };\n\n    List.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        if (this.size === 0) {\n          return emptyList();\n        }\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeList(\n        this._origin,\n        this._capacity,\n        this._level,\n        this._root,\n        this._tail,\n        ownerID,\n        this.__hash\n      );\n    };\n\n    return List;\n  }(IndexedCollection));\n\n  List.isList = isList;\n\n  var ListPrototype = List.prototype;\n  ListPrototype[IS_LIST_SYMBOL] = true;\n  ListPrototype[DELETE] = ListPrototype.remove;\n  ListPrototype.merge = ListPrototype.concat;\n  ListPrototype.setIn = setIn$1;\n  ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;\n  ListPrototype.update = update$1;\n  ListPrototype.updateIn = updateIn$1;\n  ListPrototype.mergeIn = mergeIn;\n  ListPrototype.mergeDeepIn = mergeDeepIn;\n  ListPrototype.withMutations = withMutations;\n  ListPrototype.wasAltered = wasAltered;\n  ListPrototype.asImmutable = asImmutable;\n  ListPrototype['@@transducer/init'] = ListPrototype.asMutable = asMutable;\n  ListPrototype['@@transducer/step'] = function (result, arr) {\n    return result.push(arr);\n  };\n  ListPrototype['@@transducer/result'] = function (obj) {\n    return obj.asImmutable();\n  };\n\n  var VNode = function VNode(array, ownerID) {\n    this.array = array;\n    this.ownerID = ownerID;\n  };\n\n  // TODO: seems like these methods are very similar\n\n  VNode.prototype.removeBefore = function removeBefore (ownerID, level, index) {\n    if (index === level ? 1 << level :  this.array.length === 0) {\n      return this;\n    }\n    var originIndex = (index >>> level) & MASK;\n    if (originIndex >= this.array.length) {\n      return new VNode([], ownerID);\n    }\n    var removingFirst = originIndex === 0;\n    var newChild;\n    if (level > 0) {\n      var oldChild = this.array[originIndex];\n      newChild =\n        oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n      if (newChild === oldChild && removingFirst) {\n        return this;\n      }\n    }\n    if (removingFirst && !newChild) {\n      return this;\n    }\n    var editable = editableVNode(this, ownerID);\n    if (!removingFirst) {\n      for (var ii = 0; ii < originIndex; ii++) {\n        editable.array[ii] = undefined;\n      }\n    }\n    if (newChild) {\n      editable.array[originIndex] = newChild;\n    }\n    return editable;\n  };\n\n  VNode.prototype.removeAfter = function removeAfter (ownerID, level, index) {\n    if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n      return this;\n    }\n    var sizeIndex = ((index - 1) >>> level) & MASK;\n    if (sizeIndex >= this.array.length) {\n      return this;\n    }\n\n    var newChild;\n    if (level > 0) {\n      var oldChild = this.array[sizeIndex];\n      newChild =\n        oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n      if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n        return this;\n      }\n    }\n\n    var editable = editableVNode(this, ownerID);\n    editable.array.splice(sizeIndex + 1);\n    if (newChild) {\n      editable.array[sizeIndex] = newChild;\n    }\n    return editable;\n  };\n\n  var DONE = {};\n\n  function iterateList(list, reverse) {\n    var left = list._origin;\n    var right = list._capacity;\n    var tailPos = getTailOffset(right);\n    var tail = list._tail;\n\n    return iterateNodeOrLeaf(list._root, list._level, 0);\n\n    function iterateNodeOrLeaf(node, level, offset) {\n      return level === 0\n        ? iterateLeaf(node, offset)\n        : iterateNode(node, level, offset);\n    }\n\n    function iterateLeaf(node, offset) {\n      var array = offset === tailPos ? tail && tail.array : node && node.array;\n      var from = offset > left ? 0 : left - offset;\n      var to = right - offset;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function () {\n        if (from === to) {\n          return DONE;\n        }\n        var idx = reverse ? --to : from++;\n        return array && array[idx];\n      };\n    }\n\n    function iterateNode(node, level, offset) {\n      var values;\n      var array = node && node.array;\n      var from = offset > left ? 0 : (left - offset) >> level;\n      var to = ((right - offset) >> level) + 1;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function () {\n        while (true) {\n          if (values) {\n            var value = values();\n            if (value !== DONE) {\n              return value;\n            }\n            values = null;\n          }\n          if (from === to) {\n            return DONE;\n          }\n          var idx = reverse ? --to : from++;\n          values = iterateNodeOrLeaf(\n            array && array[idx],\n            level - SHIFT,\n            offset + (idx << level)\n          );\n        }\n      };\n    }\n  }\n\n  function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n    var list = Object.create(ListPrototype);\n    list.size = capacity - origin;\n    list._origin = origin;\n    list._capacity = capacity;\n    list._level = level;\n    list._root = root;\n    list._tail = tail;\n    list.__ownerID = ownerID;\n    list.__hash = hash;\n    list.__altered = false;\n    return list;\n  }\n\n  var EMPTY_LIST;\n  function emptyList() {\n    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n  }\n\n  function updateList(list, index, value) {\n    index = wrapIndex(list, index);\n\n    if (index !== index) {\n      return list;\n    }\n\n    if (index >= list.size || index < 0) {\n      return list.withMutations(function (list) {\n        index < 0\n          ? setListBounds(list, index).set(0, value)\n          : setListBounds(list, 0, index + 1).set(index, value);\n      });\n    }\n\n    index += list._origin;\n\n    var newTail = list._tail;\n    var newRoot = list._root;\n    var didAlter = MakeRef();\n    if (index >= getTailOffset(list._capacity)) {\n      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n    } else {\n      newRoot = updateVNode(\n        newRoot,\n        list.__ownerID,\n        list._level,\n        index,\n        value,\n        didAlter\n      );\n    }\n\n    if (!didAlter.value) {\n      return list;\n    }\n\n    if (list.__ownerID) {\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n  }\n\n  function updateVNode(node, ownerID, level, index, value, didAlter) {\n    var idx = (index >>> level) & MASK;\n    var nodeHas = node && idx < node.array.length;\n    if (!nodeHas && value === undefined) {\n      return node;\n    }\n\n    var newNode;\n\n    if (level > 0) {\n      var lowerNode = node && node.array[idx];\n      var newLowerNode = updateVNode(\n        lowerNode,\n        ownerID,\n        level - SHIFT,\n        index,\n        value,\n        didAlter\n      );\n      if (newLowerNode === lowerNode) {\n        return node;\n      }\n      newNode = editableVNode(node, ownerID);\n      newNode.array[idx] = newLowerNode;\n      return newNode;\n    }\n\n    if (nodeHas && node.array[idx] === value) {\n      return node;\n    }\n\n    if (didAlter) {\n      SetRef(didAlter);\n    }\n\n    newNode = editableVNode(node, ownerID);\n    if (value === undefined && idx === newNode.array.length - 1) {\n      newNode.array.pop();\n    } else {\n      newNode.array[idx] = value;\n    }\n    return newNode;\n  }\n\n  function editableVNode(node, ownerID) {\n    if (ownerID && node && ownerID === node.ownerID) {\n      return node;\n    }\n    return new VNode(node ? node.array.slice() : [], ownerID);\n  }\n\n  function listNodeFor(list, rawIndex) {\n    if (rawIndex >= getTailOffset(list._capacity)) {\n      return list._tail;\n    }\n    if (rawIndex < 1 << (list._level + SHIFT)) {\n      var node = list._root;\n      var level = list._level;\n      while (node && level > 0) {\n        node = node.array[(rawIndex >>> level) & MASK];\n        level -= SHIFT;\n      }\n      return node;\n    }\n  }\n\n  function setListBounds(list, begin, end) {\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin |= 0;\n    }\n    if (end !== undefined) {\n      end |= 0;\n    }\n    var owner = list.__ownerID || new OwnerID();\n    var oldOrigin = list._origin;\n    var oldCapacity = list._capacity;\n    var newOrigin = oldOrigin + begin;\n    var newCapacity =\n      end === undefined\n        ? oldCapacity\n        : end < 0\n        ? oldCapacity + end\n        : oldOrigin + end;\n    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n      return list;\n    }\n\n    // If it's going to end after it starts, it's empty.\n    if (newOrigin >= newCapacity) {\n      return list.clear();\n    }\n\n    var newLevel = list._level;\n    var newRoot = list._root;\n\n    // New origin might need creating a higher root.\n    var offsetShift = 0;\n    while (newOrigin + offsetShift < 0) {\n      newRoot = new VNode(\n        newRoot && newRoot.array.length ? [undefined, newRoot] : [],\n        owner\n      );\n      newLevel += SHIFT;\n      offsetShift += 1 << newLevel;\n    }\n    if (offsetShift) {\n      newOrigin += offsetShift;\n      oldOrigin += offsetShift;\n      newCapacity += offsetShift;\n      oldCapacity += offsetShift;\n    }\n\n    var oldTailOffset = getTailOffset(oldCapacity);\n    var newTailOffset = getTailOffset(newCapacity);\n\n    // New size might need creating a higher root.\n    while (newTailOffset >= 1 << (newLevel + SHIFT)) {\n      newRoot = new VNode(\n        newRoot && newRoot.array.length ? [newRoot] : [],\n        owner\n      );\n      newLevel += SHIFT;\n    }\n\n    // Locate or create the new tail.\n    var oldTail = list._tail;\n    var newTail =\n      newTailOffset < oldTailOffset\n        ? listNodeFor(list, newCapacity - 1)\n        : newTailOffset > oldTailOffset\n        ? new VNode([], owner)\n        : oldTail;\n\n    // Merge Tail into tree.\n    if (\n      oldTail &&\n      newTailOffset > oldTailOffset &&\n      newOrigin < oldCapacity &&\n      oldTail.array.length\n    ) {\n      newRoot = editableVNode(newRoot, owner);\n      var node = newRoot;\n      for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n        var idx = (oldTailOffset >>> level) & MASK;\n        node = node.array[idx] = editableVNode(node.array[idx], owner);\n      }\n      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n    }\n\n    // If the size has been reduced, there's a chance the tail needs to be trimmed.\n    if (newCapacity < oldCapacity) {\n      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n    }\n\n    // If the new origin is within the tail, then we do not need a root.\n    if (newOrigin >= newTailOffset) {\n      newOrigin -= newTailOffset;\n      newCapacity -= newTailOffset;\n      newLevel = SHIFT;\n      newRoot = null;\n      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n      // Otherwise, if the root has been trimmed, garbage collect.\n    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n      offsetShift = 0;\n\n      // Identify the new top root node of the subtree of the old root.\n      while (newRoot) {\n        var beginIndex = (newOrigin >>> newLevel) & MASK;\n        if ((beginIndex !== newTailOffset >>> newLevel) & MASK) {\n          break;\n        }\n        if (beginIndex) {\n          offsetShift += (1 << newLevel) * beginIndex;\n        }\n        newLevel -= SHIFT;\n        newRoot = newRoot.array[beginIndex];\n      }\n\n      // Trim the new sides of the new root.\n      if (newRoot && newOrigin > oldOrigin) {\n        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n      }\n      if (newRoot && newTailOffset < oldTailOffset) {\n        newRoot = newRoot.removeAfter(\n          owner,\n          newLevel,\n          newTailOffset - offsetShift\n        );\n      }\n      if (offsetShift) {\n        newOrigin -= offsetShift;\n        newCapacity -= offsetShift;\n      }\n    }\n\n    if (list.__ownerID) {\n      list.size = newCapacity - newOrigin;\n      list._origin = newOrigin;\n      list._capacity = newCapacity;\n      list._level = newLevel;\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n  }\n\n  function getTailOffset(size) {\n    return size < SIZE ? 0 : ((size - 1) >>> SHIFT) << SHIFT;\n  }\n\n  var OrderedMap = /*@__PURE__*/(function (Map) {\n    function OrderedMap(value) {\n      return value === null || value === undefined\n        ? emptyOrderedMap()\n        : isOrderedMap(value)\n        ? value\n        : emptyOrderedMap().withMutations(function (map) {\n            var iter = KeyedCollection(value);\n            assertNotInfinite(iter.size);\n            iter.forEach(function (v, k) { return map.set(k, v); });\n          });\n    }\n\n    if ( Map ) OrderedMap.__proto__ = Map;\n    OrderedMap.prototype = Object.create( Map && Map.prototype );\n    OrderedMap.prototype.constructor = OrderedMap;\n\n    OrderedMap.of = function of (/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedMap.prototype.toString = function toString () {\n      return this.__toString('OrderedMap {', '}');\n    };\n\n    // @pragma Access\n\n    OrderedMap.prototype.get = function get (k, notSetValue) {\n      var index = this._map.get(k);\n      return index !== undefined ? this._list.get(index)[1] : notSetValue;\n    };\n\n    // @pragma Modification\n\n    OrderedMap.prototype.clear = function clear () {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._map.clear();\n        this._list.clear();\n        return this;\n      }\n      return emptyOrderedMap();\n    };\n\n    OrderedMap.prototype.set = function set (k, v) {\n      return updateOrderedMap(this, k, v);\n    };\n\n    OrderedMap.prototype.remove = function remove (k) {\n      return updateOrderedMap(this, k, NOT_SET);\n    };\n\n    OrderedMap.prototype.wasAltered = function wasAltered () {\n      return this._map.wasAltered() || this._list.wasAltered();\n    };\n\n    OrderedMap.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      return this._list.__iterate(\n        function (entry) { return entry && fn(entry[1], entry[0], this$1); },\n        reverse\n      );\n    };\n\n    OrderedMap.prototype.__iterator = function __iterator (type, reverse) {\n      return this._list.fromEntrySeq().__iterator(type, reverse);\n    };\n\n    OrderedMap.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      var newList = this._list.__ensureOwner(ownerID);\n      if (!ownerID) {\n        if (this.size === 0) {\n          return emptyOrderedMap();\n        }\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        this._list = newList;\n        return this;\n      }\n      return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n    };\n\n    return OrderedMap;\n  }(Map));\n\n  OrderedMap.isOrderedMap = isOrderedMap;\n\n  OrderedMap.prototype[IS_ORDERED_SYMBOL] = true;\n  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\n  function makeOrderedMap(map, list, ownerID, hash) {\n    var omap = Object.create(OrderedMap.prototype);\n    omap.size = map ? map.size : 0;\n    omap._map = map;\n    omap._list = list;\n    omap.__ownerID = ownerID;\n    omap.__hash = hash;\n    return omap;\n  }\n\n  var EMPTY_ORDERED_MAP;\n  function emptyOrderedMap() {\n    return (\n      EMPTY_ORDERED_MAP ||\n      (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()))\n    );\n  }\n\n  function updateOrderedMap(omap, k, v) {\n    var map = omap._map;\n    var list = omap._list;\n    var i = map.get(k);\n    var has = i !== undefined;\n    var newMap;\n    var newList;\n    if (v === NOT_SET) {\n      // removed\n      if (!has) {\n        return omap;\n      }\n      if (list.size >= SIZE && list.size >= map.size * 2) {\n        newList = list.filter(function (entry, idx) { return entry !== undefined && i !== idx; });\n        newMap = newList\n          .toKeyedSeq()\n          .map(function (entry) { return entry[0]; })\n          .flip()\n          .toMap();\n        if (omap.__ownerID) {\n          newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n        }\n      } else {\n        newMap = map.remove(k);\n        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n      }\n    } else if (has) {\n      if (v === list.get(i)[1]) {\n        return omap;\n      }\n      newMap = map;\n      newList = list.set(i, [k, v]);\n    } else {\n      newMap = map.set(k, list.size);\n      newList = list.set(list.size, [k, v]);\n    }\n    if (omap.__ownerID) {\n      omap.size = newMap.size;\n      omap._map = newMap;\n      omap._list = newList;\n      omap.__hash = undefined;\n      return omap;\n    }\n    return makeOrderedMap(newMap, newList);\n  }\n\n  var IS_STACK_SYMBOL = '@@__IMMUTABLE_STACK__@@';\n\n  function isStack(maybeStack) {\n    return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);\n  }\n\n  var Stack = /*@__PURE__*/(function (IndexedCollection) {\n    function Stack(value) {\n      return value === null || value === undefined\n        ? emptyStack()\n        : isStack(value)\n        ? value\n        : emptyStack().pushAll(value);\n    }\n\n    if ( IndexedCollection ) Stack.__proto__ = IndexedCollection;\n    Stack.prototype = Object.create( IndexedCollection && IndexedCollection.prototype );\n    Stack.prototype.constructor = Stack;\n\n    Stack.of = function of (/*...values*/) {\n      return this(arguments);\n    };\n\n    Stack.prototype.toString = function toString () {\n      return this.__toString('Stack [', ']');\n    };\n\n    // @pragma Access\n\n    Stack.prototype.get = function get (index, notSetValue) {\n      var head = this._head;\n      index = wrapIndex(this, index);\n      while (head && index--) {\n        head = head.next;\n      }\n      return head ? head.value : notSetValue;\n    };\n\n    Stack.prototype.peek = function peek () {\n      return this._head && this._head.value;\n    };\n\n    // @pragma Modification\n\n    Stack.prototype.push = function push (/*...values*/) {\n      var arguments$1 = arguments;\n\n      if (arguments.length === 0) {\n        return this;\n      }\n      var newSize = this.size + arguments.length;\n      var head = this._head;\n      for (var ii = arguments.length - 1; ii >= 0; ii--) {\n        head = {\n          value: arguments$1[ii],\n          next: head,\n        };\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pushAll = function pushAll (iter) {\n      iter = IndexedCollection(iter);\n      if (iter.size === 0) {\n        return this;\n      }\n      if (this.size === 0 && isStack(iter)) {\n        return iter;\n      }\n      assertNotInfinite(iter.size);\n      var newSize = this.size;\n      var head = this._head;\n      iter.__iterate(function (value) {\n        newSize++;\n        head = {\n          value: value,\n          next: head,\n        };\n      }, /* reverse */ true);\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pop = function pop () {\n      return this.slice(1);\n    };\n\n    Stack.prototype.clear = function clear () {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._head = undefined;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyStack();\n    };\n\n    Stack.prototype.slice = function slice (begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      var resolvedBegin = resolveBegin(begin, this.size);\n      var resolvedEnd = resolveEnd(end, this.size);\n      if (resolvedEnd !== this.size) {\n        // super.slice(begin, end);\n        return IndexedCollection.prototype.slice.call(this, begin, end);\n      }\n      var newSize = this.size - resolvedBegin;\n      var head = this._head;\n      while (resolvedBegin--) {\n        head = head.next;\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    // @pragma Mutability\n\n    Stack.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        if (this.size === 0) {\n          return emptyStack();\n        }\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeStack(this.size, this._head, ownerID, this.__hash);\n    };\n\n    // @pragma Iteration\n\n    Stack.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return new ArraySeq(this.toArray()).__iterate(\n          function (v, k) { return fn(v, k, this$1); },\n          reverse\n        );\n      }\n      var iterations = 0;\n      var node = this._head;\n      while (node) {\n        if (fn(node.value, iterations++, this) === false) {\n          break;\n        }\n        node = node.next;\n      }\n      return iterations;\n    };\n\n    Stack.prototype.__iterator = function __iterator (type, reverse) {\n      if (reverse) {\n        return new ArraySeq(this.toArray()).__iterator(type, reverse);\n      }\n      var iterations = 0;\n      var node = this._head;\n      return new Iterator(function () {\n        if (node) {\n          var value = node.value;\n          node = node.next;\n          return iteratorValue(type, iterations++, value);\n        }\n        return iteratorDone();\n      });\n    };\n\n    return Stack;\n  }(IndexedCollection));\n\n  Stack.isStack = isStack;\n\n  var StackPrototype = Stack.prototype;\n  StackPrototype[IS_STACK_SYMBOL] = true;\n  StackPrototype.shift = StackPrototype.pop;\n  StackPrototype.unshift = StackPrototype.push;\n  StackPrototype.unshiftAll = StackPrototype.pushAll;\n  StackPrototype.withMutations = withMutations;\n  StackPrototype.wasAltered = wasAltered;\n  StackPrototype.asImmutable = asImmutable;\n  StackPrototype['@@transducer/init'] = StackPrototype.asMutable = asMutable;\n  StackPrototype['@@transducer/step'] = function (result, arr) {\n    return result.unshift(arr);\n  };\n  StackPrototype['@@transducer/result'] = function (obj) {\n    return obj.asImmutable();\n  };\n\n  function makeStack(size, head, ownerID, hash) {\n    var map = Object.create(StackPrototype);\n    map.size = size;\n    map._head = head;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_STACK;\n  function emptyStack() {\n    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n  }\n\n  var IS_SET_SYMBOL = '@@__IMMUTABLE_SET__@@';\n\n  function isSet(maybeSet) {\n    return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);\n  }\n\n  function isOrderedSet(maybeOrderedSet) {\n    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n  }\n\n  function deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    if (\n      !isCollection(b) ||\n      (a.size !== undefined && b.size !== undefined && a.size !== b.size) ||\n      (a.__hash !== undefined &&\n        b.__hash !== undefined &&\n        a.__hash !== b.__hash) ||\n      isKeyed(a) !== isKeyed(b) ||\n      isIndexed(a) !== isIndexed(b) ||\n      isOrdered(a) !== isOrdered(b)\n    ) {\n      return false;\n    }\n\n    if (a.size === 0 && b.size === 0) {\n      return true;\n    }\n\n    var notAssociative = !isAssociative(a);\n\n    if (isOrdered(a)) {\n      var entries = a.entries();\n      return (\n        b.every(function (v, k) {\n          var entry = entries.next().value;\n          return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n        }) && entries.next().done\n      );\n    }\n\n    var flipped = false;\n\n    if (a.size === undefined) {\n      if (b.size === undefined) {\n        if (typeof a.cacheResult === 'function') {\n          a.cacheResult();\n        }\n      } else {\n        flipped = true;\n        var _ = a;\n        a = b;\n        b = _;\n      }\n    }\n\n    var allEqual = true;\n    var bSize = b.__iterate(function (v, k) {\n      if (\n        notAssociative\n          ? !a.has(v)\n          : flipped\n          ? !is(v, a.get(k, NOT_SET))\n          : !is(a.get(k, NOT_SET), v)\n      ) {\n        allEqual = false;\n        return false;\n      }\n    });\n\n    return allEqual && a.size === bSize;\n  }\n\n  function mixin(ctor, methods) {\n    var keyCopier = function (key) {\n      ctor.prototype[key] = methods[key];\n    };\n    Object.keys(methods).forEach(keyCopier);\n    Object.getOwnPropertySymbols &&\n      Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n    return ctor;\n  }\n\n  function toJS(value) {\n    if (!value || typeof value !== 'object') {\n      return value;\n    }\n    if (!isCollection(value)) {\n      if (!isDataStructure(value)) {\n        return value;\n      }\n      value = Seq(value);\n    }\n    if (isKeyed(value)) {\n      var result$1 = {};\n      value.__iterate(function (v, k) {\n        result$1[k] = toJS(v);\n      });\n      return result$1;\n    }\n    var result = [];\n    value.__iterate(function (v) {\n      result.push(toJS(v));\n    });\n    return result;\n  }\n\n  var Set = /*@__PURE__*/(function (SetCollection) {\n    function Set(value) {\n      return value === null || value === undefined\n        ? emptySet()\n        : isSet(value) && !isOrdered(value)\n        ? value\n        : emptySet().withMutations(function (set) {\n            var iter = SetCollection(value);\n            assertNotInfinite(iter.size);\n            iter.forEach(function (v) { return set.add(v); });\n          });\n    }\n\n    if ( SetCollection ) Set.__proto__ = SetCollection;\n    Set.prototype = Object.create( SetCollection && SetCollection.prototype );\n    Set.prototype.constructor = Set;\n\n    Set.of = function of (/*...values*/) {\n      return this(arguments);\n    };\n\n    Set.fromKeys = function fromKeys (value) {\n      return this(KeyedCollection(value).keySeq());\n    };\n\n    Set.intersect = function intersect (sets) {\n      sets = Collection(sets).toArray();\n      return sets.length\n        ? SetPrototype.intersect.apply(Set(sets.pop()), sets)\n        : emptySet();\n    };\n\n    Set.union = function union (sets) {\n      sets = Collection(sets).toArray();\n      return sets.length\n        ? SetPrototype.union.apply(Set(sets.pop()), sets)\n        : emptySet();\n    };\n\n    Set.prototype.toString = function toString () {\n      return this.__toString('Set {', '}');\n    };\n\n    // @pragma Access\n\n    Set.prototype.has = function has (value) {\n      return this._map.has(value);\n    };\n\n    // @pragma Modification\n\n    Set.prototype.add = function add (value) {\n      return updateSet(this, this._map.set(value, value));\n    };\n\n    Set.prototype.remove = function remove (value) {\n      return updateSet(this, this._map.remove(value));\n    };\n\n    Set.prototype.clear = function clear () {\n      return updateSet(this, this._map.clear());\n    };\n\n    // @pragma Composition\n\n    Set.prototype.map = function map (mapper, context) {\n      var this$1 = this;\n\n      var removes = [];\n      var adds = [];\n      this.forEach(function (value) {\n        var mapped = mapper.call(context, value, value, this$1);\n        if (mapped !== value) {\n          removes.push(value);\n          adds.push(mapped);\n        }\n      });\n      return this.withMutations(function (set) {\n        removes.forEach(function (value) { return set.remove(value); });\n        adds.forEach(function (value) { return set.add(value); });\n      });\n    };\n\n    Set.prototype.union = function union () {\n      var iters = [], len = arguments.length;\n      while ( len-- ) iters[ len ] = arguments[ len ];\n\n      iters = iters.filter(function (x) { return x.size !== 0; });\n      if (iters.length === 0) {\n        return this;\n      }\n      if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n        return this.constructor(iters[0]);\n      }\n      return this.withMutations(function (set) {\n        for (var ii = 0; ii < iters.length; ii++) {\n          SetCollection(iters[ii]).forEach(function (value) { return set.add(value); });\n        }\n      });\n    };\n\n    Set.prototype.intersect = function intersect () {\n      var iters = [], len = arguments.length;\n      while ( len-- ) iters[ len ] = arguments[ len ];\n\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function (iter) { return SetCollection(iter); });\n      var toRemove = [];\n      this.forEach(function (value) {\n        if (!iters.every(function (iter) { return iter.includes(value); })) {\n          toRemove.push(value);\n        }\n      });\n      return this.withMutations(function (set) {\n        toRemove.forEach(function (value) {\n          set.remove(value);\n        });\n      });\n    };\n\n    Set.prototype.subtract = function subtract () {\n      var iters = [], len = arguments.length;\n      while ( len-- ) iters[ len ] = arguments[ len ];\n\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function (iter) { return SetCollection(iter); });\n      var toRemove = [];\n      this.forEach(function (value) {\n        if (iters.some(function (iter) { return iter.includes(value); })) {\n          toRemove.push(value);\n        }\n      });\n      return this.withMutations(function (set) {\n        toRemove.forEach(function (value) {\n          set.remove(value);\n        });\n      });\n    };\n\n    Set.prototype.sort = function sort (comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator));\n    };\n\n    Set.prototype.sortBy = function sortBy (mapper, comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator, mapper));\n    };\n\n    Set.prototype.wasAltered = function wasAltered () {\n      return this._map.wasAltered();\n    };\n\n    Set.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      return this._map.__iterate(function (k) { return fn(k, k, this$1); }, reverse);\n    };\n\n    Set.prototype.__iterator = function __iterator (type, reverse) {\n      return this._map.__iterator(type, reverse);\n    };\n\n    Set.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        if (this.size === 0) {\n          return this.__empty();\n        }\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return this.__make(newMap, ownerID);\n    };\n\n    return Set;\n  }(SetCollection));\n\n  Set.isSet = isSet;\n\n  var SetPrototype = Set.prototype;\n  SetPrototype[IS_SET_SYMBOL] = true;\n  SetPrototype[DELETE] = SetPrototype.remove;\n  SetPrototype.merge = SetPrototype.concat = SetPrototype.union;\n  SetPrototype.withMutations = withMutations;\n  SetPrototype.asImmutable = asImmutable;\n  SetPrototype['@@transducer/init'] = SetPrototype.asMutable = asMutable;\n  SetPrototype['@@transducer/step'] = function (result, arr) {\n    return result.add(arr);\n  };\n  SetPrototype['@@transducer/result'] = function (obj) {\n    return obj.asImmutable();\n  };\n\n  SetPrototype.__empty = emptySet;\n  SetPrototype.__make = makeSet;\n\n  function updateSet(set, newMap) {\n    if (set.__ownerID) {\n      set.size = newMap.size;\n      set._map = newMap;\n      return set;\n    }\n    return newMap === set._map\n      ? set\n      : newMap.size === 0\n      ? set.__empty()\n      : set.__make(newMap);\n  }\n\n  function makeSet(map, ownerID) {\n    var set = Object.create(SetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_SET;\n  function emptySet() {\n    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n  }\n\n  /**\n   * Returns a lazy seq of nums from start (inclusive) to end\n   * (exclusive), by step, where start defaults to 0, step to 1, and end to\n   * infinity. When start is equal to end, returns empty list.\n   */\n  var Range = /*@__PURE__*/(function (IndexedSeq) {\n    function Range(start, end, step) {\n      if (!(this instanceof Range)) {\n        return new Range(start, end, step);\n      }\n      invariant(step !== 0, 'Cannot step a Range by 0');\n      start = start || 0;\n      if (end === undefined) {\n        end = Infinity;\n      }\n      step = step === undefined ? 1 : Math.abs(step);\n      if (end < start) {\n        step = -step;\n      }\n      this._start = start;\n      this._end = end;\n      this._step = step;\n      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n      if (this.size === 0) {\n        if (EMPTY_RANGE) {\n          return EMPTY_RANGE;\n        }\n        EMPTY_RANGE = this;\n      }\n    }\n\n    if ( IndexedSeq ) Range.__proto__ = IndexedSeq;\n    Range.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n    Range.prototype.constructor = Range;\n\n    Range.prototype.toString = function toString () {\n      if (this.size === 0) {\n        return 'Range []';\n      }\n      return (\n        'Range [ ' +\n        this._start +\n        '...' +\n        this._end +\n        (this._step !== 1 ? ' by ' + this._step : '') +\n        ' ]'\n      );\n    };\n\n    Range.prototype.get = function get (index, notSetValue) {\n      return this.has(index)\n        ? this._start + wrapIndex(this, index) * this._step\n        : notSetValue;\n    };\n\n    Range.prototype.includes = function includes (searchValue) {\n      var possibleIndex = (searchValue - this._start) / this._step;\n      return (\n        possibleIndex >= 0 &&\n        possibleIndex < this.size &&\n        possibleIndex === Math.floor(possibleIndex)\n      );\n    };\n\n    Range.prototype.slice = function slice (begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      begin = resolveBegin(begin, this.size);\n      end = resolveEnd(end, this.size);\n      if (end <= begin) {\n        return new Range(0, 0);\n      }\n      return new Range(\n        this.get(begin, this._end),\n        this.get(end, this._end),\n        this._step\n      );\n    };\n\n    Range.prototype.indexOf = function indexOf (searchValue) {\n      var offsetValue = searchValue - this._start;\n      if (offsetValue % this._step === 0) {\n        var index = offsetValue / this._step;\n        if (index >= 0 && index < this.size) {\n          return index;\n        }\n      }\n      return -1;\n    };\n\n    Range.prototype.lastIndexOf = function lastIndexOf (searchValue) {\n      return this.indexOf(searchValue);\n    };\n\n    Range.prototype.__iterate = function __iterate (fn, reverse) {\n      var size = this.size;\n      var step = this._step;\n      var value = reverse ? this._start + (size - 1) * step : this._start;\n      var i = 0;\n      while (i !== size) {\n        if (fn(value, reverse ? size - ++i : i++, this) === false) {\n          break;\n        }\n        value += reverse ? -step : step;\n      }\n      return i;\n    };\n\n    Range.prototype.__iterator = function __iterator (type, reverse) {\n      var size = this.size;\n      var step = this._step;\n      var value = reverse ? this._start + (size - 1) * step : this._start;\n      var i = 0;\n      return new Iterator(function () {\n        if (i === size) {\n          return iteratorDone();\n        }\n        var v = value;\n        value += reverse ? -step : step;\n        return iteratorValue(type, reverse ? size - ++i : i++, v);\n      });\n    };\n\n    Range.prototype.equals = function equals (other) {\n      return other instanceof Range\n        ? this._start === other._start &&\n            this._end === other._end &&\n            this._step === other._step\n        : deepEqual(this, other);\n    };\n\n    return Range;\n  }(IndexedSeq));\n\n  var EMPTY_RANGE;\n\n  function getIn(collection, searchKeyPath, notSetValue) {\n    var keyPath = coerceKeyPath(searchKeyPath);\n    var i = 0;\n    while (i !== keyPath.length) {\n      collection = get(collection, keyPath[i++], NOT_SET);\n      if (collection === NOT_SET) {\n        return notSetValue;\n      }\n    }\n    return collection;\n  }\n\n  function getIn$1(searchKeyPath, notSetValue) {\n    return getIn(this, searchKeyPath, notSetValue);\n  }\n\n  function hasIn(collection, keyPath) {\n    return getIn(collection, keyPath, NOT_SET) !== NOT_SET;\n  }\n\n  function hasIn$1(searchKeyPath) {\n    return hasIn(this, searchKeyPath);\n  }\n\n  function toObject() {\n    assertNotInfinite(this.size);\n    var object = {};\n    this.__iterate(function (v, k) {\n      object[k] = v;\n    });\n    return object;\n  }\n\n  // Note: all of these methods are deprecated.\n  Collection.isIterable = isCollection;\n  Collection.isKeyed = isKeyed;\n  Collection.isIndexed = isIndexed;\n  Collection.isAssociative = isAssociative;\n  Collection.isOrdered = isOrdered;\n\n  Collection.Iterator = Iterator;\n\n  mixin(Collection, {\n    // ### Conversion to other types\n\n    toArray: function toArray() {\n      assertNotInfinite(this.size);\n      var array = new Array(this.size || 0);\n      var useTuples = isKeyed(this);\n      var i = 0;\n      this.__iterate(function (v, k) {\n        // Keyed collections produce an array of tuples.\n        array[i++] = useTuples ? [k, v] : v;\n      });\n      return array;\n    },\n\n    toIndexedSeq: function toIndexedSeq() {\n      return new ToIndexedSequence(this);\n    },\n\n    toJS: function toJS$1() {\n      return toJS(this);\n    },\n\n    toKeyedSeq: function toKeyedSeq() {\n      return new ToKeyedSequence(this, true);\n    },\n\n    toMap: function toMap() {\n      // Use Late Binding here to solve the circular dependency.\n      return Map(this.toKeyedSeq());\n    },\n\n    toObject: toObject,\n\n    toOrderedMap: function toOrderedMap() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedMap(this.toKeyedSeq());\n    },\n\n    toOrderedSet: function toOrderedSet() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSet: function toSet() {\n      // Use Late Binding here to solve the circular dependency.\n      return Set(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSetSeq: function toSetSeq() {\n      return new ToSetSequence(this);\n    },\n\n    toSeq: function toSeq() {\n      return isIndexed(this)\n        ? this.toIndexedSeq()\n        : isKeyed(this)\n        ? this.toKeyedSeq()\n        : this.toSetSeq();\n    },\n\n    toStack: function toStack() {\n      // Use Late Binding here to solve the circular dependency.\n      return Stack(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toList: function toList() {\n      // Use Late Binding here to solve the circular dependency.\n      return List(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    // ### Common JavaScript methods and properties\n\n    toString: function toString() {\n      return '[Collection]';\n    },\n\n    __toString: function __toString(head, tail) {\n      if (this.size === 0) {\n        return head + tail;\n      }\n      return (\n        head +\n        ' ' +\n        this.toSeq().map(this.__toStringMapper).join(', ') +\n        ' ' +\n        tail\n      );\n    },\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    concat: function concat() {\n      var values = [], len = arguments.length;\n      while ( len-- ) values[ len ] = arguments[ len ];\n\n      return reify(this, concatFactory(this, values));\n    },\n\n    includes: function includes(searchValue) {\n      return this.some(function (value) { return is(value, searchValue); });\n    },\n\n    entries: function entries() {\n      return this.__iterator(ITERATE_ENTRIES);\n    },\n\n    every: function every(predicate, context) {\n      assertNotInfinite(this.size);\n      var returnValue = true;\n      this.__iterate(function (v, k, c) {\n        if (!predicate.call(context, v, k, c)) {\n          returnValue = false;\n          return false;\n        }\n      });\n      return returnValue;\n    },\n\n    filter: function filter(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, true));\n    },\n\n    find: function find(predicate, context, notSetValue) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[1] : notSetValue;\n    },\n\n    forEach: function forEach(sideEffect, context) {\n      assertNotInfinite(this.size);\n      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n    },\n\n    join: function join(separator) {\n      assertNotInfinite(this.size);\n      separator = separator !== undefined ? '' + separator : ',';\n      var joined = '';\n      var isFirst = true;\n      this.__iterate(function (v) {\n        isFirst ? (isFirst = false) : (joined += separator);\n        joined += v !== null && v !== undefined ? v.toString() : '';\n      });\n      return joined;\n    },\n\n    keys: function keys() {\n      return this.__iterator(ITERATE_KEYS);\n    },\n\n    map: function map(mapper, context) {\n      return reify(this, mapFactory(this, mapper, context));\n    },\n\n    reduce: function reduce$1(reducer, initialReduction, context) {\n      return reduce(\n        this,\n        reducer,\n        initialReduction,\n        context,\n        arguments.length < 2,\n        false\n      );\n    },\n\n    reduceRight: function reduceRight(reducer, initialReduction, context) {\n      return reduce(\n        this,\n        reducer,\n        initialReduction,\n        context,\n        arguments.length < 2,\n        true\n      );\n    },\n\n    reverse: function reverse() {\n      return reify(this, reverseFactory(this, true));\n    },\n\n    slice: function slice(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, true));\n    },\n\n    some: function some(predicate, context) {\n      return !this.every(not(predicate), context);\n    },\n\n    sort: function sort(comparator) {\n      return reify(this, sortFactory(this, comparator));\n    },\n\n    values: function values() {\n      return this.__iterator(ITERATE_VALUES);\n    },\n\n    // ### More sequential methods\n\n    butLast: function butLast() {\n      return this.slice(0, -1);\n    },\n\n    isEmpty: function isEmpty() {\n      return this.size !== undefined ? this.size === 0 : !this.some(function () { return true; });\n    },\n\n    count: function count(predicate, context) {\n      return ensureSize(\n        predicate ? this.toSeq().filter(predicate, context) : this\n      );\n    },\n\n    countBy: function countBy(grouper, context) {\n      return countByFactory(this, grouper, context);\n    },\n\n    equals: function equals(other) {\n      return deepEqual(this, other);\n    },\n\n    entrySeq: function entrySeq() {\n      var collection = this;\n      if (collection._cache) {\n        // We cache as an entries array, so we can just return the cache!\n        return new ArraySeq(collection._cache);\n      }\n      var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();\n      entriesSequence.fromEntrySeq = function () { return collection.toSeq(); };\n      return entriesSequence;\n    },\n\n    filterNot: function filterNot(predicate, context) {\n      return this.filter(not(predicate), context);\n    },\n\n    findEntry: function findEntry(predicate, context, notSetValue) {\n      var found = notSetValue;\n      this.__iterate(function (v, k, c) {\n        if (predicate.call(context, v, k, c)) {\n          found = [k, v];\n          return false;\n        }\n      });\n      return found;\n    },\n\n    findKey: function findKey(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry && entry[0];\n    },\n\n    findLast: function findLast(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n    },\n\n    findLastEntry: function findLastEntry(predicate, context, notSetValue) {\n      return this.toKeyedSeq()\n        .reverse()\n        .findEntry(predicate, context, notSetValue);\n    },\n\n    findLastKey: function findLastKey(predicate, context) {\n      return this.toKeyedSeq().reverse().findKey(predicate, context);\n    },\n\n    first: function first(notSetValue) {\n      return this.find(returnTrue, null, notSetValue);\n    },\n\n    flatMap: function flatMap(mapper, context) {\n      return reify(this, flatMapFactory(this, mapper, context));\n    },\n\n    flatten: function flatten(depth) {\n      return reify(this, flattenFactory(this, depth, true));\n    },\n\n    fromEntrySeq: function fromEntrySeq() {\n      return new FromEntriesSequence(this);\n    },\n\n    get: function get(searchKey, notSetValue) {\n      return this.find(function (_, key) { return is(key, searchKey); }, undefined, notSetValue);\n    },\n\n    getIn: getIn$1,\n\n    groupBy: function groupBy(grouper, context) {\n      return groupByFactory(this, grouper, context);\n    },\n\n    has: function has(searchKey) {\n      return this.get(searchKey, NOT_SET) !== NOT_SET;\n    },\n\n    hasIn: hasIn$1,\n\n    isSubset: function isSubset(iter) {\n      iter = typeof iter.includes === 'function' ? iter : Collection(iter);\n      return this.every(function (value) { return iter.includes(value); });\n    },\n\n    isSuperset: function isSuperset(iter) {\n      iter = typeof iter.isSubset === 'function' ? iter : Collection(iter);\n      return iter.isSubset(this);\n    },\n\n    keyOf: function keyOf(searchValue) {\n      return this.findKey(function (value) { return is(value, searchValue); });\n    },\n\n    keySeq: function keySeq() {\n      return this.toSeq().map(keyMapper).toIndexedSeq();\n    },\n\n    last: function last(notSetValue) {\n      return this.toSeq().reverse().first(notSetValue);\n    },\n\n    lastKeyOf: function lastKeyOf(searchValue) {\n      return this.toKeyedSeq().reverse().keyOf(searchValue);\n    },\n\n    max: function max(comparator) {\n      return maxFactory(this, comparator);\n    },\n\n    maxBy: function maxBy(mapper, comparator) {\n      return maxFactory(this, comparator, mapper);\n    },\n\n    min: function min(comparator) {\n      return maxFactory(\n        this,\n        comparator ? neg(comparator) : defaultNegComparator\n      );\n    },\n\n    minBy: function minBy(mapper, comparator) {\n      return maxFactory(\n        this,\n        comparator ? neg(comparator) : defaultNegComparator,\n        mapper\n      );\n    },\n\n    rest: function rest() {\n      return this.slice(1);\n    },\n\n    skip: function skip(amount) {\n      return amount === 0 ? this : this.slice(Math.max(0, amount));\n    },\n\n    skipLast: function skipLast(amount) {\n      return amount === 0 ? this : this.slice(0, -Math.max(0, amount));\n    },\n\n    skipWhile: function skipWhile(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, true));\n    },\n\n    skipUntil: function skipUntil(predicate, context) {\n      return this.skipWhile(not(predicate), context);\n    },\n\n    sortBy: function sortBy(mapper, comparator) {\n      return reify(this, sortFactory(this, comparator, mapper));\n    },\n\n    take: function take(amount) {\n      return this.slice(0, Math.max(0, amount));\n    },\n\n    takeLast: function takeLast(amount) {\n      return this.slice(-Math.max(0, amount));\n    },\n\n    takeWhile: function takeWhile(predicate, context) {\n      return reify(this, takeWhileFactory(this, predicate, context));\n    },\n\n    takeUntil: function takeUntil(predicate, context) {\n      return this.takeWhile(not(predicate), context);\n    },\n\n    update: function update(fn) {\n      return fn(this);\n    },\n\n    valueSeq: function valueSeq() {\n      return this.toIndexedSeq();\n    },\n\n    // ### Hashable Object\n\n    hashCode: function hashCode() {\n      return this.__hash || (this.__hash = hashCollection(this));\n    },\n\n    // ### Internal\n\n    // abstract __iterate(fn, reverse)\n\n    // abstract __iterator(type, reverse)\n  });\n\n  var CollectionPrototype = Collection.prototype;\n  CollectionPrototype[IS_COLLECTION_SYMBOL] = true;\n  CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;\n  CollectionPrototype.toJSON = CollectionPrototype.toArray;\n  CollectionPrototype.__toStringMapper = quoteString;\n  CollectionPrototype.inspect = CollectionPrototype.toSource = function () {\n    return this.toString();\n  };\n  CollectionPrototype.chain = CollectionPrototype.flatMap;\n  CollectionPrototype.contains = CollectionPrototype.includes;\n\n  mixin(KeyedCollection, {\n    // ### More sequential methods\n\n    flip: function flip() {\n      return reify(this, flipFactory(this));\n    },\n\n    mapEntries: function mapEntries(mapper, context) {\n      var this$1 = this;\n\n      var iterations = 0;\n      return reify(\n        this,\n        this.toSeq()\n          .map(function (v, k) { return mapper.call(context, [k, v], iterations++, this$1); })\n          .fromEntrySeq()\n      );\n    },\n\n    mapKeys: function mapKeys(mapper, context) {\n      var this$1 = this;\n\n      return reify(\n        this,\n        this.toSeq()\n          .flip()\n          .map(function (k, v) { return mapper.call(context, k, v, this$1); })\n          .flip()\n      );\n    },\n  });\n\n  var KeyedCollectionPrototype = KeyedCollection.prototype;\n  KeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;\n  KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;\n  KeyedCollectionPrototype.toJSON = toObject;\n  KeyedCollectionPrototype.__toStringMapper = function (v, k) { return quoteString(k) + ': ' + quoteString(v); };\n\n  mixin(IndexedCollection, {\n    // ### Conversion to other types\n\n    toKeyedSeq: function toKeyedSeq() {\n      return new ToKeyedSequence(this, false);\n    },\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    filter: function filter(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, false));\n    },\n\n    findIndex: function findIndex(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    indexOf: function indexOf(searchValue) {\n      var key = this.keyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    lastIndexOf: function lastIndexOf(searchValue) {\n      var key = this.lastKeyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    reverse: function reverse() {\n      return reify(this, reverseFactory(this, false));\n    },\n\n    slice: function slice(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, false));\n    },\n\n    splice: function splice(index, removeNum /*, ...values*/) {\n      var numArgs = arguments.length;\n      removeNum = Math.max(removeNum || 0, 0);\n      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n        return this;\n      }\n      // If index is negative, it should resolve relative to the size of the\n      // collection. However size may be expensive to compute if not cached, so\n      // only call count() if the number is in fact negative.\n      index = resolveBegin(index, index < 0 ? this.count() : this.size);\n      var spliced = this.slice(0, index);\n      return reify(\n        this,\n        numArgs === 1\n          ? spliced\n          : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n      );\n    },\n\n    // ### More collection methods\n\n    findLastIndex: function findLastIndex(predicate, context) {\n      var entry = this.findLastEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    first: function first(notSetValue) {\n      return this.get(0, notSetValue);\n    },\n\n    flatten: function flatten(depth) {\n      return reify(this, flattenFactory(this, depth, false));\n    },\n\n    get: function get(index, notSetValue) {\n      index = wrapIndex(this, index);\n      return index < 0 ||\n        this.size === Infinity ||\n        (this.size !== undefined && index > this.size)\n        ? notSetValue\n        : this.find(function (_, key) { return key === index; }, undefined, notSetValue);\n    },\n\n    has: function has(index) {\n      index = wrapIndex(this, index);\n      return (\n        index >= 0 &&\n        (this.size !== undefined\n          ? this.size === Infinity || index < this.size\n          : this.indexOf(index) !== -1)\n      );\n    },\n\n    interpose: function interpose(separator) {\n      return reify(this, interposeFactory(this, separator));\n    },\n\n    interleave: function interleave(/*...collections*/) {\n      var collections = [this].concat(arrCopy(arguments));\n      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);\n      var interleaved = zipped.flatten(true);\n      if (zipped.size) {\n        interleaved.size = zipped.size * collections.length;\n      }\n      return reify(this, interleaved);\n    },\n\n    keySeq: function keySeq() {\n      return Range(0, this.size);\n    },\n\n    last: function last(notSetValue) {\n      return this.get(-1, notSetValue);\n    },\n\n    skipWhile: function skipWhile(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, false));\n    },\n\n    zip: function zip(/*, ...collections */) {\n      var collections = [this].concat(arrCopy(arguments));\n      return reify(this, zipWithFactory(this, defaultZipper, collections));\n    },\n\n    zipAll: function zipAll(/*, ...collections */) {\n      var collections = [this].concat(arrCopy(arguments));\n      return reify(this, zipWithFactory(this, defaultZipper, collections, true));\n    },\n\n    zipWith: function zipWith(zipper /*, ...collections */) {\n      var collections = arrCopy(arguments);\n      collections[0] = this;\n      return reify(this, zipWithFactory(this, zipper, collections));\n    },\n  });\n\n  var IndexedCollectionPrototype = IndexedCollection.prototype;\n  IndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;\n  IndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;\n\n  mixin(SetCollection, {\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    get: function get(value, notSetValue) {\n      return this.has(value) ? value : notSetValue;\n    },\n\n    includes: function includes(value) {\n      return this.has(value);\n    },\n\n    // ### More sequential methods\n\n    keySeq: function keySeq() {\n      return this.valueSeq();\n    },\n  });\n\n  SetCollection.prototype.has = CollectionPrototype.includes;\n  SetCollection.prototype.contains = SetCollection.prototype.includes;\n\n  // Mixin subclasses\n\n  mixin(KeyedSeq, KeyedCollection.prototype);\n  mixin(IndexedSeq, IndexedCollection.prototype);\n  mixin(SetSeq, SetCollection.prototype);\n\n  // #pragma Helper functions\n\n  function reduce(collection, reducer, reduction, context, useFirst, reverse) {\n    assertNotInfinite(collection.size);\n    collection.__iterate(function (v, k, c) {\n      if (useFirst) {\n        useFirst = false;\n        reduction = v;\n      } else {\n        reduction = reducer.call(context, reduction, v, k, c);\n      }\n    }, reverse);\n    return reduction;\n  }\n\n  function keyMapper(v, k) {\n    return k;\n  }\n\n  function entryMapper(v, k) {\n    return [k, v];\n  }\n\n  function not(predicate) {\n    return function () {\n      return !predicate.apply(this, arguments);\n    };\n  }\n\n  function neg(predicate) {\n    return function () {\n      return -predicate.apply(this, arguments);\n    };\n  }\n\n  function defaultZipper() {\n    return arrCopy(arguments);\n  }\n\n  function defaultNegComparator(a, b) {\n    return a < b ? 1 : a > b ? -1 : 0;\n  }\n\n  function hashCollection(collection) {\n    if (collection.size === Infinity) {\n      return 0;\n    }\n    var ordered = isOrdered(collection);\n    var keyed = isKeyed(collection);\n    var h = ordered ? 1 : 0;\n    var size = collection.__iterate(\n      keyed\n        ? ordered\n          ? function (v, k) {\n              h = (31 * h + hashMerge(hash(v), hash(k))) | 0;\n            }\n          : function (v, k) {\n              h = (h + hashMerge(hash(v), hash(k))) | 0;\n            }\n        : ordered\n        ? function (v) {\n            h = (31 * h + hash(v)) | 0;\n          }\n        : function (v) {\n            h = (h + hash(v)) | 0;\n          }\n    );\n    return murmurHashOfSize(size, h);\n  }\n\n  function murmurHashOfSize(size, h) {\n    h = imul(h, 0xcc9e2d51);\n    h = imul((h << 15) | (h >>> -15), 0x1b873593);\n    h = imul((h << 13) | (h >>> -13), 5);\n    h = ((h + 0xe6546b64) | 0) ^ size;\n    h = imul(h ^ (h >>> 16), 0x85ebca6b);\n    h = imul(h ^ (h >>> 13), 0xc2b2ae35);\n    h = smi(h ^ (h >>> 16));\n    return h;\n  }\n\n  function hashMerge(a, b) {\n    return (a ^ (b + 0x9e3779b9 + (a << 6) + (a >> 2))) | 0; // int\n  }\n\n  var OrderedSet = /*@__PURE__*/(function (Set) {\n    function OrderedSet(value) {\n      return value === null || value === undefined\n        ? emptyOrderedSet()\n        : isOrderedSet(value)\n        ? value\n        : emptyOrderedSet().withMutations(function (set) {\n            var iter = SetCollection(value);\n            assertNotInfinite(iter.size);\n            iter.forEach(function (v) { return set.add(v); });\n          });\n    }\n\n    if ( Set ) OrderedSet.__proto__ = Set;\n    OrderedSet.prototype = Object.create( Set && Set.prototype );\n    OrderedSet.prototype.constructor = OrderedSet;\n\n    OrderedSet.of = function of (/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedSet.fromKeys = function fromKeys (value) {\n      return this(KeyedCollection(value).keySeq());\n    };\n\n    OrderedSet.prototype.toString = function toString () {\n      return this.__toString('OrderedSet {', '}');\n    };\n\n    return OrderedSet;\n  }(Set));\n\n  OrderedSet.isOrderedSet = isOrderedSet;\n\n  var OrderedSetPrototype = OrderedSet.prototype;\n  OrderedSetPrototype[IS_ORDERED_SYMBOL] = true;\n  OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;\n  OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;\n\n  OrderedSetPrototype.__empty = emptyOrderedSet;\n  OrderedSetPrototype.__make = makeOrderedSet;\n\n  function makeOrderedSet(map, ownerID) {\n    var set = Object.create(OrderedSetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_ORDERED_SET;\n  function emptyOrderedSet() {\n    return (\n      EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()))\n    );\n  }\n\n  var Record = function Record(defaultValues, name) {\n    var hasInitialized;\n\n    var RecordType = function Record(values) {\n      var this$1 = this;\n\n      if (values instanceof RecordType) {\n        return values;\n      }\n      if (!(this instanceof RecordType)) {\n        return new RecordType(values);\n      }\n      if (!hasInitialized) {\n        hasInitialized = true;\n        var keys = Object.keys(defaultValues);\n        var indices = (RecordTypePrototype._indices = {});\n        // Deprecated: left to attempt not to break any external code which\n        // relies on a ._name property existing on record instances.\n        // Use Record.getDescriptiveName() instead\n        RecordTypePrototype._name = name;\n        RecordTypePrototype._keys = keys;\n        RecordTypePrototype._defaultValues = defaultValues;\n        for (var i = 0; i < keys.length; i++) {\n          var propName = keys[i];\n          indices[propName] = i;\n          if (RecordTypePrototype[propName]) {\n            /* eslint-disable no-console */\n            typeof console === 'object' &&\n              console.warn &&\n              console.warn(\n                'Cannot define ' +\n                  recordName(this) +\n                  ' with property \"' +\n                  propName +\n                  '\" since that property name is part of the Record API.'\n              );\n            /* eslint-enable no-console */\n          } else {\n            setProp(RecordTypePrototype, propName);\n          }\n        }\n      }\n      this.__ownerID = undefined;\n      this._values = List().withMutations(function (l) {\n        l.setSize(this$1._keys.length);\n        KeyedCollection(values).forEach(function (v, k) {\n          l.set(this$1._indices[k], v === this$1._defaultValues[k] ? undefined : v);\n        });\n      });\n    };\n\n    var RecordTypePrototype = (RecordType.prototype =\n      Object.create(RecordPrototype));\n    RecordTypePrototype.constructor = RecordType;\n\n    if (name) {\n      RecordType.displayName = name;\n    }\n\n    return RecordType;\n  };\n\n  Record.prototype.toString = function toString () {\n    var str = recordName(this) + ' { ';\n    var keys = this._keys;\n    var k;\n    for (var i = 0, l = keys.length; i !== l; i++) {\n      k = keys[i];\n      str += (i ? ', ' : '') + k + ': ' + quoteString(this.get(k));\n    }\n    return str + ' }';\n  };\n\n  Record.prototype.equals = function equals (other) {\n    return (\n      this === other ||\n      (other &&\n        this._keys === other._keys &&\n        recordSeq(this).equals(recordSeq(other)))\n    );\n  };\n\n  Record.prototype.hashCode = function hashCode () {\n    return recordSeq(this).hashCode();\n  };\n\n  // @pragma Access\n\n  Record.prototype.has = function has (k) {\n    return this._indices.hasOwnProperty(k);\n  };\n\n  Record.prototype.get = function get (k, notSetValue) {\n    if (!this.has(k)) {\n      return notSetValue;\n    }\n    var index = this._indices[k];\n    var value = this._values.get(index);\n    return value === undefined ? this._defaultValues[k] : value;\n  };\n\n  // @pragma Modification\n\n  Record.prototype.set = function set (k, v) {\n    if (this.has(k)) {\n      var newValues = this._values.set(\n        this._indices[k],\n        v === this._defaultValues[k] ? undefined : v\n      );\n      if (newValues !== this._values && !this.__ownerID) {\n        return makeRecord(this, newValues);\n      }\n    }\n    return this;\n  };\n\n  Record.prototype.remove = function remove (k) {\n    return this.set(k);\n  };\n\n  Record.prototype.clear = function clear () {\n    var newValues = this._values.clear().setSize(this._keys.length);\n    return this.__ownerID ? this : makeRecord(this, newValues);\n  };\n\n  Record.prototype.wasAltered = function wasAltered () {\n    return this._values.wasAltered();\n  };\n\n  Record.prototype.toSeq = function toSeq () {\n    return recordSeq(this);\n  };\n\n  Record.prototype.toJS = function toJS$1 () {\n    return toJS(this);\n  };\n\n  Record.prototype.entries = function entries () {\n    return this.__iterator(ITERATE_ENTRIES);\n  };\n\n  Record.prototype.__iterator = function __iterator (type, reverse) {\n    return recordSeq(this).__iterator(type, reverse);\n  };\n\n  Record.prototype.__iterate = function __iterate (fn, reverse) {\n    return recordSeq(this).__iterate(fn, reverse);\n  };\n\n  Record.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    var newValues = this._values.__ensureOwner(ownerID);\n    if (!ownerID) {\n      this.__ownerID = ownerID;\n      this._values = newValues;\n      return this;\n    }\n    return makeRecord(this, newValues, ownerID);\n  };\n\n  Record.isRecord = isRecord;\n  Record.getDescriptiveName = recordName;\n  var RecordPrototype = Record.prototype;\n  RecordPrototype[IS_RECORD_SYMBOL] = true;\n  RecordPrototype[DELETE] = RecordPrototype.remove;\n  RecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;\n  RecordPrototype.getIn = getIn$1;\n  RecordPrototype.hasIn = CollectionPrototype.hasIn;\n  RecordPrototype.merge = merge;\n  RecordPrototype.mergeWith = mergeWith;\n  RecordPrototype.mergeIn = mergeIn;\n  RecordPrototype.mergeDeep = mergeDeep$1;\n  RecordPrototype.mergeDeepWith = mergeDeepWith$1;\n  RecordPrototype.mergeDeepIn = mergeDeepIn;\n  RecordPrototype.setIn = setIn$1;\n  RecordPrototype.update = update$1;\n  RecordPrototype.updateIn = updateIn$1;\n  RecordPrototype.withMutations = withMutations;\n  RecordPrototype.asMutable = asMutable;\n  RecordPrototype.asImmutable = asImmutable;\n  RecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;\n  RecordPrototype.toJSON = RecordPrototype.toObject =\n    CollectionPrototype.toObject;\n  RecordPrototype.inspect = RecordPrototype.toSource = function () {\n    return this.toString();\n  };\n\n  function makeRecord(likeRecord, values, ownerID) {\n    var record = Object.create(Object.getPrototypeOf(likeRecord));\n    record._values = values;\n    record.__ownerID = ownerID;\n    return record;\n  }\n\n  function recordName(record) {\n    return record.constructor.displayName || record.constructor.name || 'Record';\n  }\n\n  function recordSeq(record) {\n    return keyedSeqFromValue(record._keys.map(function (k) { return [k, record.get(k)]; }));\n  }\n\n  function setProp(prototype, name) {\n    try {\n      Object.defineProperty(prototype, name, {\n        get: function () {\n          return this.get(name);\n        },\n        set: function (value) {\n          invariant(this.__ownerID, 'Cannot set on an immutable record.');\n          this.set(name, value);\n        },\n      });\n    } catch (error) {\n      // Object.defineProperty failed. Probably IE8.\n    }\n  }\n\n  /**\n   * Returns a lazy Seq of `value` repeated `times` times. When `times` is\n   * undefined, returns an infinite sequence of `value`.\n   */\n  var Repeat = /*@__PURE__*/(function (IndexedSeq) {\n    function Repeat(value, times) {\n      if (!(this instanceof Repeat)) {\n        return new Repeat(value, times);\n      }\n      this._value = value;\n      this.size = times === undefined ? Infinity : Math.max(0, times);\n      if (this.size === 0) {\n        if (EMPTY_REPEAT) {\n          return EMPTY_REPEAT;\n        }\n        EMPTY_REPEAT = this;\n      }\n    }\n\n    if ( IndexedSeq ) Repeat.__proto__ = IndexedSeq;\n    Repeat.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n    Repeat.prototype.constructor = Repeat;\n\n    Repeat.prototype.toString = function toString () {\n      if (this.size === 0) {\n        return 'Repeat []';\n      }\n      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n    };\n\n    Repeat.prototype.get = function get (index, notSetValue) {\n      return this.has(index) ? this._value : notSetValue;\n    };\n\n    Repeat.prototype.includes = function includes (searchValue) {\n      return is(this._value, searchValue);\n    };\n\n    Repeat.prototype.slice = function slice (begin, end) {\n      var size = this.size;\n      return wholeSlice(begin, end, size)\n        ? this\n        : new Repeat(\n            this._value,\n            resolveEnd(end, size) - resolveBegin(begin, size)\n          );\n    };\n\n    Repeat.prototype.reverse = function reverse () {\n      return this;\n    };\n\n    Repeat.prototype.indexOf = function indexOf (searchValue) {\n      if (is(this._value, searchValue)) {\n        return 0;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.lastIndexOf = function lastIndexOf (searchValue) {\n      if (is(this._value, searchValue)) {\n        return this.size;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.__iterate = function __iterate (fn, reverse) {\n      var size = this.size;\n      var i = 0;\n      while (i !== size) {\n        if (fn(this._value, reverse ? size - ++i : i++, this) === false) {\n          break;\n        }\n      }\n      return i;\n    };\n\n    Repeat.prototype.__iterator = function __iterator (type, reverse) {\n      var this$1 = this;\n\n      var size = this.size;\n      var i = 0;\n      return new Iterator(function () { return i === size\n          ? iteratorDone()\n          : iteratorValue(type, reverse ? size - ++i : i++, this$1._value); }\n      );\n    };\n\n    Repeat.prototype.equals = function equals (other) {\n      return other instanceof Repeat\n        ? is(this._value, other._value)\n        : deepEqual(other);\n    };\n\n    return Repeat;\n  }(IndexedSeq));\n\n  var EMPTY_REPEAT;\n\n  function fromJS(value, converter) {\n    return fromJSWith(\n      [],\n      converter || defaultConverter,\n      value,\n      '',\n      converter && converter.length > 2 ? [] : undefined,\n      { '': value }\n    );\n  }\n\n  function fromJSWith(stack, converter, value, key, keyPath, parentValue) {\n    var toSeq = Array.isArray(value)\n      ? IndexedSeq\n      : isPlainObj(value)\n      ? KeyedSeq\n      : null;\n    if (toSeq) {\n      if (~stack.indexOf(value)) {\n        throw new TypeError('Cannot convert circular structure to Immutable');\n      }\n      stack.push(value);\n      keyPath && key !== '' && keyPath.push(key);\n      var converted = converter.call(\n        parentValue,\n        key,\n        toSeq(value).map(function (v, k) { return fromJSWith(stack, converter, v, k, keyPath, value); }\n        ),\n        keyPath && keyPath.slice()\n      );\n      stack.pop();\n      keyPath && keyPath.pop();\n      return converted;\n    }\n    return value;\n  }\n\n  function defaultConverter(k, v) {\n    return isKeyed(v) ? v.toMap() : v.toList();\n  }\n\n  var version = \"4.0.0-rc.12\";\n\n  var Immutable = {\n    version: version,\n\n    Collection: Collection,\n    // Note: Iterable is deprecated\n    Iterable: Collection,\n\n    Seq: Seq,\n    Map: Map,\n    OrderedMap: OrderedMap,\n    List: List,\n    Stack: Stack,\n    Set: Set,\n    OrderedSet: OrderedSet,\n\n    Record: Record,\n    Range: Range,\n    Repeat: Repeat,\n\n    is: is,\n    fromJS: fromJS,\n    hash: hash,\n\n    isImmutable: isImmutable,\n    isCollection: isCollection,\n    isKeyed: isKeyed,\n    isIndexed: isIndexed,\n    isAssociative: isAssociative,\n    isOrdered: isOrdered,\n    isValueObject: isValueObject,\n    isSeq: isSeq,\n    isList: isList,\n    isMap: isMap,\n    isOrderedMap: isOrderedMap,\n    isStack: isStack,\n    isSet: isSet,\n    isOrderedSet: isOrderedSet,\n    isRecord: isRecord,\n\n    get: get,\n    getIn: getIn,\n    has: has,\n    hasIn: hasIn,\n    merge: merge$1,\n    mergeDeep: mergeDeep,\n    mergeWith: mergeWith$1,\n    mergeDeepWith: mergeDeepWith,\n    remove: remove,\n    removeIn: removeIn,\n    set: set,\n    setIn: setIn,\n    update: update,\n    updateIn: updateIn,\n  };\n\n  // Note: Iterable is deprecated\n  var Iterable = Collection;\n\n  exports.Collection = Collection;\n  exports.Iterable = Iterable;\n  exports.List = List;\n  exports.Map = Map;\n  exports.OrderedMap = OrderedMap;\n  exports.OrderedSet = OrderedSet;\n  exports.Range = Range;\n  exports.Record = Record;\n  exports.Repeat = Repeat;\n  exports.Seq = Seq;\n  exports.Set = Set;\n  exports.Stack = Stack;\n  exports.default = Immutable;\n  exports.fromJS = fromJS;\n  exports.get = get;\n  exports.getIn = getIn;\n  exports.has = has;\n  exports.hasIn = hasIn;\n  exports.hash = hash;\n  exports.is = is;\n  exports.isAssociative = isAssociative;\n  exports.isCollection = isCollection;\n  exports.isImmutable = isImmutable;\n  exports.isIndexed = isIndexed;\n  exports.isKeyed = isKeyed;\n  exports.isOrdered = isOrdered;\n  exports.isValueObject = isValueObject;\n  exports.merge = merge$1;\n  exports.mergeDeep = mergeDeep;\n  exports.mergeDeepWith = mergeDeepWith;\n  exports.mergeWith = mergeWith$1;\n  exports.remove = remove;\n  exports.removeIn = removeIn;\n  exports.set = set;\n  exports.setIn = setIn;\n  exports.update = update;\n  exports.updateIn = updateIn;\n  exports.version = version;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species != null &&\n    Buffer[Symbol.species] === Buffer) {\n  Object.defineProperty(Buffer, Symbol.species, {\n    value: null,\n    configurable: true,\n    enumerable: false,\n    writable: false\n  })\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayLike(value)\n  }\n\n  if (value == null) {\n    throw TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__ = Uint8Array.prototype\nBuffer.__proto__ = Uint8Array\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      buf = Buffer.from(buf)\n    }\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n        : (firstByte > 0xBF) ? 2\n          : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  newBuf.__proto__ = Buffer.prototype\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (var i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","/**\n * marked - a markdown parser\n * Copyright (c) 2011-2020, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = global || self, global.marked = factory());\n}(this, (function () { 'use strict';\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it;\n\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    it = o[Symbol.iterator]();\n    return it.next.bind(it);\n  }\n\n  function createCommonjsModule(fn, module) {\n  \treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n  }\n\n  var defaults = createCommonjsModule(function (module) {\n    function getDefaults() {\n      return {\n        baseUrl: null,\n        breaks: false,\n        gfm: true,\n        headerIds: true,\n        headerPrefix: '',\n        highlight: null,\n        langPrefix: 'language-',\n        mangle: true,\n        pedantic: false,\n        renderer: null,\n        sanitize: false,\n        sanitizer: null,\n        silent: false,\n        smartLists: false,\n        smartypants: false,\n        tokenizer: null,\n        walkTokens: null,\n        xhtml: false\n      };\n    }\n\n    function changeDefaults(newDefaults) {\n      module.exports.defaults = newDefaults;\n    }\n\n    module.exports = {\n      defaults: getDefaults(),\n      getDefaults: getDefaults,\n      changeDefaults: changeDefaults\n    };\n  });\n  var defaults_1 = defaults.defaults;\n  var defaults_2 = defaults.getDefaults;\n  var defaults_3 = defaults.changeDefaults;\n\n  /**\n   * Helpers\n   */\n  var escapeTest = /[&<>\"']/;\n  var escapeReplace = /[&<>\"']/g;\n  var escapeTestNoEncode = /[<>\"']|&(?!#?\\w+;)/;\n  var escapeReplaceNoEncode = /[<>\"']|&(?!#?\\w+;)/g;\n  var escapeReplacements = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n\n  var getEscapeReplacement = function getEscapeReplacement(ch) {\n    return escapeReplacements[ch];\n  };\n\n  function escape(html, encode) {\n    if (encode) {\n      if (escapeTest.test(html)) {\n        return html.replace(escapeReplace, getEscapeReplacement);\n      }\n    } else {\n      if (escapeTestNoEncode.test(html)) {\n        return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n      }\n    }\n\n    return html;\n  }\n\n  var unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n\n  function unescape(html) {\n    // explicitly match decimal, hex, and named HTML entities\n    return html.replace(unescapeTest, function (_, n) {\n      n = n.toLowerCase();\n      if (n === 'colon') return ':';\n\n      if (n.charAt(0) === '#') {\n        return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));\n      }\n\n      return '';\n    });\n  }\n\n  var caret = /(^|[^\\[])\\^/g;\n\n  function edit(regex, opt) {\n    regex = regex.source || regex;\n    opt = opt || '';\n    var obj = {\n      replace: function replace(name, val) {\n        val = val.source || val;\n        val = val.replace(caret, '$1');\n        regex = regex.replace(name, val);\n        return obj;\n      },\n      getRegex: function getRegex() {\n        return new RegExp(regex, opt);\n      }\n    };\n    return obj;\n  }\n\n  var nonWordAndColonTest = /[^\\w:]/g;\n  var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;\n\n  function cleanUrl(sanitize, base, href) {\n    if (sanitize) {\n      var prot;\n\n      try {\n        prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, '').toLowerCase();\n      } catch (e) {\n        return null;\n      }\n\n      if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n        return null;\n      }\n    }\n\n    if (base && !originIndependentUrl.test(href)) {\n      href = resolveUrl(base, href);\n    }\n\n    try {\n      href = encodeURI(href).replace(/%25/g, '%');\n    } catch (e) {\n      return null;\n    }\n\n    return href;\n  }\n\n  var baseUrls = {};\n  var justDomain = /^[^:]+:\\/*[^/]*$/;\n  var protocol = /^([^:]+:)[\\s\\S]*$/;\n  var domain = /^([^:]+:\\/*[^/]*)[\\s\\S]*$/;\n\n  function resolveUrl(base, href) {\n    if (!baseUrls[' ' + base]) {\n      // we can ignore everything in base after the last slash of its path component,\n      // but we might need to add _that_\n      // https://tools.ietf.org/html/rfc3986#section-3\n      if (justDomain.test(base)) {\n        baseUrls[' ' + base] = base + '/';\n      } else {\n        baseUrls[' ' + base] = rtrim(base, '/', true);\n      }\n    }\n\n    base = baseUrls[' ' + base];\n    var relativeBase = base.indexOf(':') === -1;\n\n    if (href.substring(0, 2) === '//') {\n      if (relativeBase) {\n        return href;\n      }\n\n      return base.replace(protocol, '$1') + href;\n    } else if (href.charAt(0) === '/') {\n      if (relativeBase) {\n        return href;\n      }\n\n      return base.replace(domain, '$1') + href;\n    } else {\n      return base + href;\n    }\n  }\n\n  var noopTest = {\n    exec: function noopTest() {}\n  };\n\n  function merge(obj) {\n    var i = 1,\n        target,\n        key;\n\n    for (; i < arguments.length; i++) {\n      target = arguments[i];\n\n      for (key in target) {\n        if (Object.prototype.hasOwnProperty.call(target, key)) {\n          obj[key] = target[key];\n        }\n      }\n    }\n\n    return obj;\n  }\n\n  function splitCells(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    var row = tableRow.replace(/\\|/g, function (match, offset, str) {\n      var escaped = false,\n          curr = offset;\n\n      while (--curr >= 0 && str[curr] === '\\\\') {\n        escaped = !escaped;\n      }\n\n      if (escaped) {\n        // odd number of slashes means | is escaped\n        // so we leave it alone\n        return '|';\n      } else {\n        // add space before unescaped |\n        return ' |';\n      }\n    }),\n        cells = row.split(/ \\|/);\n    var i = 0;\n\n    if (cells.length > count) {\n      cells.splice(count);\n    } else {\n      while (cells.length < count) {\n        cells.push('');\n      }\n    }\n\n    for (; i < cells.length; i++) {\n      // leading or trailing whitespace is ignored per the gfm spec\n      cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n    }\n\n    return cells;\n  } // Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n  // /c*$/ is vulnerable to REDOS.\n  // invert: Remove suffix of non-c chars instead. Default falsey.\n\n\n  function rtrim(str, c, invert) {\n    var l = str.length;\n\n    if (l === 0) {\n      return '';\n    } // Length of suffix matching the invert condition.\n\n\n    var suffLen = 0; // Step left until we fail to match the invert condition.\n\n    while (suffLen < l) {\n      var currChar = str.charAt(l - suffLen - 1);\n\n      if (currChar === c && !invert) {\n        suffLen++;\n      } else if (currChar !== c && invert) {\n        suffLen++;\n      } else {\n        break;\n      }\n    }\n\n    return str.substr(0, l - suffLen);\n  }\n\n  function findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n      return -1;\n    }\n\n    var l = str.length;\n    var level = 0,\n        i = 0;\n\n    for (; i < l; i++) {\n      if (str[i] === '\\\\') {\n        i++;\n      } else if (str[i] === b[0]) {\n        level++;\n      } else if (str[i] === b[1]) {\n        level--;\n\n        if (level < 0) {\n          return i;\n        }\n      }\n    }\n\n    return -1;\n  }\n\n  function checkSanitizeDeprecation(opt) {\n    if (opt && opt.sanitize && !opt.silent) {\n      console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');\n    }\n  }\n\n  var helpers = {\n    escape: escape,\n    unescape: unescape,\n    edit: edit,\n    cleanUrl: cleanUrl,\n    resolveUrl: resolveUrl,\n    noopTest: noopTest,\n    merge: merge,\n    splitCells: splitCells,\n    rtrim: rtrim,\n    findClosingBracket: findClosingBracket,\n    checkSanitizeDeprecation: checkSanitizeDeprecation\n  };\n\n  var defaults$1 = defaults.defaults;\n  var rtrim$1 = helpers.rtrim,\n      splitCells$1 = helpers.splitCells,\n      _escape = helpers.escape,\n      findClosingBracket$1 = helpers.findClosingBracket;\n\n  function outputLink(cap, link, raw) {\n    var href = link.href;\n    var title = link.title ? _escape(link.title) : null;\n    var text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n\n    if (cap[0].charAt(0) !== '!') {\n      return {\n        type: 'link',\n        raw: raw,\n        href: href,\n        title: title,\n        text: text\n      };\n    } else {\n      return {\n        type: 'image',\n        raw: raw,\n        href: href,\n        title: title,\n        text: _escape(text)\n      };\n    }\n  }\n\n  function indentCodeCompensation(raw, text) {\n    var matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n\n    if (matchIndentToCode === null) {\n      return text;\n    }\n\n    var indentToCode = matchIndentToCode[1];\n    return text.split('\\n').map(function (node) {\n      var matchIndentInNode = node.match(/^\\s+/);\n\n      if (matchIndentInNode === null) {\n        return node;\n      }\n\n      var indentInNode = matchIndentInNode[0];\n\n      if (indentInNode.length >= indentToCode.length) {\n        return node.slice(indentToCode.length);\n      }\n\n      return node;\n    }).join('\\n');\n  }\n  /**\n   * Tokenizer\n   */\n\n\n  var Tokenizer_1 = /*#__PURE__*/function () {\n    function Tokenizer(options) {\n      this.options = options || defaults$1;\n    }\n\n    var _proto = Tokenizer.prototype;\n\n    _proto.space = function space(src) {\n      var cap = this.rules.block.newline.exec(src);\n\n      if (cap) {\n        if (cap[0].length > 1) {\n          return {\n            type: 'space',\n            raw: cap[0]\n          };\n        }\n\n        return {\n          raw: '\\n'\n        };\n      }\n    };\n\n    _proto.code = function code(src, tokens) {\n      var cap = this.rules.block.code.exec(src);\n\n      if (cap) {\n        var lastToken = tokens[tokens.length - 1]; // An indented code block cannot interrupt a paragraph.\n\n        if (lastToken && lastToken.type === 'paragraph') {\n          return {\n            raw: cap[0],\n            text: cap[0].trimRight()\n          };\n        }\n\n        var text = cap[0].replace(/^ {4}/gm, '');\n        return {\n          type: 'code',\n          raw: cap[0],\n          codeBlockStyle: 'indented',\n          text: !this.options.pedantic ? rtrim$1(text, '\\n') : text\n        };\n      }\n    };\n\n    _proto.fences = function fences(src) {\n      var cap = this.rules.block.fences.exec(src);\n\n      if (cap) {\n        var raw = cap[0];\n        var text = indentCodeCompensation(raw, cap[3] || '');\n        return {\n          type: 'code',\n          raw: raw,\n          lang: cap[2] ? cap[2].trim() : cap[2],\n          text: text\n        };\n      }\n    };\n\n    _proto.heading = function heading(src) {\n      var cap = this.rules.block.heading.exec(src);\n\n      if (cap) {\n        return {\n          type: 'heading',\n          raw: cap[0],\n          depth: cap[1].length,\n          text: cap[2]\n        };\n      }\n    };\n\n    _proto.nptable = function nptable(src) {\n      var cap = this.rules.block.nptable.exec(src);\n\n      if (cap) {\n        var item = {\n          type: 'table',\n          header: splitCells$1(cap[1].replace(/^ *| *\\| *$/g, '')),\n          align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n          cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : [],\n          raw: cap[0]\n        };\n\n        if (item.header.length === item.align.length) {\n          var l = item.align.length;\n          var i;\n\n          for (i = 0; i < l; i++) {\n            if (/^ *-+: *$/.test(item.align[i])) {\n              item.align[i] = 'right';\n            } else if (/^ *:-+: *$/.test(item.align[i])) {\n              item.align[i] = 'center';\n            } else if (/^ *:-+ *$/.test(item.align[i])) {\n              item.align[i] = 'left';\n            } else {\n              item.align[i] = null;\n            }\n          }\n\n          l = item.cells.length;\n\n          for (i = 0; i < l; i++) {\n            item.cells[i] = splitCells$1(item.cells[i], item.header.length);\n          }\n\n          return item;\n        }\n      }\n    };\n\n    _proto.hr = function hr(src) {\n      var cap = this.rules.block.hr.exec(src);\n\n      if (cap) {\n        return {\n          type: 'hr',\n          raw: cap[0]\n        };\n      }\n    };\n\n    _proto.blockquote = function blockquote(src) {\n      var cap = this.rules.block.blockquote.exec(src);\n\n      if (cap) {\n        var text = cap[0].replace(/^ *> ?/gm, '');\n        return {\n          type: 'blockquote',\n          raw: cap[0],\n          text: text\n        };\n      }\n    };\n\n    _proto.list = function list(src) {\n      var cap = this.rules.block.list.exec(src);\n\n      if (cap) {\n        var raw = cap[0];\n        var bull = cap[2];\n        var isordered = bull.length > 1;\n        var isparen = bull[bull.length - 1] === ')';\n        var list = {\n          type: 'list',\n          raw: raw,\n          ordered: isordered,\n          start: isordered ? +bull.slice(0, -1) : '',\n          loose: false,\n          items: []\n        }; // Get each top-level item.\n\n        var itemMatch = cap[0].match(this.rules.block.item);\n        var next = false,\n            item,\n            space,\n            b,\n            addBack,\n            loose,\n            istask,\n            ischecked;\n        var l = itemMatch.length;\n\n        for (var i = 0; i < l; i++) {\n          item = itemMatch[i];\n          raw = item; // Remove the list item's bullet\n          // so it is seen as the next token.\n\n          space = item.length;\n          item = item.replace(/^ *([*+-]|\\d+[.)]) */, ''); // Outdent whatever the\n          // list item contains. Hacky.\n\n          if (~item.indexOf('\\n ')) {\n            space -= item.length;\n            item = !this.options.pedantic ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '') : item.replace(/^ {1,4}/gm, '');\n          } // Determine whether the next list item belongs here.\n          // Backpedal if it does not belong in this list.\n\n\n          if (i !== l - 1) {\n            b = this.rules.block.bullet.exec(itemMatch[i + 1])[0];\n\n            if (isordered ? b.length === 1 || !isparen && b[b.length - 1] === ')' : b.length > 1 || this.options.smartLists && b !== bull) {\n              addBack = itemMatch.slice(i + 1).join('\\n');\n              list.raw = list.raw.substring(0, list.raw.length - addBack.length);\n              i = l - 1;\n            }\n          } // Determine whether item is loose or not.\n          // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n          // for discount behavior.\n\n\n          loose = next || /\\n\\n(?!\\s*$)/.test(item);\n\n          if (i !== l - 1) {\n            next = item.charAt(item.length - 1) === '\\n';\n            if (!loose) loose = next;\n          }\n\n          if (loose) {\n            list.loose = true;\n          } // Check for task list items\n\n\n          istask = /^\\[[ xX]\\] /.test(item);\n          ischecked = undefined;\n\n          if (istask) {\n            ischecked = item[1] !== ' ';\n            item = item.replace(/^\\[[ xX]\\] +/, '');\n          }\n\n          list.items.push({\n            type: 'list_item',\n            raw: raw,\n            task: istask,\n            checked: ischecked,\n            loose: loose,\n            text: item\n          });\n        }\n\n        return list;\n      }\n    };\n\n    _proto.html = function html(src) {\n      var cap = this.rules.block.html.exec(src);\n\n      if (cap) {\n        return {\n          type: this.options.sanitize ? 'paragraph' : 'html',\n          raw: cap[0],\n          pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]\n        };\n      }\n    };\n\n    _proto.def = function def(src) {\n      var cap = this.rules.block.def.exec(src);\n\n      if (cap) {\n        if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);\n        var tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n        return {\n          tag: tag,\n          raw: cap[0],\n          href: cap[2],\n          title: cap[3]\n        };\n      }\n    };\n\n    _proto.table = function table(src) {\n      var cap = this.rules.block.table.exec(src);\n\n      if (cap) {\n        var item = {\n          type: 'table',\n          header: splitCells$1(cap[1].replace(/^ *| *\\| *$/g, '')),\n          align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n          cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n        };\n\n        if (item.header.length === item.align.length) {\n          item.raw = cap[0];\n          var l = item.align.length;\n          var i;\n\n          for (i = 0; i < l; i++) {\n            if (/^ *-+: *$/.test(item.align[i])) {\n              item.align[i] = 'right';\n            } else if (/^ *:-+: *$/.test(item.align[i])) {\n              item.align[i] = 'center';\n            } else if (/^ *:-+ *$/.test(item.align[i])) {\n              item.align[i] = 'left';\n            } else {\n              item.align[i] = null;\n            }\n          }\n\n          l = item.cells.length;\n\n          for (i = 0; i < l; i++) {\n            item.cells[i] = splitCells$1(item.cells[i].replace(/^ *\\| *| *\\| *$/g, ''), item.header.length);\n          }\n\n          return item;\n        }\n      }\n    };\n\n    _proto.lheading = function lheading(src) {\n      var cap = this.rules.block.lheading.exec(src);\n\n      if (cap) {\n        return {\n          type: 'heading',\n          raw: cap[0],\n          depth: cap[2].charAt(0) === '=' ? 1 : 2,\n          text: cap[1]\n        };\n      }\n    };\n\n    _proto.paragraph = function paragraph(src) {\n      var cap = this.rules.block.paragraph.exec(src);\n\n      if (cap) {\n        return {\n          type: 'paragraph',\n          raw: cap[0],\n          text: cap[1].charAt(cap[1].length - 1) === '\\n' ? cap[1].slice(0, -1) : cap[1]\n        };\n      }\n    };\n\n    _proto.text = function text(src, tokens) {\n      var cap = this.rules.block.text.exec(src);\n\n      if (cap) {\n        var lastToken = tokens[tokens.length - 1];\n\n        if (lastToken && lastToken.type === 'text') {\n          return {\n            raw: cap[0],\n            text: cap[0]\n          };\n        }\n\n        return {\n          type: 'text',\n          raw: cap[0],\n          text: cap[0]\n        };\n      }\n    };\n\n    _proto.escape = function escape(src) {\n      var cap = this.rules.inline.escape.exec(src);\n\n      if (cap) {\n        return {\n          type: 'escape',\n          raw: cap[0],\n          text: _escape(cap[1])\n        };\n      }\n    };\n\n    _proto.tag = function tag(src, inLink, inRawBlock) {\n      var cap = this.rules.inline.tag.exec(src);\n\n      if (cap) {\n        if (!inLink && /^<a /i.test(cap[0])) {\n          inLink = true;\n        } else if (inLink && /^<\\/a>/i.test(cap[0])) {\n          inLink = false;\n        }\n\n        if (!inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n          inRawBlock = true;\n        } else if (inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n          inRawBlock = false;\n        }\n\n        return {\n          type: this.options.sanitize ? 'text' : 'html',\n          raw: cap[0],\n          inLink: inLink,\n          inRawBlock: inRawBlock,\n          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]\n        };\n      }\n    };\n\n    _proto.link = function link(src) {\n      var cap = this.rules.inline.link.exec(src);\n\n      if (cap) {\n        var lastParenIndex = findClosingBracket$1(cap[2], '()');\n\n        if (lastParenIndex > -1) {\n          var start = cap[0].indexOf('!') === 0 ? 5 : 4;\n          var linkLen = start + cap[1].length + lastParenIndex;\n          cap[2] = cap[2].substring(0, lastParenIndex);\n          cap[0] = cap[0].substring(0, linkLen).trim();\n          cap[3] = '';\n        }\n\n        var href = cap[2];\n        var title = '';\n\n        if (this.options.pedantic) {\n          var link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n\n          if (link) {\n            href = link[1];\n            title = link[3];\n          } else {\n            title = '';\n          }\n        } else {\n          title = cap[3] ? cap[3].slice(1, -1) : '';\n        }\n\n        href = href.trim().replace(/^<([\\s\\S]*)>$/, '$1');\n        var token = outputLink(cap, {\n          href: href ? href.replace(this.rules.inline._escapes, '$1') : href,\n          title: title ? title.replace(this.rules.inline._escapes, '$1') : title\n        }, cap[0]);\n        return token;\n      }\n    };\n\n    _proto.reflink = function reflink(src, links) {\n      var cap;\n\n      if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n        var link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n        link = links[link.toLowerCase()];\n\n        if (!link || !link.href) {\n          var text = cap[0].charAt(0);\n          return {\n            type: 'text',\n            raw: text,\n            text: text\n          };\n        }\n\n        var token = outputLink(cap, link, cap[0]);\n        return token;\n      }\n    };\n\n    _proto.strong = function strong(src, maskedSrc, prevChar) {\n      if (prevChar === void 0) {\n        prevChar = '';\n      }\n\n      var match = this.rules.inline.strong.start.exec(src);\n\n      if (match && (!match[1] || match[1] && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar)))) {\n        maskedSrc = maskedSrc.slice(-1 * src.length);\n        var endReg = match[0] === '**' ? this.rules.inline.strong.endAst : this.rules.inline.strong.endUnd;\n        endReg.lastIndex = 0;\n        var cap;\n\n        while ((match = endReg.exec(maskedSrc)) != null) {\n          cap = this.rules.inline.strong.middle.exec(maskedSrc.slice(0, match.index + 3));\n\n          if (cap) {\n            return {\n              type: 'strong',\n              raw: src.slice(0, cap[0].length),\n              text: src.slice(2, cap[0].length - 2)\n            };\n          }\n        }\n      }\n    };\n\n    _proto.em = function em(src, maskedSrc, prevChar) {\n      if (prevChar === void 0) {\n        prevChar = '';\n      }\n\n      var match = this.rules.inline.em.start.exec(src);\n\n      if (match && (!match[1] || match[1] && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar)))) {\n        maskedSrc = maskedSrc.slice(-1 * src.length);\n        var endReg = match[0] === '*' ? this.rules.inline.em.endAst : this.rules.inline.em.endUnd;\n        endReg.lastIndex = 0;\n        var cap;\n\n        while ((match = endReg.exec(maskedSrc)) != null) {\n          cap = this.rules.inline.em.middle.exec(maskedSrc.slice(0, match.index + 2));\n\n          if (cap) {\n            return {\n              type: 'em',\n              raw: src.slice(0, cap[0].length),\n              text: src.slice(1, cap[0].length - 1)\n            };\n          }\n        }\n      }\n    };\n\n    _proto.codespan = function codespan(src) {\n      var cap = this.rules.inline.code.exec(src);\n\n      if (cap) {\n        var text = cap[2].replace(/\\n/g, ' ');\n        var hasNonSpaceChars = /[^ ]/.test(text);\n        var hasSpaceCharsOnBothEnds = text.startsWith(' ') && text.endsWith(' ');\n\n        if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n          text = text.substring(1, text.length - 1);\n        }\n\n        text = _escape(text, true);\n        return {\n          type: 'codespan',\n          raw: cap[0],\n          text: text\n        };\n      }\n    };\n\n    _proto.br = function br(src) {\n      var cap = this.rules.inline.br.exec(src);\n\n      if (cap) {\n        return {\n          type: 'br',\n          raw: cap[0]\n        };\n      }\n    };\n\n    _proto.del = function del(src) {\n      var cap = this.rules.inline.del.exec(src);\n\n      if (cap) {\n        return {\n          type: 'del',\n          raw: cap[0],\n          text: cap[1]\n        };\n      }\n    };\n\n    _proto.autolink = function autolink(src, mangle) {\n      var cap = this.rules.inline.autolink.exec(src);\n\n      if (cap) {\n        var text, href;\n\n        if (cap[2] === '@') {\n          text = _escape(this.options.mangle ? mangle(cap[1]) : cap[1]);\n          href = 'mailto:' + text;\n        } else {\n          text = _escape(cap[1]);\n          href = text;\n        }\n\n        return {\n          type: 'link',\n          raw: cap[0],\n          text: text,\n          href: href,\n          tokens: [{\n            type: 'text',\n            raw: text,\n            text: text\n          }]\n        };\n      }\n    };\n\n    _proto.url = function url(src, mangle) {\n      var cap;\n\n      if (cap = this.rules.inline.url.exec(src)) {\n        var text, href;\n\n        if (cap[2] === '@') {\n          text = _escape(this.options.mangle ? mangle(cap[0]) : cap[0]);\n          href = 'mailto:' + text;\n        } else {\n          // do extended autolink path validation\n          var prevCapZero;\n\n          do {\n            prevCapZero = cap[0];\n            cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];\n          } while (prevCapZero !== cap[0]);\n\n          text = _escape(cap[0]);\n\n          if (cap[1] === 'www.') {\n            href = 'http://' + text;\n          } else {\n            href = text;\n          }\n        }\n\n        return {\n          type: 'link',\n          raw: cap[0],\n          text: text,\n          href: href,\n          tokens: [{\n            type: 'text',\n            raw: text,\n            text: text\n          }]\n        };\n      }\n    };\n\n    _proto.inlineText = function inlineText(src, inRawBlock, smartypants) {\n      var cap = this.rules.inline.text.exec(src);\n\n      if (cap) {\n        var text;\n\n        if (inRawBlock) {\n          text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0];\n        } else {\n          text = _escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);\n        }\n\n        return {\n          type: 'text',\n          raw: cap[0],\n          text: text\n        };\n      }\n    };\n\n    return Tokenizer;\n  }();\n\n  var noopTest$1 = helpers.noopTest,\n      edit$1 = helpers.edit,\n      merge$1 = helpers.merge;\n  /**\n   * Block-Level Grammar\n   */\n\n  var block = {\n    newline: /^\\n+/,\n    code: /^( {4}[^\\n]+\\n*)+/,\n    fences: /^ {0,3}(`{3,}(?=[^`\\n]*\\n)|~{3,})([^\\n]*)\\n(?:|([\\s\\S]*?)\\n)(?: {0,3}\\1[~`]* *(?:\\n+|$)|$)/,\n    hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)/,\n    heading: /^ {0,3}(#{1,6}) +([^\\n]*?)(?: +#+)? *(?:\\n+|$)/,\n    blockquote: /^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/,\n    list: /^( {0,3})(bull) [\\s\\S]+?(?:hr|def|\\n{2,}(?! )(?!\\1bull )\\n*|\\s*$)/,\n    html: '^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (6)\n    + '|<(?!script|pre|style)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (7) open tag\n    + '|</(?!script|pre|style)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (7) closing tag\n    + ')',\n    def: /^ {0,3}\\[(label)\\]: *\\n? *<?([^\\s>]+)>?(?:(?: +\\n? *| *\\n *)(title))? *(?:\\n+|$)/,\n    nptable: noopTest$1,\n    table: noopTest$1,\n    lheading: /^([^\\n]+)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    // regex template, placeholders will be replaced according to different paragraph\n    // interruption rules of commonmark and the original markdown spec:\n    _paragraph: /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html)[^\\n]+)*)/,\n    text: /^[^\\n]+/\n  };\n  block._label = /(?!\\s*\\])(?:\\\\[\\[\\]]|[^\\[\\]])+/;\n  block._title = /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/;\n  block.def = edit$1(block.def).replace('label', block._label).replace('title', block._title).getRegex();\n  block.bullet = /(?:[*+-]|\\d{1,9}[.)])/;\n  block.item = /^( *)(bull) ?[^\\n]*(?:\\n(?!\\1bull ?)[^\\n]*)*/;\n  block.item = edit$1(block.item, 'gm').replace(/bull/g, block.bullet).getRegex();\n  block.list = edit$1(block.list).replace(/bull/g, block.bullet).replace('hr', '\\\\n+(?=\\\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$))').replace('def', '\\\\n+(?=' + block.def.source + ')').getRegex();\n  block._tag = 'address|article|aside|base|basefont|blockquote|body|caption' + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr' + '|track|ul';\n  block._comment = /<!--(?!-?>)[\\s\\S]*?(?:-->|$)/;\n  block.html = edit$1(block.html, 'i').replace('comment', block._comment).replace('tag', block._tag).replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\n  block.paragraph = edit$1(block._paragraph).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n  .replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|!--)').replace('tag', block._tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n  block.blockquote = edit$1(block.blockquote).replace('paragraph', block.paragraph).getRegex();\n  /**\n   * Normal Block Grammar\n   */\n\n  block.normal = merge$1({}, block);\n  /**\n   * GFM Block Grammar\n   */\n\n  block.gfm = merge$1({}, block.normal, {\n    nptable: '^ *([^|\\\\n ].*\\\\|.*)\\\\n' // Header\n    + ' {0,3}([-:]+ *\\\\|[-| :]*)' // Align\n    + '(?:\\\\n((?:(?!\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)',\n    // Cells\n    table: '^ *\\\\|(.+)\\\\n' // Header\n    + ' {0,3}\\\\|?( *[-:]+[-| :]*)' // Align\n    + '(?:\\\\n *((?:(?!\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)' // Cells\n\n  });\n  block.gfm.nptable = edit$1(block.gfm.nptable).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|!--)').replace('tag', block._tag) // tables can be interrupted by type (6) html blocks\n  .getRegex();\n  block.gfm.table = edit$1(block.gfm.table).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|!--)').replace('tag', block._tag) // tables can be interrupted by type (6) html blocks\n  .getRegex();\n  /**\n   * Pedantic grammar (original John Gruber's loose markdown specification)\n   */\n\n  block.pedantic = merge$1({}, block.normal, {\n    html: edit$1('^ *(?:comment *(?:\\\\n|\\\\s*$)' + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n    + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))').replace('comment', block._comment).replace(/tag/g, '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b').getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^ *(#{1,6}) *([^\\n]+?) *(?:#+ *)?(?:\\n+|$)/,\n    fences: noopTest$1,\n    // fences not supported\n    paragraph: edit$1(block.normal._paragraph).replace('hr', block.hr).replace('heading', ' *#{1,6} *[^\\n]').replace('lheading', block.lheading).replace('blockquote', ' {0,3}>').replace('|fences', '').replace('|list', '').replace('|html', '').getRegex()\n  });\n  /**\n   * Inline-Level Grammar\n   */\n\n  var inline = {\n    escape: /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n    autolink: /^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/,\n    url: noopTest$1,\n    tag: '^comment' + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>',\n    // CDATA section\n    link: /^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/,\n    reflink: /^!?\\[(label)\\]\\[(?!\\s*\\])((?:\\\\[\\[\\]]?|[^\\[\\]\\\\])+)\\]/,\n    nolink: /^!?\\[(?!\\s*\\])((?:\\[[^\\[\\]]*\\]|\\\\[\\[\\]]|[^\\[\\]])*)\\](?:\\[\\])?/,\n    reflinkSearch: 'reflink|nolink(?!\\\\()',\n    strong: {\n      start: /^(?:(\\*\\*(?=[*punctuation]))|\\*\\*)(?![\\s])|__/,\n      // (1) returns if starts w/ punctuation\n      middle: /^\\*\\*(?:(?:(?!overlapSkip)(?:[^*]|\\\\\\*)|overlapSkip)|\\*(?:(?!overlapSkip)(?:[^*]|\\\\\\*)|overlapSkip)*?\\*)+?\\*\\*$|^__(?![\\s])((?:(?:(?!overlapSkip)(?:[^_]|\\\\_)|overlapSkip)|_(?:(?!overlapSkip)(?:[^_]|\\\\_)|overlapSkip)*?_)+?)__$/,\n      endAst: /[^punctuation\\s]\\*\\*(?!\\*)|[punctuation]\\*\\*(?!\\*)(?:(?=[punctuation_\\s]|$))/,\n      // last char can't be punct, or final * must also be followed by punct (or endline)\n      endUnd: /[^\\s]__(?!_)(?:(?=[punctuation*\\s])|$)/ // last char can't be a space, and final _ must preceed punct or \\s (or endline)\n\n    },\n    em: {\n      start: /^(?:(\\*(?=[punctuation]))|\\*)(?![*\\s])|_/,\n      // (1) returns if starts w/ punctuation\n      middle: /^\\*(?:(?:(?!overlapSkip)(?:[^*]|\\\\\\*)|overlapSkip)|\\*(?:(?!overlapSkip)(?:[^*]|\\\\\\*)|overlapSkip)*?\\*)+?\\*$|^_(?![_\\s])(?:(?:(?!overlapSkip)(?:[^_]|\\\\_)|overlapSkip)|_(?:(?!overlapSkip)(?:[^_]|\\\\_)|overlapSkip)*?_)+?_$/,\n      endAst: /[^punctuation\\s]\\*(?!\\*)|[punctuation]\\*(?!\\*)(?:(?=[punctuation_\\s]|$))/,\n      // last char can't be punct, or final * must also be followed by punct (or endline)\n      endUnd: /[^\\s]_(?!_)(?:(?=[punctuation*\\s])|$)/ // last char can't be a space, and final _ must preceed punct or \\s (or endline)\n\n    },\n    code: /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/,\n    br: /^( {2,}|\\\\)\\n(?!\\s*$)/,\n    del: noopTest$1,\n    text: /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*]|\\b_|$)|[^ ](?= {2,}\\n)))/,\n    punctuation: /^([\\s*punctuation])/\n  }; // list of punctuation marks from common mark spec\n  // without * and _ to workaround cases with double emphasis\n\n  inline._punctuation = '!\"#$%&\\'()+\\\\-.,/:;<=>?@\\\\[\\\\]`^{|}~';\n  inline.punctuation = edit$1(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex(); // sequences em should skip over [title](link), `code`, <html>\n\n  inline._blockSkip = '\\\\[[^\\\\]]*?\\\\]\\\\([^\\\\)]*?\\\\)|`[^`]*?`|<[^>]*?>';\n  inline._overlapSkip = '__[^_]*?__|\\\\*\\\\*\\\\[^\\\\*\\\\]*?\\\\*\\\\*';\n  inline._comment = edit$1(block._comment).replace('(?:-->|$)', '-->').getRegex();\n  inline.em.start = edit$1(inline.em.start).replace(/punctuation/g, inline._punctuation).getRegex();\n  inline.em.middle = edit$1(inline.em.middle).replace(/punctuation/g, inline._punctuation).replace(/overlapSkip/g, inline._overlapSkip).getRegex();\n  inline.em.endAst = edit$1(inline.em.endAst, 'g').replace(/punctuation/g, inline._punctuation).getRegex();\n  inline.em.endUnd = edit$1(inline.em.endUnd, 'g').replace(/punctuation/g, inline._punctuation).getRegex();\n  inline.strong.start = edit$1(inline.strong.start).replace(/punctuation/g, inline._punctuation).getRegex();\n  inline.strong.middle = edit$1(inline.strong.middle).replace(/punctuation/g, inline._punctuation).replace(/overlapSkip/g, inline._overlapSkip).getRegex();\n  inline.strong.endAst = edit$1(inline.strong.endAst, 'g').replace(/punctuation/g, inline._punctuation).getRegex();\n  inline.strong.endUnd = edit$1(inline.strong.endUnd, 'g').replace(/punctuation/g, inline._punctuation).getRegex();\n  inline.blockSkip = edit$1(inline._blockSkip, 'g').getRegex();\n  inline.overlapSkip = edit$1(inline._overlapSkip, 'g').getRegex();\n  inline._escapes = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/g;\n  inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;\n  inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;\n  inline.autolink = edit$1(inline.autolink).replace('scheme', inline._scheme).replace('email', inline._email).getRegex();\n  inline._attribute = /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/;\n  inline.tag = edit$1(inline.tag).replace('comment', inline._comment).replace('attribute', inline._attribute).getRegex();\n  inline._label = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\n  inline._href = /<(?:\\\\[<>]?|[^\\s<>\\\\])*>|[^\\s\\x00-\\x1f]*/;\n  inline._title = /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/;\n  inline.link = edit$1(inline.link).replace('label', inline._label).replace('href', inline._href).replace('title', inline._title).getRegex();\n  inline.reflink = edit$1(inline.reflink).replace('label', inline._label).getRegex();\n  inline.reflinkSearch = edit$1(inline.reflinkSearch, 'g').replace('reflink', inline.reflink).replace('nolink', inline.nolink).getRegex();\n  /**\n   * Normal Inline Grammar\n   */\n\n  inline.normal = merge$1({}, inline);\n  /**\n   * Pedantic Inline Grammar\n   */\n\n  inline.pedantic = merge$1({}, inline.normal, {\n    strong: {\n      start: /^__|\\*\\*/,\n      middle: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n      endAst: /\\*\\*(?!\\*)/g,\n      endUnd: /__(?!_)/g\n    },\n    em: {\n      start: /^_|\\*/,\n      middle: /^()\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)|^_(?=\\S)([\\s\\S]*?\\S)_(?!_)/,\n      endAst: /\\*(?!\\*)/g,\n      endUnd: /_(?!_)/g\n    },\n    link: edit$1(/^!?\\[(label)\\]\\((.*?)\\)/).replace('label', inline._label).getRegex(),\n    reflink: edit$1(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace('label', inline._label).getRegex()\n  });\n  /**\n   * GFM Inline Grammar\n   */\n\n  inline.gfm = merge$1({}, inline.normal, {\n    escape: edit$1(inline.escape).replace('])', '~|])').getRegex(),\n    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,\n    url: /^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/,\n    _backpedal: /(?:[^?!.,:;*_~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,\n    del: /^~+(?=\\S)([\\s\\S]*?\\S)~+/,\n    text: /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@))|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@))/\n  });\n  inline.gfm.url = edit$1(inline.gfm.url, 'i').replace('email', inline.gfm._extended_email).getRegex();\n  /**\n   * GFM + Line Breaks Inline Grammar\n   */\n\n  inline.breaks = merge$1({}, inline.gfm, {\n    br: edit$1(inline.br).replace('{2,}', '*').getRegex(),\n    text: edit$1(inline.gfm.text).replace('\\\\b_', '\\\\b_| {2,}\\\\n').replace(/\\{2,\\}/g, '*').getRegex()\n  });\n  var rules = {\n    block: block,\n    inline: inline\n  };\n\n  var defaults$2 = defaults.defaults;\n  var block$1 = rules.block,\n      inline$1 = rules.inline;\n  /**\n   * smartypants text replacement\n   */\n\n  function smartypants(text) {\n    return text // em-dashes\n    .replace(/---/g, \"\\u2014\") // en-dashes\n    .replace(/--/g, \"\\u2013\") // opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, \"$1\\u2018\") // closing singles & apostrophes\n    .replace(/'/g, \"\\u2019\") // opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, \"$1\\u201C\") // closing doubles\n    .replace(/\"/g, \"\\u201D\") // ellipses\n    .replace(/\\.{3}/g, \"\\u2026\");\n  }\n  /**\n   * mangle email addresses\n   */\n\n\n  function mangle(text) {\n    var out = '',\n        i,\n        ch;\n    var l = text.length;\n\n    for (i = 0; i < l; i++) {\n      ch = text.charCodeAt(i);\n\n      if (Math.random() > 0.5) {\n        ch = 'x' + ch.toString(16);\n      }\n\n      out += '&#' + ch + ';';\n    }\n\n    return out;\n  }\n  /**\n   * Block Lexer\n   */\n\n\n  var Lexer_1 = /*#__PURE__*/function () {\n    function Lexer(options) {\n      this.tokens = [];\n      this.tokens.links = Object.create(null);\n      this.options = options || defaults$2;\n      this.options.tokenizer = this.options.tokenizer || new Tokenizer_1();\n      this.tokenizer = this.options.tokenizer;\n      this.tokenizer.options = this.options;\n      var rules = {\n        block: block$1.normal,\n        inline: inline$1.normal\n      };\n\n      if (this.options.pedantic) {\n        rules.block = block$1.pedantic;\n        rules.inline = inline$1.pedantic;\n      } else if (this.options.gfm) {\n        rules.block = block$1.gfm;\n\n        if (this.options.breaks) {\n          rules.inline = inline$1.breaks;\n        } else {\n          rules.inline = inline$1.gfm;\n        }\n      }\n\n      this.tokenizer.rules = rules;\n    }\n    /**\n     * Expose Rules\n     */\n\n\n    /**\n     * Static Lex Method\n     */\n    Lexer.lex = function lex(src, options) {\n      var lexer = new Lexer(options);\n      return lexer.lex(src);\n    }\n    /**\n     * Static Lex Inline Method\n     */\n    ;\n\n    Lexer.lexInline = function lexInline(src, options) {\n      var lexer = new Lexer(options);\n      return lexer.inlineTokens(src);\n    }\n    /**\n     * Preprocessing\n     */\n    ;\n\n    var _proto = Lexer.prototype;\n\n    _proto.lex = function lex(src) {\n      src = src.replace(/\\r\\n|\\r/g, '\\n').replace(/\\t/g, '    ');\n      this.blockTokens(src, this.tokens, true);\n      this.inline(this.tokens);\n      return this.tokens;\n    }\n    /**\n     * Lexing\n     */\n    ;\n\n    _proto.blockTokens = function blockTokens(src, tokens, top) {\n      if (tokens === void 0) {\n        tokens = [];\n      }\n\n      if (top === void 0) {\n        top = true;\n      }\n\n      src = src.replace(/^ +$/gm, '');\n      var token, i, l, lastToken;\n\n      while (src) {\n        // newline\n        if (token = this.tokenizer.space(src)) {\n          src = src.substring(token.raw.length);\n\n          if (token.type) {\n            tokens.push(token);\n          }\n\n          continue;\n        } // code\n\n\n        if (token = this.tokenizer.code(src, tokens)) {\n          src = src.substring(token.raw.length);\n\n          if (token.type) {\n            tokens.push(token);\n          } else {\n            lastToken = tokens[tokens.length - 1];\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.text;\n          }\n\n          continue;\n        } // fences\n\n\n        if (token = this.tokenizer.fences(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // heading\n\n\n        if (token = this.tokenizer.heading(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // table no leading pipe (gfm)\n\n\n        if (token = this.tokenizer.nptable(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // hr\n\n\n        if (token = this.tokenizer.hr(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // blockquote\n\n\n        if (token = this.tokenizer.blockquote(src)) {\n          src = src.substring(token.raw.length);\n          token.tokens = this.blockTokens(token.text, [], top);\n          tokens.push(token);\n          continue;\n        } // list\n\n\n        if (token = this.tokenizer.list(src)) {\n          src = src.substring(token.raw.length);\n          l = token.items.length;\n\n          for (i = 0; i < l; i++) {\n            token.items[i].tokens = this.blockTokens(token.items[i].text, [], false);\n          }\n\n          tokens.push(token);\n          continue;\n        } // html\n\n\n        if (token = this.tokenizer.html(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // def\n\n\n        if (top && (token = this.tokenizer.def(src))) {\n          src = src.substring(token.raw.length);\n\n          if (!this.tokens.links[token.tag]) {\n            this.tokens.links[token.tag] = {\n              href: token.href,\n              title: token.title\n            };\n          }\n\n          continue;\n        } // table (gfm)\n\n\n        if (token = this.tokenizer.table(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // lheading\n\n\n        if (token = this.tokenizer.lheading(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // top-level paragraph\n\n\n        if (top && (token = this.tokenizer.paragraph(src))) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // text\n\n\n        if (token = this.tokenizer.text(src, tokens)) {\n          src = src.substring(token.raw.length);\n\n          if (token.type) {\n            tokens.push(token);\n          } else {\n            lastToken = tokens[tokens.length - 1];\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.text;\n          }\n\n          continue;\n        }\n\n        if (src) {\n          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n\n          if (this.options.silent) {\n            console.error(errMsg);\n            break;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n\n      return tokens;\n    };\n\n    _proto.inline = function inline(tokens) {\n      var i, j, k, l2, row, token;\n      var l = tokens.length;\n\n      for (i = 0; i < l; i++) {\n        token = tokens[i];\n\n        switch (token.type) {\n          case 'paragraph':\n          case 'text':\n          case 'heading':\n            {\n              token.tokens = [];\n              this.inlineTokens(token.text, token.tokens);\n              break;\n            }\n\n          case 'table':\n            {\n              token.tokens = {\n                header: [],\n                cells: []\n              }; // header\n\n              l2 = token.header.length;\n\n              for (j = 0; j < l2; j++) {\n                token.tokens.header[j] = [];\n                this.inlineTokens(token.header[j], token.tokens.header[j]);\n              } // cells\n\n\n              l2 = token.cells.length;\n\n              for (j = 0; j < l2; j++) {\n                row = token.cells[j];\n                token.tokens.cells[j] = [];\n\n                for (k = 0; k < row.length; k++) {\n                  token.tokens.cells[j][k] = [];\n                  this.inlineTokens(row[k], token.tokens.cells[j][k]);\n                }\n              }\n\n              break;\n            }\n\n          case 'blockquote':\n            {\n              this.inline(token.tokens);\n              break;\n            }\n\n          case 'list':\n            {\n              l2 = token.items.length;\n\n              for (j = 0; j < l2; j++) {\n                this.inline(token.items[j].tokens);\n              }\n\n              break;\n            }\n        }\n      }\n\n      return tokens;\n    }\n    /**\n     * Lexing/Compiling\n     */\n    ;\n\n    _proto.inlineTokens = function inlineTokens(src, tokens, inLink, inRawBlock, prevChar) {\n      if (tokens === void 0) {\n        tokens = [];\n      }\n\n      if (inLink === void 0) {\n        inLink = false;\n      }\n\n      if (inRawBlock === void 0) {\n        inRawBlock = false;\n      }\n\n      if (prevChar === void 0) {\n        prevChar = '';\n      }\n\n      var token; // String with links masked to avoid interference with em and strong\n\n      var maskedSrc = src;\n      var match; // Mask out reflinks\n\n      if (this.tokens.links) {\n        var links = Object.keys(this.tokens.links);\n\n        if (links.length > 0) {\n          while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n            if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n              maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n            }\n          }\n        }\n      } // Mask out other blocks\n\n\n      while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n        maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n      }\n\n      while (src) {\n        // escape\n        if (token = this.tokenizer.escape(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // tag\n\n\n        if (token = this.tokenizer.tag(src, inLink, inRawBlock)) {\n          src = src.substring(token.raw.length);\n          inLink = token.inLink;\n          inRawBlock = token.inRawBlock;\n          tokens.push(token);\n          continue;\n        } // link\n\n\n        if (token = this.tokenizer.link(src)) {\n          src = src.substring(token.raw.length);\n\n          if (token.type === 'link') {\n            token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);\n          }\n\n          tokens.push(token);\n          continue;\n        } // reflink, nolink\n\n\n        if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n          src = src.substring(token.raw.length);\n\n          if (token.type === 'link') {\n            token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);\n          }\n\n          tokens.push(token);\n          continue;\n        } // strong\n\n\n        if (token = this.tokenizer.strong(src, maskedSrc, prevChar)) {\n          src = src.substring(token.raw.length);\n          token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);\n          tokens.push(token);\n          continue;\n        } // em\n\n\n        if (token = this.tokenizer.em(src, maskedSrc, prevChar)) {\n          src = src.substring(token.raw.length);\n          token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);\n          tokens.push(token);\n          continue;\n        } // code\n\n\n        if (token = this.tokenizer.codespan(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // br\n\n\n        if (token = this.tokenizer.br(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // del (gfm)\n\n\n        if (token = this.tokenizer.del(src)) {\n          src = src.substring(token.raw.length);\n          token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);\n          tokens.push(token);\n          continue;\n        } // autolink\n\n\n        if (token = this.tokenizer.autolink(src, mangle)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // url (gfm)\n\n\n        if (!inLink && (token = this.tokenizer.url(src, mangle))) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // text\n\n\n        if (token = this.tokenizer.inlineText(src, inRawBlock, smartypants)) {\n          src = src.substring(token.raw.length);\n          prevChar = token.raw.slice(-1);\n          tokens.push(token);\n          continue;\n        }\n\n        if (src) {\n          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n\n          if (this.options.silent) {\n            console.error(errMsg);\n            break;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n\n      return tokens;\n    };\n\n    _createClass(Lexer, null, [{\n      key: \"rules\",\n      get: function get() {\n        return {\n          block: block$1,\n          inline: inline$1\n        };\n      }\n    }]);\n\n    return Lexer;\n  }();\n\n  var defaults$3 = defaults.defaults;\n  var cleanUrl$1 = helpers.cleanUrl,\n      escape$1 = helpers.escape;\n  /**\n   * Renderer\n   */\n\n  var Renderer_1 = /*#__PURE__*/function () {\n    function Renderer(options) {\n      this.options = options || defaults$3;\n    }\n\n    var _proto = Renderer.prototype;\n\n    _proto.code = function code(_code, infostring, escaped) {\n      var lang = (infostring || '').match(/\\S*/)[0];\n\n      if (this.options.highlight) {\n        var out = this.options.highlight(_code, lang);\n\n        if (out != null && out !== _code) {\n          escaped = true;\n          _code = out;\n        }\n      }\n\n      if (!lang) {\n        return '<pre><code>' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\\n';\n      }\n\n      return '<pre><code class=\"' + this.options.langPrefix + escape$1(lang, true) + '\">' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\\n';\n    };\n\n    _proto.blockquote = function blockquote(quote) {\n      return '<blockquote>\\n' + quote + '</blockquote>\\n';\n    };\n\n    _proto.html = function html(_html) {\n      return _html;\n    };\n\n    _proto.heading = function heading(text, level, raw, slugger) {\n      if (this.options.headerIds) {\n        return '<h' + level + ' id=\"' + this.options.headerPrefix + slugger.slug(raw) + '\">' + text + '</h' + level + '>\\n';\n      } // ignore IDs\n\n\n      return '<h' + level + '>' + text + '</h' + level + '>\\n';\n    };\n\n    _proto.hr = function hr() {\n      return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n    };\n\n    _proto.list = function list(body, ordered, start) {\n      var type = ordered ? 'ol' : 'ul',\n          startatt = ordered && start !== 1 ? ' start=\"' + start + '\"' : '';\n      return '<' + type + startatt + '>\\n' + body + '</' + type + '>\\n';\n    };\n\n    _proto.listitem = function listitem(text) {\n      return '<li>' + text + '</li>\\n';\n    };\n\n    _proto.checkbox = function checkbox(checked) {\n      return '<input ' + (checked ? 'checked=\"\" ' : '') + 'disabled=\"\" type=\"checkbox\"' + (this.options.xhtml ? ' /' : '') + '> ';\n    };\n\n    _proto.paragraph = function paragraph(text) {\n      return '<p>' + text + '</p>\\n';\n    };\n\n    _proto.table = function table(header, body) {\n      if (body) body = '<tbody>' + body + '</tbody>';\n      return '<table>\\n' + '<thead>\\n' + header + '</thead>\\n' + body + '</table>\\n';\n    };\n\n    _proto.tablerow = function tablerow(content) {\n      return '<tr>\\n' + content + '</tr>\\n';\n    };\n\n    _proto.tablecell = function tablecell(content, flags) {\n      var type = flags.header ? 'th' : 'td';\n      var tag = flags.align ? '<' + type + ' align=\"' + flags.align + '\">' : '<' + type + '>';\n      return tag + content + '</' + type + '>\\n';\n    } // span level renderer\n    ;\n\n    _proto.strong = function strong(text) {\n      return '<strong>' + text + '</strong>';\n    };\n\n    _proto.em = function em(text) {\n      return '<em>' + text + '</em>';\n    };\n\n    _proto.codespan = function codespan(text) {\n      return '<code>' + text + '</code>';\n    };\n\n    _proto.br = function br() {\n      return this.options.xhtml ? '<br/>' : '<br>';\n    };\n\n    _proto.del = function del(text) {\n      return '<del>' + text + '</del>';\n    };\n\n    _proto.link = function link(href, title, text) {\n      href = cleanUrl$1(this.options.sanitize, this.options.baseUrl, href);\n\n      if (href === null) {\n        return text;\n      }\n\n      var out = '<a href=\"' + escape$1(href) + '\"';\n\n      if (title) {\n        out += ' title=\"' + title + '\"';\n      }\n\n      out += '>' + text + '</a>';\n      return out;\n    };\n\n    _proto.image = function image(href, title, text) {\n      href = cleanUrl$1(this.options.sanitize, this.options.baseUrl, href);\n\n      if (href === null) {\n        return text;\n      }\n\n      var out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n\n      if (title) {\n        out += ' title=\"' + title + '\"';\n      }\n\n      out += this.options.xhtml ? '/>' : '>';\n      return out;\n    };\n\n    _proto.text = function text(_text) {\n      return _text;\n    };\n\n    return Renderer;\n  }();\n\n  /**\n   * TextRenderer\n   * returns only the textual part of the token\n   */\n  var TextRenderer_1 = /*#__PURE__*/function () {\n    function TextRenderer() {}\n\n    var _proto = TextRenderer.prototype;\n\n    // no need for block level renderers\n    _proto.strong = function strong(text) {\n      return text;\n    };\n\n    _proto.em = function em(text) {\n      return text;\n    };\n\n    _proto.codespan = function codespan(text) {\n      return text;\n    };\n\n    _proto.del = function del(text) {\n      return text;\n    };\n\n    _proto.html = function html(text) {\n      return text;\n    };\n\n    _proto.text = function text(_text) {\n      return _text;\n    };\n\n    _proto.link = function link(href, title, text) {\n      return '' + text;\n    };\n\n    _proto.image = function image(href, title, text) {\n      return '' + text;\n    };\n\n    _proto.br = function br() {\n      return '';\n    };\n\n    return TextRenderer;\n  }();\n\n  /**\n   * Slugger generates header id\n   */\n  var Slugger_1 = /*#__PURE__*/function () {\n    function Slugger() {\n      this.seen = {};\n    }\n\n    var _proto = Slugger.prototype;\n\n    _proto.serialize = function serialize(value) {\n      return value.toLowerCase().trim() // remove html tags\n      .replace(/<[!\\/a-z].*?>/ig, '') // remove unwanted chars\n      .replace(/[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,./:;<=>?@[\\]^`{|}~]/g, '').replace(/\\s/g, '-');\n    }\n    /**\n     * Finds the next safe (unique) slug to use\n     */\n    ;\n\n    _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {\n      var slug = originalSlug;\n      var occurenceAccumulator = 0;\n\n      if (this.seen.hasOwnProperty(slug)) {\n        occurenceAccumulator = this.seen[originalSlug];\n\n        do {\n          occurenceAccumulator++;\n          slug = originalSlug + '-' + occurenceAccumulator;\n        } while (this.seen.hasOwnProperty(slug));\n      }\n\n      if (!isDryRun) {\n        this.seen[originalSlug] = occurenceAccumulator;\n        this.seen[slug] = 0;\n      }\n\n      return slug;\n    }\n    /**\n     * Convert string to unique id\n     * @param {object} options\n     * @param {boolean} options.dryrun Generates the next unique slug without updating the internal accumulator.\n     */\n    ;\n\n    _proto.slug = function slug(value, options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      var slug = this.serialize(value);\n      return this.getNextSafeSlug(slug, options.dryrun);\n    };\n\n    return Slugger;\n  }();\n\n  var defaults$4 = defaults.defaults;\n  var unescape$1 = helpers.unescape;\n  /**\n   * Parsing & Compiling\n   */\n\n  var Parser_1 = /*#__PURE__*/function () {\n    function Parser(options) {\n      this.options = options || defaults$4;\n      this.options.renderer = this.options.renderer || new Renderer_1();\n      this.renderer = this.options.renderer;\n      this.renderer.options = this.options;\n      this.textRenderer = new TextRenderer_1();\n      this.slugger = new Slugger_1();\n    }\n    /**\n     * Static Parse Method\n     */\n\n\n    Parser.parse = function parse(tokens, options) {\n      var parser = new Parser(options);\n      return parser.parse(tokens);\n    }\n    /**\n     * Static Parse Inline Method\n     */\n    ;\n\n    Parser.parseInline = function parseInline(tokens, options) {\n      var parser = new Parser(options);\n      return parser.parseInline(tokens);\n    }\n    /**\n     * Parse Loop\n     */\n    ;\n\n    var _proto = Parser.prototype;\n\n    _proto.parse = function parse(tokens, top) {\n      if (top === void 0) {\n        top = true;\n      }\n\n      var out = '',\n          i,\n          j,\n          k,\n          l2,\n          l3,\n          row,\n          cell,\n          header,\n          body,\n          token,\n          ordered,\n          start,\n          loose,\n          itemBody,\n          item,\n          checked,\n          task,\n          checkbox;\n      var l = tokens.length;\n\n      for (i = 0; i < l; i++) {\n        token = tokens[i];\n\n        switch (token.type) {\n          case 'space':\n            {\n              continue;\n            }\n\n          case 'hr':\n            {\n              out += this.renderer.hr();\n              continue;\n            }\n\n          case 'heading':\n            {\n              out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape$1(this.parseInline(token.tokens, this.textRenderer)), this.slugger);\n              continue;\n            }\n\n          case 'code':\n            {\n              out += this.renderer.code(token.text, token.lang, token.escaped);\n              continue;\n            }\n\n          case 'table':\n            {\n              header = ''; // header\n\n              cell = '';\n              l2 = token.header.length;\n\n              for (j = 0; j < l2; j++) {\n                cell += this.renderer.tablecell(this.parseInline(token.tokens.header[j]), {\n                  header: true,\n                  align: token.align[j]\n                });\n              }\n\n              header += this.renderer.tablerow(cell);\n              body = '';\n              l2 = token.cells.length;\n\n              for (j = 0; j < l2; j++) {\n                row = token.tokens.cells[j];\n                cell = '';\n                l3 = row.length;\n\n                for (k = 0; k < l3; k++) {\n                  cell += this.renderer.tablecell(this.parseInline(row[k]), {\n                    header: false,\n                    align: token.align[k]\n                  });\n                }\n\n                body += this.renderer.tablerow(cell);\n              }\n\n              out += this.renderer.table(header, body);\n              continue;\n            }\n\n          case 'blockquote':\n            {\n              body = this.parse(token.tokens);\n              out += this.renderer.blockquote(body);\n              continue;\n            }\n\n          case 'list':\n            {\n              ordered = token.ordered;\n              start = token.start;\n              loose = token.loose;\n              l2 = token.items.length;\n              body = '';\n\n              for (j = 0; j < l2; j++) {\n                item = token.items[j];\n                checked = item.checked;\n                task = item.task;\n                itemBody = '';\n\n                if (item.task) {\n                  checkbox = this.renderer.checkbox(checked);\n\n                  if (loose) {\n                    if (item.tokens.length > 0 && item.tokens[0].type === 'text') {\n                      item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n\n                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n                      }\n                    } else {\n                      item.tokens.unshift({\n                        type: 'text',\n                        text: checkbox\n                      });\n                    }\n                  } else {\n                    itemBody += checkbox;\n                  }\n                }\n\n                itemBody += this.parse(item.tokens, loose);\n                body += this.renderer.listitem(itemBody, task, checked);\n              }\n\n              out += this.renderer.list(body, ordered, start);\n              continue;\n            }\n\n          case 'html':\n            {\n              // TODO parse inline content if parameter markdown=1\n              out += this.renderer.html(token.text);\n              continue;\n            }\n\n          case 'paragraph':\n            {\n              out += this.renderer.paragraph(this.parseInline(token.tokens));\n              continue;\n            }\n\n          case 'text':\n            {\n              body = token.tokens ? this.parseInline(token.tokens) : token.text;\n\n              while (i + 1 < l && tokens[i + 1].type === 'text') {\n                token = tokens[++i];\n                body += '\\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);\n              }\n\n              out += top ? this.renderer.paragraph(body) : body;\n              continue;\n            }\n\n          default:\n            {\n              var errMsg = 'Token with \"' + token.type + '\" type was not found.';\n\n              if (this.options.silent) {\n                console.error(errMsg);\n                return;\n              } else {\n                throw new Error(errMsg);\n              }\n            }\n        }\n      }\n\n      return out;\n    }\n    /**\n     * Parse Inline Tokens\n     */\n    ;\n\n    _proto.parseInline = function parseInline(tokens, renderer) {\n      renderer = renderer || this.renderer;\n      var out = '',\n          i,\n          token;\n      var l = tokens.length;\n\n      for (i = 0; i < l; i++) {\n        token = tokens[i];\n\n        switch (token.type) {\n          case 'escape':\n            {\n              out += renderer.text(token.text);\n              break;\n            }\n\n          case 'html':\n            {\n              out += renderer.html(token.text);\n              break;\n            }\n\n          case 'link':\n            {\n              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'image':\n            {\n              out += renderer.image(token.href, token.title, token.text);\n              break;\n            }\n\n          case 'strong':\n            {\n              out += renderer.strong(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'em':\n            {\n              out += renderer.em(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'codespan':\n            {\n              out += renderer.codespan(token.text);\n              break;\n            }\n\n          case 'br':\n            {\n              out += renderer.br();\n              break;\n            }\n\n          case 'del':\n            {\n              out += renderer.del(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'text':\n            {\n              out += renderer.text(token.text);\n              break;\n            }\n\n          default:\n            {\n              var errMsg = 'Token with \"' + token.type + '\" type was not found.';\n\n              if (this.options.silent) {\n                console.error(errMsg);\n                return;\n              } else {\n                throw new Error(errMsg);\n              }\n            }\n        }\n      }\n\n      return out;\n    };\n\n    return Parser;\n  }();\n\n  var merge$2 = helpers.merge,\n      checkSanitizeDeprecation$1 = helpers.checkSanitizeDeprecation,\n      escape$2 = helpers.escape;\n  var getDefaults = defaults.getDefaults,\n      changeDefaults = defaults.changeDefaults,\n      defaults$5 = defaults.defaults;\n  /**\n   * Marked\n   */\n\n  function marked(src, opt, callback) {\n    // throw error in case of non string input\n    if (typeof src === 'undefined' || src === null) {\n      throw new Error('marked(): input parameter is undefined or null');\n    }\n\n    if (typeof src !== 'string') {\n      throw new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');\n    }\n\n    if (typeof opt === 'function') {\n      callback = opt;\n      opt = null;\n    }\n\n    opt = merge$2({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation$1(opt);\n\n    if (callback) {\n      var highlight = opt.highlight;\n      var tokens;\n\n      try {\n        tokens = Lexer_1.lex(src, opt);\n      } catch (e) {\n        return callback(e);\n      }\n\n      var done = function done(err) {\n        var out;\n\n        if (!err) {\n          try {\n            out = Parser_1.parse(tokens, opt);\n          } catch (e) {\n            err = e;\n          }\n        }\n\n        opt.highlight = highlight;\n        return err ? callback(err) : callback(null, out);\n      };\n\n      if (!highlight || highlight.length < 3) {\n        return done();\n      }\n\n      delete opt.highlight;\n      if (!tokens.length) return done();\n      var pending = 0;\n      marked.walkTokens(tokens, function (token) {\n        if (token.type === 'code') {\n          pending++;\n          setTimeout(function () {\n            highlight(token.text, token.lang, function (err, code) {\n              if (err) {\n                return done(err);\n              }\n\n              if (code != null && code !== token.text) {\n                token.text = code;\n                token.escaped = true;\n              }\n\n              pending--;\n\n              if (pending === 0) {\n                done();\n              }\n            });\n          }, 0);\n        }\n      });\n\n      if (pending === 0) {\n        done();\n      }\n\n      return;\n    }\n\n    try {\n      var _tokens = Lexer_1.lex(src, opt);\n\n      if (opt.walkTokens) {\n        marked.walkTokens(_tokens, opt.walkTokens);\n      }\n\n      return Parser_1.parse(_tokens, opt);\n    } catch (e) {\n      e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n      if (opt.silent) {\n        return '<p>An error occurred:</p><pre>' + escape$2(e.message + '', true) + '</pre>';\n      }\n\n      throw e;\n    }\n  }\n  /**\n   * Options\n   */\n\n\n  marked.options = marked.setOptions = function (opt) {\n    merge$2(marked.defaults, opt);\n    changeDefaults(marked.defaults);\n    return marked;\n  };\n\n  marked.getDefaults = getDefaults;\n  marked.defaults = defaults$5;\n  /**\n   * Use Extension\n   */\n\n  marked.use = function (extension) {\n    var opts = merge$2({}, extension);\n\n    if (extension.renderer) {\n      (function () {\n        var renderer = marked.defaults.renderer || new Renderer_1();\n\n        var _loop = function _loop(prop) {\n          var prevRenderer = renderer[prop];\n\n          renderer[prop] = function () {\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n\n            var ret = extension.renderer[prop].apply(renderer, args);\n\n            if (ret === false) {\n              ret = prevRenderer.apply(renderer, args);\n            }\n\n            return ret;\n          };\n        };\n\n        for (var prop in extension.renderer) {\n          _loop(prop);\n        }\n\n        opts.renderer = renderer;\n      })();\n    }\n\n    if (extension.tokenizer) {\n      (function () {\n        var tokenizer = marked.defaults.tokenizer || new Tokenizer_1();\n\n        var _loop2 = function _loop2(prop) {\n          var prevTokenizer = tokenizer[prop];\n\n          tokenizer[prop] = function () {\n            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              args[_key2] = arguments[_key2];\n            }\n\n            var ret = extension.tokenizer[prop].apply(tokenizer, args);\n\n            if (ret === false) {\n              ret = prevTokenizer.apply(tokenizer, args);\n            }\n\n            return ret;\n          };\n        };\n\n        for (var prop in extension.tokenizer) {\n          _loop2(prop);\n        }\n\n        opts.tokenizer = tokenizer;\n      })();\n    }\n\n    if (extension.walkTokens) {\n      var walkTokens = marked.defaults.walkTokens;\n\n      opts.walkTokens = function (token) {\n        extension.walkTokens(token);\n\n        if (walkTokens) {\n          walkTokens(token);\n        }\n      };\n    }\n\n    marked.setOptions(opts);\n  };\n  /**\n   * Run callback for every token\n   */\n\n\n  marked.walkTokens = function (tokens, callback) {\n    for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done;) {\n      var token = _step.value;\n      callback(token);\n\n      switch (token.type) {\n        case 'table':\n          {\n            for (var _iterator2 = _createForOfIteratorHelperLoose(token.tokens.header), _step2; !(_step2 = _iterator2()).done;) {\n              var cell = _step2.value;\n              marked.walkTokens(cell, callback);\n            }\n\n            for (var _iterator3 = _createForOfIteratorHelperLoose(token.tokens.cells), _step3; !(_step3 = _iterator3()).done;) {\n              var row = _step3.value;\n\n              for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done;) {\n                var _cell = _step4.value;\n                marked.walkTokens(_cell, callback);\n              }\n            }\n\n            break;\n          }\n\n        case 'list':\n          {\n            marked.walkTokens(token.items, callback);\n            break;\n          }\n\n        default:\n          {\n            if (token.tokens) {\n              marked.walkTokens(token.tokens, callback);\n            }\n          }\n      }\n    }\n  };\n  /**\n   * Parse Inline\n   */\n\n\n  marked.parseInline = function (src, opt) {\n    // throw error in case of non string input\n    if (typeof src === 'undefined' || src === null) {\n      throw new Error('marked.parseInline(): input parameter is undefined or null');\n    }\n\n    if (typeof src !== 'string') {\n      throw new Error('marked.parseInline(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');\n    }\n\n    opt = merge$2({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation$1(opt);\n\n    try {\n      var tokens = Lexer_1.lexInline(src, opt);\n\n      if (opt.walkTokens) {\n        marked.walkTokens(tokens, opt.walkTokens);\n      }\n\n      return Parser_1.parseInline(tokens, opt);\n    } catch (e) {\n      e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n      if (opt.silent) {\n        return '<p>An error occurred:</p><pre>' + escape$2(e.message + '', true) + '</pre>';\n      }\n\n      throw e;\n    }\n  };\n  /**\n   * Expose\n   */\n\n\n  marked.Parser = Parser_1;\n  marked.parser = Parser_1.parse;\n  marked.Renderer = Renderer_1;\n  marked.TextRenderer = TextRenderer_1;\n  marked.Lexer = Lexer_1;\n  marked.lexer = Lexer_1.lex;\n  marked.Tokenizer = Tokenizer_1;\n  marked.Slugger = Slugger_1;\n  marked.parse = marked;\n  var marked_1 = marked;\n\n  return marked_1;\n\n})));\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/**\n * Actions that modify the URL.\n */\nvar LocationActions = {\n\n  /**\n   * Indicates a new location is being pushed to the history stack.\n   */\n  PUSH: 'push',\n\n  /**\n   * Indicates the current location should be replaced.\n   */\n  REPLACE: 'replace',\n\n  /**\n   * Indicates the most recent entry should be removed from the history stack.\n   */\n  POP: 'pop'\n\n};\n\nmodule.exports = LocationActions;\n","var LocationActions = require('../actions/LocationActions');\n\n/**\n * A scroll behavior that attempts to imitate the default behavior\n * of modern browsers.\n */\nvar ImitateBrowserBehavior = {\n\n  updateScrollPosition: function (position, actionType) {\n    switch (actionType) {\n      case LocationActions.PUSH:\n      case LocationActions.REPLACE:\n        window.scrollTo(0, 0);\n        break;\n      case LocationActions.POP:\n        if (position) {\n          window.scrollTo(position.x, position.y);\n        } else {\n          window.scrollTo(0, 0);\n        }\n        break;\n    }\n  }\n\n};\n\nmodule.exports = ImitateBrowserBehavior;\n","/**\n * A scroll behavior that always scrolls to the top of the page\n * after a transition.\n */\nvar ScrollToTopBehavior = {\n\n  updateScrollPosition: function () {\n    window.scrollTo(0, 0);\n  }\n\n};\n\nmodule.exports = ScrollToTopBehavior;\n","var React = require('react');\nvar FakeNode = require('../mixins/FakeNode');\nvar PropTypes = require('../utils/PropTypes');\n\n/**\n * A <DefaultRoute> component is a special kind of <Route> that\n * renders when its parent matches but none of its siblings do.\n * Only one such route may be used at any given level in the\n * route hierarchy.\n */\nvar DefaultRoute = React.createClass({\n\n  displayName: 'DefaultRoute',\n\n  mixins: [ FakeNode ],\n\n  propTypes: {\n    name: React.PropTypes.string,\n    path: PropTypes.falsy,\n    handler: React.PropTypes.func.isRequired\n  }\n\n});\n\nmodule.exports = DefaultRoute;\n","var React = require('react');\nvar classSet = require('react/lib/cx');\nvar assign = require('react/lib/Object.assign');\nvar Navigation = require('../mixins/Navigation');\nvar State = require('../mixins/State');\n\nfunction isLeftClickEvent(event) {\n  return event.button === 0;\n}\n\nfunction isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\n\n/**\n * <Link> components are used to create an <a> element that links to a route.\n * When that route is active, the link gets an \"active\" class name (or the\n * value of its `activeClassName` prop).\n *\n * For example, assuming you have the following route:\n *\n *   <Route name=\"showPost\" path=\"/posts/:postID\" handler={Post}/>\n *\n * You could use the following component to link to that route:\n *\n *   <Link to=\"showPost\" params={{ postID: \"123\" }} />\n *\n * In addition to params, links may pass along query string parameters\n * using the `query` prop.\n *\n *   <Link to=\"showPost\" params={{ postID: \"123\" }} query={{ show:true }}/>\n */\nvar Link = React.createClass({\n\n  displayName: 'Link',\n\n  mixins: [ Navigation, State ],\n\n  propTypes: {\n    activeClassName: React.PropTypes.string.isRequired,\n    to: React.PropTypes.string.isRequired,\n    params: React.PropTypes.object,\n    query: React.PropTypes.object,\n    onClick: React.PropTypes.func\n  },\n\n  getDefaultProps: function () {\n    return {\n      activeClassName: 'active'\n    };\n  },\n\n  handleClick: function (event) {\n    var allowTransition = true;\n    var clickResult;\n\n    if (this.props.onClick)\n      clickResult = this.props.onClick(event);\n\n    if (isModifiedEvent(event) || !isLeftClickEvent(event))\n      return;\n\n    if (clickResult === false || event.defaultPrevented === true)\n      allowTransition = false;\n\n    event.preventDefault();\n\n    if (allowTransition)\n      this.transitionTo(this.props.to, this.props.params, this.props.query);\n  },\n\n  /**\n   * Returns the value of the \"href\" attribute to use on the DOM element.\n   */\n  getHref: function () {\n    return this.makeHref(this.props.to, this.props.params, this.props.query);\n  },\n\n  /**\n   * Returns the value of the \"class\" attribute to use on the DOM element, which contains\n   * the value of the activeClassName property when this <Link> is active.\n   */\n  getClassName: function () {\n    var classNames = {};\n\n    if (this.props.className)\n      classNames[this.props.className] = true;\n\n    if (this.isActive(this.props.to, this.props.params, this.props.query))\n      classNames[this.props.activeClassName] = true;\n\n    return classSet(classNames);\n  },\n\n  render: function () {\n    var props = assign({}, this.props, {\n      href: this.getHref(),\n      className: this.getClassName(),\n      onClick: this.handleClick\n    });\n\n    return React.DOM.a(props, this.props.children);\n  }\n\n});\n\nmodule.exports = Link;\n","var React = require('react');\nvar FakeNode = require('../mixins/FakeNode');\nvar PropTypes = require('../utils/PropTypes');\n\n/**\n * A <NotFoundRoute> is a special kind of <Route> that\n * renders when the beginning of its parent's path matches\n * but none of its siblings do, including any <DefaultRoute>.\n * Only one such route may be used at any given level in the\n * route hierarchy.\n */\nvar NotFoundRoute = React.createClass({\n\n  displayName: 'NotFoundRoute',\n\n  mixins: [ FakeNode ],\n\n  propTypes: {\n    name: React.PropTypes.string,\n    path: PropTypes.falsy,\n    handler: React.PropTypes.func.isRequired\n  }\n\n});\n\nmodule.exports = NotFoundRoute;\n","var React = require('react');\nvar FakeNode = require('../mixins/FakeNode');\nvar PropTypes = require('../utils/PropTypes');\n\n/**\n * A <Redirect> component is a special kind of <Route> that always\n * redirects to another route when it matches.\n */\nvar Redirect = React.createClass({\n\n  displayName: 'Redirect',\n\n  mixins: [ FakeNode ],\n\n  propTypes: {\n    path: React.PropTypes.string,\n    from: React.PropTypes.string, // Alias for path.\n    to: React.PropTypes.string,\n    handler: PropTypes.falsy\n  }\n\n});\n\nmodule.exports = Redirect;\n","var React = require('react');\nvar FakeNode = require('../mixins/FakeNode');\n\n/**\n * <Route> components specify components that are rendered to the page when the\n * URL matches a given pattern.\n *\n * Routes are arranged in a nested tree structure. When a new URL is requested,\n * the tree is searched depth-first to find a route whose path matches the URL.\n * When one is found, all routes in the tree that lead to it are considered\n * \"active\" and their components are rendered into the DOM, nested in the same\n * order as they are in the tree.\n *\n * The preferred way to configure a router is using JSX. The XML-like syntax is\n * a great way to visualize how routes are laid out in an application.\n *\n *   var routes = [\n *     <Route handler={App}>\n *       <Route name=\"login\" handler={Login}/>\n *       <Route name=\"logout\" handler={Logout}/>\n *       <Route name=\"about\" handler={About}/>\n *     </Route>\n *   ];\n *   \n *   Router.run(routes, function (Handler) {\n *     React.render(<Handler/>, document.body);\n *   });\n *\n * Handlers for Route components that contain children can render their active\n * child route using a <RouteHandler> element.\n *\n *   var App = React.createClass({\n *     render: function () {\n *       return (\n *         <div class=\"application\">\n *           <RouteHandler/>\n *         </div>\n *       );\n *     }\n *   });\n */\nvar Route = React.createClass({\n\n  displayName: 'Route',\n\n  mixins: [ FakeNode ],\n\n  propTypes: {\n    name: React.PropTypes.string,\n    path: React.PropTypes.string,\n    handler: React.PropTypes.func.isRequired,\n    ignoreScrollBehavior: React.PropTypes.bool\n  }\n\n});\n\nmodule.exports = Route;\n","var React = require('react');\nvar RouteHandlerMixin = require('../mixins/RouteHandler');\n\n/**\n * A <RouteHandler> component renders the active child route handler\n * when routes are nested.\n */\nvar RouteHandler = React.createClass({\n\n  displayName: 'RouteHandler',\n\n  mixins: [RouteHandlerMixin],\n\n  getDefaultProps: function () {\n    return {\n      ref: '__routeHandler__'\n    };\n  },\n\n  render: function () {\n    return this.getRouteHandler();\n  }\n\n});\n\nmodule.exports = RouteHandler;\n","exports.DefaultRoute = require('./components/DefaultRoute');\nexports.Link = require('./components/Link');\nexports.NotFoundRoute = require('./components/NotFoundRoute');\nexports.Redirect = require('./components/Redirect');\nexports.Route = require('./components/Route');\nexports.RouteHandler = require('./components/RouteHandler');\n\nexports.HashLocation = require('./locations/HashLocation');\nexports.HistoryLocation = require('./locations/HistoryLocation');\nexports.RefreshLocation = require('./locations/RefreshLocation');\n\nexports.ImitateBrowserBehavior = require('./behaviors/ImitateBrowserBehavior');\nexports.ScrollToTopBehavior = require('./behaviors/ScrollToTopBehavior');\n\nexports.Navigation = require('./mixins/Navigation');\nexports.State = require('./mixins/State');\n\nexports.create = require('./utils/createRouter');\nexports.run = require('./utils/runRouter');\n\nexports.History = require('./utils/History');\n","var LocationActions = require('../actions/LocationActions');\nvar History = require('../utils/History');\nvar Path = require('../utils/Path');\n\n/**\n * Returns the current URL path from the `hash` portion of the URL, including\n * query string.\n */\nfunction getHashPath() {\n  return Path.decode(\n    // We can't use window.location.hash here because it's not\n    // consistent across browsers - Firefox will pre-decode it!\n    window.location.href.split('#')[1] || ''\n  );\n}\n\nvar _actionType;\n\nfunction ensureSlash() {\n  var path = getHashPath();\n\n  if (path.charAt(0) === '/')\n    return true;\n\n  HashLocation.replace('/' + path);\n\n  return false;\n}\n\nvar _changeListeners = [];\n\nfunction notifyChange(type) {\n  if (type === LocationActions.PUSH)\n    History.length += 1;\n\n  var change = {\n    path: getHashPath(),\n    type: type\n  };\n\n  _changeListeners.forEach(function (listener) {\n    listener(change);\n  });\n}\n\nvar _isListening = false;\n\nfunction onHashChange() {\n  if (ensureSlash()) {\n    // If we don't have an _actionType then all we know is the hash\n    // changed. It was probably caused by the user clicking the Back\n    // button, but may have also been the Forward button or manual\n    // manipulation. So just guess 'pop'.\n    notifyChange(_actionType || LocationActions.POP);\n    _actionType = null;\n  }\n}\n\n/**\n * A Location that uses `window.location.hash`.\n */\nvar HashLocation = {\n\n  addChangeListener: function (listener) {\n    _changeListeners.push(listener);\n\n    // Do this BEFORE listening for hashchange.\n    ensureSlash();\n\n    if (_isListening)\n      return;\n\n    if (window.addEventListener) {\n      window.addEventListener('hashchange', onHashChange, false);\n    } else {\n      window.attachEvent('onhashchange', onHashChange);\n    }\n\n    _isListening = true;\n  },\n\n  removeChangeListener: function(listener) {\n    for (var i = 0, l = _changeListeners.length; i < l; i ++) {\n      if (_changeListeners[i] === listener) {\n        _changeListeners.splice(i, 1);\n        break;\n      }\n    }\n\n    if (window.removeEventListener) {\n      window.removeEventListener('hashchange', onHashChange, false);\n    } else {\n      window.removeEvent('onhashchange', onHashChange);\n    }\n\n    if (_changeListeners.length === 0)\n      _isListening = false;\n  },\n\n\n\n  push: function (path) {\n    _actionType = LocationActions.PUSH;\n    window.location.hash = Path.encode(path);\n  },\n\n  replace: function (path) {\n    _actionType = LocationActions.REPLACE;\n    window.location.replace(window.location.pathname + '#' + Path.encode(path));\n  },\n\n  pop: function () {\n    _actionType = LocationActions.POP;\n    History.back();\n  },\n\n  getCurrentPath: getHashPath,\n\n  toString: function () {\n    return '<HashLocation>';\n  }\n\n};\n\nmodule.exports = HashLocation;\n","var LocationActions = require('../actions/LocationActions');\nvar History = require('../utils/History');\nvar Path = require('../utils/Path');\n\n/**\n * Returns the current URL path from `window.location`, including query string.\n */\nfunction getWindowPath() {\n  return Path.decode(\n    window.location.pathname + window.location.search\n  );\n}\n\nvar _changeListeners = [];\n\nfunction notifyChange(type) {\n  var change = {\n    path: getWindowPath(),\n    type: type\n  };\n\n  _changeListeners.forEach(function (listener) {\n    listener(change);\n  });\n}\n\nvar _isListening = false;\n\nfunction onPopState() {\n  notifyChange(LocationActions.POP);\n}\n\n/**\n * A Location that uses HTML5 history.\n */\nvar HistoryLocation = {\n\n  addChangeListener: function (listener) {\n    _changeListeners.push(listener);\n\n    if (_isListening)\n      return;\n\n    if (window.addEventListener) {\n      window.addEventListener('popstate', onPopState, false);\n    } else {\n      window.attachEvent('popstate', onPopState);\n    }\n\n    _isListening = true;\n  },\n\n  removeChangeListener: function(listener) {\n    for (var i = 0, l = _changeListeners.length; i < l; i ++) {\n      if (_changeListeners[i] === listener) {\n        _changeListeners.splice(i, 1);\n        break;\n      }\n    }\n\n    if (window.addEventListener) {\n      window.removeEventListener('popstate', onPopState);\n    } else {\n      window.removeEvent('popstate', onPopState);\n    }\n\n    if (_changeListeners.length === 0)\n      _isListening = false;\n  },\n\n\n\n  push: function (path) {\n    window.history.pushState({ path: path }, '', Path.encode(path));\n    History.length += 1;\n    notifyChange(LocationActions.PUSH);\n  },\n\n  replace: function (path) {\n    window.history.replaceState({ path: path }, '', Path.encode(path));\n    notifyChange(LocationActions.REPLACE);\n  },\n\n  pop: History.back,\n\n  getCurrentPath: getWindowPath,\n\n  toString: function () {\n    return '<HistoryLocation>';\n  }\n\n};\n\nmodule.exports = HistoryLocation;\n","var HistoryLocation = require('./HistoryLocation');\nvar History = require('../utils/History');\nvar Path = require('../utils/Path');\n\n/**\n * A Location that uses full page refreshes. This is used as\n * the fallback for HistoryLocation in browsers that do not\n * support the HTML5 history API.\n */\nvar RefreshLocation = {\n\n  push: function (path) {\n    window.location = Path.encode(path);\n  },\n\n  replace: function (path) {\n    window.location.replace(Path.encode(path));\n  },\n\n  pop: History.back,\n\n  getCurrentPath: HistoryLocation.getCurrentPath,\n\n  toString: function () {\n    return '<RefreshLocation>';\n  }\n\n};\n\nmodule.exports = RefreshLocation;\n","var invariant = require('react/lib/invariant');\n\nvar FakeNode = {\n\n  render: function () {\n    invariant(\n      false,\n      '%s elements should not be rendered',\n      this.constructor.displayName\n    );\n  }\n\n};\n\nmodule.exports = FakeNode;\n","var React = require('react');\n\n/**\n * A mixin for components that modify the URL.\n *\n * Example:\n *\n *   var MyLink = React.createClass({\n *     mixins: [ Router.Navigation ],\n *     handleClick: function (event) {\n *       event.preventDefault();\n *       this.transitionTo('aRoute', { the: 'params' }, { the: 'query' });\n *     },\n *     render: function () {\n *       return (\n *         <a onClick={this.handleClick}>Click me!</a>\n *       );\n *     }\n *   });\n */\nvar Navigation = {\n\n  contextTypes: {\n    makePath: React.PropTypes.func.isRequired,\n    makeHref: React.PropTypes.func.isRequired,\n    transitionTo: React.PropTypes.func.isRequired,\n    replaceWith: React.PropTypes.func.isRequired,\n    goBack: React.PropTypes.func.isRequired\n  },\n\n  /**\n   * Returns an absolute URL path created from the given route\n   * name, URL parameters, and query values.\n   */\n  makePath: function (to, params, query) {\n    return this.context.makePath(to, params, query);\n  },\n\n  /**\n   * Returns a string that may safely be used as the href of a\n   * link to the route with the given name.\n   */\n  makeHref: function (to, params, query) {\n    return this.context.makeHref(to, params, query);\n  },\n\n  /**\n   * Transitions to the URL specified in the arguments by pushing\n   * a new URL onto the history stack.\n   */\n  transitionTo: function (to, params, query) {\n    this.context.transitionTo(to, params, query);\n  },\n\n  /**\n   * Transitions to the URL specified in the arguments by replacing\n   * the current URL in the history stack.\n   */\n  replaceWith: function (to, params, query) {\n    this.context.replaceWith(to, params, query);\n  },\n\n  /**\n   * Transitions to the previous URL.\n   */\n  goBack: function () {\n    this.context.goBack();\n  }\n\n};\n\nmodule.exports = Navigation;\n","var React = require('react');\n\n/**\n * Provides the router with context for Router.Navigation.\n */\nvar NavigationContext = {\n\n  childContextTypes: {\n    makePath: React.PropTypes.func.isRequired,\n    makeHref: React.PropTypes.func.isRequired,\n    transitionTo: React.PropTypes.func.isRequired,\n    replaceWith: React.PropTypes.func.isRequired,\n    goBack: React.PropTypes.func.isRequired\n  },\n\n  getChildContext: function () {\n    return {\n      makePath: this.constructor.makePath,\n      makeHref: this.constructor.makeHref,\n      transitionTo: this.constructor.transitionTo,\n      replaceWith: this.constructor.replaceWith,\n      goBack: this.constructor.goBack\n    };\n  }\n\n};\n\nmodule.exports = NavigationContext;\n","var React = require('react');\n\nmodule.exports = {\n  contextTypes: {\n    getRouteAtDepth: React.PropTypes.func.isRequired,\n    getRouteComponents: React.PropTypes.func.isRequired,\n    routeHandlers: React.PropTypes.array.isRequired\n  },\n\n  childContextTypes: {\n    routeHandlers: React.PropTypes.array.isRequired\n  },\n\n  getChildContext: function () {\n    return {\n      routeHandlers: this.context.routeHandlers.concat([ this ])\n    };\n  },\n\n  getRouteDepth: function () {\n    return this.context.routeHandlers.length - 1;\n  },\n\n  componentDidMount: function () {\n    this._updateRouteComponent();\n  },\n\n  componentDidUpdate: function () {\n    this._updateRouteComponent();\n  },\n\n  _updateRouteComponent: function () {\n    var depth = this.getRouteDepth();\n    var components = this.context.getRouteComponents();\n    components[depth] = this.refs[this.props.ref || '__routeHandler__'];\n  },\n\n  getRouteHandler: function (props) {\n    var route = this.context.getRouteAtDepth(this.getRouteDepth());\n    return route ? React.createElement(route.handler, props || this.props) : null;\n  }\n};","var invariant = require('react/lib/invariant');\nvar canUseDOM = require('react/lib/ExecutionEnvironment').canUseDOM;\nvar getWindowScrollPosition = require('../utils/getWindowScrollPosition');\n\nfunction shouldUpdateScroll(state, prevState) {\n  if (!prevState)\n    return true;\n\n  // Don't update scroll position when only the query has changed.\n  if (state.pathname === prevState.pathname)\n    return false;\n\n  var routes = state.routes;\n  var prevRoutes = prevState.routes;\n\n  var sharedAncestorRoutes = routes.filter(function (route) {\n    return prevRoutes.indexOf(route) !== -1;\n  });\n\n  return !sharedAncestorRoutes.some(function (route) {\n    return route.ignoreScrollBehavior;\n  });\n}\n\n/**\n * Provides the router with the ability to manage window scroll position\n * according to its scroll behavior.\n */\nvar Scrolling = {\n\n  statics: {\n    /**\n     * Records curent scroll position as the last known position for the given URL path.\n     */\n    recordScrollPosition: function (path) {\n      if (!this.scrollHistory)\n        this.scrollHistory = {};\n\n      this.scrollHistory[path] = getWindowScrollPosition();\n    },\n\n    /**\n     * Returns the last known scroll position for the given URL path.\n     */\n    getScrollPosition: function (path) {\n      if (!this.scrollHistory)\n        this.scrollHistory = {};\n\n      return this.scrollHistory[path] || null;\n    }\n  },\n\n  componentWillMount: function () {\n    invariant(\n      this.getScrollBehavior() == null || canUseDOM,\n      'Cannot use scroll behavior without a DOM'\n    );\n  },\n\n  componentDidMount: function () {\n    this._updateScroll();\n  },\n\n  componentDidUpdate: function (prevProps, prevState) {\n    this._updateScroll(prevState);\n  },\n\n  _updateScroll: function (prevState) {\n    if (!shouldUpdateScroll(this.state, prevState))\n      return;\n\n    var scrollBehavior = this.getScrollBehavior();\n\n    if (scrollBehavior)\n      scrollBehavior.updateScrollPosition(\n        this.constructor.getScrollPosition(this.state.path),\n        this.state.action\n      );\n  }\n\n};\n\nmodule.exports = Scrolling;\n","var React = require('react');\n\n/**\n * A mixin for components that need to know the path, routes, URL\n * params and query that are currently active.\n *\n * Example:\n *\n *   var AboutLink = React.createClass({\n *     mixins: [ Router.State ],\n *     render: function () {\n *       var className = this.props.className;\n *   \n *       if (this.isActive('about'))\n *         className += ' is-active';\n *   \n *       return React.DOM.a({ className: className }, this.props.children);\n *     }\n *   });\n */\nvar State = {\n\n  contextTypes: {\n    getCurrentPath: React.PropTypes.func.isRequired,\n    getCurrentRoutes: React.PropTypes.func.isRequired,\n    getCurrentPathname: React.PropTypes.func.isRequired,\n    getCurrentParams: React.PropTypes.func.isRequired,\n    getCurrentQuery: React.PropTypes.func.isRequired,\n    isActive: React.PropTypes.func.isRequired\n  },\n\n  /**\n   * Returns the current URL path.\n   */\n  getPath: function () {\n    return this.context.getCurrentPath();\n  },\n\n  /**\n   * Returns an array of the routes that are currently active.\n   */\n  getRoutes: function () {\n    return this.context.getCurrentRoutes();\n  },\n\n  /**\n   * Returns the current URL path without the query string.\n   */\n  getPathname: function () {\n    return this.context.getCurrentPathname();\n  },\n\n  /**\n   * Returns an object of the URL params that are currently active.\n   */\n  getParams: function () {\n    return this.context.getCurrentParams();\n  },\n\n  /**\n   * Returns an object of the query params that are currently active.\n   */\n  getQuery: function () {\n    return this.context.getCurrentQuery();\n  },\n\n  /**\n   * A helper method to determine if a given route, params, and query\n   * are active.\n   */\n  isActive: function (to, params, query) {\n    return this.context.isActive(to, params, query);\n  }\n\n};\n\nmodule.exports = State;\n","var React = require('react');\nvar assign = require('react/lib/Object.assign');\nvar Path = require('../utils/Path');\n\nfunction routeIsActive(activeRoutes, routeName) {\n  return activeRoutes.some(function (route) {\n    return route.name === routeName;\n  });\n}\n\nfunction paramsAreActive(activeParams, params) {\n  for (var property in params)\n    if (String(activeParams[property]) !== String(params[property]))\n      return false;\n\n  return true;\n}\n\nfunction queryIsActive(activeQuery, query) {\n  for (var property in query)\n    if (String(activeQuery[property]) !== String(query[property]))\n      return false;\n\n  return true;\n}\n\n/**\n * Provides the router with context for Router.State.\n */\nvar StateContext = {\n\n  /**\n   * Returns the current URL path + query string.\n   */\n  getCurrentPath: function () {\n    return this.state.path;\n  },\n\n  /**\n   * Returns a read-only array of the currently active routes.\n   */\n  getCurrentRoutes: function () {\n    return this.state.routes.slice(0);\n  },\n\n  /**\n   * Returns the current URL path without the query string.\n   */\n  getCurrentPathname: function () {\n    return this.state.pathname;\n  },\n\n  /**\n   * Returns a read-only object of the currently active URL parameters.\n   */\n  getCurrentParams: function () {\n    return assign({}, this.state.params);\n  },\n\n  /**\n   * Returns a read-only object of the currently active query parameters.\n   */\n  getCurrentQuery: function () {\n    return assign({}, this.state.query);\n  },\n\n  /**\n   * Returns true if the given route, params, and query are active.\n   */\n  isActive: function (to, params, query) {\n    if (Path.isAbsolute(to))\n      return to === this.state.path;\n\n    return routeIsActive(this.state.routes, to) &&\n      paramsAreActive(this.state.params, params) &&\n      (query == null || queryIsActive(this.state.query, query));\n  },\n\n  childContextTypes: {\n    getCurrentPath: React.PropTypes.func.isRequired,\n    getCurrentRoutes: React.PropTypes.func.isRequired,\n    getCurrentPathname: React.PropTypes.func.isRequired,\n    getCurrentParams: React.PropTypes.func.isRequired,\n    getCurrentQuery: React.PropTypes.func.isRequired,\n    isActive: React.PropTypes.func.isRequired\n  },\n\n  getChildContext: function () {\n    return {\n      getCurrentPath: this.getCurrentPath,\n      getCurrentRoutes: this.getCurrentRoutes,\n      getCurrentPathname: this.getCurrentPathname,\n      getCurrentParams: this.getCurrentParams,\n      getCurrentQuery: this.getCurrentQuery,\n      isActive: this.isActive\n    };\n  }\n\n};\n\nmodule.exports = StateContext;\n","/**\n * Represents a cancellation caused by navigating away\n * before the previous transition has fully resolved.\n */\nfunction Cancellation() { }\n\nmodule.exports = Cancellation;\n","var invariant = require('react/lib/invariant');\nvar canUseDOM = require('react/lib/ExecutionEnvironment').canUseDOM;\n\nvar History = {\n\n  /**\n   * Sends the browser back one entry in the history.\n   */\n  back: function () {\n    invariant(\n      canUseDOM,\n      'Cannot use History.back without a DOM'\n    );\n\n    // Do this first so that History.length will\n    // be accurate in location change listeners.\n    History.length -= 1;\n\n    window.history.back();\n  },\n\n  /**\n   * The current number of entries in the history.\n   */\n  length: 1\n\n};\n\nmodule.exports = History;\n","var invariant = require('react/lib/invariant');\nvar merge = require('qs/lib/utils').merge;\nvar qs = require('qs');\n\nvar paramCompileMatcher = /:([a-zA-Z_$][a-zA-Z0-9_$]*)|[*.()\\[\\]\\\\+|{}^$]/g;\nvar paramInjectMatcher = /:([a-zA-Z_$][a-zA-Z0-9_$?]*[?]?)|[*]/g;\nvar paramInjectTrailingSlashMatcher = /\\/\\/\\?|\\/\\?/g;\nvar queryMatcher = /\\?(.+)/;\n\nvar _compiledPatterns = {};\n\nfunction compilePattern(pattern) {\n  if (!(pattern in _compiledPatterns)) {\n    var paramNames = [];\n    var source = pattern.replace(paramCompileMatcher, function (match, paramName) {\n      if (paramName) {\n        paramNames.push(paramName);\n        return '([^/?#]+)';\n      } else if (match === '*') {\n        paramNames.push('splat');\n        return '(.*?)';\n      } else {\n        return '\\\\' + match;\n      }\n    });\n\n    _compiledPatterns[pattern] = {\n      matcher: new RegExp('^' + source + '$', 'i'),\n      paramNames: paramNames\n    };\n  }\n\n  return _compiledPatterns[pattern];\n}\n\nvar Path = {\n\n  /**\n   * Safely decodes special characters in the given URL path.\n   */\n  decode: function (path) {\n    return decodeURI(path.replace(/\\+/g, ' '));\n  },\n\n  /**\n   * Safely encodes special characters in the given URL path.\n   */\n  encode: function (path) {\n    return encodeURI(path).replace(/%20/g, '+');\n  },\n\n  /**\n   * Returns an array of the names of all parameters in the given pattern.\n   */\n  extractParamNames: function (pattern) {\n    return compilePattern(pattern).paramNames;\n  },\n\n  /**\n   * Extracts the portions of the given URL path that match the given pattern\n   * and returns an object of param name => value pairs. Returns null if the\n   * pattern does not match the given path.\n   */\n  extractParams: function (pattern, path) {\n    var object = compilePattern(pattern);\n    var match = path.match(object.matcher);\n\n    if (!match)\n      return null;\n\n    var params = {};\n\n    object.paramNames.forEach(function (paramName, index) {\n      params[paramName] = match[index + 1];\n    });\n\n    return params;\n  },\n\n  /**\n   * Returns a version of the given route path with params interpolated. Throws\n   * if there is a dynamic segment of the route path for which there is no param.\n   */\n  injectParams: function (pattern, params) {\n    params = params || {};\n\n    var splatIndex = 0;\n\n    return pattern.replace(paramInjectMatcher, function (match, paramName) {\n      paramName = paramName || 'splat';\n\n      // If param is optional don't check for existence\n      if (paramName.slice(-1) !== '?') {\n        invariant(\n          params[paramName] != null,\n          'Missing \"' + paramName + '\" parameter for path \"' + pattern + '\"'\n        );\n      } else {\n        paramName = paramName.slice(0, -1);\n\n        if (params[paramName] == null)\n          return '';\n      }\n\n      var segment;\n      if (paramName === 'splat' && Array.isArray(params[paramName])) {\n        segment = params[paramName][splatIndex++];\n\n        invariant(\n          segment != null,\n          'Missing splat # ' + splatIndex + ' for path \"' + pattern + '\"'\n        );\n      } else {\n        segment = params[paramName];\n      }\n\n      return segment;\n    }).replace(paramInjectTrailingSlashMatcher, '/');\n  },\n\n  /**\n   * Returns an object that is the result of parsing any query string contained\n   * in the given path, null if the path contains no query string.\n   */\n  extractQuery: function (path) {\n    var match = path.match(queryMatcher);\n    return match && qs.parse(match[1]);\n  },\n\n  /**\n   * Returns a version of the given path without the query string.\n   */\n  withoutQuery: function (path) {\n    return path.replace(queryMatcher, '');\n  },\n\n  /**\n   * Returns a version of the given path with the parameters in the given\n   * query merged into the query string.\n   */\n  withQuery: function (path, query) {\n    var existingQuery = Path.extractQuery(path);\n\n    if (existingQuery)\n      query = query ? merge(existingQuery, query) : existingQuery;\n\n    var queryString = query && qs.stringify(query);\n\n    if (queryString)\n      return Path.withoutQuery(path) + '?' + queryString;\n\n    return path;\n  },\n\n  /**\n   * Returns true if the given path is absolute.\n   */\n  isAbsolute: function (path) {\n    return path.charAt(0) === '/';\n  },\n\n  /**\n   * Returns a normalized version of the given path.\n   */\n  normalize: function (path, parentRoute) {\n    return path.replace(/^\\/*/, '/');\n  },\n\n  /**\n   * Joins two URL paths together.\n   */\n  join: function (a, b) {\n    return a.replace(/\\/*$/, '/') + b;\n  }\n\n};\n\nmodule.exports = Path;\n","var Promise = require('when/lib/Promise');\n\n// TODO: Use process.env.NODE_ENV check + envify to enable\n// when's promise monitor here when in dev.\n\nmodule.exports = Promise;\n","var PropTypes = {\n\n  /**\n   * Requires that the value of a prop be falsy.\n   */\n  falsy: function (props, propName, componentName) {\n    if (props[propName])\n      return new Error('<' + componentName + '> may not have a \"' + propName + '\" prop');\n  }\n\n};\n\nmodule.exports = PropTypes;\n","/**\n * Encapsulates a redirect to the given route.\n */\nfunction Redirect(to, params, query) {\n  this.to = to;\n  this.params = params;\n  this.query = query;\n}\n\nmodule.exports = Redirect;\n","var assign = require('react/lib/Object.assign');\nvar reversedArray = require('./reversedArray');\nvar Redirect = require('./Redirect');\nvar Promise = require('./Promise');\n\n/**\n * Runs all hook functions serially and calls callback(error) when finished.\n * A hook may return a promise if it needs to execute asynchronously.\n */\nfunction runHooks(hooks, callback) {\n  var promise;\n  try {\n    promise = hooks.reduce(function (promise, hook) {\n      // The first hook to use transition.wait makes the rest\n      // of the transition async from that point forward.\n      return promise ? promise.then(hook) : hook();\n    }, null);\n  } catch (error) {\n    return callback(error); // Sync error.\n  }\n\n  if (promise) {\n    // Use setTimeout to break the promise chain.\n    promise.then(function () {\n      setTimeout(callback);\n    }, function (error) {\n      setTimeout(function () {\n        callback(error);\n      });\n    });\n  } else {\n    callback();\n  }\n}\n\n/**\n * Calls the willTransitionFrom hook of all handlers in the given matches\n * serially in reverse with the transition object and the current instance of\n * the route's handler, so that the deepest nested handlers are called first.\n * Calls callback(error) when finished.\n */\nfunction runTransitionFromHooks(transition, routes, components, callback) {\n  components = reversedArray(components);\n\n  var hooks = reversedArray(routes).map(function (route, index) {\n    return function () {\n      var handler = route.handler;\n\n      if (!transition.isAborted && handler.willTransitionFrom)\n        return handler.willTransitionFrom(transition, components[index]);\n\n      var promise = transition._promise;\n      transition._promise = null;\n\n      return promise;\n    };\n  });\n\n  runHooks(hooks, callback);\n}\n\n/**\n * Calls the willTransitionTo hook of all handlers in the given matches\n * serially with the transition object and any params that apply to that\n * handler. Calls callback(error) when finished.\n */\nfunction runTransitionToHooks(transition, routes, params, query, callback) {\n  var hooks = routes.map(function (route) {\n    return function () {\n      var handler = route.handler;\n\n      if (!transition.isAborted && handler.willTransitionTo)\n        handler.willTransitionTo(transition, params, query);\n\n      var promise = transition._promise;\n      transition._promise = null;\n\n      return promise;\n    };\n  });\n\n  runHooks(hooks, callback);\n}\n\n/**\n * Encapsulates a transition to a given path.\n *\n * The willTransitionTo and willTransitionFrom handlers receive\n * an instance of this class as their first argument.\n */\nfunction Transition(path, retry) {\n  this.path = path;\n  this.abortReason = null;\n  this.isAborted = false;\n  this.retry = retry.bind(this);\n  this._promise = null;\n}\n\nassign(Transition.prototype, {\n\n  abort: function (reason) {\n    if (this.isAborted) {\n      // First abort wins.\n      return;\n    }\n\n    this.abortReason = reason;\n    this.isAborted = true;\n  },\n\n  redirect: function (to, params, query) {\n    this.abort(new Redirect(to, params, query));\n  },\n\n  wait: function (value) {\n    this._promise = Promise.resolve(value);\n  },\n\n  from: function (routes, components, callback) {\n    return runTransitionFromHooks(this, routes, components, callback);\n  },\n\n  to: function (routes, params, query, callback) {\n    return runTransitionToHooks(this, routes, params, query, callback);\n  }\n\n});\n\nmodule.exports = Transition;\n","/* jshint -W058 */\nvar React = require('react');\nvar warning = require('react/lib/warning');\nvar invariant = require('react/lib/invariant');\nvar canUseDOM = require('react/lib/ExecutionEnvironment').canUseDOM;\nvar ImitateBrowserBehavior = require('../behaviors/ImitateBrowserBehavior');\nvar RouteHandler = require('../components/RouteHandler');\nvar LocationActions = require('../actions/LocationActions');\nvar HashLocation = require('../locations/HashLocation');\nvar HistoryLocation = require('../locations/HistoryLocation');\nvar RefreshLocation = require('../locations/RefreshLocation');\nvar NavigationContext = require('../mixins/NavigationContext');\nvar StateContext = require('../mixins/StateContext');\nvar Scrolling = require('../mixins/Scrolling');\nvar createRoutesFromChildren = require('./createRoutesFromChildren');\nvar supportsHistory = require('./supportsHistory');\nvar Transition = require('./Transition');\nvar PropTypes = require('./PropTypes');\nvar Redirect = require('./Redirect');\nvar History = require('./History');\nvar Cancellation = require('./Cancellation');\nvar Path = require('./Path');\n\n/**\n * The default location for new routers.\n */\nvar DEFAULT_LOCATION = canUseDOM ? HashLocation : '/';\n\n/**\n * The default scroll behavior for new routers.\n */\nvar DEFAULT_SCROLL_BEHAVIOR = canUseDOM ? ImitateBrowserBehavior : null;\n\n/**\n * The default error handler for new routers.\n */\nfunction defaultErrorHandler(error) {\n  // Throw so we don't silently swallow async errors.\n  throw error; // This error probably originated in a transition hook.\n}\n\n/**\n * The default aborted transition handler for new routers.\n */\nfunction defaultAbortHandler(abortReason, location) {\n  if (typeof location === 'string')\n    throw new Error('Unhandled aborted transition! Reason: ' + abortReason);\n\n  if (abortReason instanceof Cancellation) {\n    return;\n  } else if (abortReason instanceof Redirect) {\n    location.replace(this.makePath(abortReason.to, abortReason.params, abortReason.query));\n  } else {\n    location.pop();\n  }\n}\n\nfunction findMatch(pathname, routes, defaultRoute, notFoundRoute) {\n  var match, route, params;\n\n  for (var i = 0, len = routes.length; i < len; ++i) {\n    route = routes[i];\n\n    // Check the subtree first to find the most deeply-nested match.\n    match = findMatch(pathname, route.childRoutes, route.defaultRoute, route.notFoundRoute);\n\n    if (match != null) {\n      match.routes.unshift(route);\n      return match;\n    }\n\n    // No routes in the subtree matched, so check this route.\n    params = Path.extractParams(route.path, pathname);\n\n    if (params)\n      return createMatch(route, params);\n  }\n\n  // No routes matched, so try the default route if there is one.\n  if (defaultRoute && (params = Path.extractParams(defaultRoute.path, pathname)))\n    return createMatch(defaultRoute, params);\n\n  // Last attempt: does the \"not found\" route match?\n  if (notFoundRoute && (params = Path.extractParams(notFoundRoute.path, pathname)))\n    return createMatch(notFoundRoute, params);\n\n  return match;\n}\n\nfunction createMatch(route, params) {\n  return { routes: [ route ], params: params };\n}\n\nfunction hasProperties(object, properties) {\n  for (var propertyName in properties)\n    if (properties.hasOwnProperty(propertyName) && object[propertyName] !== properties[propertyName])\n      return false;\n\n  return true;\n}\n\nfunction hasMatch(routes, route, prevParams, nextParams, prevQuery, nextQuery) {\n  return routes.some(function (r) {\n    if (r !== route)\n      return false;\n\n    var paramNames = route.paramNames;\n    var paramName;\n\n    // Ensure that all params the route cares about did not change.\n    for (var i = 0, len = paramNames.length; i < len; ++i) {\n      paramName = paramNames[i];\n\n      if (nextParams[paramName] !== prevParams[paramName])\n        return false;\n    }\n\n    // Ensure the query hasn't changed.\n    return hasProperties(prevQuery, nextQuery) && hasProperties(nextQuery, prevQuery);\n  });\n}\n\n/**\n * Creates and returns a new router using the given options. A router\n * is a ReactComponent class that knows how to react to changes in the\n * URL and keep the contents of the page in sync.\n *\n * Options may be any of the following:\n *\n * - routes           (required) The route config\n * - location         The location to use. Defaults to HashLocation when\n *                    the DOM is available, \"/\" otherwise\n * - scrollBehavior   The scroll behavior to use. Defaults to ImitateBrowserBehavior\n *                    when the DOM is available, null otherwise\n * - onError          A function that is used to handle errors\n * - onAbort          A function that is used to handle aborted transitions\n *\n * When rendering in a server-side environment, the location should simply\n * be the URL path that was used in the request, including the query string.\n */\nfunction createRouter(options) {\n  options = options || {};\n\n  if (typeof options === 'function') {\n    options = { routes: options }; // Router.create(<Route>)\n  } else if (Array.isArray(options)) {\n    options = { routes: options }; // Router.create([ <Route>, <Route> ])\n  }\n\n  var routes = [];\n  var namedRoutes = {};\n  var components = [];\n  var location = options.location || DEFAULT_LOCATION;\n  var scrollBehavior = options.scrollBehavior || DEFAULT_SCROLL_BEHAVIOR;\n  var onError = options.onError || defaultErrorHandler;\n  var onAbort = options.onAbort || defaultAbortHandler;\n  var state = {};\n  var nextState = {};\n  var pendingTransition = null;\n\n  function updateState() {\n    state = nextState;\n    nextState = {};\n  }\n\n  if (typeof location === 'string') {\n    warning(\n      !canUseDOM || process.env.NODE_ENV === 'test',\n      'You should not use a static location in a DOM environment because ' +\n      'the router will not be kept in sync with the current URL'\n    );\n  } else {\n    invariant(\n      canUseDOM,\n      'You cannot use %s without a DOM',\n      location\n    );\n  }\n\n  // Automatically fall back to full page refreshes in\n  // browsers that don't support the HTML history API.\n  if (location === HistoryLocation && !supportsHistory())\n    location = RefreshLocation;\n\n  var router = React.createClass({\n\n    displayName: 'Router',\n\n    mixins: [ NavigationContext, StateContext, Scrolling ],\n\n    statics: {\n\n      defaultRoute: null,\n      notFoundRoute: null,\n\n      /**\n       * Adds routes to this router from the given children object (see ReactChildren).\n       */\n      addRoutes: function (children) {\n        routes.push.apply(routes, createRoutesFromChildren(children, this, namedRoutes));\n      },\n\n      /**\n       * Returns an absolute URL path created from the given route\n       * name, URL parameters, and query.\n       */\n      makePath: function (to, params, query) {\n        var path;\n        if (Path.isAbsolute(to)) {\n          path = Path.normalize(to);\n        } else {\n          var route = namedRoutes[to];\n\n          invariant(\n            route,\n            'Unable to find <Route name=\"%s\">',\n            to\n          );\n\n          path = route.path;\n        }\n\n        return Path.withQuery(Path.injectParams(path, params), query);\n      },\n\n      /**\n       * Returns a string that may safely be used as the href of a link\n       * to the route with the given name, URL parameters, and query.\n       */\n      makeHref: function (to, params, query) {\n        var path = this.makePath(to, params, query);\n        return (location === HashLocation) ? '#' + path : path;\n      },\n\n      /**\n       * Transitions to the URL specified in the arguments by pushing\n       * a new URL onto the history stack.\n       */\n      transitionTo: function (to, params, query) {\n        invariant(\n          typeof location !== 'string',\n          'You cannot use transitionTo with a static location'\n        );\n\n        var path = this.makePath(to, params, query);\n\n        if (pendingTransition) {\n          // Replace so pending location does not stay in history.\n          location.replace(path);\n        } else {\n          location.push(path);\n        }\n      },\n\n      /**\n       * Transitions to the URL specified in the arguments by replacing\n       * the current URL in the history stack.\n       */\n      replaceWith: function (to, params, query) {\n        invariant(\n          typeof location !== 'string',\n          'You cannot use replaceWith with a static location'\n        );\n\n        location.replace(this.makePath(to, params, query));\n      },\n\n      /**\n       * Transitions to the previous URL if one is available. Returns true if the\n       * router was able to go back, false otherwise.\n       *\n       * Note: The router only tracks history entries in your application, not the\n       * current browser session, so you can safely call this function without guarding\n       * against sending the user back to some other site. However, when using\n       * RefreshLocation (which is the fallback for HistoryLocation in browsers that\n       * don't support HTML5 history) this method will *always* send the client back\n       * because we cannot reliably track history length.\n       */\n      goBack: function () {\n        invariant(\n          typeof location !== 'string',\n          'You cannot use goBack with a static location'\n        );\n\n        if (History.length > 1 || location === RefreshLocation) {\n          location.pop();\n          return true;\n        }\n\n        warning(false, 'goBack() was ignored because there is no router history');\n\n        return false;\n      },\n\n      /**\n       * Performs a match of the given pathname against this router and returns an object\n       * with the { routes, params } that match. Returns null if no match can be made.\n       */\n      match: function (pathname) {\n        return findMatch(pathname, routes, this.defaultRoute, this.notFoundRoute) || null;\n      },\n\n      /**\n       * Performs a transition to the given path and calls callback(error, abortReason)\n       * when the transition is finished. If both arguments are null the router's state\n       * was updated. Otherwise the transition did not complete.\n       *\n       * In a transition, a router first determines which routes are involved by beginning\n       * with the current route, up the route tree to the first parent route that is shared\n       * with the destination route, and back down the tree to the destination route. The\n       * willTransitionFrom hook is invoked on all route handlers we're transitioning away\n       * from, in reverse nesting order. Likewise, the willTransitionTo hook is invoked on\n       * all route handlers we're transitioning to.\n       *\n       * Both willTransitionFrom and willTransitionTo hooks may either abort or redirect the\n       * transition. To resolve asynchronously, they may use transition.wait(promise). If no\n       * hooks wait, the transition is fully synchronous.\n       */\n      dispatch: function (path, action, callback) {\n        if (pendingTransition) {\n          pendingTransition.abort(new Cancellation);\n          pendingTransition = null;\n        }\n\n        var prevPath = state.path;\n        if (prevPath === path)\n          return; // Nothing to do!\n\n        // Record the scroll position as early as possible to\n        // get it before browsers try update it automatically.\n        if (prevPath && action !== LocationActions.REPLACE)\n          this.recordScrollPosition(prevPath);\n\n        var pathname = Path.withoutQuery(path);\n        var match = this.match(pathname);\n\n        warning(\n          match != null,\n          'No route matches path \"%s\". Make sure you have <Route path=\"%s\"> somewhere in your routes',\n          path, path\n        );\n\n        if (match == null)\n          match = {};\n\n        var prevRoutes = state.routes || [];\n        var prevParams = state.params || {};\n        var prevQuery = state.query || {};\n\n        var nextRoutes = match.routes || [];\n        var nextParams = match.params || {};\n        var nextQuery = Path.extractQuery(path) || {};\n\n        var fromRoutes, toRoutes;\n        if (prevRoutes.length) {\n          fromRoutes = prevRoutes.filter(function (route) {\n            return !hasMatch(nextRoutes, route, prevParams, nextParams, prevQuery, nextQuery);\n          });\n\n          toRoutes = nextRoutes.filter(function (route) {\n            return !hasMatch(prevRoutes, route, prevParams, nextParams, prevQuery, nextQuery);\n          });\n        } else {\n          fromRoutes = [];\n          toRoutes = nextRoutes;\n        }\n\n        var transition = new Transition(path, this.replaceWith.bind(this, path));\n        pendingTransition = transition;\n\n        transition.from(fromRoutes, components, function (error) {\n          if (error || transition.isAborted)\n            return callback.call(router, error, transition);\n\n          transition.to(toRoutes, nextParams, nextQuery, function (error) {\n            if (error || transition.isAborted)\n              return callback.call(router, error, transition);\n\n            nextState.path = path;\n            nextState.action = action;\n            nextState.pathname = pathname;\n            nextState.routes = nextRoutes;\n            nextState.params = nextParams;\n            nextState.query = nextQuery;\n\n            callback.call(router, null, transition);\n          });\n        });\n      },\n\n      /**\n       * Starts this router and calls callback(router, state) when the route changes.\n       *\n       * If the router's location is static (i.e. a URL path in a server environment)\n       * the callback is called only once. Otherwise, the location should be one of the\n       * Router.*Location objects (e.g. Router.HashLocation or Router.HistoryLocation).\n       */\n      run: function (callback) {\n        var dispatchHandler = function (error, transition) {\n          pendingTransition = null;\n\n          if (error) {\n            onError.call(router, error);\n          } else if (transition.isAborted) {\n            onAbort.call(router, transition.abortReason, location);\n          } else {\n            callback.call(router, router, nextState);\n          }\n        };\n\n        if (typeof location === 'string') {\n          router.dispatch(location, null, dispatchHandler);\n        } else {\n          // Listen for changes to the location.\n          var changeListener = function (change) {\n            router.dispatch(change.path, change.type, dispatchHandler);\n          };\n\n          if (location.addChangeListener)\n            location.addChangeListener(changeListener);\n\n          // Bootstrap using the current path.\n          router.dispatch(location.getCurrentPath(), null, dispatchHandler);\n        }\n      },\n\n      teardown: function() {\n        location.removeChangeListener(this.changeListener);\n      }\n\n    },\n\n    propTypes: {\n      children: PropTypes.falsy\n    },\n\n    getLocation: function () {\n      return location;\n    },\n\n    getScrollBehavior: function () {\n      return scrollBehavior;\n    },\n\n    getRouteAtDepth: function (depth) {\n      var routes = this.state.routes;\n      return routes && routes[depth];\n    },\n\n    getRouteComponents: function () {\n      return components;\n    },\n\n    getInitialState: function () {\n      updateState();\n      return state;\n    },\n\n    componentWillReceiveProps: function () {\n      updateState();\n      this.setState(state);\n    },\n\n    componentWillUnmount: function() {\n      router.teardown();\n    },\n\n    render: function () {\n      return this.getRouteAtDepth(0) ? React.createElement(RouteHandler, this.props) : null;\n    },\n\n    childContextTypes: {\n      getRouteAtDepth: React.PropTypes.func.isRequired,\n      getRouteComponents: React.PropTypes.func.isRequired,\n      routeHandlers: React.PropTypes.array.isRequired\n    },\n\n    getChildContext: function () {\n      return {\n        getRouteComponents: this.getRouteComponents,\n        getRouteAtDepth: this.getRouteAtDepth,\n        routeHandlers: [ this ]\n      };\n    }\n\n  });\n\n  if (options.routes)\n    router.addRoutes(options.routes);\n\n  return router;\n}\n\nmodule.exports = createRouter;\n","/* jshint -W084 */\nvar React = require('react');\nvar warning = require('react/lib/warning');\nvar invariant = require('react/lib/invariant');\nvar DefaultRoute = require('../components/DefaultRoute');\nvar NotFoundRoute = require('../components/NotFoundRoute');\nvar Redirect = require('../components/Redirect');\nvar Route = require('../components/Route');\nvar Path = require('./Path');\n\nvar CONFIG_ELEMENT_TYPES = [\n  DefaultRoute.type,\n  NotFoundRoute.type,\n  Redirect.type,\n  Route.type\n];\n\nfunction createRedirectHandler(to, _params, _query) {\n  return React.createClass({\n    statics: {\n      willTransitionTo: function (transition, params, query) {\n        transition.redirect(to, _params || params, _query || query);\n      }\n    },\n\n    render: function () {\n      return null;\n    }\n  });\n}\n\nfunction checkPropTypes(componentName, propTypes, props) {\n  for (var propName in propTypes) {\n    if (propTypes.hasOwnProperty(propName)) {\n      var error = propTypes[propName](props, propName, componentName);\n\n      if (error instanceof Error)\n        warning(false, error.message);\n    }\n  }\n}\n\nfunction createRoute(element, parentRoute, namedRoutes) {\n  var type = element.type;\n  var props = element.props;\n  var componentName = (type && type.displayName) || 'UnknownComponent';\n\n  invariant(\n    CONFIG_ELEMENT_TYPES.indexOf(type) !== -1,\n    'Unrecognized route configuration element \"<%s>\"',\n    componentName\n  );\n\n  if (type.propTypes)\n    checkPropTypes(componentName, type.propTypes, props);\n\n  var route = { name: props.name };\n\n  if (props.ignoreScrollBehavior) {\n    route.ignoreScrollBehavior = true;\n  }\n\n  if (type === Redirect.type) {\n    route.handler = createRedirectHandler(props.to, props.params, props.query);\n    props.path = props.path || props.from || '*';\n  } else {\n    route.handler = props.handler;\n  }\n\n  var parentPath = (parentRoute && parentRoute.path) || '/';\n\n  if ((props.path || props.name) && type !== DefaultRoute.type && type !== NotFoundRoute.type) {\n    var path = props.path || props.name;\n\n    // Relative paths extend their parent.\n    if (!Path.isAbsolute(path))\n      path = Path.join(parentPath, path);\n\n    route.path = Path.normalize(path);\n  } else {\n    route.path = parentPath;\n\n    if (type === NotFoundRoute.type)\n      route.path += '*';\n  }\n\n  route.paramNames = Path.extractParamNames(route.path);\n\n  // Make sure the route's path has all params its parent needs.\n  if (parentRoute && Array.isArray(parentRoute.paramNames)) {\n    parentRoute.paramNames.forEach(function (paramName) {\n      invariant(\n        route.paramNames.indexOf(paramName) !== -1,\n        'The nested route path \"%s\" is missing the \"%s\" parameter of its parent path \"%s\"',\n        route.path, paramName, parentRoute.path\n      );\n    });\n  }\n\n  // Make sure the route can be looked up by <Link>s.\n  if (props.name) {\n    invariant(\n      namedRoutes[props.name] == null,\n      'You cannot use the name \"%s\" for more than one route',\n      props.name\n    );\n\n    namedRoutes[props.name] = route;\n  }\n\n  // Handle <NotFoundRoute>.\n  if (type === NotFoundRoute.type) {\n    invariant(\n      parentRoute,\n      '<NotFoundRoute> must have a parent <Route>'\n    );\n\n    invariant(\n      parentRoute.notFoundRoute == null,\n      'You may not have more than one <NotFoundRoute> per <Route>'\n    );\n\n    parentRoute.notFoundRoute = route;\n\n    return null;\n  }\n\n  // Handle <DefaultRoute>.\n  if (type === DefaultRoute.type) {\n    invariant(\n      parentRoute,\n      '<DefaultRoute> must have a parent <Route>'\n    );\n\n    invariant(\n      parentRoute.defaultRoute == null,\n      'You may not have more than one <DefaultRoute> per <Route>'\n    );\n\n    parentRoute.defaultRoute = route;\n\n    return null;\n  }\n\n  route.childRoutes = createRoutesFromChildren(props.children, route, namedRoutes);\n\n  return route;\n}\n\n/**\n * Creates and returns an array of route objects from the given ReactChildren.\n */\nfunction createRoutesFromChildren(children, parentRoute, namedRoutes) {\n  var routes = [];\n\n  React.Children.forEach(children, function (child) {\n    // Exclude <DefaultRoute>s and <NotFoundRoute>s.\n    if (child = createRoute(child, parentRoute, namedRoutes))\n      routes.push(child);\n  });\n\n  return routes;\n}\n\nmodule.exports = createRoutesFromChildren;\n","var invariant = require('react/lib/invariant');\nvar canUseDOM = require('react/lib/ExecutionEnvironment').canUseDOM;\n\n/**\n * Returns the current scroll position of the window as { x, y }.\n */\nfunction getWindowScrollPosition() {\n  invariant(\n    canUseDOM,\n    'Cannot get current scroll position without a DOM'\n  );\n\n  return {\n    x: window.pageXOffset || document.documentElement.scrollLeft,\n    y: window.pageYOffset || document.documentElement.scrollTop\n  };\n}\n\nmodule.exports = getWindowScrollPosition;\n","function reversedArray(array) {\n  return array.slice(0).reverse();\n}\n\nmodule.exports = reversedArray;\n","var createRouter = require('./createRouter');\n\n/**\n * A high-level convenience method that creates, configures, and\n * runs a router in one shot. The method signature is:\n *\n *   Router.run(routes[, location ], callback);\n *\n * Using `window.location.hash` to manage the URL, you could do:\n *\n *   Router.run(routes, function (Handler) {\n *     React.render(<Handler/>, document.body);\n *   });\n * \n * Using HTML5 history and a custom \"cursor\" prop:\n * \n *   Router.run(routes, Router.HistoryLocation, function (Handler) {\n *     React.render(<Handler cursor={cursor}/>, document.body);\n *   });\n *\n * Returns the newly created router.\n *\n * Note: If you need to specify further options for your router such\n * as error/abort handling or custom scroll behavior, use Router.create\n * instead.\n *\n *   var router = Router.create(options);\n *   router.run(function (Handler) {\n *     // ...\n *   });\n */\nfunction runRouter(routes, location, callback) {\n  if (typeof location === 'function') {\n    callback = location;\n    location = null;\n  }\n\n  var router = createRouter({\n    routes: routes,\n    location: location\n  });\n\n  router.run(callback);\n\n  return router;\n}\n\nmodule.exports = runRouter;\n","function supportsHistory() {\n  /*! taken from modernizr\n   * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\n   * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\n   * changed to avoid false negatives for Windows Phones: https://github.com/rackt/react-router/issues/586\n   */\n  var ua = navigator.userAgent;\n  if ((ua.indexOf('Android 2.') !== -1 ||\n      (ua.indexOf('Android 4.0') !== -1)) &&\n      ua.indexOf('Mobile Safari') !== -1 &&\n      ua.indexOf('Chrome') === -1 &&\n      ua.indexOf('Windows Phone') === -1) {\n    return false;\n  }\n  return (window.history && 'pushState' in window.history);\n}\n\nmodule.exports = supportsHistory;\n","module.exports = require('./lib');\n","// Load modules\n\nvar Stringify = require('./stringify');\nvar Parse = require('./parse');\n\n\n// Declare internals\n\nvar internals = {};\n\n\nmodule.exports = {\n    stringify: Stringify,\n    parse: Parse\n};\n","// Load modules\n\nvar Utils = require('./utils');\n\n\n// Declare internals\n\nvar internals = {\n    delimiter: '&',\n    depth: 5,\n    arrayLimit: 20,\n    parameterLimit: 1000\n};\n\n\ninternals.parseValues = function (str, options) {\n\n    var obj = {};\n    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);\n\n    for (var i = 0, il = parts.length; i < il; ++i) {\n        var part = parts[i];\n        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;\n\n        if (pos === -1) {\n            obj[Utils.decode(part)] = '';\n        }\n        else {\n            var key = Utils.decode(part.slice(0, pos));\n            var val = Utils.decode(part.slice(pos + 1));\n\n            if (!obj[key]) {\n                obj[key] = val;\n            }\n            else {\n                obj[key] = [].concat(obj[key]).concat(val);\n            }\n        }\n    }\n\n    return obj;\n};\n\n\ninternals.parseObject = function (chain, val, options) {\n\n    if (!chain.length) {\n        return val;\n    }\n\n    var root = chain.shift();\n\n    var obj = {};\n    if (root === '[]') {\n        obj = [];\n        obj = obj.concat(internals.parseObject(chain, val, options));\n    }\n    else {\n        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;\n        var index = parseInt(cleanRoot, 10);\n        if (!isNaN(index) &&\n            root !== cleanRoot &&\n            index <= options.arrayLimit) {\n\n            obj = [];\n            obj[index] = internals.parseObject(chain, val, options);\n        }\n        else {\n            obj[cleanRoot] = internals.parseObject(chain, val, options);\n        }\n    }\n\n    return obj;\n};\n\n\ninternals.parseKeys = function (key, val, options) {\n\n    if (!key) {\n        return;\n    }\n\n    // The regex chunks\n\n    var parent = /^([^\\[\\]]*)/;\n    var child = /(\\[[^\\[\\]]*\\])/g;\n\n    // Get the parent\n\n    var segment = parent.exec(key);\n\n    // Don't allow them to overwrite object prototype properties\n\n    if (Object.prototype.hasOwnProperty(segment[1])) {\n        return;\n    }\n\n    // Stash the parent if it exists\n\n    var keys = [];\n    if (segment[1]) {\n        keys.push(segment[1]);\n    }\n\n    // Loop through children appending to the array until we hit depth\n\n    var i = 0;\n    while ((segment = child.exec(key)) !== null && i < options.depth) {\n\n        ++i;\n        if (!Object.prototype.hasOwnProperty(segment[1].replace(/\\[|\\]/g, ''))) {\n            keys.push(segment[1]);\n        }\n    }\n\n    // If there's a remainder, just add whatever is left\n\n    if (segment) {\n        keys.push('[' + key.slice(segment.index) + ']');\n    }\n\n    return internals.parseObject(keys, val, options);\n};\n\n\nmodule.exports = function (str, options) {\n\n    if (str === '' ||\n        str === null ||\n        typeof str === 'undefined') {\n\n        return {};\n    }\n\n    options = options || {};\n    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : internals.delimiter;\n    options.depth = typeof options.depth === 'number' ? options.depth : internals.depth;\n    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : internals.arrayLimit;\n    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : internals.parameterLimit;\n\n    var tempObj = typeof str === 'string' ? internals.parseValues(str, options) : str;\n    var obj = {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0, il = keys.length; i < il; ++i) {\n        var key = keys[i];\n        var newObj = internals.parseKeys(key, tempObj[key], options);\n        obj = Utils.merge(obj, newObj);\n    }\n\n    return Utils.compact(obj);\n};\n","// Load modules\n\nvar Utils = require('./utils');\n\n\n// Declare internals\n\nvar internals = {\n    delimiter: '&'\n};\n\n\ninternals.stringify = function (obj, prefix) {\n\n    if (Utils.isBuffer(obj)) {\n        obj = obj.toString();\n    }\n    else if (obj instanceof Date) {\n        obj = obj.toISOString();\n    }\n    else if (obj === null) {\n        obj = '';\n    }\n\n    if (typeof obj === 'string' ||\n        typeof obj === 'number' ||\n        typeof obj === 'boolean') {\n\n        return [encodeURIComponent(prefix) + '=' + encodeURIComponent(obj)];\n    }\n\n    var values = [];\n\n    for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            values = values.concat(internals.stringify(obj[key], prefix + '[' + key + ']'));\n        }\n    }\n\n    return values;\n};\n\n\nmodule.exports = function (obj, options) {\n\n    options = options || {};\n    var delimiter = typeof options.delimiter === 'undefined' ? internals.delimiter : options.delimiter;\n\n    var keys = [];\n\n    for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            keys = keys.concat(internals.stringify(obj[key], key));\n        }\n    }\n\n    return keys.join(delimiter);\n};\n","// Load modules\n\n\n// Declare internals\n\nvar internals = {};\n\n\nexports.arrayToObject = function (source) {\n\n    var obj = {};\n    for (var i = 0, il = source.length; i < il; ++i) {\n        if (typeof source[i] !== 'undefined') {\n\n            obj[i] = source[i];\n        }\n    }\n\n    return obj;\n};\n\n\nexports.merge = function (target, source) {\n\n    if (!source) {\n        return target;\n    }\n\n    if (Array.isArray(source)) {\n        for (var i = 0, il = source.length; i < il; ++i) {\n            if (typeof source[i] !== 'undefined') {\n                if (typeof target[i] === 'object') {\n                    target[i] = exports.merge(target[i], source[i]);\n                }\n                else {\n                    target[i] = source[i];\n                }\n            }\n        }\n\n        return target;\n    }\n\n    if (Array.isArray(target)) {\n        if (typeof source !== 'object') {\n            target.push(source);\n            return target;\n        }\n        else {\n            target = exports.arrayToObject(target);\n        }\n    }\n\n    var keys = Object.keys(source);\n    for (var k = 0, kl = keys.length; k < kl; ++k) {\n        var key = keys[k];\n        var value = source[key];\n\n        if (value &&\n            typeof value === 'object') {\n\n            if (!target[key]) {\n                target[key] = value;\n            }\n            else {\n                target[key] = exports.merge(target[key], value);\n            }\n        }\n        else {\n            target[key] = value;\n        }\n    }\n\n    return target;\n};\n\n\nexports.decode = function (str) {\n\n    try {\n        return decodeURIComponent(str.replace(/\\+/g, ' '));\n    } catch (e) {\n        return str;\n    }\n};\n\n\nexports.compact = function (obj, refs) {\n\n    if (typeof obj !== 'object' ||\n        obj === null) {\n\n        return obj;\n    }\n\n    refs = refs || [];\n    var lookup = refs.indexOf(obj);\n    if (lookup !== -1) {\n        return refs[lookup];\n    }\n\n    refs.push(obj);\n\n    if (Array.isArray(obj)) {\n        var compacted = [];\n\n        for (var i = 0, l = obj.length; i < l; ++i) {\n            if (typeof obj[i] !== 'undefined') {\n                compacted.push(obj[i]);\n            }\n        }\n\n        return compacted;\n    }\n\n    var keys = Object.keys(obj);\n    for (var i = 0, il = keys.length; i < il; ++i) {\n        var key = keys[i];\n        obj[key] = exports.compact(obj[key], refs);\n    }\n\n    return obj;\n};\n\n\nexports.isRegExp = function (obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\n\nexports.isBuffer = function (obj) {\n\n    if (typeof Buffer !== 'undefined') {\n        return Buffer.isBuffer(obj);\n    }\n    else {\n        return false;\n    }\n};\n","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function (require) {\n\n\tvar makePromise = require('./makePromise');\n\tvar Scheduler = require('./Scheduler');\n\tvar async = require('./async');\n\n\treturn makePromise({\n\t\tscheduler: new Scheduler(async)\n\t});\n\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\t/**\n\t * Circular queue\n\t * @param {number} capacityPow2 power of 2 to which this queue's capacity\n\t *  will be set initially. eg when capacityPow2 == 3, queue capacity\n\t *  will be 8.\n\t * @constructor\n\t */\n\tfunction Queue(capacityPow2) {\n\t\tthis.head = this.tail = this.length = 0;\n\t\tthis.buffer = new Array(1 << capacityPow2);\n\t}\n\n\tQueue.prototype.push = function(x) {\n\t\tif(this.length === this.buffer.length) {\n\t\t\tthis._ensureCapacity(this.length * 2);\n\t\t}\n\n\t\tthis.buffer[this.tail] = x;\n\t\tthis.tail = (this.tail + 1) & (this.buffer.length - 1);\n\t\t++this.length;\n\t\treturn this.length;\n\t};\n\n\tQueue.prototype.shift = function() {\n\t\tvar x = this.buffer[this.head];\n\t\tthis.buffer[this.head] = void 0;\n\t\tthis.head = (this.head + 1) & (this.buffer.length - 1);\n\t\t--this.length;\n\t\treturn x;\n\t};\n\n\tQueue.prototype._ensureCapacity = function(capacity) {\n\t\tvar head = this.head;\n\t\tvar buffer = this.buffer;\n\t\tvar newBuffer = new Array(capacity);\n\t\tvar i = 0;\n\t\tvar len;\n\n\t\tif(head === 0) {\n\t\t\tlen = this.length;\n\t\t\tfor(; i<len; ++i) {\n\t\t\t\tnewBuffer[i] = buffer[i];\n\t\t\t}\n\t\t} else {\n\t\t\tcapacity = buffer.length;\n\t\t\tlen = this.tail;\n\t\t\tfor(; head<capacity; ++i, ++head) {\n\t\t\t\tnewBuffer[i] = buffer[head];\n\t\t\t}\n\n\t\t\tfor(head=0; head<len; ++i, ++head) {\n\t\t\t\tnewBuffer[i] = buffer[head];\n\t\t\t}\n\t\t}\n\n\t\tthis.buffer = newBuffer;\n\t\tthis.head = 0;\n\t\tthis.tail = this.length;\n\t};\n\n\treturn Queue;\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar Queue = require('./Queue');\n\n\t// Credit to Twisol (https://github.com/Twisol) for suggesting\n\t// this type of extensible queue + trampoline approach for next-tick conflation.\n\n\t/**\n\t * Async task scheduler\n\t * @param {function} async function to schedule a single async function\n\t * @constructor\n\t */\n\tfunction Scheduler(async) {\n\t\tthis._async = async;\n\t\tthis._queue = new Queue(15);\n\t\tthis._afterQueue = new Queue(5);\n\t\tthis._running = false;\n\n\t\tvar self = this;\n\t\tthis.drain = function() {\n\t\t\tself._drain();\n\t\t};\n\t}\n\n\t/**\n\t * Enqueue a task\n\t * @param {{ run:function }} task\n\t */\n\tScheduler.prototype.enqueue = function(task) {\n\t\tthis._add(this._queue, task);\n\t};\n\n\t/**\n\t * Enqueue a task to run after the main task queue\n\t * @param {{ run:function }} task\n\t */\n\tScheduler.prototype.afterQueue = function(task) {\n\t\tthis._add(this._afterQueue, task);\n\t};\n\n\t/**\n\t * Drain the handler queue entirely, and then the after queue\n\t */\n\tScheduler.prototype._drain = function() {\n\t\trunQueue(this._queue);\n\t\tthis._running = false;\n\t\trunQueue(this._afterQueue);\n\t};\n\n\t/**\n\t * Add a task to the q, and schedule drain if not already scheduled\n\t * @param {Queue} queue\n\t * @param {{run:function}} task\n\t * @private\n\t */\n\tScheduler.prototype._add = function(queue, task) {\n\t\tqueue.push(task);\n\t\tif(!this._running) {\n\t\t\tthis._running = true;\n\t\t\tthis._async(this.drain);\n\t\t}\n\t};\n\n\t/**\n\t * Run all the tasks in the q\n\t * @param queue\n\t */\n\tfunction runQueue(queue) {\n\t\twhile(queue.length > 0) {\n\t\t\tqueue.shift().run();\n\t\t}\n\t}\n\n\treturn Scheduler;\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\t// Sniff \"best\" async scheduling option\n\t// Prefer process.nextTick or MutationObserver, then check for\n\t// vertx and finally fall back to setTimeout\n\n\t/*jshint maxcomplexity:6*/\n\t/*global process,document,setTimeout,MutationObserver,WebKitMutationObserver*/\n\tvar nextTick, MutationObs;\n\n\tif (typeof process !== 'undefined' && process !== null &&\n\t\ttypeof process.nextTick === 'function') {\n\t\tnextTick = function(f) {\n\t\t\tprocess.nextTick(f);\n\t\t};\n\n\t} else if (MutationObs =\n\t\t(typeof MutationObserver === 'function' && MutationObserver) ||\n\t\t(typeof WebKitMutationObserver === 'function' && WebKitMutationObserver)) {\n\t\tnextTick = (function (document, MutationObserver) {\n\t\t\tvar scheduled;\n\t\t\tvar el = document.createElement('div');\n\t\t\tvar o = new MutationObserver(run);\n\t\t\to.observe(el, { attributes: true });\n\n\t\t\tfunction run() {\n\t\t\t\tvar f = scheduled;\n\t\t\t\tscheduled = void 0;\n\t\t\t\tf();\n\t\t\t}\n\n\t\t\treturn function (f) {\n\t\t\t\tscheduled = f;\n\t\t\t\tel.setAttribute('class', 'x');\n\t\t\t};\n\t\t}(document, MutationObs));\n\n\t} else {\n\t\tnextTick = (function(cjsRequire) {\n\t\t\tvar vertx;\n\t\t\ttry {\n\t\t\t\t// vert.x 1.x || 2.x\n\t\t\t\tvertx = cjsRequire('vertx');\n\t\t\t} catch (ignore) {}\n\n\t\t\tif (vertx) {\n\t\t\t\tif (typeof vertx.runOnLoop === 'function') {\n\t\t\t\t\treturn vertx.runOnLoop;\n\t\t\t\t}\n\t\t\t\tif (typeof vertx.runOnContext === 'function') {\n\t\t\t\t\treturn vertx.runOnContext;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// capture setTimeout to avoid being caught by fake timers\n\t\t\t// used in time based tests\n\t\t\tvar capturedSetTimeout = setTimeout;\n\t\t\treturn function (t) {\n\t\t\t\tcapturedSetTimeout(t, 0);\n\t\t\t};\n\t\t}(require));\n\t}\n\n\treturn nextTick;\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function makePromise(environment) {\n\n\t\tvar tasks = environment.scheduler;\n\n\t\tvar objectCreate = Object.create ||\n\t\t\tfunction(proto) {\n\t\t\t\tfunction Child() {}\n\t\t\t\tChild.prototype = proto;\n\t\t\t\treturn new Child();\n\t\t\t};\n\n\t\t/**\n\t\t * Create a promise whose fate is determined by resolver\n\t\t * @constructor\n\t\t * @returns {Promise} promise\n\t\t * @name Promise\n\t\t */\n\t\tfunction Promise(resolver, handler) {\n\t\t\tthis._handler = resolver === Handler ? handler : init(resolver);\n\t\t}\n\n\t\t/**\n\t\t * Run the supplied resolver\n\t\t * @param resolver\n\t\t * @returns {Pending}\n\t\t */\n\t\tfunction init(resolver) {\n\t\t\tvar handler = new Pending();\n\n\t\t\ttry {\n\t\t\t\tresolver(promiseResolve, promiseReject, promiseNotify);\n\t\t\t} catch (e) {\n\t\t\t\tpromiseReject(e);\n\t\t\t}\n\n\t\t\treturn handler;\n\n\t\t\t/**\n\t\t\t * Transition from pre-resolution state to post-resolution state, notifying\n\t\t\t * all listeners of the ultimate fulfillment or rejection\n\t\t\t * @param {*} x resolution value\n\t\t\t */\n\t\t\tfunction promiseResolve (x) {\n\t\t\t\thandler.resolve(x);\n\t\t\t}\n\t\t\t/**\n\t\t\t * Reject this promise with reason, which will be used verbatim\n\t\t\t * @param {Error|*} reason rejection reason, strongly suggested\n\t\t\t *   to be an Error type\n\t\t\t */\n\t\t\tfunction promiseReject (reason) {\n\t\t\t\thandler.reject(reason);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Issue a progress event, notifying all progress listeners\n\t\t\t * @param {*} x progress event payload to pass to all listeners\n\t\t\t */\n\t\t\tfunction promiseNotify (x) {\n\t\t\t\thandler.notify(x);\n\t\t\t}\n\t\t}\n\n\t\t// Creation\n\n\t\tPromise.resolve = resolve;\n\t\tPromise.reject = reject;\n\t\tPromise.never = never;\n\n\t\tPromise._defer = defer;\n\t\tPromise._handler = getHandler;\n\n\t\t/**\n\t\t * Returns a trusted promise. If x is already a trusted promise, it is\n\t\t * returned, otherwise returns a new trusted Promise which follows x.\n\t\t * @param  {*} x\n\t\t * @return {Promise} promise\n\t\t */\n\t\tfunction resolve(x) {\n\t\t\treturn isPromise(x) ? x\n\t\t\t\t: new Promise(Handler, new Async(getHandler(x)));\n\t\t}\n\n\t\t/**\n\t\t * Return a reject promise with x as its reason (x is used verbatim)\n\t\t * @param {*} x\n\t\t * @returns {Promise} rejected promise\n\t\t */\n\t\tfunction reject(x) {\n\t\t\treturn new Promise(Handler, new Async(new Rejected(x)));\n\t\t}\n\n\t\t/**\n\t\t * Return a promise that remains pending forever\n\t\t * @returns {Promise} forever-pending promise.\n\t\t */\n\t\tfunction never() {\n\t\t\treturn foreverPendingPromise; // Should be frozen\n\t\t}\n\n\t\t/**\n\t\t * Creates an internal {promise, resolver} pair\n\t\t * @private\n\t\t * @returns {Promise}\n\t\t */\n\t\tfunction defer() {\n\t\t\treturn new Promise(Handler, new Pending());\n\t\t}\n\n\t\t// Transformation and flow control\n\n\t\t/**\n\t\t * Transform this promise's fulfillment value, returning a new Promise\n\t\t * for the transformed result.  If the promise cannot be fulfilled, onRejected\n\t\t * is called with the reason.  onProgress *may* be called with updates toward\n\t\t * this promise's fulfillment.\n\t\t * @param {function=} onFulfilled fulfillment handler\n\t\t * @param {function=} onRejected rejection handler\n\t\t * @deprecated @param {function=} onProgress progress handler\n\t\t * @return {Promise} new promise\n\t\t */\n\t\tPromise.prototype.then = function(onFulfilled, onRejected) {\n\t\t\tvar parent = this._handler;\n\t\t\tvar state = parent.join().state();\n\n\t\t\tif ((typeof onFulfilled !== 'function' && state > 0) ||\n\t\t\t\t(typeof onRejected !== 'function' && state < 0)) {\n\t\t\t\t// Short circuit: value will not change, simply share handler\n\t\t\t\treturn new this.constructor(Handler, parent);\n\t\t\t}\n\n\t\t\tvar p = this._beget();\n\t\t\tvar child = p._handler;\n\n\t\t\tparent.chain(child, parent.receiver, onFulfilled, onRejected,\n\t\t\t\t\targuments.length > 2 ? arguments[2] : void 0);\n\n\t\t\treturn p;\n\t\t};\n\n\t\t/**\n\t\t * If this promise cannot be fulfilled due to an error, call onRejected to\n\t\t * handle the error. Shortcut for .then(undefined, onRejected)\n\t\t * @param {function?} onRejected\n\t\t * @return {Promise}\n\t\t */\n\t\tPromise.prototype['catch'] = function(onRejected) {\n\t\t\treturn this.then(void 0, onRejected);\n\t\t};\n\n\t\t/**\n\t\t * Creates a new, pending promise of the same type as this promise\n\t\t * @private\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype._beget = function() {\n\t\t\tvar parent = this._handler;\n\t\t\tvar child = new Pending(parent.receiver, parent.join().context);\n\t\t\treturn new this.constructor(Handler, child);\n\t\t};\n\n\t\t// Array combinators\n\n\t\tPromise.all = all;\n\t\tPromise.race = race;\n\n\t\t/**\n\t\t * Return a promise that will fulfill when all promises in the\n\t\t * input array have fulfilled, or will reject when one of the\n\t\t * promises rejects.\n\t\t * @param {array} promises array of promises\n\t\t * @returns {Promise} promise for array of fulfillment values\n\t\t */\n\t\tfunction all(promises) {\n\t\t\t/*jshint maxcomplexity:8*/\n\t\t\tvar resolver = new Pending();\n\t\t\tvar pending = promises.length >>> 0;\n\t\t\tvar results = new Array(pending);\n\n\t\t\tvar i, h, x, s;\n\t\t\tfor (i = 0; i < promises.length; ++i) {\n\t\t\t\tx = promises[i];\n\n\t\t\t\tif (x === void 0 && !(i in promises)) {\n\t\t\t\t\t--pending;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (maybeThenable(x)) {\n\t\t\t\t\th = getHandlerMaybeThenable(x);\n\n\t\t\t\t\ts = h.state();\n\t\t\t\t\tif (s === 0) {\n\t\t\t\t\t\th.fold(settleAt, i, results, resolver);\n\t\t\t\t\t} else if (s > 0) {\n\t\t\t\t\t\tresults[i] = h.value;\n\t\t\t\t\t\t--pending;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tunreportRemaining(promises, i+1, h);\n\t\t\t\t\t\tresolver.become(h);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tresults[i] = x;\n\t\t\t\t\t--pending;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(pending === 0) {\n\t\t\t\tresolver.become(new Fulfilled(results));\n\t\t\t}\n\n\t\t\treturn new Promise(Handler, resolver);\n\n\t\t\tfunction settleAt(i, x, resolver) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\tthis[i] = x;\n\t\t\t\tif(--pending === 0) {\n\t\t\t\t\tresolver.become(new Fulfilled(this));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction unreportRemaining(promises, start, rejectedHandler) {\n\t\t\tvar i, h, x;\n\t\t\tfor(i=start; i<promises.length; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif(maybeThenable(x)) {\n\t\t\t\t\th = getHandlerMaybeThenable(x);\n\n\t\t\t\t\tif(h !== rejectedHandler) {\n\t\t\t\t\t\th.visit(h, void 0, h._unreport);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Fulfill-reject competitive race. Return a promise that will settle\n\t\t * to the same state as the earliest input promise to settle.\n\t\t *\n\t\t * WARNING: The ES6 Promise spec requires that race()ing an empty array\n\t\t * must return a promise that is pending forever.  This implementation\n\t\t * returns a singleton forever-pending promise, the same singleton that is\n\t\t * returned by Promise.never(), thus can be checked with ===\n\t\t *\n\t\t * @param {array} promises array of promises to race\n\t\t * @returns {Promise} if input is non-empty, a promise that will settle\n\t\t * to the same outcome as the earliest input promise to settle. if empty\n\t\t * is empty, returns a promise that will never settle.\n\t\t */\n\t\tfunction race(promises) {\n\t\t\t// Sigh, race([]) is untestable unless we return *something*\n\t\t\t// that is recognizable without calling .then() on it.\n\t\t\tif(Object(promises) === promises && promises.length === 0) {\n\t\t\t\treturn never();\n\t\t\t}\n\n\t\t\tvar h = new Pending();\n\t\t\tvar i, x;\n\t\t\tfor(i=0; i<promises.length; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif (x !== void 0 && i in promises) {\n\t\t\t\t\tgetHandler(x).visit(h, h.resolve, h.reject);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new Promise(Handler, h);\n\t\t}\n\n\t\t// Promise internals\n\t\t// Below this, everything is @private\n\n\t\t/**\n\t\t * Get an appropriate handler for x, without checking for cycles\n\t\t * @param {*} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandler(x) {\n\t\t\tif(isPromise(x)) {\n\t\t\t\treturn x._handler.join();\n\t\t\t}\n\t\t\treturn maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);\n\t\t}\n\n\t\t/**\n\t\t * Get a handler for thenable x.\n\t\t * NOTE: You must only call this if maybeThenable(x) == true\n\t\t * @param {object|function|Promise} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandlerMaybeThenable(x) {\n\t\t\treturn isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);\n\t\t}\n\n\t\t/**\n\t\t * Get a handler for potentially untrusted thenable x\n\t\t * @param {*} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandlerUntrusted(x) {\n\t\t\ttry {\n\t\t\t\tvar untrustedThen = x.then;\n\t\t\t\treturn typeof untrustedThen === 'function'\n\t\t\t\t\t? new Thenable(untrustedThen, x)\n\t\t\t\t\t: new Fulfilled(x);\n\t\t\t} catch(e) {\n\t\t\t\treturn new Rejected(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Handler for a promise that is pending forever\n\t\t * @constructor\n\t\t */\n\t\tfunction Handler() {}\n\n\t\tHandler.prototype.when\n\t\t\t= Handler.prototype.become\n\t\t\t= Handler.prototype.notify\n\t\t\t= Handler.prototype.fail\n\t\t\t= Handler.prototype._unreport\n\t\t\t= Handler.prototype._report\n\t\t\t= noop;\n\n\t\tHandler.prototype._state = 0;\n\n\t\tHandler.prototype.state = function() {\n\t\t\treturn this._state;\n\t\t};\n\n\t\t/**\n\t\t * Recursively collapse handler chain to find the handler\n\t\t * nearest to the fully resolved value.\n\t\t * @returns {object} handler nearest the fully resolved value\n\t\t */\n\t\tHandler.prototype.join = function() {\n\t\t\tvar h = this;\n\t\t\twhile(h.handler !== void 0) {\n\t\t\t\th = h.handler;\n\t\t\t}\n\t\t\treturn h;\n\t\t};\n\n\t\tHandler.prototype.chain = function(to, receiver, fulfilled, rejected, progress) {\n\t\t\tthis.when({\n\t\t\t\tresolver: to,\n\t\t\t\treceiver: receiver,\n\t\t\t\tfulfilled: fulfilled,\n\t\t\t\trejected: rejected,\n\t\t\t\tprogress: progress\n\t\t\t});\n\t\t};\n\n\t\tHandler.prototype.visit = function(receiver, fulfilled, rejected, progress) {\n\t\t\tthis.chain(failIfRejected, receiver, fulfilled, rejected, progress);\n\t\t};\n\n\t\tHandler.prototype.fold = function(f, z, c, to) {\n\t\t\tthis.visit(to, function(x) {\n\t\t\t\tf.call(c, z, x, this);\n\t\t\t}, to.reject, to.notify);\n\t\t};\n\n\t\t/**\n\t\t * Handler that invokes fail() on any handler it becomes\n\t\t * @constructor\n\t\t */\n\t\tfunction FailIfRejected() {}\n\n\t\tinherit(Handler, FailIfRejected);\n\n\t\tFailIfRejected.prototype.become = function(h) {\n\t\t\th.fail();\n\t\t};\n\n\t\tvar failIfRejected = new FailIfRejected();\n\n\t\t/**\n\t\t * Handler that manages a queue of consumers waiting on a pending promise\n\t\t * @constructor\n\t\t */\n\t\tfunction Pending(receiver, inheritedContext) {\n\t\t\tPromise.createContext(this, inheritedContext);\n\n\t\t\tthis.consumers = void 0;\n\t\t\tthis.receiver = receiver;\n\t\t\tthis.handler = void 0;\n\t\t\tthis.resolved = false;\n\t\t}\n\n\t\tinherit(Handler, Pending);\n\n\t\tPending.prototype._state = 0;\n\n\t\tPending.prototype.resolve = function(x) {\n\t\t\tthis.become(getHandler(x));\n\t\t};\n\n\t\tPending.prototype.reject = function(x) {\n\t\t\tif(this.resolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.become(new Rejected(x));\n\t\t};\n\n\t\tPending.prototype.join = function() {\n\t\t\tif (!this.resolved) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tvar h = this;\n\n\t\t\twhile (h.handler !== void 0) {\n\t\t\t\th = h.handler;\n\t\t\t\tif (h === this) {\n\t\t\t\t\treturn this.handler = cycle();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn h;\n\t\t};\n\n\t\tPending.prototype.run = function() {\n\t\t\tvar q = this.consumers;\n\t\t\tvar handler = this.join();\n\t\t\tthis.consumers = void 0;\n\n\t\t\tfor (var i = 0; i < q.length; ++i) {\n\t\t\t\thandler.when(q[i]);\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.become = function(handler) {\n\t\t\tif(this.resolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.resolved = true;\n\t\t\tthis.handler = handler;\n\t\t\tif(this.consumers !== void 0) {\n\t\t\t\ttasks.enqueue(this);\n\t\t\t}\n\n\t\t\tif(this.context !== void 0) {\n\t\t\t\thandler._report(this.context);\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.when = function(continuation) {\n\t\t\tif(this.resolved) {\n\t\t\t\ttasks.enqueue(new ContinuationTask(continuation, this.handler));\n\t\t\t} else {\n\t\t\t\tif(this.consumers === void 0) {\n\t\t\t\t\tthis.consumers = [continuation];\n\t\t\t\t} else {\n\t\t\t\t\tthis.consumers.push(continuation);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.notify = function(x) {\n\t\t\tif(!this.resolved) {\n\t\t\t\ttasks.enqueue(new ProgressTask(x, this));\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.fail = function(context) {\n\t\t\tvar c = typeof context === 'undefined' ? this.context : context;\n\t\t\tthis.resolved && this.handler.join().fail(c);\n\t\t};\n\n\t\tPending.prototype._report = function(context) {\n\t\t\tthis.resolved && this.handler.join()._report(context);\n\t\t};\n\n\t\tPending.prototype._unreport = function() {\n\t\t\tthis.resolved && this.handler.join()._unreport();\n\t\t};\n\n\t\t/**\n\t\t * Wrap another handler and force it into a future stack\n\t\t * @param {object} handler\n\t\t * @constructor\n\t\t */\n\t\tfunction Async(handler) {\n\t\t\tthis.handler = handler;\n\t\t}\n\n\t\tinherit(Handler, Async);\n\n\t\tAsync.prototype.when = function(continuation) {\n\t\t\ttasks.enqueue(new ContinuationTask(continuation, this));\n\t\t};\n\n\t\tAsync.prototype._report = function(context) {\n\t\t\tthis.join()._report(context);\n\t\t};\n\n\t\tAsync.prototype._unreport = function() {\n\t\t\tthis.join()._unreport();\n\t\t};\n\n\t\t/**\n\t\t * Handler that wraps an untrusted thenable and assimilates it in a future stack\n\t\t * @param {function} then\n\t\t * @param {{then: function}} thenable\n\t\t * @constructor\n\t\t */\n\t\tfunction Thenable(then, thenable) {\n\t\t\tPending.call(this);\n\t\t\ttasks.enqueue(new AssimilateTask(then, thenable, this));\n\t\t}\n\n\t\tinherit(Pending, Thenable);\n\n\t\t/**\n\t\t * Handler for a fulfilled promise\n\t\t * @param {*} x fulfillment value\n\t\t * @constructor\n\t\t */\n\t\tfunction Fulfilled(x) {\n\t\t\tPromise.createContext(this);\n\t\t\tthis.value = x;\n\t\t}\n\n\t\tinherit(Handler, Fulfilled);\n\n\t\tFulfilled.prototype._state = 1;\n\n\t\tFulfilled.prototype.fold = function(f, z, c, to) {\n\t\t\trunContinuation3(f, z, this, c, to);\n\t\t};\n\n\t\tFulfilled.prototype.when = function(cont) {\n\t\t\trunContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);\n\t\t};\n\n\t\tvar errorId = 0;\n\n\t\t/**\n\t\t * Handler for a rejected promise\n\t\t * @param {*} x rejection reason\n\t\t * @constructor\n\t\t */\n\t\tfunction Rejected(x) {\n\t\t\tPromise.createContext(this);\n\n\t\t\tthis.id = ++errorId;\n\t\t\tthis.value = x;\n\t\t\tthis.handled = false;\n\t\t\tthis.reported = false;\n\n\t\t\tthis._report();\n\t\t}\n\n\t\tinherit(Handler, Rejected);\n\n\t\tRejected.prototype._state = -1;\n\n\t\tRejected.prototype.fold = function(f, z, c, to) {\n\t\t\tto.become(this);\n\t\t};\n\n\t\tRejected.prototype.when = function(cont) {\n\t\t\tif(typeof cont.rejected === 'function') {\n\t\t\t\tthis._unreport();\n\t\t\t}\n\t\t\trunContinuation1(cont.rejected, this, cont.receiver, cont.resolver);\n\t\t};\n\n\t\tRejected.prototype._report = function(context) {\n\t\t\ttasks.afterQueue(new ReportTask(this, context));\n\t\t};\n\n\t\tRejected.prototype._unreport = function() {\n\t\t\tthis.handled = true;\n\t\t\ttasks.afterQueue(new UnreportTask(this));\n\t\t};\n\n\t\tRejected.prototype.fail = function(context) {\n\t\t\tPromise.onFatalRejection(this, context === void 0 ? this.context : context);\n\t\t};\n\n\t\tfunction ReportTask(rejection, context) {\n\t\t\tthis.rejection = rejection;\n\t\t\tthis.context = context;\n\t\t}\n\n\t\tReportTask.prototype.run = function() {\n\t\t\tif(!this.rejection.handled) {\n\t\t\t\tthis.rejection.reported = true;\n\t\t\t\tPromise.onPotentiallyUnhandledRejection(this.rejection, this.context);\n\t\t\t}\n\t\t};\n\n\t\tfunction UnreportTask(rejection) {\n\t\t\tthis.rejection = rejection;\n\t\t}\n\n\t\tUnreportTask.prototype.run = function() {\n\t\t\tif(this.rejection.reported) {\n\t\t\t\tPromise.onPotentiallyUnhandledRejectionHandled(this.rejection);\n\t\t\t}\n\t\t};\n\n\t\t// Unhandled rejection hooks\n\t\t// By default, everything is a noop\n\n\t\t// TODO: Better names: \"annotate\"?\n\t\tPromise.createContext\n\t\t\t= Promise.enterContext\n\t\t\t= Promise.exitContext\n\t\t\t= Promise.onPotentiallyUnhandledRejection\n\t\t\t= Promise.onPotentiallyUnhandledRejectionHandled\n\t\t\t= Promise.onFatalRejection\n\t\t\t= noop;\n\n\t\t// Errors and singletons\n\n\t\tvar foreverPendingHandler = new Handler();\n\t\tvar foreverPendingPromise = new Promise(Handler, foreverPendingHandler);\n\n\t\tfunction cycle() {\n\t\t\treturn new Rejected(new TypeError('Promise cycle'));\n\t\t}\n\n\t\t// Task runners\n\n\t\t/**\n\t\t * Run a single consumer\n\t\t * @constructor\n\t\t */\n\t\tfunction ContinuationTask(continuation, handler) {\n\t\t\tthis.continuation = continuation;\n\t\t\tthis.handler = handler;\n\t\t}\n\n\t\tContinuationTask.prototype.run = function() {\n\t\t\tthis.handler.join().when(this.continuation);\n\t\t};\n\n\t\t/**\n\t\t * Run a queue of progress handlers\n\t\t * @constructor\n\t\t */\n\t\tfunction ProgressTask(value, handler) {\n\t\t\tthis.handler = handler;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tProgressTask.prototype.run = function() {\n\t\t\tvar q = this.handler.consumers;\n\t\t\tif(q === void 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var c, i = 0; i < q.length; ++i) {\n\t\t\t\tc = q[i];\n\t\t\t\trunNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Assimilate a thenable, sending it's value to resolver\n\t\t * @param {function} then\n\t\t * @param {object|function} thenable\n\t\t * @param {object} resolver\n\t\t * @constructor\n\t\t */\n\t\tfunction AssimilateTask(then, thenable, resolver) {\n\t\t\tthis._then = then;\n\t\t\tthis.thenable = thenable;\n\t\t\tthis.resolver = resolver;\n\t\t}\n\n\t\tAssimilateTask.prototype.run = function() {\n\t\t\tvar h = this.resolver;\n\t\t\ttryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);\n\n\t\t\tfunction _resolve(x) { h.resolve(x); }\n\t\t\tfunction _reject(x)  { h.reject(x); }\n\t\t\tfunction _notify(x)  { h.notify(x); }\n\t\t};\n\n\t\tfunction tryAssimilate(then, thenable, resolve, reject, notify) {\n\t\t\ttry {\n\t\t\t\tthen.call(thenable, resolve, reject, notify);\n\t\t\t} catch (e) {\n\t\t\t\treject(e);\n\t\t\t}\n\t\t}\n\n\t\t// Other helpers\n\n\t\t/**\n\t\t * @param {*} x\n\t\t * @returns {boolean} true iff x is a trusted Promise\n\t\t */\n\t\tfunction isPromise(x) {\n\t\t\treturn x instanceof Promise;\n\t\t}\n\n\t\t/**\n\t\t * Test just enough to rule out primitives, in order to take faster\n\t\t * paths in some code\n\t\t * @param {*} x\n\t\t * @returns {boolean} false iff x is guaranteed *not* to be a thenable\n\t\t */\n\t\tfunction maybeThenable(x) {\n\t\t\treturn (typeof x === 'object' || typeof x === 'function') && x !== null;\n\t\t}\n\n\t\tfunction runContinuation1(f, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.become(h);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReject(f, h.value, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\tfunction runContinuation3(f, x, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.become(h);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReject3(f, x, h.value, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\tfunction runNotify(f, x, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.notify(x);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReturn(f, x, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\t/**\n\t\t * Return f.call(thisArg, x), or if it throws return a rejected promise for\n\t\t * the thrown exception\n\t\t */\n\t\tfunction tryCatchReject(f, x, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tnext.become(getHandler(f.call(thisArg, x)));\n\t\t\t} catch(e) {\n\t\t\t\tnext.become(new Rejected(e));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Same as above, but includes the extra argument parameter.\n\t\t */\n\t\tfunction tryCatchReject3(f, x, y, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tf.call(thisArg, x, y, next);\n\t\t\t} catch(e) {\n\t\t\t\tnext.become(new Rejected(e));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Return f.call(thisArg, x), or if it throws, *return* the exception\n\t\t */\n\t\tfunction tryCatchReturn(f, x, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tnext.notify(f.call(thisArg, x));\n\t\t\t} catch(e) {\n\t\t\t\tnext.notify(e);\n\t\t\t}\n\t\t}\n\n\t\tfunction inherit(Parent, Child) {\n\t\t\tChild.prototype = objectCreate(Parent.prototype);\n\t\t\tChild.prototype.constructor = Child;\n\t\t}\n\n\t\tfunction noop() {}\n\n\t\treturn Promise;\n\t};\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n","/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule CSSCore\n * @typechecks\n */\n\nvar invariant = require(\"./invariant\");\n\n/**\n * The CSSCore module specifies the API (and implements most of the methods)\n * that should be used when dealing with the display of elements (via their\n * CSS classes and visibility on screen. It is an API focused on mutating the\n * display and not reading it as no logical state should be encoded in the\n * display of elements.\n */\n\nvar CSSCore = {\n\n  /**\n   * Adds the class passed in to the element if it doesn't already have it.\n   *\n   * @param {DOMElement} element the element to set the class on\n   * @param {string} className the CSS className\n   * @return {DOMElement} the element passed in\n   */\n  addClass: function(element, className) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      !/\\s/.test(className),\n      'CSSCore.addClass takes only a single class name. \"%s\" contains ' +\n      'multiple classes.', className\n    ) : invariant(!/\\s/.test(className)));\n\n    if (className) {\n      if (element.classList) {\n        element.classList.add(className);\n      } else if (!CSSCore.hasClass(element, className)) {\n        element.className = element.className + ' ' + className;\n      }\n    }\n    return element;\n  },\n\n  /**\n   * Removes the class passed in from the element\n   *\n   * @param {DOMElement} element the element to set the class on\n   * @param {string} className the CSS className\n   * @return {DOMElement} the element passed in\n   */\n  removeClass: function(element, className) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      !/\\s/.test(className),\n      'CSSCore.removeClass takes only a single class name. \"%s\" contains ' +\n      'multiple classes.', className\n    ) : invariant(!/\\s/.test(className)));\n\n    if (className) {\n      if (element.classList) {\n        element.classList.remove(className);\n      } else if (CSSCore.hasClass(element, className)) {\n        element.className = element.className\n          .replace(new RegExp('(^|\\\\s)' + className + '(?:\\\\s|$)', 'g'), '$1')\n          .replace(/\\s+/g, ' ') // multiple spaces to one\n          .replace(/^\\s*|\\s*$/g, ''); // trim the ends\n      }\n    }\n    return element;\n  },\n\n  /**\n   * Helper to add or remove a class from an element based on a condition.\n   *\n   * @param {DOMElement} element the element to set the class on\n   * @param {string} className the CSS className\n   * @param {*} bool condition to whether to add or remove the class\n   * @return {DOMElement} the element passed in\n   */\n  conditionClass: function(element, className, bool) {\n    return (bool ? CSSCore.addClass : CSSCore.removeClass)(element, className);\n  },\n\n  /**\n   * Tests whether the element has the class specified.\n   *\n   * @param {DOMNode|DOMWindow} element the element to set the class on\n   * @param {string} className the CSS className\n   * @return {boolean} true if the element has the class, false if not\n   */\n  hasClass: function(element, className) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      !/\\s/.test(className),\n      'CSS.hasClass takes only a single class name.'\n    ) : invariant(!/\\s/.test(className)));\n    if (element.classList) {\n      return !!className && element.classList.contains(className);\n    }\n    return (' ' + element.className + ' ').indexOf(' ' + className + ' ') > -1;\n  }\n\n};\n\nmodule.exports = CSSCore;\n","/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ExecutionEnvironment\n */\n\n/*jslint evil: true */\n\n\"use strict\";\n\nvar canUseDOM = !!(\n  typeof window !== 'undefined' &&\n  window.document &&\n  window.document.createElement\n);\n\n/**\n * Simple, lightweight module assisting with the detection and context of\n * Worker. Helps avoid circular dependencies and allows code to reason about\n * whether or not they are in a Worker, even if they never include the main\n * `ReactWorker` dependency.\n */\nvar ExecutionEnvironment = {\n\n  canUseDOM: canUseDOM,\n\n  canUseWorkers: typeof Worker !== 'undefined',\n\n  canUseEventListeners:\n    canUseDOM && !!(window.addEventListener || window.attachEvent),\n\n  canUseViewport: canUseDOM && !!window.screen,\n\n  isInWorker: !canUseDOM // For now, this is true - might change in the future.\n\n};\n\nmodule.exports = ExecutionEnvironment;\n","/**\n * Copyright 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule Object.assign\n */\n\n// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign\n\nfunction assign(target, sources) {\n  if (target == null) {\n    throw new TypeError('Object.assign target cannot be null or undefined');\n  }\n\n  var to = Object(target);\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {\n    var nextSource = arguments[nextIndex];\n    if (nextSource == null) {\n      continue;\n    }\n\n    var from = Object(nextSource);\n\n    // We don't currently support accessors nor proxies. Therefore this\n    // copy cannot throw. If we ever supported this then we must handle\n    // exceptions and side-effects. We don't support symbols so they won't\n    // be transferred.\n\n    for (var key in from) {\n      if (hasOwnProperty.call(from, key)) {\n        to[key] = from[key];\n      }\n    }\n  }\n\n  return to;\n};\n\nmodule.exports = assign;\n","/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactTransitionEvents\n */\n\n\"use strict\";\n\nvar ExecutionEnvironment = require(\"./ExecutionEnvironment\");\n\n/**\n * EVENT_NAME_MAP is used to determine which event fired when a\n * transition/animation ends, based on the style property used to\n * define that event.\n */\nvar EVENT_NAME_MAP = {\n  transitionend: {\n    'transition': 'transitionend',\n    'WebkitTransition': 'webkitTransitionEnd',\n    'MozTransition': 'mozTransitionEnd',\n    'OTransition': 'oTransitionEnd',\n    'msTransition': 'MSTransitionEnd'\n  },\n\n  animationend: {\n    'animation': 'animationend',\n    'WebkitAnimation': 'webkitAnimationEnd',\n    'MozAnimation': 'mozAnimationEnd',\n    'OAnimation': 'oAnimationEnd',\n    'msAnimation': 'MSAnimationEnd'\n  }\n};\n\nvar endEvents = [];\n\nfunction detectEvents() {\n  var testEl = document.createElement('div');\n  var style = testEl.style;\n\n  // On some platforms, in particular some releases of Android 4.x,\n  // the un-prefixed \"animation\" and \"transition\" properties are defined on the\n  // style object but the events that fire will still be prefixed, so we need\n  // to check if the un-prefixed events are useable, and if not remove them\n  // from the map\n  if (!('AnimationEvent' in window)) {\n    delete EVENT_NAME_MAP.animationend.animation;\n  }\n\n  if (!('TransitionEvent' in window)) {\n    delete EVENT_NAME_MAP.transitionend.transition;\n  }\n\n  for (var baseEventName in EVENT_NAME_MAP) {\n    var baseEvents = EVENT_NAME_MAP[baseEventName];\n    for (var styleName in baseEvents) {\n      if (styleName in style) {\n        endEvents.push(baseEvents[styleName]);\n        break;\n      }\n    }\n  }\n}\n\nif (ExecutionEnvironment.canUseDOM) {\n  detectEvents();\n}\n\n// We use the raw {add|remove}EventListener() call because EventListener\n// does not know how to remove event listeners and we really should\n// clean up. Also, these events are not triggered in older browsers\n// so we should be A-OK here.\n\nfunction addEventListener(node, eventName, eventListener) {\n  node.addEventListener(eventName, eventListener, false);\n}\n\nfunction removeEventListener(node, eventName, eventListener) {\n  node.removeEventListener(eventName, eventListener, false);\n}\n\nvar ReactTransitionEvents = {\n  addEndEventListener: function(node, eventListener) {\n    if (endEvents.length === 0) {\n      // If CSS transitions are not supported, trigger an \"end animation\"\n      // event immediately.\n      window.setTimeout(eventListener, 0);\n      return;\n    }\n    endEvents.forEach(function(endEvent) {\n      addEventListener(node, endEvent, eventListener);\n    });\n  },\n\n  removeEndEventListener: function(node, eventListener) {\n    if (endEvents.length === 0) {\n      return;\n    }\n    endEvents.forEach(function(endEvent) {\n      removeEventListener(node, endEvent, eventListener);\n    });\n  }\n};\n\nmodule.exports = ReactTransitionEvents;\n","/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule cx\n */\n\n/**\n * This function is used to mark string literals representing CSS class names\n * so that they can be transformed statically. This allows for modularization\n * and minification of CSS class names.\n *\n * In static_upstream, this function is actually implemented, but it should\n * eventually be replaced with something more descriptive, and the transform\n * that is used in the main stack should be ported for use elsewhere.\n *\n * @param string|object className to modularize, or an object of key/values.\n *                      In the object case, the values are conditions that\n *                      determine if the className keys should be included.\n * @param [string ...]  Variable list of classNames in the string case.\n * @return string       Renderable space-separated CSS className.\n */\nfunction cx(classNames) {\n  if (typeof classNames == 'object') {\n    return Object.keys(classNames).filter(function(className) {\n      return classNames[className];\n    }).join(' ');\n  } else {\n    return Array.prototype.join.call(arguments, ' ');\n  }\n}\n\nmodule.exports = cx;\n","/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule emptyFunction\n */\n\nfunction makeEmptyFunction(arg) {\n  return function() {\n    return arg;\n  };\n}\n\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\nfunction emptyFunction() {}\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\nemptyFunction.thatReturnsThis = function() { return this; };\nemptyFunction.thatReturnsArgument = function(arg) { return arg; };\n\nmodule.exports = emptyFunction;\n","/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule invariant\n */\n\n\"use strict\";\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (\"production\" !== process.env.NODE_ENV) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        'Invariant Violation: ' +\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n","/**\n * Copyright 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule warning\n */\n\n\"use strict\";\n\nvar emptyFunction = require(\"./emptyFunction\");\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = emptyFunction;\n\nif (\"production\" !== process.env.NODE_ENV) {\n  warning = function(condition, format ) {for (var args=[],$__0=2,$__1=arguments.length;$__0<$__1;$__0++) args.push(arguments[$__0]);\n    if (format === undefined) {\n      throw new Error(\n        '`warning(condition, format, ...args)` requires a warning ' +\n        'message argument'\n      );\n    }\n\n    if (!condition) {\n      var argIndex = 0;\n      console.warn('Warning: ' + format.replace(/%s/g, function()  {return args[argIndex++];}));\n    }\n  };\n}\n\nmodule.exports = warning;\n","module.exports={\n  \"name\": \"immutable\",\n  \"version\": \"4.0.0-rc.12\",\n  \"description\": \"Immutable Data Collections\",\n  \"license\": \"MIT\",\n  \"homepage\": \"https://immutable-js.com\",\n  \"author\": {\n    \"name\": \"Lee Byron\",\n    \"url\": \"https://github.com/leebyron\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/immutable-js/immutable-js.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/immutable-js/immutable-js/issues\"\n  },\n  \"main\": \"dist/immutable.js\",\n  \"module\": \"dist/immutable.es.js\",\n  \"typings\": \"dist/immutable-nonambient.d.ts\",\n  \"typescript\": {\n    \"definition\": \"dist/immutable.d.ts\"\n  },\n  \"scripts\": {\n    \"build\": \"run-s build:*\",\n    \"build:dist\": \"run-s clean:dist bundle:dist bundle:es copy:dist stats:dist prepare:dist\",\n    \"build:pages\": \"gulp --gulpfile ./resources/gulpfile.js default\",\n    \"stats:dist\": \"node ./resources/dist-stats.js\",\n    \"clean:dist\": \"rimraf dist\",\n    \"bundle:dist\": \"rollup -c ./resources/rollup-config.js\",\n    \"bundle:es\": \"rollup -c ./resources/rollup-config-es.js\",\n    \"copy:dist\": \"node ./resources/copy-dist-typedefs.js\",\n    \"prepare:dist\": \"./resources/prepare-dist.sh\",\n    \"format\": \"npm run lint:format -- --write\",\n    \"lint\": \"run-s lint:*\",\n    \"lint:ts\": \"tslint \\\"__tests__/**/*.ts\\\"\",\n    \"lint:js\": \"eslint \\\"{__tests__,src,pages/src,pages/lib}/**/*.js\\\"\",\n    \"lint:format\": \"prettier --check \\\"{__tests__,src,pages/src,pages/lib,perf,resources}/**/*{\\\\.js,\\\\.ts}\\\"\",\n    \"testonly\": \"./resources/jest\",\n    \"test\": \"run-s format build lint testonly test:types\",\n    \"check:git-clean\": \"./resources/check-changes\",\n    \"test:types\": \"run-s test:types:*\",\n    \"test:types:ts\": \"tsc ./type-definitions/Immutable.d.ts --lib es2015 && dtslint type-definitions/ts-tests\",\n    \"test:types:flow\": \"flow check type-definitions/flow-tests --include-warnings\",\n    \"perf\": \"node ./resources/bench.js\",\n    \"start\": \"gulp --gulpfile ./resources/gulpfile.js dev\"\n  },\n  \"prettier\": {\n    \"singleQuote\": true,\n    \"trailingComma\": \"es5\",\n    \"semi\": true,\n    \"arrowParens\": \"avoid\"\n  },\n  \"jest\": {\n    \"moduleFileExtensions\": [\n      \"js\",\n      \"ts\"\n    ],\n    \"transform\": {\n      \"^.+\\\\.ts$\": \"<rootDir>/resources/jestPreprocessor.js\"\n    },\n    \"testRegex\": \"/__tests__/.*\\\\.(ts|js)$\",\n    \"unmockedModulePathPatterns\": [\n      \"./node_modules/react\"\n    ]\n  },\n  \"devDependencies\": {\n    \"benchmark\": \"2.1.4\",\n    \"browser-sync\": \"^2.26.12\",\n    \"browserify\": \"16.5.2\",\n    \"colors\": \"1.4.0\",\n    \"del\": \"6.0.0\",\n    \"dtslint\": \"4.1.0\",\n    \"eslint\": \"7.29.0\",\n    \"eslint-config-airbnb\": \"18.2.1\",\n    \"eslint-config-prettier\": \"8.3.0\",\n    \"eslint-plugin-import\": \"2.23.4\",\n    \"eslint-plugin-jsx-a11y\": \"6.4.1\",\n    \"eslint-plugin-prettier\": \"3.4.0\",\n    \"eslint-plugin-react\": \"7.24.0\",\n    \"flow-bin\": \"0.89.0\",\n    \"gulp\": \"4.0.2\",\n    \"gulp-concat\": \"2.6.1\",\n    \"gulp-filter\": \"6.0.0\",\n    \"gulp-header\": \"2.0.9\",\n    \"gulp-less\": \"4.0.1\",\n    \"gulp-size\": \"3.0.0\",\n    \"gulp-sourcemaps\": \"2.6.5\",\n    \"gulp-uglify\": \"3.0.2\",\n    \"gulp-util\": \"3.0.8\",\n    \"jasmine-check\": \"0.1.5\",\n    \"jest\": \"26.5.2\",\n    \"marked\": \"1.2.0\",\n    \"microtime\": \"3.0.0\",\n    \"mkdirp\": \"1.0.4\",\n    \"npm-run-all\": \"4.1.5\",\n    \"prettier\": \"^2.3.1\",\n    \"react\": \"^0.12.2\",\n    \"react-router\": \"^0.11.6\",\n    \"react-tools\": \"0.13.3\",\n    \"rimraf\": \"3.0.2\",\n    \"rollup\": \"2.29.0\",\n    \"rollup-plugin-buble\": \"0.19.2\",\n    \"rollup-plugin-commonjs\": \"9.1.3\",\n    \"rollup-plugin-json\": \"3.0.0\",\n    \"rollup-plugin-strip-banner\": \"2.0.0\",\n    \"through2\": \"4.0.2\",\n    \"transducers-js\": \"^0.4.174\",\n    \"tslint\": \"6.1.3\",\n    \"typescript\": \"4.3.4\",\n    \"uglify-js\": \"3.11.1\",\n    \"uglify-save-license\": \"0.4.1\",\n    \"vinyl-buffer\": \"1.0.1\",\n    \"vinyl-source-stream\": \"2.0.0\"\n  },\n  \"files\": [\n    \"dist\",\n    \"contrib\",\n    \"README.md\",\n    \"LICENSE\"\n  ],\n  \"keywords\": [\n    \"immutable\",\n    \"persistent\",\n    \"lazy\",\n    \"data\",\n    \"datastructure\",\n    \"functional\",\n    \"collection\",\n    \"stateless\",\n    \"sequence\",\n    \"iteration\"\n  ]\n}\n","module.exports={\"Immutable\":{\"doc\":{\"synopsis\":\"Immutable data encourages pure functions (data-in, data-out) and lends itself\\nto much simpler application development and enabling techniques from\\nfunctional programming such as lazy evaluation.\",\"description\":\"While designed to bring these powerful functional concepts to JavaScript, it\\npresents an Object-Oriented API familiar to Javascript engineers and closely\\nmirroring that of Array, Map, and Set. It is easy and efficient to convert to\\nand from plain Javascript types.\\n\\n## How to read these docs\\n\\nIn order to better explain what kinds of values the Immutable.js API expects\\nand produces, this documentation is presented in a statically typed dialect of\\nJavaScript (like [Flow][] or [TypeScript][]). You *don't need* to use these\\ntype checking tools in order to use Immutable.js, however becoming familiar\\nwith their syntax will help you get a deeper understanding of this API.\\n\\n**A few examples and how to read them.**\\n\\nAll methods describe the kinds of data they accept and the kinds of data\\nthey return. For example a function which accepts two numbers and returns\\na number would look like this:\\n\\n```js\\nsum(first: number, second: number): number\\n```\\n\\nSometimes, methods can accept different kinds of data or return different\\nkinds of data, and this is described with a *type variable*, which is\\ntypically in all-caps. For example, a function which always returns the same\\nkind of data it was provided would look like this:\\n\\n```js\\nidentity<T>(value: T): T\\n```\\n\\nType variables are defined with classes and referred to in methods. For\\nexample, a class that holds onto a value for you might look like this:\\n\\n```js\\nclass Box<T> {\\n  constructor(value: T)\\n  getValue(): T\\n}\\n```\\n\\nIn order to manipulate Immutable data, methods that we're used to affecting\\na Collection instead return a new Collection of the same type. The type\\n`this` refers to the same kind of class. For example, a List which returns\\nnew Lists when you `push` a value onto it might look like:\\n\\n```js\\nclass List<T> {\\n  push(value: T): this\\n}\\n```\\n\\nMany methods in Immutable.js accept values which implement the JavaScript\\n[Iterable][] protocol, and might appear like `Iterable<string>` for something\\nwhich represents sequence of strings. Typically in JavaScript we use plain\\nArrays (`[]`) when an Iterable is expected, but also all of the Immutable.js\\ncollections are iterable themselves!\\n\\nFor example, to get a value deep within a structure of data, we might use\\n`getIn` which expects an `Iterable` path:\\n\\n```\\ngetIn(path: Iterable<string | number>): unknown\\n```\\n\\nTo use this method, we could pass an array: `data.getIn([ \\\"key\\\", 2 ])`.\\n\\n\\nNote: All examples are presented in the modern [ES2015][] version of\\nJavaScript. Use tools like Babel to support older browsers.\\n\\nFor example:\\n\\n```js\\n// ES2015\\nconst mappedFoo = foo.map(x => x * x);\\n// ES5\\nvar mappedFoo = foo.map(function (x) { return x * x; });\\n```\\n\\n[ES2015]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla\\n[TypeScript]: https://www.typescriptlang.org/\\n[Flow]: https://flowtype.org/\\n[Iterable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\",\"notes\":[]},\"module\":{\"List\":{\"doc\":{\"synopsis\":\"Lists are ordered indexed dense collections, much like a JavaScript\\nArray.\",\"description\":\"Lists are immutable and fully persistent with O(log32 N) gets and sets,\\nand O(1) push and pop.\\n\\nLists implement Deque, with efficient addition and removal from both the\\nend (`push`, `pop`) and beginning (`unshift`, `shift`).\\n\\nUnlike a JavaScript Array, there is no distinction between an\\n\\\"unset\\\" index and an index set to `undefined`. `List#forEach` visits all\\nindices from 0 to size, regardless of whether they were explicitly defined.\",\"notes\":[]},\"module\":{\"isList\":{\"call\":{\"doc\":{\"synopsis\":\"True if the provided value is a List\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable');\\nList.isList([]); // false\\nList.isList(List()); // true\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeList\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":120}]}},\"of\":{\"call\":{\"doc\":{\"synopsis\":\"Creates a new List containing `values`.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable');\\nList.of(1, 2, 3, 4)\\n// List [ 1, 2, 3, 4 ]\\n```\\n\\nNote: Values are not altered or converted in any way.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable');\\nList.of({x:1}, 2, [3], 4)\\n// List [ { x: 1 }, 2, [ 3 ], 4 ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":141}]}}},\"call\":{\"doc\":{\"synopsis\":\"Create a new immutable List containing the values of the provided\\ncollection-like.\",\"description\":\"Note: `List` is a factory function and not a class, and does not use the\\n`new` keyword during construction.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { List, Set } = require('immutable')\\n\\nconst emptyList = List()\\n// List []\\n\\nconst plainArray = [ 1, 2, 3, 4 ]\\nconst listFromPlainArray = List(plainArray)\\n// List [ 1, 2, 3, 4 ]\\n\\nconst plainSet = Set([ 1, 2, 3, 4 ])\\nconst listFromPlainSet = List(plainSet)\\n// List [ 1, 2, 3, 4 ]\\n\\nconst arrayIterator = plainArray[Symbol.iterator]()\\nconst listFromCollectionArray = List(arrayIterator)\\n// List [ 1, 2, 3, 4 ]\\n\\nlistFromPlainArray.equals(listFromCollectionArray) // true\\nlistFromPlainSet.equals(listFromCollectionArray) // true\\nlistFromPlainSet.equals(listFromPlainArray) // true\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":175},{\"typeParams\":[\"T\"],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":176},{\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":17}]},\"line\":177}]},\"interface\":{\"line\":179,\"typeParams\":[\"T\"],\"extends\":[{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]}],\"groups\":[{\"members\":{\"#size\":{\"line\":184}}},{\"title\":\"Persistent changes\",\"members\":{\"#set\":{\"doc\":{\"synopsis\":\"Returns a new List which includes `value` at `index`. If `index` already\\nexists in this List, it will be replaced.\",\"description\":\"`index` may be a negative number, which indexes back from the end of the\\nList. `v.set(-1, \\\"value\\\")` sets the last item in the List.\\n\\nIf `index` larger than `size`, the returned List's `size` will be large\\nenough to include the `index`.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nconst originalList = List([ 0 ]);\\n// List [ 0 ]\\noriginalList.set(1, 1);\\n// List [ 0, 1 ]\\noriginalList.set(0, 'overwritten');\\n// List [ \\\"overwritten\\\" ]\\noriginalList.set(2, 2);\\n// List [ 0, undefined, 2 ]\\n\\nList().set(50000, 'value').size;\\n// 50001\\n```\\n\\nNote: `set` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":217}]},\"#delete\":{\"doc\":{\"synopsis\":\"Returns a new List which excludes this `index` and with a size 1 less\\nthan this List. Values at indices above `index` are shifted down by 1 to\\nfill the position.\",\"description\":\"This is synonymous with `list.splice(index, 1)`.\\n\\n`index` may be a negative number, which indexes back from the end of the\\nList. `v.delete(-1)` deletes the last item in the List.\\n\\nNote: `delete` cannot be safely used in IE8\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nList([ 0, 1, 2, 3, 4 ]).delete(0);\\n// List [ 1, 2, 3, 4 ]\\n```\\n\\nSince `delete()` re-indexes values, it produces a complete copy, which\\nhas `O(N)` complexity.\\n\\nNote: `delete` *cannot* be used in `withMutations`.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"remove\"}]},\"signatures\":[{\"params\":[{\"name\":\"index\",\"type\":{\"k\":2}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":246}]},\"#insert\":{\"doc\":{\"synopsis\":\"Returns a new List with `value` at `index` with a size 1 more than this\\nList. Values at indices above `index` are shifted over by 1.\",\"description\":\"This is synonymous with `list.splice(index, 0, value)`.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nList([ 0, 1, 2, 3, 4 ]).insert(6, 5)\\n// List [ 0, 1, 2, 3, 4, 5 ]\\n```\\n\\nSince `insert()` re-indexes values, it produces a complete copy, which\\nhas `O(N)` complexity.\\n\\nNote: `insert` *cannot* be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":268}]},\"#clear\":{\"doc\":{\"synopsis\":\"Returns a new List with 0 size and no values in constant time.\",\"description\":\"<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nList([ 1, 2, 3, 4 ]).clear()\\n// List []\\n```\\n\\nNote: `clear` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":283}]},\"#push\":{\"doc\":{\"synopsis\":\"Returns a new List with the provided `values` appended, starting at this\\nList's `size`.\",\"description\":\"<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nList([ 1, 2, 3, 4 ]).push(5)\\n// List [ 1, 2, 3, 4, 5 ]\\n```\\n\\nNote: `push` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":299}]},\"#pop\":{\"doc\":{\"synopsis\":\"Returns a new List with a size ones less than this List, excluding\\nthe last index in this List.\",\"description\":\"Note: this differs from `Array#pop` because it returns a new\\nList rather than the removed value. Use `last()` to get the last value\\nin this List.\\n\\n```js\\nList([ 1, 2, 3, 4 ]).pop()\\n// List[ 1, 2, 3 ]\\n```\\n\\nNote: `pop` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":316}]},\"#unshift\":{\"doc\":{\"synopsis\":\"Returns a new List with the provided `values` prepended, shifting other\\nvalues ahead to higher indices.\",\"description\":\"<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nList([ 2, 3, 4]).unshift(1);\\n// List [ 1, 2, 3, 4 ]\\n```\\n\\nNote: `unshift` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":332}]},\"#shift\":{\"doc\":{\"synopsis\":\"Returns a new List with a size ones less than this List, excluding\\nthe first index in this List, shifting all other values to a lower index.\",\"description\":\"Note: this differs from `Array#shift` because it returns a new\\nList rather than the removed value. Use `first()` to get the first\\nvalue in this List.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nList([ 0, 1, 2, 3, 4 ]).shift();\\n// List [ 1, 2, 3, 4 ]\\n```\\n\\nNote: `shift` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":352}]},\"#update\":{\"doc\":{\"synopsis\":\"Returns a new List with an updated value at `index` with the return\\nvalue of calling `updater` with the existing value, or `notSetValue` if\\n`index` was not set. If called with a single argument, `updater` is\\ncalled with the List itself.\",\"description\":\"`index` may be a negative number, which indexes back from the end of the\\nList. `v.update(-1)` updates the last item in the List.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nconst list = List([ 'a', 'b', 'c' ])\\nconst result = list.update(2, val => val.toUpperCase())\\n// List [ \\\"a\\\", \\\"b\\\", \\\"C\\\" ]\\n```\\n\\nThis can be very useful as a way to \\\"chain\\\" a normal function into a\\nsequence of methods. RxJS calls this \\\"let\\\" and lodash calls it \\\"thru\\\".\\n\\nFor example, to sum a List after mapping and filtering:\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nfunction sum(collection) {\\n  return collection.reduce((sum, x) => sum + x, 0)\\n}\\n\\nList([ 1, 2, 3 ])\\n  .map(x => x + 1)\\n  .filter(x => x % 2 === 0)\\n  .update(sum)\\n// 6\\n```\\n\\nNote: `update(index)` can be used in `withMutations`.\\n\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#update`\"}]},\"signatures\":[{\"params\":[{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":8,\"param\":\"T\"}}}],\"type\":{\"k\":10},\"line\":396},{\"params\":[{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":8,\"param\":\"T\"}}}],\"type\":{\"k\":10},\"line\":397},{\"typeParams\":[\"R\"],\"params\":[{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"R\"}}}],\"type\":{\"k\":8,\"param\":\"R\"},\"line\":398}]},\"#setSize\":{\"doc\":{\"synopsis\":\"Returns a new List with size `size`. If `size` is less than this\\nList's size, the new List will exclude values at the higher indices.\\nIf `size` is greater than this List's size, the new List will have\\nundefined values for the newly available indices.\",\"description\":\"When building a new List and the final size is known up front, `setSize`\\nused in conjunction with `withMutations` may result in the more\\nperformant construction.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"size\",\"type\":{\"k\":2}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":410}]}}},{\"title\":\"Deep persistent changes\",\"members\":{\"#setIn\":{\"doc\":{\"synopsis\":\"Returns a new List having set `value` at this `keyPath`. If any keys in\\n`keyPath` do not exist, a new immutable Map will be created at that key.\",\"description\":\"Index numbers are used as keys to determine the path to follow in\\nthe List.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nconst list = List([ 0, 1, 2, List([ 3, 4 ])])\\nlist.setIn([3, 0], 999);\\n// List [ 0, 1, 2, List [ 999, 4 ] ]\\n```\\n\\nPlain JavaScript Object or Arrays may be nested within an Immutable.js\\nCollection, and setIn() can update those values as well, treating them\\nimmutably by creating new copies of those values with the changes applied.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nconst list = List([ 0, 1, 2, { plain: 'object' }])\\nlist.setIn([3, 'plain'], 'value');\\n// List([ 0, 1, 2, { plain: 'value' }])\\n```\\n\\nNote: `setIn` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":10},\"line\":444}]},\"#deleteIn\":{\"doc\":{\"synopsis\":\"Returns a new List having removed the value at this `keyPath`. If any\\nkeys in `keyPath` do not exist, no change will occur.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nconst list = List([ 0, 1, 2, List([ 3, 4 ])])\\nlist.deleteIn([3, 0]);\\n// List [ 0, 1, 2, List [ 4 ] ]\\n```\\n\\nPlain JavaScript Object or Arrays may be nested within an Immutable.js\\nCollection, and removeIn() can update those values as well, treating them\\nimmutably by creating new copies of those values with the changes applied.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nconst list = List([ 0, 1, 2, { plain: 'object' }])\\nlist.removeIn([3, 'plain']);\\n// List([ 0, 1, 2, {}])\\n```\\n\\nNote: `deleteIn` *cannot* be safely used in `withMutations`.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"removeIn\"}]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}}],\"type\":{\"k\":10},\"line\":474}]},\"#updateIn\":{\"doc\":{\"synopsis\":\"Note: `updateIn` can be used in `withMutations`.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#updateIn`\"}]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"notSetValue\",\"type\":{\"k\":17}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":482},{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":483}]},\"#mergeIn\":{\"doc\":{\"synopsis\":\"Note: `mergeIn` can be used in `withMutations`.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#mergeIn`\"}]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":490}]},\"#mergeDeepIn\":{\"doc\":{\"synopsis\":\"Note: `mergeDeepIn` can be used in `withMutations`.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#mergeDeepIn`\"}]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":497}]}}},{\"title\":\"Transient changes\",\"members\":{\"#withMutations\":{\"doc\":{\"synopsis\":\"Note: Not all methods can be safely used on a mutable collection or within\\n`withMutations`! Check the documentation for each method to see if it\\nallows being used in `withMutations`.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#withMutations`\"}]},\"signatures\":[{\"params\":[{\"name\":\"mutator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"mutable\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":508}]},\"#asMutable\":{\"doc\":{\"synopsis\":\"An alternative API for withMutations()\",\"description\":\"Note: Not all methods can be safely used on a mutable collection or within\\n`withMutations`! Check the documentation for each method to see if it\\nallows being used in `withMutations`.\\n\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asMutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":519}]},\"#wasAltered\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#wasAltered`\"}]},\"signatures\":[{\"type\":{\"k\":1},\"line\":524}]},\"#asImmutable\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asImmutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":529}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new List with other values or collections concatenated to this one.\",\"description\":\"Note: `concat` can be used in `withMutations`.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"merge\"}]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"valuesOrCollections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"C\"}]},{\"k\":8,\"param\":\"C\"}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":540}]},\"#map\":{\"doc\":{\"synopsis\":\"Returns a new List with values passed through a\\n`mapper` function.\",\"description\":\"<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nList([ 1, 2 ]).map(x => 10 * x)\\n// List [ 10, 20 ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":555}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the List, returning a new List.\",\"description\":\"Similar to `list.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":565}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new List with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"F\"}]},\"line\":577},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":581}]},\"#zip\":{\"doc\":{\"synopsis\":\"Returns a List \\\"zipped\\\" with the provided collection.\",\"description\":\"Like `zipWith`, but using the default `zipper`: creating an `Array`.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nconst a = List([ 1, 2, 3 ]);\\nconst b = List([ 4, 5, 6 ]);\\nconst c = a.zip(b); // List [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":600},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":601},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":17}]},\"line\":602}]},\"#zipAll\":{\"doc\":{\"synopsis\":\"Returns a List \\\"zipped\\\" with the provided collections.\",\"description\":\"Unlike `zip`, `zipAll` continues zipping until the longest collection is\\nexhausted. Missing values from shorter collections are filled with `undefined`.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nconst a = List([ 1, 2 ]);\\nconst b = List([ 3, 4, 5 ]);\\nconst c = a.zipAll(b); // List [ [ 1, 3 ], [ 2, 4 ], [ undefined, 5 ] ]\\n```\\n\\nNote: Since zipAll will return a collection as large as the largest\\ninput, some results may contain undefined values. TypeScript cannot\\naccount for these without cases (as of v2.5).\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":623},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":624},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":17}]},\"line\":625}]},\"#zipWith\":{\"doc\":{\"synopsis\":\"Returns a List \\\"zipped\\\" with the provided collections by using a\\ncustom `zipper` function.\",\"description\":\"<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nconst a = List([ 1, 2, 3 ]);\\nconst b = List([ 4, 5, 6 ]);\\nconst c = a.zipWith((a, b) => a + b, b);\\n// List [ 5, 7, 9 ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":641},{\"typeParams\":[\"U\",\"V\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}},{\"name\":\"thirdValue\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"thirdCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":645},{\"typeParams\":[\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"any\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":650}]}}}]}},\"Map\":{\"doc\":{\"synopsis\":\"Immutable Map is an unordered Collection.Keyed of (key, value) pairs with\\n`O(log32 N)` gets and `O(log32 N)` persistent sets.\",\"description\":\"Iteration order of a Map is undefined, however is stable. Multiple\\niterations of the same Map will iterate in the same order.\\n\\nMap's keys can be of any type, and use `Immutable.is` to determine key\\nequality. This allows the use of any value (including NaN) as a key.\\n\\nBecause `Immutable.is` returns equality based on value semantics, and\\nImmutable collections are treated as values, any Immutable collection may\\nbe used as a key.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map, List } = require('immutable');\\nMap().set(List([ 1 ]), 'listofone').get(List([ 1 ]));\\n// 'listofone'\\n```\\n\\nAny JavaScript object may be used as a key, however strict identity is used\\nto evaluate key equality. Two similar looking objects will represent two\\ndifferent keys.\\n\\nImplemented by a hash-array mapped trie.\",\"notes\":[]},\"module\":{\"isMap\":{\"call\":{\"doc\":{\"synopsis\":\"True if the provided value is a Map\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap.isMap({}) // false\\nMap.isMap(Map()) // true\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeMap\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":696}]}}},\"call\":{\"doc\":{\"synopsis\":\"Creates a new Immutable Map.\",\"description\":\"Created with the same key value pairs as the provided Collection.Keyed or\\nJavaScript Object or expects a Collection of [K, V] tuple entries.\\n\\nNote: `Map` is a factory function and not a class, and does not use the\\n`new` keyword during construction.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap({ key: \\\"value\\\" })\\nMap([ [ \\\"key\\\", \\\"value\\\" ] ])\\n```\\n\\nKeep in mind, when using JS objects to construct Immutable Maps, that\\nJavaScript Object properties are always strings, even if written in a\\nquote-less shorthand, while Immutable Maps accept keys of any type.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable');\\\" }\\n-->\\n```js\\nlet obj = { 1: \\\"one\\\" }\\nObject.keys(obj) // [ \\\"1\\\" ]\\nassert.equal(obj[\\\"1\\\"], obj[1]) // \\\"one\\\" === \\\"one\\\"\\n\\nlet map = Map(obj)\\nassert.notEqual(map.get(\\\"1\\\"), map.get(1)) // \\\"one\\\" !== undefined\\n```\\n\\nProperty access for JavaScript Objects first converts the key to a string,\\nbut since Immutable Map keys can be of any type the argument to `get()` is\\nnot altered.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\",\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]}}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":753},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"obj\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":3},{\"k\":8,\"param\":\"V\"}]},\"line\":754},{\"typeParams\":[\"K\",\"V\"],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":755},{\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":17},{\"k\":17}]},\"line\":756}]},\"interface\":{\"line\":758,\"typeParams\":[\"K\",\"V\"],\"extends\":[{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}],\"groups\":[{\"members\":{\"#size\":{\"line\":763}}},{\"title\":\"Persistent changes\",\"members\":{\"#set\":{\"doc\":{\"synopsis\":\"Returns a new Map also containing the new key, value pair. If an equivalent\\nkey already exists in this Map, it will be replaced.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst originalMap = Map()\\nconst newerMap = originalMap.set('key', 'value')\\nconst newestMap = newerMap.set('key', 'newer value')\\n\\noriginalMap\\n// Map {}\\nnewerMap\\n// Map { \\\"key\\\": \\\"value\\\" }\\nnewestMap\\n// Map { \\\"key\\\": \\\"newer value\\\" }\\n```\\n\\nNote: `set` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":10},\"line\":788}]},\"#delete\":{\"doc\":{\"synopsis\":\"Returns a new Map which excludes this `key`.\",\"description\":\"Note: `delete` cannot be safely used in IE8, but is provided to mirror\\nthe ES6 collection API.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst originalMap = Map({\\n  key: 'value',\\n  otherKey: 'other value'\\n})\\n// Map { \\\"key\\\": \\\"value\\\", \\\"otherKey\\\": \\\"other value\\\" }\\noriginalMap.delete('otherKey')\\n// Map { \\\"key\\\": \\\"value\\\" }\\n```\\n\\nNote: `delete` can be used in `withMutations`.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"remove\"}]},\"signatures\":[{\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":10},\"line\":812}]},\"#deleteAll\":{\"doc\":{\"synopsis\":\"Returns a new Map which excludes the provided `keys`.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst names = Map({ a: \\\"Aaron\\\", b: \\\"Barry\\\", c: \\\"Connor\\\" })\\nnames.deleteAll([ 'a', 'c' ])\\n// Map { \\\"b\\\": \\\"Barry\\\" }\\n```\\n\\nNote: `deleteAll` can be used in `withMutations`.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"removeAll\"}]},\"signatures\":[{\"params\":[{\"name\":\"keys\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"K\"}]}}],\"type\":{\"k\":10},\"line\":830}]},\"#clear\":{\"doc\":{\"synopsis\":\"Returns a new Map containing no keys or values.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap({ key: 'value' }).clear()\\n// Map {}\\n```\\n\\nNote: `clear` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":845}]},\"#update\":{\"doc\":{\"synopsis\":\"Returns a new Map having updated the value at this `key` with the return\\nvalue of calling `updater` with the existing value.\",\"description\":\"Similar to: `map.set(key, updater(map.get(key)))`.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst aMap = Map({ key: 'value' })\\nconst newMap = aMap.update('key', value => value + value)\\n// Map { \\\"key\\\": \\\"valuevalue\\\" }\\n```\\n\\nThis is most commonly used to call methods on collections within a\\nstructure of data. For example, in order to `.push()` onto a nested `List`,\\n`update` and `push` can be used together:\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map, List } = require('immutable');\\\" }\\n-->\\n```js\\nconst aMap = Map({ nestedList: List([ 1, 2, 3 ]) })\\nconst newMap = aMap.update('nestedList', list => list.push(4))\\n// Map { \\\"nestedList\\\": List [ 1, 2, 3, 4 ] }\\n```\\n\\nWhen a `notSetValue` is provided, it is provided to the `updater`\\nfunction when the value at the key does not exist in the Map.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable');\\\" }\\n-->\\n```js\\nconst aMap = Map({ key: 'value' })\\nconst newMap = aMap.update('noKey', 'no value', value => value + value)\\n// Map { \\\"key\\\": \\\"value\\\", \\\"noKey\\\": \\\"no valueno value\\\" }\\n```\\n\\nHowever, if the `updater` function returns the same value it was called\\nwith, then no change will occur. This is still true if `notSetValue`\\nis provided.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable');\\\" }\\n-->\\n```js\\nconst aMap = Map({ apples: 10 })\\nconst newMap = aMap.update('oranges', 0, val => val)\\n// Map { \\\"apples\\\": 10 }\\nassert.strictEqual(newMap, map);\\n```\\n\\nFor code using ES2015 or later, using `notSetValue` is discourged in\\nfavor of function parameter default values. This helps to avoid any\\npotential confusion with identify functions as described above.\\n\\nThe previous example behaves differently when written with default values:\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable');\\\" }\\n-->\\n```js\\nconst aMap = Map({ apples: 10 })\\nconst newMap = aMap.update('oranges', (val = 0) => val)\\n// Map { \\\"apples\\\": 10, \\\"oranges\\\": 0 }\\n```\\n\\nIf no key is provided, then the `updater` function return value is\\nreturned as well.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable');\\\" }\\n-->\\n```js\\nconst aMap = Map({ key: 'value' })\\nconst result = aMap.update(aMap => aMap.get('key'))\\n// \\\"value\\\"\\n```\\n\\nThis can be very useful as a way to \\\"chain\\\" a normal function into a\\nsequence of methods. RxJS calls this \\\"let\\\" and lodash calls it \\\"thru\\\".\\n\\nFor example, to sum the values in a Map\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable');\\\" }\\n-->\\n```js\\nfunction sum(collection) {\\n  return collection.reduce((sum, x) => sum + x, 0)\\n}\\n\\nMap({ x: 1, y: 2, z: 3 })\\n  .map(x => x + 1)\\n  .filter(x => x % 2 === 0)\\n  .update(sum)\\n// 6\\n```\\n\\nNote: `update(key)` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"V\"}}}],\"type\":{\"k\":10},\"line\":949},{\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"V\"}}}],\"type\":{\"k\":10},\"line\":950},{\"typeParams\":[\"R\"],\"params\":[{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"R\"}}}],\"type\":{\"k\":8,\"param\":\"R\"},\"line\":951}]},\"#merge\":{\"doc\":{\"synopsis\":\"Returns a new Map resulting from merging the provided Collections\\n(or JS objects) into this Map. In other words, this takes each entry of\\neach collection and sets it on this Map.\",\"description\":\"Note: Values provided to `merge` are shallowly converted before being\\nmerged. No nested values are altered.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst one = Map({ a: 10, b: 20, c: 30 })\\nconst two = Map({ b: 40, a: 50, d: 60 })\\none.merge(two) // Map { \\\"a\\\": 50, \\\"b\\\": 40, \\\"c\\\": 30, \\\"d\\\": 60 }\\ntwo.merge(one) // Map { \\\"b\\\": 20, \\\"a\\\": 10, \\\"d\\\": 60, \\\"c\\\": 30 }\\n```\\n\\nNote: `merge` can be used in `withMutations`.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"concat\"}]},\"signatures\":[{\"typeParams\":[\"KC\",\"VC\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KC\"},{\"k\":8,\"param\":\"VC\"}]}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"KC\"}]},{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"VC\"}]}]},\"line\":974},{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"C\"}}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":3}]},{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":975}]},\"#mergeWith\":{\"doc\":{\"synopsis\":\"Like `merge()`, `mergeWith()` returns a new Map resulting from merging\\nthe provided Collections (or JS objects) into this Map, but uses the\\n`merger` function for dealing with conflicts.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst one = Map({ a: 10, b: 20, c: 30 })\\nconst two = Map({ b: 40, a: 50, d: 60 })\\none.mergeWith((oldVal, newVal) => oldVal / newVal, two)\\n// { \\\"a\\\": 0.2, \\\"b\\\": 0.5, \\\"c\\\": 30, \\\"d\\\": 60 }\\ntwo.mergeWith((oldVal, newVal) => oldVal / newVal, one)\\n// { \\\"b\\\": 2, \\\"a\\\": 5, \\\"d\\\": 60, \\\"c\\\": 30 }\\n```\\n\\nNote: `mergeWith` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"merger\",\"type\":{\"k\":7,\"params\":[{\"name\":\"oldVal\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"newVal\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":8,\"param\":\"V\"}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":997}]},\"#mergeDeep\":{\"doc\":{\"synopsis\":\"Like `merge()`, but when two Collections conflict, it merges them as well,\\nrecursing deeply through the nested data.\",\"description\":\"Note: Values provided to `merge` are shallowly converted before being\\nmerged. No nested values are altered unless they will also be merged at\\na deeper level.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst one = Map({ a: Map({ x: 10, y: 10 }), b: Map({ x: 20, y: 50 }) })\\nconst two = Map({ a: Map({ x: 2 }), b: Map({ y: 5 }), c: Map({ z: 3 }) })\\none.mergeDeep(two)\\n// Map {\\n//   \\\"a\\\": Map { \\\"x\\\": 2, \\\"y\\\": 10 },\\n//   \\\"b\\\": Map { \\\"x\\\": 20, \\\"y\\\": 5 },\\n//   \\\"c\\\": Map { \\\"z\\\": 3 }\\n// }\\n```\\n\\nNote: `mergeDeep` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":1025}]},\"#mergeDeepWith\":{\"doc\":{\"synopsis\":\"Like `mergeDeep()`, but when two non-Collections conflict, it uses the\\n`merger` function to determine the resulting value.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst one = Map({ a: Map({ x: 10, y: 10 }), b: Map({ x: 20, y: 50 }) })\\nconst two = Map({ a: Map({ x: 2 }), b: Map({ y: 5 }), c: Map({ z: 3 }) })\\none.mergeDeepWith((oldVal, newVal) => oldVal / newVal, two)\\n// Map {\\n//   \\\"a\\\": Map { \\\"x\\\": 5, \\\"y\\\": 10 },\\n//   \\\"b\\\": Map { \\\"x\\\": 20, \\\"y\\\": 10 },\\n//   \\\"c\\\": Map { \\\"z\\\": 3 }\\n// }\\n```\\n\\nNote: `mergeDeepWith` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"merger\",\"type\":{\"k\":7,\"params\":[{\"name\":\"oldVal\",\"type\":{\"k\":17}},{\"name\":\"newVal\",\"type\":{\"k\":17}},{\"name\":\"key\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":1046}]}}},{\"title\":\"Deep persistent changes\",\"members\":{\"#setIn\":{\"doc\":{\"synopsis\":\"Returns a new Map having set `value` at this `keyPath`. If any keys in\\n`keyPath` do not exist, a new immutable Map will be created at that key.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst originalMap = Map({\\n  subObject: Map({\\n    subKey: 'subvalue',\\n    subSubObject: Map({\\n      subSubKey: 'subSubValue'\\n    })\\n  })\\n})\\n\\nconst newMap = originalMap.setIn(['subObject', 'subKey'], 'ha ha!')\\n// Map {\\n//   \\\"subObject\\\": Map {\\n//     \\\"subKey\\\": \\\"ha ha!\\\",\\n//     \\\"subSubObject\\\": Map { \\\"subSubKey\\\": \\\"subSubValue\\\" }\\n//   }\\n// }\\n\\nconst newerMap = originalMap.setIn(\\n  ['subObject', 'subSubObject', 'subSubKey'],\\n  'ha ha ha!'\\n)\\n// Map {\\n//   \\\"subObject\\\": Map {\\n//     \\\"subKey\\\": \\\"subvalue\\\",\\n//     \\\"subSubObject\\\": Map { \\\"subSubKey\\\": \\\"ha ha ha!\\\" }\\n//   }\\n// }\\n```\\n\\nPlain JavaScript Object or Arrays may be nested within an Immutable.js\\nCollection, and setIn() can update those values as well, treating them\\nimmutably by creating new copies of those values with the changes applied.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst originalMap = Map({\\n  subObject: {\\n    subKey: 'subvalue',\\n    subSubObject: {\\n      subSubKey: 'subSubValue'\\n    }\\n  }\\n})\\n\\noriginalMap.setIn(['subObject', 'subKey'], 'ha ha!')\\n// Map {\\n//   \\\"subObject\\\": {\\n//     subKey: \\\"ha ha!\\\",\\n//     subSubObject: { subSubKey: \\\"subSubValue\\\" }\\n//   }\\n// }\\n```\\n\\nIf any key in the path exists but cannot be updated (such as a primitive\\nlike number or a custom Object like Date), an error will be thrown.\\n\\nNote: `setIn` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":10},\"line\":1120}]},\"#deleteIn\":{\"doc\":{\"synopsis\":\"Returns a new Map having removed the value at this `keyPath`. If any keys\\nin `keyPath` do not exist, no change will occur.\",\"description\":\"Note: `deleteIn` can be used in `withMutations`.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"removeIn\"}]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}}],\"type\":{\"k\":10},\"line\":1130}]},\"#updateIn\":{\"doc\":{\"synopsis\":\"Returns a new Map having applied the `updater` to the entry found at the\\nkeyPath.\",\"description\":\"This is most commonly used to call methods on collections nested within a\\nstructure of data. For example, in order to `.push()` onto a nested `List`,\\n`updateIn` and `push` can be used together:\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map, List } = require('immutable')\\nconst map = Map({ inMap: Map({ inList: List([ 1, 2, 3 ]) }) })\\nconst newMap = map.updateIn(['inMap', 'inList'], list => list.push(4))\\n// Map { \\\"inMap\\\": Map { \\\"inList\\\": List [ 1, 2, 3, 4 ] } }\\n```\\n\\nIf any keys in `keyPath` do not exist, new Immutable `Map`s will\\nbe created at those keys. If the `keyPath` does not already contain a\\nvalue, the `updater` function will be called with `notSetValue`, if\\nprovided, otherwise `undefined`.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable')\\\" }\\n-->\\n```js\\nconst map = Map({ a: Map({ b: Map({ c: 10 }) }) })\\nconst newMap = map.updateIn(['a', 'b', 'c'], val => val * 2)\\n// Map { \\\"a\\\": Map { \\\"b\\\": Map { \\\"c\\\": 20 } } }\\n```\\n\\nIf the `updater` function returns the same value it was called with, then\\nno change will occur. This is still true if `notSetValue` is provided.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable')\\\" }\\n-->\\n```js\\nconst map = Map({ a: Map({ b: Map({ c: 10 }) }) })\\nconst newMap = map.updateIn(['a', 'b', 'x'], 100, val => val)\\n// Map { \\\"a\\\": Map { \\\"b\\\": Map { \\\"c\\\": 10 } } }\\nassert.strictEqual(newMap, aMap)\\n```\\n\\nFor code using ES2015 or later, using `notSetValue` is discourged in\\nfavor of function parameter default values. This helps to avoid any\\npotential confusion with identify functions as described above.\\n\\nThe previous example behaves differently when written with default values:\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable')\\\" }\\n-->\\n```js\\nconst map = Map({ a: Map({ b: Map({ c: 10 }) }) })\\nconst newMap = map.updateIn(['a', 'b', 'x'], (val = 100) => val)\\n// Map { \\\"a\\\": Map { \\\"b\\\": Map { \\\"c\\\": 10, \\\"x\\\": 100 } } }\\n```\\n\\nPlain JavaScript Object or Arrays may be nested within an Immutable.js\\nCollection, and updateIn() can update those values as well, treating them\\nimmutably by creating new copies of those values with the changes applied.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable')\\\" }\\n-->\\n```js\\nconst map = Map({ a: { b: { c: 10 } } })\\nconst newMap = map.updateIn(['a', 'b', 'c'], val => val * 2)\\n// Map { \\\"a\\\": { b: { c: 20 } } }\\n```\\n\\nIf any key in the path exists but cannot be updated (such as a primitive\\nlike number or a custom Object like Date), an error will be thrown.\\n\\nNote: `updateIn` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"notSetValue\",\"type\":{\"k\":17}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":1209},{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":1210}]},\"#mergeIn\":{\"doc\":{\"synopsis\":\"A combination of `updateIn` and `merge`, returning a new Map, but\\nperforming the merge at a point arrived at by following the keyPath.\\nIn other words, these two lines are equivalent:\",\"description\":\"```js\\nmap.updateIn(['a', 'b', 'c'], abc => abc.merge(y))\\nmap.mergeIn(['a', 'b', 'c'], y)\\n```\\n\\nNote: `mergeIn` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":1224}]},\"#mergeDeepIn\":{\"doc\":{\"synopsis\":\"A combination of `updateIn` and `mergeDeep`, returning a new Map, but\\nperforming the deep merge at a point arrived at by following the keyPath.\\nIn other words, these two lines are equivalent:\",\"description\":\"```js\\nmap.updateIn(['a', 'b', 'c'], abc => abc.mergeDeep(y))\\nmap.mergeDeepIn(['a', 'b', 'c'], y)\\n```\\n\\nNote: `mergeDeepIn` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":1238}]}}},{\"title\":\"Transient changes\",\"members\":{\"#withMutations\":{\"doc\":{\"synopsis\":\"Every time you call one of the above functions, a new immutable Map is\\ncreated. If a pure function calls a number of these to produce a final\\nreturn value, then a penalty on performance and memory has been paid by\\ncreating all of the intermediate immutable Maps.\",\"description\":\"If you need to apply a series of mutations to produce a new immutable\\nMap, `withMutations()` creates a temporary mutable copy of the Map which\\ncan apply mutations in a highly performant manner. In fact, this is\\nexactly how complex mutations like `merge` are done.\\n\\nAs an example, this results in the creation of 2, not 4, new Maps:\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst map1 = Map()\\nconst map2 = map1.withMutations(map => {\\n  map.set('a', 1).set('b', 2).set('c', 3)\\n})\\nassert.equal(map1.size, 0)\\nassert.equal(map2.size, 3)\\n```\\n\\nNote: Not all methods can be used on a mutable collection or within\\n`withMutations`! Read the documentation for each method to see if it\\nis safe to use in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"mutator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"mutable\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":1270}]},\"#asMutable\":{\"doc\":{\"synopsis\":\"Another way to avoid creation of intermediate Immutable maps is to create\\na mutable copy of this collection. Mutable copies *always* return `this`,\\nand thus shouldn't be used for equality. Your function should never return\\na mutable copy of a collection, only use it internally to create a new\\ncollection.\",\"description\":\"If possible, use `withMutations` to work with temporary mutable copies as\\nit provides an easier to use API and considers many common optimizations.\\n\\nNote: if the collection is already mutable, `asMutable` returns itself.\\n\\nNote: Not all methods can be used on a mutable collection or within\\n`withMutations`! Read the documentation for each method to see if it\\nis safe to use in `withMutations`.\\n\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asImmutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":1290}]},\"#wasAltered\":{\"doc\":{\"synopsis\":\"Returns true if this is a mutable copy (see `asMutable()`) and mutative\\nalterations have been applied.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asMutable`\"}]},\"signatures\":[{\"type\":{\"k\":1},\"line\":1298}]},\"#asImmutable\":{\"doc\":{\"synopsis\":\"The yin to `asMutable`'s yang. Because it applies to mutable collections,\\nthis operation is *mutable* and may return itself (though may not\\nreturn itself, i.e. if the result is an empty collection). Once\\nperformed, the original mutable copy must no longer be mutated since it\\nmay be the immutable result.\",\"description\":\"If possible, use `withMutations` to work with temporary mutable copies as\\nit provides an easier to use API and considers many common optimizations.\\n\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asMutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":1312}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Map with values passed through a\\n`mapper` function.\",\"description\":\"    Map({ a: 1, b: 2 }).map(x => 10 * x)\\n    // Map { a: 10, b: 20 }\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"M\"}]},\"line\":1323}]},\"#mapKeys\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.mapKeys\"}]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"M\"},{\"k\":8,\"param\":\"V\"}]},\"line\":1331}]},\"#mapEntries\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.mapEntries\"}]},\"signatures\":[{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"entry\",\"type\":{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":1339}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Map, returning a new Map.\",\"description\":\"Similar to `data.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":1349}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Map with only the entries for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"F\"}]},\"line\":1361},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":1365}]},\"#flip\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.flip\"}]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"K\"}]},\"line\":1373}]}}}]}},\"OrderedMap\":{\"doc\":{\"synopsis\":\"A type of Map that has the additional guarantee that the iteration order of\\nentries will be the order in which they were set().\",\"description\":\"The iteration behavior of OrderedMap is the same as native ES6 Map and\\nJavaScript Object.\\n\\nNote that `OrderedMap` are more expensive than non-ordered `Map` and may\\nconsume more memory. `OrderedMap#set` is amortized O(log32 N), but not\\nstable.\",\"notes\":[]},\"module\":{\"isOrderedMap\":{\"call\":{\"doc\":{\"synopsis\":\"True if the provided value is an OrderedMap.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeOrderedMap\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":1394}]}}},\"call\":{\"doc\":{\"synopsis\":\"Creates a new Immutable OrderedMap.\",\"description\":\"Created with the same key value pairs as the provided Collection.Keyed or\\nJavaScript Object or expects a Collection of [K, V] tuple entries.\\n\\nThe iteration order of key-value pairs provided to this constructor will\\nbe preserved in the OrderedMap.\\n\\n    let newOrderedMap = OrderedMap({key: \\\"value\\\"})\\n    let newOrderedMap = OrderedMap([[\\\"key\\\", \\\"value\\\"]])\\n\\nNote: `OrderedMap` is a factory function and not a class, and does not use\\nthe `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\",\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]}}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":1412},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"obj\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":3},{\"k\":8,\"param\":\"V\"}]},\"line\":1413},{\"typeParams\":[\"K\",\"V\"],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":1414},{\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":17},{\"k\":17}]},\"line\":1415}]},\"interface\":{\"line\":1417,\"typeParams\":[\"K\",\"V\"],\"extends\":[{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}],\"groups\":[{\"members\":{\"#size\":{\"line\":1422},\"#set\":{\"doc\":{\"synopsis\":\"Returns a new OrderedMap also containing the new key, value pair. If an\\nequivalent key already exists in this OrderedMap, it will be replaced\\nwhile maintaining the existing order.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { OrderedMap } = require('immutable')\\nconst originalMap = OrderedMap({a:1, b:1, c:1})\\nconst updatedMap = originalMap.set('b', 2)\\n\\noriginalMap\\n// OrderedMap {a: 1, b: 1, c: 1}\\nupdatedMap\\n// OrderedMap {a: 1, b: 2, c: 1}\\n```\\n\\nNote: `set` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":10},\"line\":1443}]},\"#merge\":{\"doc\":{\"synopsis\":\"Returns a new OrderedMap resulting from merging the provided Collections\\n(or JS objects) into this OrderedMap. In other words, this takes each\\nentry of each collection and sets it on this OrderedMap.\",\"description\":\"Note: Values provided to `merge` are shallowly converted before being\\nmerged. No nested values are altered.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { OrderedMap } = require('immutable')\\nconst one = OrderedMap({ a: 10, b: 20, c: 30 })\\nconst two = OrderedMap({ b: 40, a: 50, d: 60 })\\none.merge(two) // OrderedMap { \\\"a\\\": 50, \\\"b\\\": 40, \\\"c\\\": 30, \\\"d\\\": 60 }\\ntwo.merge(one) // OrderedMap { \\\"b\\\": 20, \\\"a\\\": 10, \\\"d\\\": 60, \\\"c\\\": 30 }\\n```\\n\\nNote: `merge` can be used in `withMutations`.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"concat\"}]},\"signatures\":[{\"typeParams\":[\"KC\",\"VC\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KC\"},{\"k\":8,\"param\":\"VC\"}]}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"KC\"}]},{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"VC\"}]}]},\"line\":1466},{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"C\"}}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":3}]},{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":1467}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#map\":{\"doc\":{\"synopsis\":\"Returns a new OrderedMap with values passed through a\\n`mapper` function.\",\"description\":\"    OrderedMap({ a: 1, b: 2 }).map(x => 10 * x)\\n    // OrderedMap { \\\"a\\\": 10, \\\"b\\\": 20 }\\n\\nNote: `map()` always returns a new instance, even if it produced the same\\nvalue at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"M\"}]},\"line\":1483}]},\"#mapKeys\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.mapKeys\"}]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"M\"},{\"k\":8,\"param\":\"V\"}]},\"line\":1491}]},\"#mapEntries\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.mapEntries\"}]},\"signatures\":[{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"entry\",\"type\":{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":1499}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the OrderedMap, returning a new OrderedMap.\",\"description\":\"Similar to `data.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":1509}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new OrderedMap with only the entries for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"F\"}]},\"line\":1521},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":1525}]},\"#flip\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.flip\"}]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"K\"}]},\"line\":1533}]}}}]}},\"Set\":{\"doc\":{\"synopsis\":\"A Collection of unique values with `O(log32 N)` adds and has.\",\"description\":\"When iterating a Set, the entries will be (value, value) pairs. Iteration\\norder of a Set is undefined, however is stable. Multiple iterations of the\\nsame Set will iterate in the same order.\\n\\nSet values, like Map keys, may be of any type. Equality is determined using\\n`Immutable.is`, enabling Sets to uniquely include other Immutable\\ncollections, custom value types, and NaN.\",\"notes\":[]},\"module\":{\"isSet\":{\"call\":{\"doc\":{\"synopsis\":\"True if the provided value is a Set\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeSet\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":1553}]}},\"of\":{\"call\":{\"doc\":{\"synopsis\":\"Creates a new Set containing `values`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1558}]}},\"fromKeys\":{\"call\":{\"doc\":{\"synopsis\":\"`Set.fromKeys()` creates a new immutable Set containing the keys from\\nthis Collection or JavaScript Object.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"iter\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"T\"},{\"k\":17}]}}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1564},{\"params\":[{\"name\":\"obj\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":17}}]}}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":3}]},\"line\":1565}]}},\"intersect\":{\"call\":{\"doc\":{\"synopsis\":\"`Set.intersect()` creates a new immutable Set that is the intersection of\\na collection of other sets.\",\"description\":\"```js\\nconst { Set } = require('immutable')\\nconst intersected = Set.intersect([\\n  Set([ 'a', 'b', 'c' ])\\n  Set([ 'c', 'a', 't' ])\\n])\\n// Set [ \\\"a\\\", \\\"c\\\" ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"sets\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}]}}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1580}]}},\"union\":{\"call\":{\"doc\":{\"synopsis\":\"`Set.union()` creates a new immutable Set that is the union of a\\ncollection of other sets.\",\"description\":\"```js\\nconst { Set } = require('immutable')\\nconst unioned = Set.union([\\n  Set([ 'a', 'b', 'c' ])\\n  Set([ 'c', 'a', 't' ])\\n])\\n// Set [ \\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"t\\\" ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"sets\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}]}}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1595}]}}},\"call\":{\"doc\":{\"synopsis\":\"Create a new immutable Set containing the values of the provided\\ncollection-like.\",\"description\":\"Note: `Set` is a factory function and not a class, and does not use the\\n`new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1605},{\"typeParams\":[\"T\"],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1606},{\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":17}]},\"line\":1607}]},\"interface\":{\"line\":1609,\"typeParams\":[\"T\"],\"extends\":[{\"k\":9,\"name\":\"Collection.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]}],\"groups\":[{\"members\":{\"#size\":{\"line\":1614}}},{\"title\":\"Persistent changes\",\"members\":{\"#add\":{\"doc\":{\"synopsis\":\"Returns a new Set which also includes this value.\",\"description\":\"Note: `add` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":10},\"line\":1623}]},\"#delete\":{\"doc\":{\"synopsis\":\"Returns a new Set which excludes this value.\",\"description\":\"Note: `delete` can be used in `withMutations`.\\n\\nNote: `delete` **cannot** be safely used in IE8, use `remove` if\\nsupporting old browsers.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"remove\"}]},\"signatures\":[{\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":10},\"line\":1635}]},\"#clear\":{\"doc\":{\"synopsis\":\"Returns a new Set containing no values.\",\"description\":\"Note: `clear` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":1643}]},\"#union\":{\"doc\":{\"synopsis\":\"Returns a Set including any value from `collections` that does not already\\nexist in this Set.\",\"description\":\"Note: `union` can be used in `withMutations`.\",\"notes\":[{\"name\":\"alias\",\"body\":\"merge\"},{\"name\":\"alias\",\"body\":\"concat\"}]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"C\"}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":1653}]},\"#intersect\":{\"doc\":{\"synopsis\":\"Returns a Set which has removed any values not also contained\\nwithin `collections`.\",\"description\":\"Note: `intersect` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":1663}]},\"#subtract\":{\"doc\":{\"synopsis\":\"Returns a Set excluding any values contained within `collections`.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { OrderedSet } = require('immutable')\\nOrderedSet([ 1, 2, 3 ]).subtract([1, 3])\\n// OrderedSet [2]\\n```\\n\\nNote: `subtract` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":1677}]}}},{\"title\":\"Transient changes\",\"members\":{\"#withMutations\":{\"doc\":{\"synopsis\":\"Note: Not all methods can be used on a mutable collection or within\\n`withMutations`! Check the documentation for each method to see if it\\nmentions being safe to use in `withMutations`.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#withMutations`\"}]},\"signatures\":[{\"params\":[{\"name\":\"mutator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"mutable\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":1689}]},\"#asMutable\":{\"doc\":{\"synopsis\":\"Note: Not all methods can be used on a mutable collection or within\\n`withMutations`! Check the documentation for each method to see if it\\nmentions being safe to use in `withMutations`.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asMutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":1698}]},\"#wasAltered\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#wasAltered`\"}]},\"signatures\":[{\"type\":{\"k\":1},\"line\":1703}]},\"#asImmutable\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asImmutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":1708}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Set with values passed through a\\n`mapper` function.\",\"description\":\"    Set([1,2]).map(x => 10 * x)\\n    // Set [10,20]\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":1719}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Set, returning a new Set.\",\"description\":\"Similar to `set.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":1729}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Set with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"F\"}]},\"line\":1741},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":1745}]}}}]}},\"OrderedSet\":{\"doc\":{\"synopsis\":\"A type of Set that has the additional guarantee that the iteration order of\\nvalues will be the order in which they were `add`ed.\",\"description\":\"The iteration behavior of OrderedSet is the same as native ES6 Set.\\n\\nNote that `OrderedSet` are more expensive than non-ordered `Set` and may\\nconsume more memory. `OrderedSet#add` is amortized O(log32 N), but not\\nstable.\",\"notes\":[]},\"module\":{\"isOrderedSet\":{\"call\":{\"doc\":{\"synopsis\":\"True if the provided value is an OrderedSet.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeOrderedSet\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":1767}]}},\"of\":{\"call\":{\"doc\":{\"synopsis\":\"Creates a new OrderedSet containing `values`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1772}]}},\"fromKeys\":{\"call\":{\"doc\":{\"synopsis\":\"`OrderedSet.fromKeys()` creates a new immutable OrderedSet containing\\nthe keys from this Collection or JavaScript Object.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"iter\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"T\"},{\"k\":17}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1778},{\"params\":[{\"name\":\"obj\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":17}}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":3}]},\"line\":1779}]}}},\"call\":{\"doc\":{\"synopsis\":\"Create a new immutable OrderedSet containing the values of the provided\\ncollection-like.\",\"description\":\"Note: `OrderedSet` is a factory function and not a class, and does not use\\nthe `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1789},{\"typeParams\":[\"T\"],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1790},{\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":17}]},\"line\":1791}]},\"interface\":{\"line\":1793,\"typeParams\":[\"T\"],\"extends\":[{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]}],\"groups\":[{\"members\":{\"#size\":{\"line\":1798},\"#union\":{\"doc\":{\"synopsis\":\"Returns an OrderedSet including any value from `collections` that does\\nnot already exist in this OrderedSet.\",\"description\":\"Note: `union` can be used in `withMutations`.\",\"notes\":[{\"name\":\"alias\",\"body\":\"merge\"},{\"name\":\"alias\",\"body\":\"concat\"}]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"C\"}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":1808}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Set with values passed through a\\n`mapper` function.\",\"description\":\"    OrderedSet([ 1, 2 ]).map(x => 10 * x)\\n    // OrderedSet [10, 20]\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":1821}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the OrderedSet, returning a new OrderedSet.\",\"description\":\"Similar to `set.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":1831}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new OrderedSet with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"F\"}]},\"line\":1843},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":1847}]},\"#zip\":{\"doc\":{\"synopsis\":\"Returns an OrderedSet of the same type \\\"zipped\\\" with the provided\\ncollections.\",\"description\":\"Like `zipWith`, but using the default `zipper`: creating an `Array`.\\n\\n```js\\nconst a = OrderedSet([ 1, 2, 3 ])\\nconst b = OrderedSet([ 4, 5, 6 ])\\nconst c = a.zip(b)\\n// OrderedSet [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":1865},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other1\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":1866},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":17}]},\"line\":1867}]},\"#zipAll\":{\"doc\":{\"synopsis\":\"Returns a OrderedSet of the same type \\\"zipped\\\" with the provided\\ncollections.\",\"description\":\"Unlike `zip`, `zipAll` continues zipping until the longest collection is\\nexhausted. Missing values from shorter collections are filled with `undefined`.\\n\\n```js\\nconst a = OrderedSet([ 1, 2 ]);\\nconst b = OrderedSet([ 3, 4, 5 ]);\\nconst c = a.zipAll(b); // OrderedSet [ [ 1, 3 ], [ 2, 4 ], [ undefined, 5 ] ]\\n```\\n\\nNote: Since zipAll will return a collection as large as the largest\\ninput, some results may contain undefined values. TypeScript cannot\\naccount for these without cases (as of v2.5).\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":1886},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other1\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":1887},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":17}]},\"line\":1888}]},\"#zipWith\":{\"doc\":{\"synopsis\":\"Returns an OrderedSet of the same type \\\"zipped\\\" with the provided\\ncollections by using a custom `zipper` function.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Seq.Indexed.zipWith\"}]},\"signatures\":[{\"typeParams\":[\"U\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":1896},{\"typeParams\":[\"U\",\"V\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}},{\"name\":\"thirdValue\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"thirdCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":1900},{\"typeParams\":[\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"any\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":1905}]}}}]}},\"Stack\":{\"doc\":{\"synopsis\":\"Stacks are indexed collections which support very efficient O(1) addition\\nand removal from the front using `unshift(v)` and `shift()`.\",\"description\":\"For familiarity, Stack also provides `push(v)`, `pop()`, and `peek()`, but\\nbe aware that they also operate on the front of the list, unlike List or\\na JavaScript Array.\\n\\nNote: `reverse()` or any inherent reverse traversal (`reduceRight`,\\n`lastIndexOf`, etc.) is not efficient with a Stack.\\n\\nStack is implemented with a Single-Linked List.\",\"notes\":[]},\"module\":{\"isStack\":{\"call\":{\"doc\":{\"synopsis\":\"True if the provided value is a Stack\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeStack\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":1931}]}},\"of\":{\"call\":{\"doc\":{\"synopsis\":\"Creates a new Stack containing `values`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1936}]}}},\"call\":{\"doc\":{\"synopsis\":\"Create a new immutable Stack containing the values of the provided\\ncollection-like.\",\"description\":\"The iteration order of the provided collection is preserved in the\\nresulting `Stack`.\\n\\nNote: `Stack` is a factory function and not a class, and does not use the\\n`new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1949},{\"typeParams\":[\"T\"],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1950},{\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":17}]},\"line\":1951}]},\"interface\":{\"line\":1953,\"typeParams\":[\"T\"],\"extends\":[{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]}],\"groups\":[{\"members\":{\"#size\":{\"line\":1958}}},{\"title\":\"Reading values\",\"members\":{\"#peek\":{\"doc\":{\"synopsis\":\"Alias for `Stack.first()`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":11}]},\"line\":1965}]}}},{\"title\":\"Persistent changes\",\"members\":{\"#clear\":{\"doc\":{\"synopsis\":\"Returns a new Stack with 0 size and no values.\",\"description\":\"Note: `clear` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1975}]},\"#unshift\":{\"doc\":{\"synopsis\":\"Returns a new Stack with the provided `values` prepended, shifting other\\nvalues ahead to higher indices.\",\"description\":\"This is very efficient for Stack.\\n\\nNote: `unshift` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1985}]},\"#unshiftAll\":{\"doc\":{\"synopsis\":\"Like `Stack#unshift`, but accepts a collection rather than varargs.\",\"description\":\"Note: `unshiftAll` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"iter\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1992}]},\"#shift\":{\"doc\":{\"synopsis\":\"Returns a new Stack with a size ones less than this Stack, excluding\\nthe first item in this Stack, shifting all other values to a lower index.\",\"description\":\"Note: this differs from `Array#shift` because it returns a new\\nStack rather than the removed value. Use `first()` or `peek()` to get the\\nfirst value in this Stack.\\n\\nNote: `shift` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2004}]},\"#push\":{\"doc\":{\"synopsis\":\"Alias for `Stack#unshift` and is not equivalent to `List#push`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2009}]},\"#pushAll\":{\"doc\":{\"synopsis\":\"Alias for `Stack#unshiftAll`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"iter\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2014}]},\"#pop\":{\"doc\":{\"synopsis\":\"Alias for `Stack#shift` and is not equivalent to `List#pop`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2019}]}}},{\"title\":\"Transient changes\",\"members\":{\"#withMutations\":{\"doc\":{\"synopsis\":\"Note: Not all methods can be used on a mutable collection or within\\n`withMutations`! Check the documentation for each method to see if it\\nmentions being safe to use in `withMutations`.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#withMutations`\"}]},\"signatures\":[{\"params\":[{\"name\":\"mutator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"mutable\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":2031}]},\"#asMutable\":{\"doc\":{\"synopsis\":\"Note: Not all methods can be used on a mutable collection or within\\n`withMutations`! Check the documentation for each method to see if it\\nmentions being safe to use in `withMutations`.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asMutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":2040}]},\"#wasAltered\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#wasAltered`\"}]},\"signatures\":[{\"type\":{\"k\":1},\"line\":2045}]},\"#asImmutable\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asImmutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":2050}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new Stack with other collections concatenated to this one.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"valuesOrCollections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"C\"}]},{\"k\":8,\"param\":\"C\"}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":2057}]},\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Stack with values passed through a\\n`mapper` function.\",\"description\":\"    Stack([ 1, 2 ]).map(x => 10 * x)\\n    // Stack [ 10, 20 ]\\n\\nNote: `map()` always returns a new instance, even if it produced the same\\nvalue at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":2069}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Stack, returning a new Stack.\",\"description\":\"Similar to `stack.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":2079}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Set with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"F\"}]},\"line\":2091},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":2095}]},\"#zip\":{\"doc\":{\"synopsis\":\"Returns a Stack \\\"zipped\\\" with the provided collections.\",\"description\":\"Like `zipWith`, but using the default `zipper`: creating an `Array`.\\n\\n```js\\nconst a = Stack([ 1, 2, 3 ]);\\nconst b = Stack([ 4, 5, 6 ]);\\nconst c = a.zip(b); // Stack [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":2111},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":2112},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":17}]},\"line\":2113}]},\"#zipAll\":{\"doc\":{\"synopsis\":\"Returns a Stack \\\"zipped\\\" with the provided collections.\",\"description\":\"Unlike `zip`, `zipAll` continues zipping until the longest collection is\\nexhausted. Missing values from shorter collections are filled with `undefined`.\\n\\n```js\\nconst a = Stack([ 1, 2 ]);\\nconst b = Stack([ 3, 4, 5 ]);\\nconst c = a.zipAll(b); // Stack [ [ 1, 3 ], [ 2, 4 ], [ undefined, 5 ] ]\\n```\\n\\nNote: Since zipAll will return a collection as large as the largest\\ninput, some results may contain undefined values. TypeScript cannot\\naccount for these without cases (as of v2.5).\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":2131},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":2132},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":17}]},\"line\":2133}]},\"#zipWith\":{\"doc\":{\"synopsis\":\"Returns a Stack \\\"zipped\\\" with the provided collections by using a\\ncustom `zipper` function.\",\"description\":\"```js\\nconst a = Stack([ 1, 2, 3 ]);\\nconst b = Stack([ 4, 5, 6 ]);\\nconst c = a.zipWith((a, b) => a + b, b);\\n// Stack [ 5, 7, 9 ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":2146},{\"typeParams\":[\"U\",\"V\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}},{\"name\":\"thirdValue\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"thirdCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":2150},{\"typeParams\":[\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"any\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":2155}]}}}]}},\"Range\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a Seq.Indexed of numbers from `start` (inclusive) to `end`\\n(exclusive), by `step`, where `start` defaults to 0, `step` to 1, and `end` to\\ninfinity. When `start` is equal to `end`, returns empty range.\",\"description\":\"Note: `Range` is a factory function and not a class, and does not use the\\n`new` keyword during construction.\\n\\n```js\\nconst { Range } = require('immutable')\\nRange() // [ 0, 1, 2, 3, ... ]\\nRange(10) // [ 10, 11, 12, 13, ... ]\\nRange(10, 15) // [ 10, 11, 12, 13, 14 ]\\nRange(10, 30, 5) // [ 10, 15, 20, 25 ]\\nRange(30, 10, 5) // [ 30, 25, 20, 15 ]\\nRange(30, 30, 5) // []\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"start\",\"type\":{\"k\":2},\"optional\":true},{\"name\":\"end\",\"type\":{\"k\":2},\"optional\":true},{\"name\":\"step\",\"type\":{\"k\":2},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":2}]},\"line\":2180}]}},\"Repeat\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a Seq.Indexed of `value` repeated `times` times. When `times` is\\nnot defined, returns an infinite `Seq` of `value`.\",\"description\":\"Note: `Repeat` is a factory function and not a class, and does not use the\\n`new` keyword during construction.\\n\\n```js\\nconst { Repeat } = require('immutable')\\nRepeat('foo') // [ 'foo', 'foo', 'foo', ... ]\\nRepeat('bar', 4) // [ 'bar', 'bar', 'bar', 'bar' ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"times\",\"type\":{\"k\":2},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2196}]}},\"Record\":{\"doc\":{\"synopsis\":\"A record is similar to a JS object, but enforces a specific set of allowed\\nstring keys, and has default values.\",\"description\":\"The `Record()` function produces new Record Factories, which when called\\ncreate Record instances.\\n\\n```js\\nconst { Record } = require('immutable')\\nconst ABRecord = Record({ a: 1, b: 2 })\\nconst myRecord = ABRecord({ b: 3 })\\n```\\n\\nRecords always have a value for the keys they define. `remove`ing a key\\nfrom a record simply resets it to the default value for that key.\\n\\n```js\\nmyRecord.size // 2\\nmyRecord.get('a') // 1\\nmyRecord.get('b') // 3\\nconst myRecordWithoutB = myRecord.remove('b')\\nmyRecordWithoutB.get('b') // 2\\nmyRecordWithoutB.size // 2\\n```\\n\\nValues provided to the constructor not found in the Record type will\\nbe ignored. For example, in this case, ABRecord is provided a key \\\"x\\\" even\\nthough only \\\"a\\\" and \\\"b\\\" have been defined. The value for \\\"x\\\" will be\\nignored for this record.\\n\\n```js\\nconst myRecord = ABRecord({ b: 3, x: 10 })\\nmyRecord.get('x') // undefined\\n```\\n\\nBecause Records have a known set of string keys, property get access works\\nas expected, however property sets will throw an Error.\\n\\nNote: IE8 does not support property access. Only use `get()` when\\nsupporting IE8.\\n\\n```js\\nmyRecord.b // 3\\nmyRecord.b = 5 // throws Error\\n```\\n\\nRecord Types can be extended as well, allowing for custom methods on your\\nRecord. This is not a common pattern in functional environments, but is in\\nmany JS programs.\\n\\nHowever Record Types are more restricted than typical JavaScript classes.\\nThey do not use a class constructor, which also means they cannot use\\nclass properties (since those are technically part of a constructor).\\n\\nWhile Record Types can be syntactically created with the JavaScript `class`\\nform, the resulting Record function is actually a factory function, not a\\nclass constructor. Even though Record Types are not classes, JavaScript\\ncurrently requires the use of `new` when creating new Record instances if\\nthey are defined as a `class`.\\n\\n```\\nclass ABRecord extends Record({ a: 1, b: 2 }) {\\n  getAB() {\\n    return this.a + this.b;\\n  }\\n}\\n\\nvar myRecord = new ABRecord({b: 3})\\nmyRecord.getAB() // 4\\n```\\n\\n\\n**Flow Typing Records:**\\n\\nImmutable.js exports two Flow types designed to make it easier to use\\nRecords with flow typed code, `RecordOf<TProps>` and `RecordFactory<TProps>`.\\n\\nWhen defining a new kind of Record factory function, use a flow type that\\ndescribes the values the record contains along with `RecordFactory<TProps>`.\\nTo type instances of the Record (which the factory function returns),\\nuse `RecordOf<TProps>`.\\n\\nTypically, new Record definitions will export both the Record factory\\nfunction as well as the Record instance type for use in other code.\\n\\n```js\\nimport type { RecordFactory, RecordOf } from 'immutable';\\n\\n// Use RecordFactory<TProps> for defining new Record factory functions.\\ntype Point3DProps = { x: number, y: number, z: number };\\nconst defaultValues: Point3DProps = { x: 0, y: 0, z: 0 };\\nconst makePoint3D: RecordFactory<Point3DProps> = Record(defaultValues);\\nexport makePoint3D;\\n\\n// Use RecordOf<T> for defining new instances of that Record.\\nexport type Point3D = RecordOf<Point3DProps>;\\nconst some3DPoint: Point3D = makePoint3D({ x: 10, y: 20, z: 30 });\\n```\\n\\n**Flow Typing Record Subclasses:**\\n\\nRecords can be subclassed as a means to add additional methods to Record\\ninstances. This is generally discouraged in favor of a more functional API,\\nsince Subclasses have some minor overhead. However the ability to create\\na rich API on Record types can be quite valuable.\\n\\nWhen using Flow to type Subclasses, do not use `RecordFactory<TProps>`,\\ninstead apply the props type when subclassing:\\n\\n```js\\ntype PersonProps = {name: string, age: number};\\nconst defaultValues: PersonProps = {name: 'Aristotle', age: 2400};\\nconst PersonRecord = Record(defaultValues);\\nclass Person extends PersonRecord<PersonProps> {\\n  getName(): string {\\n    return this.get('name')\\n  }\\n\\n  setName(name: string): this {\\n    return this.set('name', name);\\n  }\\n}\\n```\\n\\n**Choosing Records vs plain JavaScript objects**\\n\\nRecords offer a persistently immutable alternative to plain JavaScript\\nobjects, however they're not required to be used within Immutable.js\\ncollections. In fact, the deep-access and deep-updating functions\\nlike `getIn()` and `setIn()` work with plain JavaScript Objects as well.\\n\\nDeciding to use Records or Objects in your application should be informed\\nby the tradeoffs and relative benefits of each:\\n\\n- *Runtime immutability*: plain JS objects may be carefully treated as\\n  immutable, however Record instances will *throw* if attempted to be\\n  mutated directly. Records provide this additional guarantee, however at\\n  some marginal runtime cost. While JS objects are mutable by nature, the\\n  use of type-checking tools like [Flow](https://medium.com/@gcanti/immutability-with-flow-faa050a1aef4)\\n  can help gain confidence in code written to favor immutability.\\n\\n- *Value equality*: Records use value equality when compared with `is()`\\n  or `record.equals()`. That is, two Records with the same keys and values\\n  are equal. Plain objects use *reference equality*. Two objects with the\\n  same keys and values are not equal since they are different objects.\\n  This is important to consider when using objects as keys in a `Map` or\\n  values in a `Set`, which use equality when retrieving values.\\n\\n- *API methods*: Records have a full featured API, with methods like\\n  `.getIn()`, and `.equals()`. These can make working with these values\\n  easier, but comes at the cost of not allowing keys with those names.\\n\\n- *Default values*: Records provide default values for every key, which\\n  can be useful when constructing Records with often unchanging values.\\n  However default values can make using Flow and TypeScript more laborious.\\n\\n- *Serialization*: Records use a custom internal representation to\\n  efficiently store and update their values. Converting to and from this\\n  form isn't free. If converting Records to plain objects is common,\\n  consider sticking with plain objects to begin with.\",\"notes\":[]},\"module\":{\"isRecord\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeRecord` is an instance of a Record.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeRecord\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":2365}]}},\"getDescriptiveName\":{\"call\":{\"doc\":{\"synopsis\":\"Records allow passing a second parameter to supply a descriptive name\\nthat appears when converting a Record to a string or in any error\\nmessages. A descriptive name for any record can be accessed by using this\\nmethod. If one was not provided, the string \\\"Record\\\" is returned.\",\"description\":\"```js\\nconst { Record } = require('immutable')\\nconst Person = Record({\\n  name: null\\n}, 'Person')\\n\\nvar me = Person({ name: 'My Name' })\\nme.toString() // \\\"Person { \\\"name\\\": \\\"My Name\\\" }\\\"\\nRecord.getDescriptiveName(me) // \\\"Person\\\"\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"record\",\"type\":{\"k\":9,\"name\":\"Record\",\"args\":[{\"k\":0}]}}],\"type\":{\"k\":3},\"line\":2384}]}},\"Factory\":{\"doc\":{\"synopsis\":\"A Record.Factory is created by the `Record()` function. Record instances\\nare created by passing it some of the accepted values for that Record\\ntype:\",\"description\":\"<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Record } = require('immutable')\\\" }\\n-->\\n```js\\n// makePerson is a Record Factory function\\nconst makePerson = Record({ name: null, favoriteColor: 'unknown' });\\n\\n// alan is a Record instance\\nconst alan = makePerson({ name: 'Alan' });\\n```\\n\\nNote that Record Factories return `Record<TProps> & Readonly<TProps>`,\\nthis allows use of both the Record instance API, and direct property\\naccess on the resulting instances:\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Record } = require('immutable');const makePerson = Record({ name: null, favoriteColor: 'unknown' });const alan = makePerson({ name: 'Alan' });\\\" }\\n-->\\n```js\\n// Use the Record API\\nconsole.log('Record API: ' + alan.get('name'))\\n\\n// Or direct property access (Readonly)\\nconsole.log('property access: ' + alan.name)\\n```\\n\\n**Flow Typing Records:**\\n\\nUse the `RecordFactory<TProps>` Flow type to get high quality type checking of\\nRecords:\\n\\n```js\\nimport type { RecordFactory, RecordOf } from 'immutable';\\n\\n// Use RecordFactory<TProps> for defining new Record factory functions.\\ntype PersonProps = { name: ?string, favoriteColor: string };\\nconst makePerson: RecordFactory<PersonProps> = Record({ name: null, favoriteColor: 'unknown' });\\n\\n// Use RecordOf<T> for defining new instances of that Record.\\ntype Person = RecordOf<PersonProps>;\\nconst alan: Person = makePerson({ name: 'Alan' });\\n```\",\"notes\":[]},\"module\":{},\"interface\":{\"line\":2436,\"typeParams\":[\"TProps\"],\"groups\":[{\"members\":{\"#displayName\":{\"line\":2444}}}]},\"call\":{\"signatures\":[{\"typeParams\":[\"TProps\"],\"params\":[{\"name\":\"values\",\"type\":{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Partial\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":3},{\"k\":17}]}]}]},\"optional\":true}],\"type\":{\"k\":13,\"types\":[{\"k\":9,\"name\":\"Record\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]},{\"k\":9,\"name\":\"Readonly\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]}]},\"line\":2447}]}}},\"call\":{\"doc\":{\"synopsis\":\"Unlike other types in Immutable.js, the `Record()` function creates a new\\nRecord Factory, which is a function that creates Record instances.\",\"description\":\"See above for examples of using `Record()`.\\n\\nNote: `Record` is a factory function and not a class, and does not use the\\n`new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"TProps\"],\"params\":[{\"name\":\"defaultValues\",\"type\":{\"k\":8,\"param\":\"TProps\"}},{\"name\":\"name\",\"type\":{\"k\":3},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Record.Factory\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]},\"line\":2459}]},\"interface\":{\"line\":2461,\"typeParams\":[\"TProps\"],\"groups\":[{\"title\":\"Reading values\",\"members\":{\"#has\":{\"signatures\":[{\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":1},\"line\":2465}]},\"#get\":{\"doc\":{\"synopsis\":\"Returns the value associated with the provided key, which may be the\\ndefault value defined when creating the Record factory function.\",\"description\":\"If the requested key is not defined by this Record type, then\\nnotSetValue will be returned if provided. Note that this scenario would\\nproduce an error when using Flow or TypeScript.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\"],\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}},\"line\":2475},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":8,\"param\":\"T\"},\"line\":2476}]}}},{\"title\":\"Reading deep values\",\"members\":{\"#hasIn\":{\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}}],\"type\":{\"k\":1},\"line\":2480}]},\"#getIn\":{\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}}],\"type\":{\"k\":17},\"line\":2481}]}}},{\"title\":\"Value equality\",\"members\":{\"#equals\":{\"signatures\":[{\"params\":[{\"name\":\"other\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":2485}]},\"#hashCode\":{\"signatures\":[{\"type\":{\"k\":2},\"line\":2486}]}}},{\"title\":\"Persistent changes\",\"members\":{\"#set\":{\"signatures\":[{\"typeParams\":[\"K\"],\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}}}],\"type\":{\"k\":10},\"line\":2490}]},\"#update\":{\"signatures\":[{\"typeParams\":[\"K\"],\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}}}],\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}}}}],\"type\":{\"k\":10},\"line\":2491}]},\"#merge\":{\"signatures\":[{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Partial\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":3},{\"k\":17}]}]}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":2492}]},\"#mergeDeep\":{\"signatures\":[{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Partial\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":3},{\"k\":17}]}]}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":2493}]},\"#mergeWith\":{\"signatures\":[{\"params\":[{\"name\":\"merger\",\"type\":{\"k\":7,\"params\":[{\"name\":\"oldVal\",\"type\":{\"k\":17}},{\"name\":\"newVal\",\"type\":{\"k\":17}},{\"name\":\"key\",\"type\":{\"k\":16,\"operator\":\"keyof\",\"type\":{\"k\":8,\"param\":\"TProps\"}}}],\"type\":{\"k\":17}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Partial\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":3},{\"k\":17}]}]}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":2495}]},\"#mergeDeepWith\":{\"signatures\":[{\"params\":[{\"name\":\"merger\",\"type\":{\"k\":7,\"params\":[{\"name\":\"oldVal\",\"type\":{\"k\":17}},{\"name\":\"newVal\",\"type\":{\"k\":17}},{\"name\":\"key\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Partial\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":3},{\"k\":17}]}]}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":2499}]},\"#delete\":{\"doc\":{\"synopsis\":\"Returns a new instance of this Record type with the value for the\\nspecific key set to its default value.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"alias\",\"body\":\"remove\"}]},\"signatures\":[{\"typeParams\":[\"K\"],\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":10},\"line\":2510}]},\"#clear\":{\"doc\":{\"synopsis\":\"Returns a new instance of this Record type with all values set\\nto their default values.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":2517}]}}},{\"title\":\"Deep persistent changes\",\"members\":{\"#setIn\":{\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":10},\"line\":2521}]},\"#updateIn\":{\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":2522}]},\"#mergeIn\":{\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":2523}]},\"#mergeDeepIn\":{\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":2524}]},\"#deleteIn\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"alias\",\"body\":\"removeIn\"}]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}}],\"type\":{\"k\":10},\"line\":2529}]}}},{\"title\":\"Conversion to JavaScript types\",\"members\":{\"#toJS\":{\"doc\":{\"synopsis\":\"Deeply converts this Record to equivalent native JavaScript Object.\",\"description\":\"Note: This method may not be overridden. Objects with custom\\nserialization to plain JS may override toJSON() instead.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":17}}]},\"line\":2540}]},\"#toJSON\":{\"doc\":{\"synopsis\":\"Shallowly converts this Record to equivalent native JavaScript Object.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":8,\"param\":\"TProps\"},\"line\":2545}]},\"#toObject\":{\"doc\":{\"synopsis\":\"Shallowly converts this Record to equivalent JavaScript Object.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":8,\"param\":\"TProps\"},\"line\":2550}]}}},{\"title\":\"Transient changes\",\"members\":{\"#withMutations\":{\"doc\":{\"synopsis\":\"Note: Not all methods can be used on a mutable collection or within\\n`withMutations`! Only `set` may be used mutatively.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#withMutations`\"}]},\"signatures\":[{\"params\":[{\"name\":\"mutator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"mutable\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":2560}]},\"#asMutable\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asMutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":2565}]},\"#wasAltered\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#wasAltered`\"}]},\"signatures\":[{\"type\":{\"k\":1},\"line\":2570}]},\"#asImmutable\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asImmutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":2575}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#toSeq\":{\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":16,\"operator\":\"keyof\",\"type\":{\"k\":8,\"param\":\"TProps\"}},{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":16,\"operator\":\"keyof\",\"type\":{\"k\":8,\"param\":\"TProps\"}}}]},\"line\":2579}]},\"#[Symbol.iterator]\":{\"signatures\":[{\"type\":{\"k\":9,\"name\":\"IterableIterator\",\"args\":[{\"k\":14,\"types\":[{\"k\":16,\"operator\":\"keyof\",\"type\":{\"k\":8,\"param\":\"TProps\"}},{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":16,\"operator\":\"keyof\",\"type\":{\"k\":8,\"param\":\"TProps\"}}}]}]},\"line\":2581}]}}}]}},\"Seq\":{\"doc\":{\"synopsis\":\"`Seq` describes a lazy operation, allowing them to efficiently chain\\nuse of all the higher-order collection methods (such as `map` and `filter`)\\nby not creating intermediate collections.\",\"description\":\"**Seq is immutable**  Once a Seq is created, it cannot be\\nchanged, appended to, rearranged or otherwise modified. Instead, any\\nmutative method called on a `Seq` will return a new `Seq`.\\n\\n**Seq is lazy**  `Seq` does as little work as necessary to respond to any\\nmethod call. Values are often created during iteration, including implicit\\niteration when reducing or converting to a concrete data structure such as\\na `List` or JavaScript `Array`.\\n\\nFor example, the following performs no work, because the resulting\\n`Seq`'s values are never iterated:\\n\\n```js\\nconst { Seq } = require('immutable')\\nconst oddSquares = Seq([ 1, 2, 3, 4, 5, 6, 7, 8 ])\\n  .filter(x => x % 2 !== 0)\\n  .map(x => x * x)\\n```\\n\\nOnce the `Seq` is used, it performs only the work necessary. In this\\nexample, no intermediate arrays are ever created, filter is called three\\ntimes, and map is only called once:\\n\\n```js\\noddSquares.get(1); // 9\\n```\\n\\nAny collection can be converted to a lazy Seq with `Seq()`.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst map = Map({ a: 1, b: 2, c: 3 })\\nconst lazySeq = Seq(map)\\n```\\n\\n`Seq` allows for the efficient chaining of operations, allowing for the\\nexpression of logic that can otherwise be very tedious:\\n\\n```js\\nlazySeq\\n  .flip()\\n  .map(key => key.toUpperCase())\\n  .flip()\\n// Seq { A: 1, B: 1, C: 1 }\\n```\\n\\nAs well as expressing logic that would otherwise seem memory or time\\nlimited, for example `Range` is a special kind of Lazy sequence.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Range } = require('immutable')\\nRange(1, Infinity)\\n  .skip(1000)\\n  .map(n => -n)\\n  .filter(n => n % 2 === 0)\\n  .take(2)\\n  .reduce((r, n) => r * n, 1)\\n// 1006008\\n```\\n\\nSeq is often used to provide a rich collection API to JavaScript Object.\\n\\n```js\\nSeq({ x: 0, y: 1, z: 2 }).map(v => v * 2).toObject();\\n// { x: 0, y: 2, z: 4 }\\n```\",\"notes\":[]},\"module\":{\"isSeq\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeSeq` is a Seq, it is not backed by a concrete\\nstructure such as Map, List, or Set.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeSeq\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":2673}]}},\"Keyed\":{\"doc\":{\"synopsis\":\"`Seq` which represents key-value pairs.\",\"description\":\"\",\"notes\":[]},\"module\":{},\"call\":{\"doc\":{\"synopsis\":\"Always returns a Seq.Keyed, if input is not keyed, expects an\\ncollection of [K, V] tuples.\",\"description\":\"Note: `Seq.Keyed` is a conversion function and not a class, and does not\\nuse the `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\",\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":2688},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"obj\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":3},{\"k\":8,\"param\":\"V\"}]},\"line\":2689},{\"typeParams\":[\"K\",\"V\"],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":2690},{\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":17},{\"k\":17}]},\"line\":2691}]},\"interface\":{\"line\":2693,\"typeParams\":[\"K\",\"V\"],\"extends\":[{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}],\"groups\":[{\"members\":{\"#toJS\":{\"doc\":{\"synopsis\":\"Deeply converts this Keyed Seq to equivalent native JavaScript Object.\",\"description\":\"Converts keys to Strings.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":17}}]},\"line\":2699}]},\"#toJSON\":{\"doc\":{\"synopsis\":\"Shallowly converts this Keyed Seq to equivalent native JavaScript Object.\",\"description\":\"Converts keys to Strings.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]},\"line\":2706}]},\"#toArray\":{\"doc\":{\"synopsis\":\"Shallowly converts this collection to an Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":2711}]},\"#toSeq\":{\"doc\":{\"synopsis\":\"Returns itself\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":2716}]},\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new Seq with other collections concatenated to this one.\",\"description\":\"All entries will be present in the resulting Seq, even if they\\nhave the same key.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"KC\",\"VC\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KC\"},{\"k\":8,\"param\":\"VC\"}]}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"KC\"}]},{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"VC\"}]}]},\"line\":2724},{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"C\"}}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":3}]},{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":2725}]},\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Seq.Keyed with values passed through a\\n`mapper` function.\",\"description\":\"```js\\nconst { Seq } = require('immutable')\\nSeq.Keyed({ a: 1, b: 2 }).map(x => 10 * x)\\n// Seq { \\\"a\\\": 10, \\\"b\\\": 20 }\\n```\\n\\nNote: `map()` always returns a new instance, even if it produced the\\nsame value at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"M\"}]},\"line\":2740}]},\"#mapKeys\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.mapKeys\"}]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"M\"},{\"k\":8,\"param\":\"V\"}]},\"line\":2748}]},\"#mapEntries\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.mapEntries\"}]},\"signatures\":[{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"entry\",\"type\":{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":2756}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Seq, returning a Seq of the same type.\",\"description\":\"Similar to `seq.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":2766}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Seq with only the entries for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"F\"}]},\"line\":2778},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":2782}]},\"#flip\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.flip\"}]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"K\"}]},\"line\":2790}]}}}]}},\"Indexed\":{\"doc\":{\"synopsis\":\"`Seq` which represents an ordered indexed list of values.\",\"description\":\"\",\"notes\":[]},\"module\":{\"of\":{\"call\":{\"doc\":{\"synopsis\":\"Provides an Seq.Indexed of the values provided.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2802}]}}},\"call\":{\"doc\":{\"synopsis\":\"Always returns Seq.Indexed, discarding associated keys and\\nsupplying incrementing indices.\",\"description\":\"Note: `Seq.Indexed` is a conversion function and not a class, and does\\nnot use the `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2812},{\"typeParams\":[\"T\"],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2813},{\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":17}]},\"line\":2814}]},\"interface\":{\"line\":2816,\"typeParams\":[\"T\"],\"extends\":[{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":2},{\"k\":8,\"param\":\"T\"}]},{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]}],\"groups\":[{\"members\":{\"#toJS\":{\"doc\":{\"synopsis\":\"Deeply converts this Indexed Seq to equivalent native JavaScript Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"line\":2820}]},\"#toJSON\":{\"doc\":{\"synopsis\":\"Shallowly converts this Indexed Seq to equivalent native JavaScript Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2825}]},\"#toArray\":{\"doc\":{\"synopsis\":\"Shallowly converts this collection to an Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2830}]},\"#toSeq\":{\"doc\":{\"synopsis\":\"Returns itself\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":2835}]},\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new Seq with other collections concatenated to this one.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"valuesOrCollections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"C\"}]},{\"k\":8,\"param\":\"C\"}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":2840}]},\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Seq.Indexed with values passed through a\\n`mapper` function.\",\"description\":\"```js\\nconst { Seq } = require('immutable')\\nSeq.Indexed([ 1, 2 ]).map(x => 10 * x)\\n// Seq [ 10, 20 ]\\n```\\n\\nNote: `map()` always returns a new instance, even if it produced the\\nsame value at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":2855}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Seq, returning a a Seq of the same type.\",\"description\":\"Similar to `seq.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":2865}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Seq with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"F\"}]},\"line\":2877},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":2881}]},\"#zip\":{\"doc\":{\"synopsis\":\"Returns a Seq \\\"zipped\\\" with the provided collections.\",\"description\":\"Like `zipWith`, but using the default `zipper`: creating an `Array`.\\n\\n```js\\nconst a = Seq([ 1, 2, 3 ]);\\nconst b = Seq([ 4, 5, 6 ]);\\nconst c = a.zip(b); // Seq [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":2897},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":2898},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":17}]},\"line\":2899}]},\"#zipAll\":{\"doc\":{\"synopsis\":\"Returns a Seq \\\"zipped\\\" with the provided collections.\",\"description\":\"Unlike `zip`, `zipAll` continues zipping until the longest collection is\\nexhausted. Missing values from shorter collections are filled with `undefined`.\\n\\n```js\\nconst a = Seq([ 1, 2 ]);\\nconst b = Seq([ 3, 4, 5 ]);\\nconst c = a.zipAll(b); // Seq [ [ 1, 3 ], [ 2, 4 ], [ undefined, 5 ] ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":2913},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":2914},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":17}]},\"line\":2915}]},\"#zipWith\":{\"doc\":{\"synopsis\":\"Returns a Seq \\\"zipped\\\" with the provided collections by using a\\ncustom `zipper` function.\",\"description\":\"```js\\nconst a = Seq([ 1, 2, 3 ]);\\nconst b = Seq([ 4, 5, 6 ]);\\nconst c = a.zipWith((a, b) => a + b, b);\\n// Seq [ 5, 7, 9 ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":2928},{\"typeParams\":[\"U\",\"V\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}},{\"name\":\"thirdValue\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"thirdCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":2932},{\"typeParams\":[\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"any\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":2937}]}}}]}},\"Set\":{\"doc\":{\"synopsis\":\"`Seq` which represents a set of values.\",\"description\":\"Because `Seq` are often lazy, `Seq.Set` does not provide the same guarantee\\nof value uniqueness as the concrete `Set`.\",\"notes\":[]},\"module\":{\"of\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a Seq.Set of the provided values\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2955}]}}},\"call\":{\"doc\":{\"synopsis\":\"Always returns a Seq.Set, discarding associated indices or keys.\",\"description\":\"Note: `Seq.Set` is a conversion function and not a class, and does not\\nuse the `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2964},{\"typeParams\":[\"T\"],\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2965},{\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":17}]},\"line\":2966}]},\"interface\":{\"line\":2968,\"typeParams\":[\"T\"],\"extends\":[{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"T\"}]},{\"k\":9,\"name\":\"Collection.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]}],\"groups\":[{\"members\":{\"#toJS\":{\"doc\":{\"synopsis\":\"Deeply converts this Set Seq to equivalent native JavaScript Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"line\":2972}]},\"#toJSON\":{\"doc\":{\"synopsis\":\"Shallowly converts this Set Seq to equivalent native JavaScript Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2977}]},\"#toArray\":{\"doc\":{\"synopsis\":\"Shallowly converts this collection to an Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2982}]},\"#toSeq\":{\"doc\":{\"synopsis\":\"Returns itself\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":2987}]},\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new Seq with other collections concatenated to this one.\",\"description\":\"All entries will be present in the resulting Seq, even if they\\nare duplicates.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"U\"}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":2995}]},\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Seq.Set with values passed through a\\n`mapper` function.\",\"description\":\"```js\\nSeq.Set([ 1, 2 ]).map(x => 10 * x)\\n// Seq { 10, 20 }\\n```\\n\\nNote: `map()` always returns a new instance, even if it produced the\\nsame value at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":3009}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Seq, returning a Seq of the same type.\",\"description\":\"Similar to `seq.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":3019}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Seq with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"F\"}]},\"line\":3031},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":3035}]}}}]}}},\"call\":{\"doc\":{\"synopsis\":\"Creates a Seq.\",\"description\":\"Returns a particular kind of `Seq` based on the input.\\n\\n  * If a `Seq`, that same `Seq`.\\n  * If an `Collection`, a `Seq` of the same kind (Keyed, Indexed, or Set).\\n  * If an Array-like, an `Seq.Indexed`.\\n  * If an Iterable Object, an `Seq.Indexed`.\\n  * If an Object, a `Seq.Keyed`.\\n\\nNote: An Iterator itself will be treated as an object, becoming a `Seq.Keyed`,\\nwhich is usually not what you want. You should turn your Iterator Object into\\nan iterable object by defining a Symbol.iterator (or @@iterator) method which\\nreturns `this`.\\n\\nNote: `Seq` is a conversion function and not a class, and does not use the\\n`new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"S\"],\"params\":[{\"name\":\"seq\",\"type\":{\"k\":8,\"param\":\"S\"}}],\"type\":{\"k\":8,\"param\":\"S\"},\"line\":3062},{\"typeParams\":[\"K\",\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":3063},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3064},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Collection.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3065},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3066},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"obj\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":3},{\"k\":8,\"param\":\"V\"}]},\"line\":3067},{\"type\":{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":17},{\"k\":17}]},\"line\":3068}]},\"interface\":{\"line\":3070,\"typeParams\":[\"K\",\"V\"],\"extends\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}],\"groups\":[{\"members\":{\"#size\":{\"line\":3082}}},{\"title\":\"Force evaluation\",\"members\":{\"#cacheResult\":{\"doc\":{\"synopsis\":\"Because Sequences are lazy and designed to be chained together, they do\\nnot cache their results. For example, this map function is called a total\\nof 6 times, as each `join` iterates the Seq of three values.\",\"description\":\"    var squares = Seq([ 1, 2, 3 ]).map(x => x * x)\\n    squares.join() + squares.join()\\n\\nIf you know a `Seq` will be used multiple times, it may be more\\nefficient to first cache it in memory. Here, the map function is called\\nonly 3 times.\\n\\n    var squares = Seq([ 1, 2, 3 ]).map(x => x * x).cacheResult()\\n    squares.join() + squares.join()\\n\\nUse this method judiciously, as it must fully evaluate a Seq which can be\\na burden on memory and possibly performance.\\n\\nNote: after calling `cacheResult`, a Seq will always have a `size`.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":3107}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Seq with values passed through a\\n`mapper` function.\",\"description\":\"```js\\nconst { Seq } = require('immutable')\\nSeq([ 1, 2 ]).map(x => 10 * x)\\n// Seq [ 10, 20 ]\\n```\\n\\nNote: `map()` always returns a new instance, even if it produced the same\\nvalue at every step.\\nNote: used only for sets.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"M\"}]},\"line\":3124},{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":8,\"param\":\"M\"},{\"k\":8,\"param\":\"M\"}]},\"line\":3143}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Seq, returning a Seq of the same type.\",\"description\":\"Similar to `seq.map(...).flatten(true)`.\\nNote: Used only for sets.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"M\"}]},\"line\":3153},{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":8,\"param\":\"M\"},{\"k\":8,\"param\":\"M\"}]},\"line\":3164}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Seq with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"F\"}]},\"line\":3176},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":3180}]}}}]}},\"Collection\":{\"doc\":{\"synopsis\":\"The `Collection` is a set of (key, value) entries which can be iterated, and\\nis the base class for all collections in `immutable`, allowing them to\\nmake use of all the Collection methods (such as `map` and `filter`).\",\"description\":\"Note: A collection is always iterated in the same order, however that order\\nmay not always be well defined, as is the case for the `Map` and `Set`.\\n\\nCollection is the abstract base class for concrete data structures. It\\ncannot be constructed directly.\\n\\nImplementations should extend one of the subclasses, `Collection.Keyed`,\\n`Collection.Indexed`, or `Collection.Set`.\",\"notes\":[]},\"module\":{\"Keyed\":{\"doc\":{\"synopsis\":\"Keyed Collections have discrete keys tied to each value.\",\"description\":\"When iterating `Collection.Keyed`, each iteration will yield a `[K, V]`\\ntuple, in other words, `Collection#entries` is the default iterator for\\nKeyed Collections.\",\"notes\":[]},\"module\":{},\"call\":{\"doc\":{\"synopsis\":\"Creates a Collection.Keyed\",\"description\":\"Similar to `Collection()`, however it expects collection-likes of [K, V]\\ntuples if not constructed from a Collection.Keyed or JS Object.\\n\\nNote: `Collection.Keyed` is a conversion function and not a class, and\\ndoes not use the `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\",\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":3241},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"obj\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":3},{\"k\":8,\"param\":\"V\"}]},\"line\":3242}]},\"interface\":{\"line\":3244,\"typeParams\":[\"K\",\"V\"],\"extends\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}],\"groups\":[{\"members\":{\"#toJS\":{\"doc\":{\"synopsis\":\"Deeply converts this Keyed collection to equivalent native JavaScript Object.\",\"description\":\"Converts keys to Strings.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":17}}]},\"line\":3250}]},\"#toJSON\":{\"doc\":{\"synopsis\":\"Shallowly converts this Keyed collection to equivalent native JavaScript Object.\",\"description\":\"Converts keys to Strings.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]},\"line\":3257}]},\"#toArray\":{\"doc\":{\"synopsis\":\"Shallowly converts this collection to an Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":3262}]},\"#toSeq\":{\"doc\":{\"synopsis\":\"Returns Seq.Keyed.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":3268}]}}},{\"title\":\"Sequence functions\",\"members\":{\"#flip\":{\"doc\":{\"synopsis\":\"Returns a new Collection.Keyed of the same type where the keys and values\\nhave been flipped.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap({ a: 'z', b: 'y' }).flip()\\n// Map { \\\"z\\\": \\\"a\\\", \\\"y\\\": \\\"b\\\" }\\n```\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"K\"}]},\"line\":3284}]},\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new Collection with other collections concatenated to this one.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"KC\",\"VC\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KC\"},{\"k\":8,\"param\":\"VC\"}]}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"KC\"}]},{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"VC\"}]}]},\"line\":3289},{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"C\"}}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":3}]},{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":3290}]},\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Collection.Keyed with values passed through a\\n`mapper` function.\",\"description\":\"```js\\nconst { Collection } = require('immutable')\\nCollection.Keyed({ a: 1, b: 2 }).map(x => 10 * x)\\n// Seq { \\\"a\\\": 10, \\\"b\\\": 20 }\\n```\\n\\nNote: `map()` always returns a new instance, even if it produced the\\nsame value at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"M\"}]},\"line\":3305}]},\"#mapKeys\":{\"doc\":{\"synopsis\":\"Returns a new Collection.Keyed of the same type with keys passed through\\na `mapper` function.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap({ a: 1, b: 2 }).mapKeys(x => x.toUpperCase())\\n// Map { \\\"A\\\": 1, \\\"B\\\": 2 }\\n```\\n\\nNote: `mapKeys()` always returns a new instance, even if it produced\\nthe same key at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"M\"},{\"k\":8,\"param\":\"V\"}]},\"line\":3324}]},\"#mapEntries\":{\"doc\":{\"synopsis\":\"Returns a new Collection.Keyed of the same type with entries\\n([key, value] tuples) passed through a `mapper` function.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap({ a: 1, b: 2 })\\n  .mapEntries(([ k, v ]) => [ k.toUpperCase(), v * 2 ])\\n// Map { \\\"A\\\": 2, \\\"B\\\": 4 }\\n```\\n\\nNote: `mapEntries()` always returns a new instance, even if it produced\\nthe same entry at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"entry\",\"type\":{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":3344}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Collection, returning a Collection of the same type.\",\"description\":\"Similar to `collection.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":3354}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Collection with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"F\"}]},\"line\":3366},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":3370}]},\"#[Symbol.iterator]\":{\"signatures\":[{\"type\":{\"k\":9,\"name\":\"IterableIterator\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":3375}]}}}]}},\"Indexed\":{\"doc\":{\"synopsis\":\"Indexed Collections have incrementing numeric keys. They exhibit\\nslightly different behavior than `Collection.Keyed` for some methods in order\\nto better mirror the behavior of JavaScript's `Array`, and add methods\\nwhich do not make sense on non-indexed Collections such as `indexOf`.\",\"description\":\"Unlike JavaScript arrays, `Collection.Indexed`s are always dense. \\\"Unset\\\"\\nindices and `undefined` indices are indistinguishable, and all indices from\\n0 to `size` are visited when iterated.\\n\\nAll Collection.Indexed methods return re-indexed Collections. In other words,\\nindices always start at 0 and increment until size. If you wish to\\npreserve indices, using them as keys, convert to a Collection.Keyed by\\ncalling `toKeyedSeq`.\",\"notes\":[]},\"module\":{},\"call\":{\"doc\":{\"synopsis\":\"Creates a new Collection.Indexed.\",\"description\":\"Note: `Collection.Indexed` is a conversion function and not a class, and\\ndoes not use the `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3402}]},\"interface\":{\"line\":3404,\"typeParams\":[\"T\"],\"extends\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":2},{\"k\":8,\"param\":\"T\"}]}],\"groups\":[{\"members\":{\"#toJS\":{\"doc\":{\"synopsis\":\"Deeply converts this Indexed collection to equivalent native JavaScript Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"line\":3408}]},\"#toJSON\":{\"doc\":{\"synopsis\":\"Shallowly converts this Indexed collection to equivalent native JavaScript Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3413}]},\"#toArray\":{\"doc\":{\"synopsis\":\"Shallowly converts this collection to an Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3418}]}}},{\"title\":\"Reading values\",\"members\":{\"#get\":{\"doc\":{\"synopsis\":\"Returns the value associated with the provided index, or notSetValue if\\nthe index is beyond the bounds of the Collection.\",\"description\":\"`index` may be a negative number, which indexes back from the end of the\\nCollection. `s.get(-1)` gets the last item in the Collection.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"NSV\"],\"params\":[{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"NSV\"}]},\"line\":3429},{\"params\":[{\"name\":\"index\",\"type\":{\"k\":2}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":11}]},\"line\":3430}]}}},{\"title\":\"Conversion to Seq\",\"members\":{\"#toSeq\":{\"doc\":{\"synopsis\":\"Returns Seq.Indexed.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3439}]},\"#fromEntrySeq\":{\"doc\":{\"synopsis\":\"If this is a collection of [key, value] entry tuples, it will return a\\nSeq.Keyed of those entries.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":17},{\"k\":17}]},\"line\":3445}]}}},{\"title\":\"Combination\",\"members\":{\"#interpose\":{\"doc\":{\"synopsis\":\"Returns a Collection of the same type with `separator` between each item\\nin this Collection.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"separator\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":10},\"line\":3454}]},\"#interleave\":{\"doc\":{\"synopsis\":\"Returns a Collection of the same type with the provided `collections`\\ninterleaved into this collection.\",\"description\":\"The resulting Collection includes the first item from each, then the\\nsecond from each, etc.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"require('immutable')\\\"}\\n-->\\n```js\\nconst { List } = require('immutable')\\nList([ 1, 2, 3 ]).interleave(List([ 'A', 'B', 'C' ]))\\n// List [ 1, \\\"A\\\", 2, \\\"B\\\", 3, \\\"C\\\" ]\\n```\\n\\nThe shortest Collection stops interleave.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable')\\\" }\\n-->\\n```js\\nList([ 1, 2, 3 ]).interleave(\\n  List([ 'A', 'B' ]),\\n  List([ 'X', 'Y', 'Z' ])\\n)\\n// List [ 1, \\\"A\\\", \\\"X\\\", 2, \\\"B\\\", \\\"Y\\\" ]\\n```\\n\\nSince `interleave()` re-indexes values, it produces a complete copy,\\nwhich has `O(N)` complexity.\\n\\nNote: `interleave` *cannot* be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"T\"}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":3490}]},\"#splice\":{\"doc\":{\"synopsis\":\"Splice returns a new indexed Collection by replacing a region of this\\nCollection with new values. If values are not provided, it only skips the\\nregion to be removed.\",\"description\":\"`index` may be a negative number, which indexes back from the end of the\\nCollection. `s.splice(-2)` splices after the second to last item.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nList([ 'a', 'b', 'c', 'd' ]).splice(1, 2, 'q', 'r', 's')\\n// List [ \\\"a\\\", \\\"q\\\", \\\"r\\\", \\\"s\\\", \\\"d\\\" ]\\n```\\n\\nSince `splice()` re-indexes values, it produces a complete copy, which\\nhas `O(N)` complexity.\\n\\nNote: `splice` *cannot* be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"removeNum\",\"type\":{\"k\":2}},{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":3512}]},\"#zip\":{\"doc\":{\"synopsis\":\"Returns a Collection of the same type \\\"zipped\\\" with the provided\\ncollections.\",\"description\":\"Like `zipWith`, but using the default `zipper`: creating an `Array`.\\n\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable')\\\" }\\n-->\\n```js\\nconst a = List([ 1, 2, 3 ]);\\nconst b = List([ 4, 5, 6 ]);\\nconst c = a.zip(b); // List [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":3534},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":3535},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":17}]},\"line\":3536}]},\"#zipAll\":{\"doc\":{\"synopsis\":\"Returns a Collection \\\"zipped\\\" with the provided collections.\",\"description\":\"Unlike `zip`, `zipAll` continues zipping until the longest collection is\\nexhausted. Missing values from shorter collections are filled with `undefined`.\\n\\n```js\\nconst a = List([ 1, 2 ]);\\nconst b = List([ 3, 4, 5 ]);\\nconst c = a.zipAll(b); // List [ [ 1, 3 ], [ 2, 4 ], [ undefined, 5 ] ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":3550},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":3551},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":17}]},\"line\":3552}]},\"#zipWith\":{\"doc\":{\"synopsis\":\"Returns a Collection of the same type \\\"zipped\\\" with the provided\\ncollections by using a custom `zipper` function.\",\"description\":\"<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable')\\\" }\\n-->\\n```js\\nconst a = List([ 1, 2, 3 ]);\\nconst b = List([ 4, 5, 6 ]);\\nconst c = a.zipWith((a, b) => a + b, b);\\n// List [ 5, 7, 9 ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":3568},{\"typeParams\":[\"U\",\"V\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}},{\"name\":\"thirdValue\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"thirdCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":3572},{\"typeParams\":[\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"any\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":3577}]}}},{\"title\":\"Search for value\",\"members\":{\"#indexOf\":{\"doc\":{\"synopsis\":\"Returns the first index at which a given value can be found in the\\nCollection, or -1 if it is not present.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"searchValue\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":2},\"line\":3589}]},\"#lastIndexOf\":{\"doc\":{\"synopsis\":\"Returns the last index at which a given value can be found in the\\nCollection, or -1 if it is not present.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"searchValue\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":2},\"line\":3595}]},\"#findIndex\":{\"doc\":{\"synopsis\":\"Returns the first index in the Collection where a value satisfies the\\nprovided predicate function. Otherwise -1 is returned.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":2},\"line\":3601}]},\"#findLastIndex\":{\"doc\":{\"synopsis\":\"Returns the last index in the Collection where a value satisfies the\\nprovided predicate function. Otherwise -1 is returned.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":2},\"line\":3610}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new Collection with other collections concatenated to this one.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"valuesOrCollections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"C\"}]},{\"k\":8,\"param\":\"C\"}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":3620}]},\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Collection.Indexed with values passed through a\\n`mapper` function.\",\"description\":\"```js\\nconst { Collection } = require('immutable')\\nCollection.Indexed([1,2]).map(x => 10 * x)\\n// Seq [ 1, 2 ]\\n```\\n\\nNote: `map()` always returns a new instance, even if it produced the\\nsame value at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":3635}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Collection, returning a Collection of the same type.\",\"description\":\"Similar to `collection.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":3645}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Collection with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"F\"}]},\"line\":3657},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":3661}]},\"#[Symbol.iterator]\":{\"signatures\":[{\"type\":{\"k\":9,\"name\":\"IterableIterator\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3666}]}}}]}},\"Set\":{\"doc\":{\"synopsis\":\"Set Collections only represent values. They have no associated keys or\\nindices. Duplicate values are possible in the lazy `Seq.Set`s, however\\nthe concrete `Set` Collection does not allow duplicate values.\",\"description\":\"Collection methods on Collection.Set such as `map` and `forEach` will provide\\nthe value as both the first and second arguments to the provided function.\\n\\n```js\\nconst { Collection } = require('immutable')\\nconst seq = Collection.Set([ 'A', 'B', 'C' ])\\n// Seq { \\\"A\\\", \\\"B\\\", \\\"C\\\" }\\nseq.forEach((v, k) =>\\n assert.equal(v, k)\\n)\\n```\",\"notes\":[]},\"module\":{},\"call\":{\"doc\":{\"synopsis\":\"Similar to `Collection()`, but always returns a Collection.Set.\",\"description\":\"Note: `Collection.Set` is a factory function and not a class, and does\\nnot use the `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3695}]},\"interface\":{\"line\":3697,\"typeParams\":[\"T\"],\"extends\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"T\"}]}],\"groups\":[{\"members\":{\"#toJS\":{\"doc\":{\"synopsis\":\"Deeply converts this Set collection to equivalent native JavaScript Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"line\":3701}]},\"#toJSON\":{\"doc\":{\"synopsis\":\"Shallowly converts this Set collection to equivalent native JavaScript Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3706}]},\"#toArray\":{\"doc\":{\"synopsis\":\"Shallowly converts this collection to an Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3711}]},\"#toSeq\":{\"doc\":{\"synopsis\":\"Returns Seq.Set.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3717}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new Collection with other collections concatenated to this one.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"U\"}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Set\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":3724}]},\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Collection.Set with values passed through a\\n`mapper` function.\",\"description\":\"```\\nCollection.Set([ 1, 2 ]).map(x => 10 * x)\\n// Seq { 1, 2 }\\n```\\n\\nNote: `map()` always returns a new instance, even if it produced the\\nsame value at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Set\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":3738}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Collection, returning a Collection of the same type.\",\"description\":\"Similar to `collection.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Set\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":3748}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Collection with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Set\",\"args\":[{\"k\":8,\"param\":\"F\"}]},\"line\":3760},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":3764}]},\"#[Symbol.iterator]\":{\"signatures\":[{\"type\":{\"k\":9,\"name\":\"IterableIterator\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3769}]}}}]}}},\"call\":{\"doc\":{\"synopsis\":\"Creates a Collection.\",\"description\":\"The type of Collection created is based on the input.\\n\\n  * If an `Collection`, that same `Collection`.\\n  * If an Array-like, an `Collection.Indexed`.\\n  * If an Object with an Iterator defined, an `Collection.Indexed`.\\n  * If an Object, an `Collection.Keyed`.\\n\\nThis methods forces the conversion of Objects and Strings to Collections.\\nIf you want to ensure that a Collection of one item is returned, use\\n`Seq.of`.\\n\\nNote: An Iterator itself will be treated as an object, becoming a `Seq.Keyed`,\\nwhich is usually not what you want. You should turn your Iterator Object into\\nan iterable object by defining a Symbol.iterator (or @@iterator) method which\\nreturns `this`.\\n\\nNote: `Collection` is a conversion function and not a class, and does not\\nuse the `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"I\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"I\"}}],\"type\":{\"k\":8,\"param\":\"I\"},\"line\":3796},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3797},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"obj\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":3},{\"k\":8,\"param\":\"V\"}]},\"line\":3798}]},\"interface\":{\"line\":3800,\"typeParams\":[\"K\",\"V\"],\"extends\":[{\"k\":9,\"name\":\"ValueObject\"}],\"groups\":[{\"title\":\"Value equality\",\"members\":{\"#equals\":{\"doc\":{\"synopsis\":\"True if this and the other Collection have value equality, as defined\\nby `Immutable.is()`.\",\"description\":\"Note: This is equivalent to `Immutable.is(this, other)`, but provided to\\nallow for chained expressions.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"other\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":3811}]},\"#hashCode\":{\"doc\":{\"synopsis\":\"Computes and returns the hashed identity for this Collection.\",\"description\":\"The `hashCode` of a Collection is used to determine potential equality,\\nand is used when adding this to a `Set` or as a key in a `Map`, enabling\\nlookup via a different instance.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Set,  List } = require('immutable')\\\" }\\n-->\\n```js\\nconst a = List([ 1, 2, 3 ]);\\nconst b = List([ 1, 2, 3 ]);\\nassert.notStrictEqual(a, b); // different instances\\nconst set = Set([ a ]);\\nassert.equal(set.has(b), true);\\n```\\n\\nIf two values have the same `hashCode`, they are [not guaranteed\\nto be equal][Hash Collision]. If two values have different `hashCode`s,\\nthey must not be equal.\\n\\n[Hash Collision]: https://en.wikipedia.org/wiki/Collision_(computer_science)\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":2},\"line\":3837}]}}},{\"title\":\"Reading values\",\"members\":{\"#get\":{\"doc\":{\"synopsis\":\"Returns the value associated with the provided key, or notSetValue if\\nthe Collection does not contain this key.\",\"description\":\"Note: it is possible a key may be associated with an `undefined` value,\\nso if `notSetValue` is not provided and this method returns `undefined`,\\nthat does not guarantee the key was not found.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"NSV\"],\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]},\"line\":3850},{\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":3851}]},\"#has\":{\"doc\":{\"synopsis\":\"True if a key exists within this `Collection`, using `Immutable.is`\\nto determine equality\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":1},\"line\":3857}]},\"#includes\":{\"doc\":{\"synopsis\":\"True if a value exists within this `Collection`, using `Immutable.is`\\nto determine equality\",\"description\":\"\",\"notes\":[{\"name\":\"alias\",\"body\":\"contains\"}]},\"signatures\":[{\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":1},\"line\":3864}]},\"#first\":{\"doc\":{\"synopsis\":\"In case the `Collection` is not empty returns the first element of the\\n`Collection`.\\nIn case the `Collection` is empty returns the optional default\\nvalue if provided, if no default value is provided returns undefined.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"NSV\"],\"params\":[{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]},\"line\":3873}]},\"#last\":{\"doc\":{\"synopsis\":\"In case the `Collection` is not empty returns the last element of the\\n`Collection`.\\nIn case the `Collection` is empty returns the optional default\\nvalue if provided, if no default value is provided returns undefined.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"NSV\"],\"params\":[{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]},\"line\":3881}]}}},{\"title\":\"Reading deep values\",\"members\":{\"#getIn\":{\"doc\":{\"synopsis\":\"Returns the value found by following a path of keys or indices through\\nnested Collections.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map, List } = require('immutable')\\nconst deepData = Map({ x: List([ Map({ y: 123 }) ]) });\\ndeepData.getIn(['x', 0, 'y']) // 123\\n```\\n\\nPlain JavaScript Object or Arrays may be nested within an Immutable.js\\nCollection, and getIn() can access those values as well:\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map, List } = require('immutable')\\nconst deepData = Map({ x: [ { y: 123 } ] });\\ndeepData.getIn(['x', 0, 'y']) // 123\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"searchKeyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"notSetValue\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":17},\"line\":3906}]},\"#hasIn\":{\"doc\":{\"synopsis\":\"True if the result of following a path of keys or indices through nested\\nCollections results in a set value.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"searchKeyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}}],\"type\":{\"k\":1},\"line\":3912}]}}},{\"title\":\"Persistent changes\",\"members\":{\"#update\":{\"doc\":{\"synopsis\":\"This can be very useful as a way to \\\"chain\\\" a normal function into a\\nsequence of methods. RxJS calls this \\\"let\\\" and lodash calls it \\\"thru\\\".\",\"description\":\"For example, to sum a Seq after mapping and filtering:\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Seq } = require('immutable')\\n\\nfunction sum(collection) {\\n  return collection.reduce((sum, x) => sum + x, 0)\\n}\\n\\nSeq([ 1, 2, 3 ])\\n  .map(x => x + 1)\\n  .filter(x => x % 2 === 0)\\n  .update(sum)\\n// 6\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"R\"],\"params\":[{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"R\"}}}],\"type\":{\"k\":8,\"param\":\"R\"},\"line\":3937}]}}},{\"title\":\"Conversion to JavaScript types\",\"members\":{\"#toJS\":{\"doc\":{\"synopsis\":\"Deeply converts this Collection to equivalent native JavaScript Array or Object.\",\"description\":\"`Collection.Indexed`, and `Collection.Set` become `Array`, while\\n`Collection.Keyed` become `Object`, converting keys to Strings.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":17}}]}]},\"line\":3948}]},\"#toJSON\":{\"doc\":{\"synopsis\":\"Shallowly converts this Collection to equivalent native JavaScript Array or Object.\",\"description\":\"`Collection.Indexed`, and `Collection.Set` become `Array`, while\\n`Collection.Keyed` become `Object`, converting keys to Strings.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"V\"}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}]},\"line\":3956}]},\"#toArray\":{\"doc\":{\"synopsis\":\"Shallowly converts this collection to an Array.\",\"description\":\"`Collection.Indexed`, and `Collection.Set` produce an Array of values.\\n`Collection.Keyed` produce an Array of [key, value] tuples.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"V\"}]},{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]}]},\"line\":3964}]},\"#toObject\":{\"doc\":{\"synopsis\":\"Shallowly converts this Collection to an Object.\",\"description\":\"Converts keys to Strings.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]},\"line\":3971}]}}},{\"title\":\"Conversion to Collections\",\"members\":{\"#toMap\":{\"doc\":{\"synopsis\":\"Converts this Collection to a Map, Throws if keys are not hashable.\",\"description\":\"Note: This is equivalent to `Map(this.toKeyedSeq())`, but provided\\nfor convenience and to allow for chained expressions.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":3982}]},\"#toOrderedMap\":{\"doc\":{\"synopsis\":\"Converts this Collection to a Map, maintaining the order of iteration.\",\"description\":\"Note: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but\\nprovided for convenience and to allow for chained expressions.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":3990}]},\"#toSet\":{\"doc\":{\"synopsis\":\"Converts this Collection to a Set, discarding keys. Throws if values\\nare not hashable.\",\"description\":\"Note: This is equivalent to `Set(this)`, but provided to allow for\\nchained expressions.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":3999}]},\"#toOrderedSet\":{\"doc\":{\"synopsis\":\"Converts this Collection to a Set, maintaining the order of iteration and\\ndiscarding keys.\",\"description\":\"Note: This is equivalent to `OrderedSet(this.valueSeq())`, but provided\\nfor convenience and to allow for chained expressions.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":4008}]},\"#toList\":{\"doc\":{\"synopsis\":\"Converts this Collection to a List, discarding keys.\",\"description\":\"This is similar to `List(collection)`, but provided to allow for chained\\nexpressions. However, when called on `Map` or other keyed collections,\\n`collection.toList()` discards the keys and creates a list of only the\\nvalues, whereas `List(collection)` creates a list of entry tuples.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map, List } = require('immutable')\\nvar myMap = Map({ a: 'Apple', b: 'Banana' })\\nList(myMap) // List [ [ \\\"a\\\", \\\"Apple\\\" ], [ \\\"b\\\", \\\"Banana\\\" ] ]\\nmyMap.toList() // List [ \\\"Apple\\\", \\\"Banana\\\" ]\\n```\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":4026}]},\"#toStack\":{\"doc\":{\"synopsis\":\"Converts this Collection to a Stack, discarding keys. Throws if values\\nare not hashable.\",\"description\":\"Note: This is equivalent to `Stack(this)`, but provided to allow for\\nchained expressions.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":4035}]}}},{\"title\":\"Conversion to Seq\",\"members\":{\"#toSeq\":{\"doc\":{\"synopsis\":\"Converts this Collection to a Seq of the same kind (indexed,\\nkeyed, or set).\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":4044}]},\"#toKeyedSeq\":{\"doc\":{\"synopsis\":\"Returns a Seq.Keyed from this Collection where indices are treated as keys.\",\"description\":\"This is useful if you want to operate on an\\nCollection.Indexed and preserve the [index, value] pairs.\\n\\nThe returned Seq will have identical iteration order as\\nthis Collection.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Seq } = require('immutable')\\nconst indexedSeq = Seq([ 'A', 'B', 'C' ])\\n// Seq [ \\\"A\\\", \\\"B\\\", \\\"C\\\" ]\\nindexedSeq.filter(v => v === 'B')\\n// Seq [ \\\"B\\\" ]\\nconst keyedSeq = indexedSeq.toKeyedSeq()\\n// Seq { 0: \\\"A\\\", 1: \\\"B\\\", 2: \\\"C\\\" }\\nkeyedSeq.filter(v => v === 'B')\\n// Seq { 1: \\\"B\\\" }\\n```\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":4068}]},\"#toIndexedSeq\":{\"doc\":{\"synopsis\":\"Returns an Seq.Indexed of the values of this Collection, discarding keys.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":4073}]},\"#toSetSeq\":{\"doc\":{\"synopsis\":\"Returns a Seq.Set of the values of this Collection, discarding keys.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":4078}]}}},{\"title\":\"Iterators\",\"members\":{\"#keys\":{\"doc\":{\"synopsis\":\"An iterator of this `Collection`'s keys.\",\"description\":\"Note: this will return an ES6 iterator which does not support\\nImmutable.js sequence algorithms. Use `keySeq` instead, if this is\\nwhat you want.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"IterableIterator\",\"args\":[{\"k\":8,\"param\":\"K\"}]},\"line\":4090}]},\"#values\":{\"doc\":{\"synopsis\":\"An iterator of this `Collection`'s values.\",\"description\":\"Note: this will return an ES6 iterator which does not support\\nImmutable.js sequence algorithms. Use `valueSeq` instead, if this is\\nwhat you want.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"IterableIterator\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":4099}]},\"#entries\":{\"doc\":{\"synopsis\":\"An iterator of this `Collection`'s entries as `[ key, value ]` tuples.\",\"description\":\"Note: this will return an ES6 iterator which does not support\\nImmutable.js sequence algorithms. Use `entrySeq` instead, if this is\\nwhat you want.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"IterableIterator\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":4108}]}}},{\"title\":\"Collections (Seq)\",\"members\":{\"#keySeq\":{\"doc\":{\"synopsis\":\"Returns a new Seq.Indexed of the keys of this Collection,\\ndiscarding values.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"K\"}]},\"line\":4117}]},\"#valueSeq\":{\"doc\":{\"synopsis\":\"Returns an Seq.Indexed of the values of this Collection, discarding keys.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":4122}]},\"#entrySeq\":{\"doc\":{\"synopsis\":\"Returns a new Seq.Indexed of [key, value] tuples.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":4127}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type with values passed through a\\n`mapper` function.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Collection } = require('immutable')\\nCollection({ a: 1, b: 2 }).map(x => 10 * x)\\n// Seq { \\\"a\\\": 10, \\\"b\\\": 20 }\\n```\\n\\nNote: `map()` always returns a new instance, even if it produced the same\\nvalue at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"M\"}]},\"line\":4146}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type with only the entries for which\\nthe `predicate` function returns true.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap({ a: 1, b: 2, c: 3, d: 4}).filter(x => x % 2 === 0)\\n// Map { \\\"b\\\": 2, \\\"d\\\": 4 }\\n```\\n\\nNote: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"F\"}]},\"line\":4173},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":4177}]},\"#filterNot\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type with only the entries for which\\nthe `predicate` function returns false.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)\\n// Map { \\\"a\\\": 1, \\\"c\\\": 3 }\\n```\\n\\nNote: `filterNot()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":4196}]},\"#reverse\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type in reverse order.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":4204}]},\"#sort\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which includes the same entries,\\nstably sorted by using a `comparator`.\",\"description\":\"If a `comparator` is not provided, a default comparator uses `<` and `>`.\\n\\n`comparator(valueA, valueB)`:\\n\\n  * Returns `0` if the elements should not be swapped.\\n  * Returns `-1` (or any negative number) if `valueA` comes before `valueB`\\n  * Returns `1` (or any positive number) if `valueA` comes after `valueB`\\n  * Is pure, i.e. it must always return the same value for the same pair\\n    of values.\\n\\nWhen sorting collections which have no defined order, their ordered\\nequivalents will be returned. e.g. `map.sort()` returns OrderedMap.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap({ \\\"c\\\": 3, \\\"a\\\": 1, \\\"b\\\": 2 }).sort((a, b) => {\\n  if (a < b) { return -1; }\\n  if (a > b) { return 1; }\\n  if (a === b) { return 0; }\\n});\\n// OrderedMap { \\\"a\\\": 1, \\\"b\\\": 2, \\\"c\\\": 3 }\\n```\\n\\nNote: `sort()` Always returns a new instance, even if the original was\\nalready sorted.\\n\\nNote: This is always an eager operation.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"comparator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"valueA\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"valueB\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":2}},\"optional\":true}],\"type\":{\"k\":10},\"line\":4239}]},\"#sortBy\":{\"doc\":{\"synopsis\":\"Like `sort`, but also accepts a `comparatorValueMapper` which allows for\\nsorting by more sophisticated means:\",\"description\":\"    hitters.sortBy(hitter => hitter.avgHits)\\n\\nNote: `sortBy()` Always returns a new instance, even if the original was\\nalready sorted.\\n\\nNote: This is always an eager operation.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"comparatorValueMapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"C\"}}},{\"name\":\"comparator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"valueA\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"valueB\",\"type\":{\"k\":8,\"param\":\"C\"}}],\"type\":{\"k\":2}},\"optional\":true}],\"type\":{\"k\":10},\"line\":4252}]},\"#groupBy\":{\"doc\":{\"synopsis\":\"Returns a `Collection.Keyed` of `Collection.Keyeds`, grouped by the return\\nvalue of the `grouper` function.\",\"description\":\"Note: This is always an eager operation.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { List, Map } = require('immutable')\\nconst listOfMaps = List([\\n  Map({ v: 0 }),\\n  Map({ v: 1 }),\\n  Map({ v: 1 }),\\n  Map({ v: 0 }),\\n  Map({ v: 2 })\\n])\\nconst groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))\\n// Map {\\n//   0: List [ Map{ \\\"v\\\": 0 }, Map { \\\"v\\\": 0 } ],\\n//   1: List [ Map{ \\\"v\\\": 1 }, Map { \\\"v\\\": 1 } ],\\n//   2: List [ Map{ \\\"v\\\": 2 } ],\\n// }\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"G\"],\"params\":[{\"name\":\"grouper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"G\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"G\"},{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":4281}]}}},{\"title\":\"Side effects\",\"members\":{\"#forEach\":{\"doc\":{\"synopsis\":\"The `sideEffect` is executed for every entry in the Collection.\",\"description\":\"Unlike `Array#forEach`, if any call of `sideEffect` returns\\n`false`, the iteration will stop. Returns the number of entries iterated\\n(including the last iteration which returned false).\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"sideEffect\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":2},\"line\":4296}]}}},{\"title\":\"Creating subsets\",\"members\":{\"#slice\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type representing a portion of this\\nCollection from start up to but not including end.\",\"description\":\"If begin is negative, it is offset from the end of the Collection. e.g.\\n`slice(-2)` returns a Collection of the last two entries. If it is not\\nprovided the new Collection will begin at the beginning of this Collection.\\n\\nIf end is negative, it is offset from the end of the Collection. e.g.\\n`slice(0, -1)` returns a Collection of everything but the last entry. If\\nit is not provided, the new Collection will continue through the end of\\nthis Collection.\\n\\nIf the requested slice is equivalent to the current Collection, then it\\nwill return itself.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"begin\",\"type\":{\"k\":2},\"optional\":true},{\"name\":\"end\",\"type\":{\"k\":2},\"optional\":true}],\"type\":{\"k\":10},\"line\":4320}]},\"#rest\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type containing all entries except\\nthe first.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":4326}]},\"#butLast\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type containing all entries except\\nthe last.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":4332}]},\"#skip\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which excludes the first `amount`\\nentries from this Collection.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"amount\",\"type\":{\"k\":2}}],\"type\":{\"k\":10},\"line\":4338}]},\"#skipLast\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which excludes the last `amount`\\nentries from this Collection.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"amount\",\"type\":{\"k\":2}}],\"type\":{\"k\":10},\"line\":4344}]},\"#skipWhile\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which includes entries starting\\nfrom when `predicate` first returns false.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\\n  .skipWhile(x => x.match(/g/))\\n// List [ \\\"cat\\\", \\\"hat\\\", \\\"god\\\" ]\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":4358}]},\"#skipUntil\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which includes entries starting\\nfrom when `predicate` first returns true.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\\n  .skipUntil(x => x.match(/hat/))\\n// List [ \\\"hat\\\", \\\"god\\\" ]\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":4375}]},\"#take\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which includes the first `amount`\\nentries from this Collection.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"amount\",\"type\":{\"k\":2}}],\"type\":{\"k\":10},\"line\":4384}]},\"#takeLast\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which includes the last `amount`\\nentries from this Collection.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"amount\",\"type\":{\"k\":2}}],\"type\":{\"k\":10},\"line\":4390}]},\"#takeWhile\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which includes entries from this\\nCollection as long as the `predicate` returns true.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\\n  .takeWhile(x => x.match(/o/))\\n// List [ \\\"dog\\\", \\\"frog\\\" ]\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":4404}]},\"#takeUntil\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which includes entries from this\\nCollection as long as the `predicate` returns false.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\\n  .takeUntil(x => x.match(/at/))\\n// List [ \\\"dog\\\", \\\"frog\\\" ]\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":4421}]}}},{\"title\":\"Combination\",\"members\":{\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type with other values and\\ncollection-like concatenated to this one.\",\"description\":\"For Seqs, all entries will be present in the resulting Seq, even if they\\nhave the same key.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"valuesOrCollections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]},\"line\":4436}]},\"#flatten\":{\"doc\":{\"synopsis\":\"Flattens nested Collections.\",\"description\":\"Will deeply flatten the Collection by default, returning a Collection of the\\nsame type, but a `depth` can be provided in the form of a number or\\nboolean (where true means to shallowly flatten one level). A depth of 0\\n(or shallow: false) will deeply flatten.\\n\\nFlattens only others Collection, not Arrays or Objects.\\n\\nNote: `flatten(true)` operates on Collection<unknown, Collection<K, V>> and\\nreturns Collection<K, V>\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"depth\",\"type\":{\"k\":2},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]},\"line\":4451},{\"params\":[{\"name\":\"shallow\",\"type\":{\"k\":1},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]},\"line\":4452}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Collection, returning a Collection of the same type.\",\"description\":\"Similar to `collection.map(...).flatten(true)`.\\nUsed for Dictionaries only.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"M\"}]},\"line\":4459},{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":4470}]}}},{\"title\":\"Reducing a value\",\"members\":{\"#reduce\":{\"doc\":{\"synopsis\":\"Reduces the Collection to a value by calling the `reducer` for every entry\\nin the Collection and passing along the reduced value.\",\"description\":\"If `initialReduction` is not provided, the first item in the\\nCollection will be used.\\n\",\"notes\":[{\"name\":\"see\",\"body\":\"`Array#reduce`.\"}]},\"signatures\":[{\"typeParams\":[\"R\"],\"params\":[{\"name\":\"reducer\",\"type\":{\"k\":7,\"params\":[{\"name\":\"reduction\",\"type\":{\"k\":8,\"param\":\"R\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"R\"}}},{\"name\":\"initialReduction\",\"type\":{\"k\":8,\"param\":\"R\"}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":8,\"param\":\"R\"},\"line\":4486},{\"typeParams\":[\"R\"],\"params\":[{\"name\":\"reducer\",\"type\":{\"k\":7,\"params\":[{\"name\":\"reduction\",\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"R\"}]}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"R\"}}}],\"type\":{\"k\":8,\"param\":\"R\"},\"line\":4491}]},\"#reduceRight\":{\"doc\":{\"synopsis\":\"Reduces the Collection in reverse (from the right side).\",\"description\":\"Note: Similar to this.reverse().reduce(), and provided for parity\\nwith `Array#reduceRight`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"R\"],\"params\":[{\"name\":\"reducer\",\"type\":{\"k\":7,\"params\":[{\"name\":\"reduction\",\"type\":{\"k\":8,\"param\":\"R\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"R\"}}},{\"name\":\"initialReduction\",\"type\":{\"k\":8,\"param\":\"R\"}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":8,\"param\":\"R\"},\"line\":4501},{\"typeParams\":[\"R\"],\"params\":[{\"name\":\"reducer\",\"type\":{\"k\":7,\"params\":[{\"name\":\"reduction\",\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"R\"}]}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"R\"}}}],\"type\":{\"k\":8,\"param\":\"R\"},\"line\":4506}]},\"#every\":{\"doc\":{\"synopsis\":\"True if `predicate` returns true for all entries in the Collection.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":1},\"line\":4513}]},\"#some\":{\"doc\":{\"synopsis\":\"True if `predicate` returns true for any entry in the Collection.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":1},\"line\":4521}]},\"#join\":{\"doc\":{\"synopsis\":\"Joins values together as a string, inserting a separator between each.\\nThe default separator is `\\\",\\\"`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"separator\",\"type\":{\"k\":3},\"optional\":true}],\"type\":{\"k\":3},\"line\":4530}]},\"#isEmpty\":{\"doc\":{\"synopsis\":\"Returns true if this Collection includes no values.\",\"description\":\"For some lazy `Seq`, `isEmpty` might need to iterate to determine\\nemptiness. At most one iteration will occur.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":1},\"line\":4538}]},\"#count\":{\"doc\":{\"synopsis\":\"Returns the size of this Collection.\",\"description\":\"Regardless of if this Collection can describe its size lazily (some Seqs\\ncannot), this method will always return the correct size. E.g. it\\nevaluates a lazy `Seq` if necessary.\\n\\nIf `predicate` is provided, then this returns the count of entries in the\\nCollection for which the `predicate` returns true.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":2},\"line\":4550},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":2},\"line\":4551}]},\"#countBy\":{\"doc\":{\"synopsis\":\"Returns a `Seq.Keyed` of counts, grouped by the return value of\\nthe `grouper` function.\",\"description\":\"Note: This is not a lazy operation.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"G\"],\"params\":[{\"name\":\"grouper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"G\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"G\"},{\"k\":2}]},\"line\":4562}]}}},{\"title\":\"Search for value\",\"members\":{\"#find\":{\"doc\":{\"synopsis\":\"Returns the first value for which the `predicate` returns true.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"V\"},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":4573}]},\"#findLast\":{\"doc\":{\"synopsis\":\"Returns the last value for which the `predicate` returns true.\",\"description\":\"Note: `predicate` will be called for each entry in reverse.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"V\"},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":4584}]},\"#findEntry\":{\"doc\":{\"synopsis\":\"Returns the first [key, value] entry for which the `predicate` returns true.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"V\"},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},{\"k\":11}]},\"line\":4593}]},\"#findLastEntry\":{\"doc\":{\"synopsis\":\"Returns the last [key, value] entry for which the `predicate`\\nreturns true.\",\"description\":\"Note: `predicate` will be called for each entry in reverse.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"V\"},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},{\"k\":11}]},\"line\":4605}]},\"#findKey\":{\"doc\":{\"synopsis\":\"Returns the key for which the `predicate` returns true.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":11}]},\"line\":4614}]},\"#findLastKey\":{\"doc\":{\"synopsis\":\"Returns the last key for which the `predicate` returns true.\",\"description\":\"Note: `predicate` will be called for each entry in reverse.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":11}]},\"line\":4624}]},\"#keyOf\":{\"doc\":{\"synopsis\":\"Returns the key associated with the search value, or undefined.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"searchValue\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":11}]},\"line\":4632}]},\"#lastKeyOf\":{\"doc\":{\"synopsis\":\"Returns the last key associated with the search value, or undefined.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"searchValue\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":11}]},\"line\":4637}]},\"#max\":{\"doc\":{\"synopsis\":\"Returns the maximum value in this collection. If any values are\\ncomparatively equivalent, the first one found will be returned.\",\"description\":\"The `comparator` is used in the same way as `Collection#sort`. If it is not\\nprovided, the default comparator is `>`.\\n\\nWhen two values are considered equivalent, the first encountered will be\\nreturned. Otherwise, `max` will operate independent of the order of input\\nas long as the comparator is commutative. The default comparator `>` is\\ncommutative *only* when types do not differ.\\n\\nIf `comparator` returns 0 and either value is NaN, undefined, or null,\\nthat value will be returned.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"comparator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"valueA\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"valueB\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":2}},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":4654}]},\"#maxBy\":{\"doc\":{\"synopsis\":\"Like `max`, but also accepts a `comparatorValueMapper` which allows for\\ncomparing by more sophisticated means:\",\"description\":\"    hitters.maxBy(hitter => hitter.avgHits);\\n\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"comparatorValueMapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"C\"}}},{\"name\":\"comparator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"valueA\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"valueB\",\"type\":{\"k\":8,\"param\":\"C\"}}],\"type\":{\"k\":2}},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":4663}]},\"#min\":{\"doc\":{\"synopsis\":\"Returns the minimum value in this collection. If any values are\\ncomparatively equivalent, the first one found will be returned.\",\"description\":\"The `comparator` is used in the same way as `Collection#sort`. If it is not\\nprovided, the default comparator is `<`.\\n\\nWhen two values are considered equivalent, the first encountered will be\\nreturned. Otherwise, `min` will operate independent of the order of input\\nas long as the comparator is commutative. The default comparator `<` is\\ncommutative *only* when types do not differ.\\n\\nIf `comparator` returns 0 and either value is NaN, undefined, or null,\\nthat value will be returned.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"comparator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"valueA\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"valueB\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":2}},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":4683}]},\"#minBy\":{\"doc\":{\"synopsis\":\"Like `min`, but also accepts a `comparatorValueMapper` which allows for\\ncomparing by more sophisticated means:\",\"description\":\"    hitters.minBy(hitter => hitter.avgHits);\\n\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"comparatorValueMapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"C\"}}},{\"name\":\"comparator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"valueA\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"valueB\",\"type\":{\"k\":8,\"param\":\"C\"}}],\"type\":{\"k\":2}},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":4692}]}}},{\"title\":\"Comparison\",\"members\":{\"#isSubset\":{\"doc\":{\"synopsis\":\"True if `iter` includes every value in this Collection.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"iter\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":1},\"line\":4703}]},\"#isSuperset\":{\"doc\":{\"synopsis\":\"True if this Collection includes every value in `iter`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"iter\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":1},\"line\":4708}]}}}]}},\"ValueObject\":{\"interface\":{\"line\":4714,\"doc\":{\"synopsis\":\"The interface to fulfill to qualify as a Value Object.\",\"description\":\"\",\"notes\":[]},\"groups\":[{\"members\":{\"#equals\":{\"doc\":{\"synopsis\":\"True if this and the other Collection have value equality, as defined\\nby `Immutable.is()`.\",\"description\":\"Note: This is equivalent to `Immutable.is(this, other)`, but provided to\\nallow for chained expressions.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"other\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4722}]},\"#hashCode\":{\"doc\":{\"synopsis\":\"Computes and returns the hashed identity for this Collection.\",\"description\":\"The `hashCode` of a Collection is used to determine potential equality,\\nand is used when adding this to a `Set` or as a key in a `Map`, enabling\\nlookup via a different instance.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { List, Set } = require('immutable');\\nconst a = List([ 1, 2, 3 ]);\\nconst b = List([ 1, 2, 3 ]);\\nassert.notStrictEqual(a, b); // different instances\\nconst set = Set([ a ]);\\nassert.equal(set.has(b), true);\\n```\\n\\nNote: hashCode() MUST return a Uint32 number. The easiest way to\\nguarantee this is to return `myHash | 0` from a custom implementation.\\n\\nIf two values have the same `hashCode`, they are [not guaranteed\\nto be equal][Hash Collision]. If two values have different `hashCode`s,\\nthey must not be equal.\\n\\nNote: `hashCode()` is not guaranteed to always be called before\\n`equals()`. Most but not all Immutable.js collections use hash codes to\\norganize their internal data structures, while all Immutable.js\\ncollections use equality during lookups.\\n\\n[Hash Collision]: https://en.wikipedia.org/wiki/Collision_(computer_science)\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":2},\"line\":4755}]}}}]}},\"fromJS\":{\"call\":{\"doc\":{\"synopsis\":\"Deeply converts plain JS objects and arrays to Immutable Maps and Lists.\",\"description\":\"If a `reviver` is optionally provided, it will be called with every\\ncollection as a Seq (beginning with the most nested collections\\nand proceeding to the top-level collection itself), along with the key\\nreferring to each collection and the parent JS object provided as `this`.\\nFor the top level, object, the key will be `\\\"\\\"`. This `reviver` is expected\\nto return a new Immutable Collection, allowing for custom conversions from\\ndeep JS objects. Finally, a `path` is provided which is the sequence of\\nkeys to this value from the starting value.\\n\\n`reviver` acts similarly to the [same parameter in `JSON.parse`][1].\\n\\nIf `reviver` is not provided, the default behavior will convert Objects\\ninto Maps and Arrays into Lists like so:\\n\\n<!-- runkit:activate -->\\n```js\\nconst { fromJS, isKeyed } = require('immutable')\\nfunction (key, value) {\\n  return isKeyed(value) ? value.toMap() : value.toList()\\n}\\n```\\n\\n`fromJS` is conservative in its conversion. It will only convert\\narrays which pass `Array.isArray` to Lists, and only raw objects (no custom\\nprototype) to Map.\\n\\nAccordingly, this example converts native JS data to OrderedMap and List:\\n\\n<!-- runkit:activate -->\\n```js\\nconst { fromJS, isKeyed } = require('immutable')\\nfromJS({ a: {b: [10, 20, 30]}, c: 40}, function (key, value, path) {\\n  console.log(key, value, path)\\n  return isKeyed(value) ? value.toOrderedMap() : value.toList()\\n})\\n\\n> \\\"b\\\", [ 10, 20, 30 ], [ \\\"a\\\", \\\"b\\\" ]\\n> \\\"a\\\", {b: [10, 20, 30]}, [ \\\"a\\\" ]\\n> \\\"\\\", {a: {b: [10, 20, 30]}, c: 40}, []\\n```\\n\\nKeep in mind, when using JS objects to construct Immutable Maps, that\\nJavaScript Object properties are always strings, even if written in a\\nquote-less shorthand, while Immutable Maps accept keys of any type.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nlet obj = { 1: \\\"one\\\" };\\nObject.keys(obj); // [ \\\"1\\\" ]\\nassert.equal(obj[\\\"1\\\"], obj[1]); // \\\"one\\\" === \\\"one\\\"\\n\\nlet map = Map(obj);\\nassert.notEqual(map.get(\\\"1\\\"), map.get(1)); // \\\"one\\\" !== undefined\\n```\\n\\nProperty access for JavaScript Objects first converts the key to a string,\\nbut since Immutable Map keys can be of any type the argument to `get()` is\\nnot altered.\\n\\n[1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Example.3A_Using_the_reviver_parameter\\n     \\\"Using the reviver parameter\\\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"jsValue\",\"type\":{\"k\":17}},{\"name\":\"reviver\",\"type\":{\"k\":7,\"params\":[{\"name\":\"key\",\"type\":{\"k\":12,\"types\":[{\"k\":3},{\"k\":2}]}},{\"name\":\"sequence\",\"type\":{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":3},{\"k\":17}]},{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":17}]}]}},{\"name\":\"path\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":3},{\"k\":2}]}]},\"optional\":true}],\"type\":{\"k\":17}},\"optional\":true}],\"type\":{\"k\":17},\"line\":4824}]}},\"is\":{\"call\":{\"doc\":{\"synopsis\":\"Value equality check with semantics similar to `Object.is`, but treats\\nImmutable `Collection`s as values, equal if the second `Collection` includes\\nequivalent values.\",\"description\":\"It's used throughout Immutable when checking for equality, including `Map`\\nkey equality and `Set` membership.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map, is } = require('immutable')\\nconst map1 = Map({ a: 1, b: 1, c: 1 })\\nconst map2 = Map({ a: 1, b: 1, c: 1 })\\nassert.equal(map1 !== map2, true)\\nassert.equal(Object.is(map1, map2), false)\\nassert.equal(is(map1, map2), true)\\n```\\n\\n`is()` compares primitive types like strings and numbers, Immutable.js\\ncollections like `Map` and `List`, but also any custom object which\\nimplements `ValueObject` by providing `equals()` and `hashCode()` methods.\\n\\nNote: Unlike `Object.is`, `Immutable.is` assumes `0` and `-0` are the same\\nvalue, matching the behavior of ES6 Map key equality.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"first\",\"type\":{\"k\":17}},{\"name\":\"second\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4858}]}},\"hash\":{\"call\":{\"doc\":{\"synopsis\":\"The `hash()` function is an important part of how Immutable determines if\\ntwo values are equivalent and is used to determine how to store those\\nvalues. Provided with any value, `hash()` will return a 31-bit integer.\",\"description\":\"When designing Objects which may be equal, it's important that when a\\n`.equals()` method returns true, that both values `.hashCode()` method\\nreturn the same value. `hash()` may be used to produce those values.\\n\\nFor non-Immutable Objects that do not provide a `.hashCode()` functions\\n(including plain Objects, plain Arrays, Date objects, etc), a unique hash\\nvalue will be created for each *instance*. That is, the create hash\\nrepresents referential equality, and not value equality for Objects. This\\nensures that if that Object is mutated over time that its hash code will\\nremain consistent, allowing Objects to be used as keys and values in\\nImmutable.js collections.\\n\\nNote that `hash()` attempts to balance between speed and avoiding\\ncollisions, however it makes no attempt to produce secure hashes.\\n\\n*New in Version 4.0*\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":2},\"line\":4882}]}},\"isImmutable\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeImmutable` is an Immutable Collection or Record.\",\"description\":\"Note: Still returns true even if the collections is within a `withMutations()`.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { isImmutable, Map, List, Stack } = require('immutable');\\nisImmutable([]); // false\\nisImmutable({}); // false\\nisImmutable(Map()); // true\\nisImmutable(List()); // true\\nisImmutable(Stack()); // true\\nisImmutable(Map().asMutable()); // true\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeImmutable\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4900}]}},\"isCollection\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeCollection` is a Collection, or any of its subclasses.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { isCollection, Map, List, Stack } = require('immutable');\\nisCollection([]); // false\\nisCollection({}); // false\\nisCollection(Map()); // true\\nisCollection(List()); // true\\nisCollection(Stack()); // true\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeCollection\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4915}]}},\"isKeyed\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeKeyed` is a Collection.Keyed, or any of its subclasses.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { isKeyed, Map, List, Stack } = require('immutable');\\nisKeyed([]); // false\\nisKeyed({}); // false\\nisKeyed(Map()); // true\\nisKeyed(List()); // false\\nisKeyed(Stack()); // false\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeKeyed\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4930}]}},\"isIndexed\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeIndexed` is a Collection.Indexed, or any of its subclasses.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { isIndexed, Map, List, Stack, Set } = require('immutable');\\nisIndexed([]); // false\\nisIndexed({}); // false\\nisIndexed(Map()); // false\\nisIndexed(List()); // true\\nisIndexed(Stack()); // true\\nisIndexed(Set()); // false\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeIndexed\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4946}]}},\"isAssociative\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeAssociative` is either a Keyed or Indexed Collection.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { isAssociative, Map, List, Stack, Set } = require('immutable');\\nisAssociative([]); // false\\nisAssociative({}); // false\\nisAssociative(Map()); // true\\nisAssociative(List()); // true\\nisAssociative(Stack()); // true\\nisAssociative(Set()); // false\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeAssociative\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4962}]}},\"isOrdered\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeOrdered` is a Collection where iteration order is well\\ndefined. True for Collection.Indexed as well as OrderedMap and OrderedSet.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { isOrdered, Map, OrderedMap, List, Set } = require('immutable');\\nisOrdered([]); // false\\nisOrdered({}); // false\\nisOrdered(Map()); // false\\nisOrdered(OrderedMap()); // true\\nisOrdered(List()); // true\\nisOrdered(Set()); // false\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeOrdered\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4979}]}},\"isValueObject\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeValue` is a JavaScript Object which has *both* `equals()`\\nand `hashCode()` methods.\",\"description\":\"Any two instances of *value objects* can be compared for value equality with\\n`Immutable.is()` and can be used as keys in a `Map` or members in a `Set`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeValue\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4988}]}},\"isSeq\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeSeq` is a Seq.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeSeq\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4994}]}},\"isList\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeList` is a List.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeList\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4999}]}},\"isMap\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeMap` is a Map.\",\"description\":\"Also true for OrderedMaps.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeMap\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":5006}]}},\"isOrderedMap\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeOrderedMap` is an OrderedMap.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeOrderedMap\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":5011}]}},\"isStack\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeStack` is a Stack.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeStack\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":5016}]}},\"isSet\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeSet` is a Set.\",\"description\":\"Also true for OrderedSets.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeSet\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":5023}]}},\"isOrderedSet\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeOrderedSet` is an OrderedSet.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeOrderedSet\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":5028}]}},\"isRecord\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeRecord` is a Record.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeRecord\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":5033}]}},\"get\":{\"call\":{\"doc\":{\"synopsis\":\"Returns the value within the provided collection associated with the\\nprovided key, or notSetValue if the key is not defined in the collection.\",\"description\":\"A functional alternative to `collection.get(key)` which will also work on\\nplain Objects and Arrays as an alternative for `collection[key]`.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { get } = require('immutable')\\nget([ 'dog', 'frog', 'cat' ], 2) // 'frog'\\nget({ x: 123, y: 456 }, 'x') // 123\\nget({ x: 123, y: 456 }, 'z', 'ifNotSet') // 'ifNotSet'\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\",\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":5052},{\"typeParams\":[\"K\",\"V\",\"NSV\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]},\"line\":5053},{\"typeParams\":[\"TProps\",\"K\"],\"params\":[{\"name\":\"record\",\"type\":{\"k\":9,\"name\":\"Record\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":17}}],\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}},\"line\":5054},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"key\",\"type\":{\"k\":2}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":5055},{\"typeParams\":[\"V\",\"NSV\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]},\"line\":5056},{\"typeParams\":[\"C\",\"K\"],\"params\":[{\"name\":\"object\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":17}}],\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"C\"},\"index\":{\"k\":8,\"param\":\"K\"}},\"line\":5057},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}},{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":5058},{\"typeParams\":[\"V\",\"NSV\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}},{\"name\":\"key\",\"type\":{\"k\":3}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]},\"line\":5059}]}},\"has\":{\"call\":{\"doc\":{\"synopsis\":\"Returns true if the key is defined in the provided collection.\",\"description\":\"A functional alternative to `collection.has(key)` which will also work with\\nplain Objects and Arrays as an alternative for\\n`collection.hasOwnProperty(key)`.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { has } = require('immutable')\\nhas([ 'dog', 'frog', 'cat' ], 2) // true\\nhas([ 'dog', 'frog', 'cat' ], 5) // false\\nhas({ x: 123, y: 456 }, 'x') // true\\nhas({ x: 123, y: 456 }, 'z') // false\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Object\"}},{\"name\":\"key\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":5077}]}},\"remove\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the value at key removed.\",\"description\":\"A functional alternative to `collection.remove(key)` which will also work\\nwith plain Objects and Arrays as an alternative for\\n`delete collectionCopy[key]`.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { remove } = require('immutable')\\nconst originalArray = [ 'dog', 'frog', 'cat' ]\\nremove(originalArray, 1) // [ 'dog', 'cat' ]\\nconsole.log(originalArray) // [ 'dog', 'frog', 'cat' ]\\nconst originalObject = { x: 123, y: 456 }\\nremove(originalObject, 'x') // { y: 456 }\\nconsole.log(originalObject) // { x: 123, y: 456 }\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\",\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5097},{\"typeParams\":[\"TProps\",\"C\",\"K\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5098},{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":2}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5099},{\"typeParams\":[\"C\",\"K\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5100},{\"typeParams\":[\"C\",\"K\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5101}]}},\"set\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the value at key set to the provided\\nvalue.\",\"description\":\"A functional alternative to `collection.set(key, value)` which will also\\nwork with plain Objects and Arrays as an alternative for\\n`collectionCopy[key] = value`.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { set } = require('immutable')\\nconst originalArray = [ 'dog', 'frog', 'cat' ]\\nset(originalArray, 1, 'cow') // [ 'dog', 'cow', 'cat' ]\\nconsole.log(originalArray) // [ 'dog', 'frog', 'cat' ]\\nconst originalObject = { x: 123, y: 456 }\\nset(originalObject, 'x', 789) // { x: 789, y: 456 }\\nconsole.log(originalObject) // { x: 123, y: 456 }\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\",\"V\",\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5122},{\"typeParams\":[\"TProps\",\"C\",\"K\"],\"params\":[{\"name\":\"record\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5123},{\"typeParams\":[\"V\",\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5124},{\"typeParams\":[\"C\",\"K\"],\"params\":[{\"name\":\"object\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"C\"},\"index\":{\"k\":8,\"param\":\"K\"}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5125},{\"typeParams\":[\"V\",\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":3}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5126}]}},\"update\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the value at key set to the result of\\nproviding the existing value to the updating function.\",\"description\":\"A functional alternative to `collection.update(key, fn)` which will also\\nwork with plain Objects and Arrays as an alternative for\\n`collectionCopy[key] = fn(collection[key])`.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { update } = require('immutable')\\nconst originalArray = [ 'dog', 'frog', 'cat' ]\\nupdate(originalArray, 1, val => val.toUpperCase()) // [ 'dog', 'FROG', 'cat' ]\\nconsole.log(originalArray) // [ 'dog', 'frog', 'cat' ]\\nconst originalObject = { x: 123, y: 456 }\\nupdate(originalObject, 'x', val => val * 6) // { x: 738, y: 456 }\\nconsole.log(originalObject) // { x: 123, y: 456 }\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\",\"V\",\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"V\"}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5147},{\"typeParams\":[\"K\",\"V\",\"C\",\"NSV\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]}}],\"type\":{\"k\":8,\"param\":\"V\"}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5148},{\"typeParams\":[\"TProps\",\"C\",\"K\"],\"params\":[{\"name\":\"record\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}}}],\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5149},{\"typeParams\":[\"TProps\",\"C\",\"K\",\"NSV\"],\"params\":[{\"name\":\"record\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":12,\"types\":[{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}},{\"k\":8,\"param\":\"NSV\"}]}}],\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5150},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"V\"}}}],\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":5151},{\"typeParams\":[\"V\",\"NSV\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]}}],\"type\":{\"k\":8,\"param\":\"V\"}}}],\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":5152},{\"typeParams\":[\"C\",\"K\"],\"params\":[{\"name\":\"object\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"C\"},\"index\":{\"k\":8,\"param\":\"K\"}}}],\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"C\"},\"index\":{\"k\":8,\"param\":\"K\"}}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5153},{\"typeParams\":[\"C\",\"K\",\"NSV\"],\"params\":[{\"name\":\"object\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":12,\"types\":[{\"k\":15,\"type\":{\"k\":8,\"param\":\"C\"},\"index\":{\"k\":8,\"param\":\"K\"}},{\"k\":8,\"param\":\"NSV\"}]}}],\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"C\"},\"index\":{\"k\":8,\"param\":\"K\"}}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5154},{\"typeParams\":[\"V\",\"C\",\"K\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"V\"}}}],\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]},\"line\":5155},{\"typeParams\":[\"V\",\"C\",\"K\",\"NSV\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]}}],\"type\":{\"k\":8,\"param\":\"V\"}}}],\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]},\"line\":5156}]}},\"getIn\":{\"call\":{\"doc\":{\"synopsis\":\"Returns the value at the provided key path starting at the provided\\ncollection, or notSetValue if the key path is not defined.\",\"description\":\"A functional alternative to `collection.getIn(keypath)` which will also\\nwork with plain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { getIn } = require('immutable')\\ngetIn({ x: { y: { z: 123 }}}, ['x', 'y', 'z']) // 123\\ngetIn({ x: { y: { z: 123 }}}, ['x', 'q', 'p'], 'ifNotSet') // 'ifNotSet'\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"collection\",\"type\":{\"k\":17}},{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"notSetValue\",\"type\":{\"k\":17}}],\"type\":{\"k\":17},\"line\":5172}]}},\"hasIn\":{\"call\":{\"doc\":{\"synopsis\":\"Returns true if the key path is defined in the provided collection.\",\"description\":\"A functional alternative to `collection.hasIn(keypath)` which will also\\nwork with plain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { hasIn } = require('immutable')\\nhasIn({ x: { y: { z: 123 }}}, ['x', 'y', 'z']) // true\\nhasIn({ x: { y: { z: 123 }}}, ['x', 'q', 'p']) // false\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"collection\",\"type\":{\"k\":17}},{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}}],\"type\":{\"k\":1},\"line\":5187}]}},\"removeIn\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the value at the key path removed.\",\"description\":\"A functional alternative to `collection.removeIn(keypath)` which will also\\nwork with plain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { removeIn } = require('immutable')\\nconst original = { x: { y: { z: 123 }}}\\nremoveIn(original, ['x', 'y', 'z']) // { x: { y: {}}}\\nconsole.log(original) // { x: { y: { z: 123 }}}\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5203}]}},\"setIn\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the value at the key path set to the\\nprovided value.\",\"description\":\"A functional alternative to `collection.setIn(keypath)` which will also\\nwork with plain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { setIn } = require('immutable')\\nconst original = { x: { y: { z: 123 }}}\\nsetIn(original, ['x', 'y', 'z'], 456) // { x: { y: { z: 456 }}}\\nconsole.log(original) // { x: { y: { z: 123 }}}\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5220}]}},\"updateIn\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the value at key path set to the\\nresult of providing the existing value to the updating function.\",\"description\":\"A functional alternative to `collection.updateIn(keypath)` which will also\\nwork with plain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { updateIn } = require('immutable')\\nconst original = { x: { y: { z: 123 }}}\\nupdateIn(original, ['x', 'y', 'z'], val => val * 6) // { x: { y: { z: 738 }}}\\nconsole.log(original) // { x: { y: { z: 123 }}}\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5237},{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"notSetValue\",\"type\":{\"k\":17}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5238}]}},\"merge\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the remaining collections merged in.\",\"description\":\"A functional alternative to `collection.merge()` which will also work with\\nplain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { merge } = require('immutable')\\nconst original = { x: 123, y: 456 }\\nmerge(original, { y: 789, z: 'abc' }) // { x: 123, y: 789, z: 'abc' }\\nconsole.log(original) // { x: 123, y: 456 }\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":17},{\"k\":17}]}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":17}}]}]}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5254}]}},\"mergeWith\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the remaining collections merged in,\\ncalling the `merger` function whenever an existing value is encountered.\",\"description\":\"A functional alternative to `collection.mergeWith()` which will also work\\nwith plain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { mergeWith } = require('immutable')\\nconst original = { x: 123, y: 456 }\\nmergeWith(\\n  (oldVal, newVal) => oldVal + newVal,\\n  original,\\n  { y: 789, z: 'abc' }\\n) // { x: 123, y: 1245, z: 'abc' }\\nconsole.log(original) // { x: 123, y: 456 }\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"merger\",\"type\":{\"k\":7,\"params\":[{\"name\":\"oldVal\",\"type\":{\"k\":17}},{\"name\":\"newVal\",\"type\":{\"k\":17}},{\"name\":\"key\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}},{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":17},{\"k\":17}]}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":17}}]}]}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5278}]}},\"mergeDeep\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the remaining collections merged in\\ndeeply (recursively).\",\"description\":\"A functional alternative to `collection.mergeDeep()` which will also work\\nwith plain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { mergeDeep } = require('immutable')\\nconst original = { x: { y: 123 }}\\nmergeDeep(original, { x: { z: 456 }}) // { x: { y: 123, z: 456 }}\\nconsole.log(original) // { x: { y: 123 }}\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":17},{\"k\":17}]}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":17}}]}]}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5299}]}},\"mergeDeepWith\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the remaining collections merged in\\ndeeply (recursively), calling the `merger` function whenever an existing\\nvalue is encountered.\",\"description\":\"A functional alternative to `collection.mergeDeepWith()` which will also\\nwork with plain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { mergeDeepWith } = require('immutable')\\nconst original = { x: { y: 123 }}\\nmergeDeepWith(\\n  (oldVal, newVal) => oldVal + newVal,\\n  original,\\n  { x: { y: 456 }}\\n) // { x: { y: 579 }}\\nconsole.log(original) // { x: { y: 123 }}\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"merger\",\"type\":{\"k\":7,\"params\":[{\"name\":\"oldVal\",\"type\":{\"k\":17}},{\"name\":\"newVal\",\"type\":{\"k\":17}},{\"name\":\"key\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}},{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":17},{\"k\":17}]}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":17}}]}]}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5324}]}}}},\"immutable\":{\"module\":{}}}","var TypeKind = {\n  Any: 0,\n\n  Boolean: 1,\n  Number: 2,\n  String: 3,\n  Object: 4,\n  Array: 5,\n  Never: 6,\n  Function: 7,\n\n  Param: 8,\n  Type: 9,\n\n  This: 10,\n  Undefined: 11,\n  Union: 12,\n  Intersection: 13,\n  Tuple: 14,\n  Indexed: 15,\n  Operator: 16,\n\n  Unknown: 17,\n};\n\nmodule.exports = TypeKind;\n","var $__0=    require('../../'),Seq=$__0.Seq;\n// Note: intentionally using raw defs, not getTypeDefs to avoid circular ref.\nvar defs = require('../generated/immutable.d.json');\n\nfunction collectMemberGroups(interfaceDef, options) {\n  var members = {};\n\n  if (interfaceDef) {\n    collectFromDef(interfaceDef);\n  }\n\n  var groups = { '': [] };\n\n  if (options.showInGroups) {\n    Seq(members).forEach(function(member)  {\n      (groups[member.group] || (groups[member.group] = [])).push(member);\n    });\n  } else {\n    groups[''] = Seq(members)\n      .sortBy(function(member)  {return member.memberName;})\n      .toArray();\n  }\n\n  if (!options.showInherited) {\n    groups = Seq(groups)\n      .map(function(members)  {return members.filter(function(member)  {return !member.inherited;});})\n      .toObject();\n  }\n\n  return groups;\n\n  function collectFromDef(def, name) {\n    def.groups &&\n      def.groups.forEach(function(g)  {\n        Seq(g.members).forEach(function(memberDef, memberName)  {\n          collectMember(g.title || '', memberName, memberDef);\n        });\n      });\n\n    def.extends &&\n      def.extends.forEach(function(e)  {\n        var superModule = defs.Immutable;\n        e.name.split('.').forEach(function(part)  {\n          superModule =\n            superModule && superModule.module && superModule.module[part];\n        });\n        var superInterface = superModule && superModule.interface;\n        if (superInterface) {\n          collectFromDef(superInterface, e.name);\n        }\n      });\n\n    function collectMember(group, memberName, memberDef) {\n      var member = members[memberName];\n      if (member) {\n        if (!member.inherited) {\n          member.overrides = { name:name, def:def, memberDef:memberDef };\n        }\n        if (!member.group && group) {\n          member.group = group;\n        }\n      } else {\n        member = {\n          group:group,\n          memberName: memberName.substr(1),\n          memberDef:memberDef,\n        };\n        if (def !== interfaceDef) {\n          member.inherited = { name:name, def:def };\n        }\n        members[memberName] = member;\n      }\n    }\n  }\n}\n\nmodule.exports = collectMemberGroups;\n","var markdownDocs = require('./markdownDocs');\nvar defs = require('../generated/immutable.d.json');\n\nmarkdownDocs(defs);\n\nmodule.exports = defs;\n","var marked = require('marked');\nvar $__0=    require('../../'),Seq=$__0.Seq;\nvar prism = require('./prism');\nvar collectMemberGroups = require('./collectMemberGroups');\n// Note: intentionally using raw defs, not getTypeDefs to avoid circular ref.\nvar defs = require('../generated/immutable.d.json');\n\nfunction collectAllMembersForAllTypes(defs) {\n  var allMembers = new WeakMap();\n  _collectAllMembersForAllTypes(defs);\n  return allMembers;\n  function _collectAllMembersForAllTypes(defs) {\n    Seq(defs).forEach(function(def)  {\n      if (def.interface) {\n        var groups = collectMemberGroups(def.interface, {\n          showInherited: true,\n        });\n        allMembers.set(\n          def.interface,\n          Seq.Keyed(\n            groups[''].map(function(member)  {return [member.memberName, member.memberDef];})\n          ).toObject()\n        );\n      }\n      if (def.module) {\n        _collectAllMembersForAllTypes(def.module);\n      }\n    });\n    return allMembers;\n  }\n}\n\nvar allMembers = collectAllMembersForAllTypes(defs);\n\n// functions come before keywords\nprism.languages.insertBefore('javascript', 'keyword', {\n  var: /\\b(this)\\b/g,\n  'block-keyword': /\\b(if|else|while|for|function)\\b/g,\n  primitive: /\\b(true|false|null|undefined)\\b/g,\n  function: prism.languages.function,\n});\n\nprism.languages.insertBefore('javascript', {\n  qualifier: /\\b[A-Z][a-z0-9_]+/g,\n});\n\nmarked.setOptions({\n  xhtml: true,\n  highlight: function(code)  {return prism.highlight(code, prism.languages.javascript);},\n});\n\nvar renderer = new marked.Renderer();\n\nconst runkitRegExp = /^<!--\\s*runkit:activate((.|\\n)*)-->(.|\\n)*$/;\nconst runkitContext = { options: '{}', activated: false };\n\nrenderer.html = function (text) {\n  const result = runkitRegExp.exec(text);\n\n  if (!result) return text;\n\n  runkitContext.activated = true;\n  try {\n    runkitContext.options = result[1] ? JSON.parse(result[1]) : {};\n  } catch (e) {\n    runkitContext.options = {};\n  }\n  return text;\n};\n\nrenderer.code = function (code, lang, escaped) {\n  if (this.options.highlight) {\n    var out = this.options.highlight(code, lang);\n    if (out != null && out !== code) {\n      escaped = true;\n      code = out;\n    }\n  }\n\n  const runItButton = runkitContext.activated\n    ? '<a class=\"try-it\" data-options=\"' +\n      escape(JSON.stringify(runkitContext.options)) +\n      '\" onClick=\"runIt(this)\">run it</a>'\n    : '';\n\n  runkitContext.activated = false;\n  runkitContext.options = '{}';\n\n  return (\n    '<code class=\"codeBlock\">' +\n    (escaped ? code : escapeCode(code, true)) +\n    runItButton +\n    '</code>'\n  );\n};\n\nvar METHOD_RX = /^(\\w+)(?:[#.](\\w+))?(?:\\(\\))?$/;\nvar PARAM_RX = /^\\w+$/;\nvar MDN_TYPES = {\n  Array: true,\n  Object: true,\n  JSON: true,\n};\nvar MDN_BASE_URL =\n  'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/';\n\nrenderer.codespan = function (text) {\n  return '<code>' + decorateCodeSpan(text, this.options) + '</code>';\n};\n\nfunction decorateCodeSpan(text, options) {\n  var context = options.context;\n\n  if (\n    context.signatures &&\n    PARAM_RX.test(text) &&\n    context.signatures.some(\n      function(sig)  {return sig.params && sig.params.some(function(param)  {return param.name === text;});}\n    )\n  ) {\n    return '<span class=\"t param\">' + text + '</span>';\n  }\n\n  var method = METHOD_RX.exec(text);\n  if (method) {\n    method = method.slice(1).filter(Boolean);\n    if (MDN_TYPES[method[0]]) {\n      return (\n        '<a href=\"' + MDN_BASE_URL + method.join('/') + '\">' + text + '</a>'\n      );\n    }\n    if (\n      context.typePath &&\n      !arrEndsWith(context.typePath, method) &&\n      !arrEndsWith(context.typePath.slice(0, -1), method)\n    ) {\n      var path = findPath(context, method);\n      if (path) {\n        var relPath = context.relPath || '';\n        return (\n          '<a target=\"_self\" href=\"' +\n          relPath +\n          '#/' +\n          path.slice(1).join('/') +\n          '\">' +\n          text +\n          '</a>'\n        );\n      }\n    }\n  }\n\n  if (options.highlight) {\n    return options.highlight(unescapeCode(text), prism.languages.javascript);\n  }\n\n  return text;\n}\n\nfunction arrEndsWith(arr1, arr2) {\n  for (var ii = 1; ii <= arr2.length; ii++) {\n    if (arr2[arr2.length - ii] !== arr1[arr1.length - ii]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction findPath(context, search) {\n  var relative = context.typePath;\n\n  for (var ii = 0; ii <= relative.length; ii++) {\n    var path = relative.slice(0, relative.length - ii).concat(search);\n    if (\n      path.reduce(\n        function(def, name) \n          {return def &&\n          ((def.module && def.module[name]) ||\n            (def.interface &&\n              allMembers &&\n              allMembers.get(def.interface)[name]) ||\n            undefined);},\n        { module: defs }\n      )\n    ) {\n      return path;\n    }\n  }\n}\n\nfunction escapeCode(code) {\n  return code\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;');\n}\n\nfunction unescapeCode(code) {\n  return code\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&quot;/g, '\"')\n    .replace(/&#39;/g, \"'\")\n    .replace(/&amp;/g, '&');\n}\n\nfunction markdown(content, context) {\n  context || (context = {});\n  return content ? marked(content, { renderer:renderer, context:context }) : content;\n}\n\nmodule.exports = markdown;\n","var $__0=    require('../../'),Seq=$__0.Seq;\nvar markdown = require('./markdown');\n\nfunction markdownDocs(defs) {\n  markdownTypes(defs, []);\n\n  function markdownTypes(typeDefs, path) {\n    Seq(typeDefs).forEach(function(typeDef, typeName)  {\n      var typePath = path.concat(typeName);\n      markdownDoc(typeDef.doc, { typePath:typePath });\n      typeDef.call &&\n        markdownDoc(typeDef.call.doc, {\n          typePath:typePath,\n          signatures: typeDef.call.signatures,\n        });\n      if (typeDef.interface) {\n        markdownDoc(typeDef.interface.doc, { defs:defs, typePath:typePath });\n        Seq(typeDef.interface.groups).forEach(function(group) \n          {return Seq(group.members).forEach(function(member, memberName) \n            {return markdownDoc(member.doc, {\n              typePath: typePath.concat(memberName.slice(1)),\n              signatures: member.signatures,\n            });}\n          );}\n        );\n      }\n      typeDef.module && markdownTypes(typeDef.module, typePath);\n    });\n  }\n}\n\nfunction markdownDoc(doc, context) {\n  if (!doc) {\n    return;\n  }\n  doc.synopsis && (doc.synopsis = markdown(doc.synopsis, context));\n  doc.description && (doc.description = markdown(doc.description, context));\n  doc.notes &&\n    doc.notes.forEach(function(note)  {\n      if (note.name !== 'alias') {\n        note.body = markdown(note.body, context);\n      }\n    });\n}\n\nmodule.exports = markdownDocs;\n","/* eslint-disable */\n\n/* **********************************************\n     Begin prism-core.js\n********************************************** */\n\nself =\n  typeof window !== 'undefined'\n    ? window // if in browser\n    : typeof WorkerGlobalScope !== 'undefined' &&\n      self instanceof WorkerGlobalScope\n    ? self // if in worker\n    : {}; // if in node js\n\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n * MIT license http://www.opensource.org/licenses/mit-license.php/\n * @author Lea Verou http://lea.verou.me\n */\n\nvar Prism = (function () {\n  // Private helper vars\n  var lang = /\\blang(?:uage)?-(?!\\*)(\\w+)\\b/i;\n\n  var _ = (self.Prism = {\n    util: {\n      encode: function (tokens) {\n        if (tokens instanceof Token) {\n          return new Token(\n            tokens.type,\n            _.util.encode(tokens.content),\n            tokens.alias\n          );\n        } else if (_.util.type(tokens) === 'Array') {\n          return tokens.map(_.util.encode);\n        } else {\n          return tokens\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/\\u00a0/g, ' ');\n        }\n      },\n\n      type: function (o) {\n        return Object.prototype.toString.call(o).match(/\\[object (\\w+)\\]/)[1];\n      },\n\n      // Deep clone a language definition (e.g. to extend it)\n      clone: function (o) {\n        var type = _.util.type(o);\n\n        switch (type) {\n          case 'Object':\n            var clone = {};\n\n            for (var key in o) {\n              if (o.hasOwnProperty(key)) {\n                clone[key] = _.util.clone(o[key]);\n              }\n            }\n\n            return clone;\n\n          case 'Array':\n            return o.slice();\n        }\n\n        return o;\n      },\n    },\n\n    languages: {\n      extend: function (id, redef) {\n        var lang = _.util.clone(_.languages[id]);\n\n        for (var key in redef) {\n          lang[key] = redef[key];\n        }\n\n        return lang;\n      },\n\n      /**\n       * Insert a token before another token in a language literal\n       * As this needs to recreate the object (we cannot actually insert before keys in object literals),\n       * we cannot just provide an object, we need anobject and a key.\n       * @param inside The key (or language id) of the parent\n       * @param before The key to insert before. If not provided, the function appends instead.\n       * @param insert Object with the key/value pairs to insert\n       * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.\n       */\n      insertBefore: function (inside, before, insert, root) {\n        root = root || _.languages;\n        var grammar = root[inside];\n\n        if (arguments.length == 2) {\n          insert = arguments[1];\n\n          for (var newToken in insert) {\n            if (insert.hasOwnProperty(newToken)) {\n              grammar[newToken] = insert[newToken];\n            }\n          }\n\n          return grammar;\n        }\n\n        var ret = {};\n\n        for (var token in grammar) {\n          if (grammar.hasOwnProperty(token)) {\n            if (token == before) {\n              for (var newToken in insert) {\n                if (insert.hasOwnProperty(newToken)) {\n                  ret[newToken] = insert[newToken];\n                }\n              }\n            }\n\n            ret[token] = grammar[token];\n          }\n        }\n\n        // Update references in other language definitions\n        _.languages.DFS(_.languages, function (key, value) {\n          if (value === root[inside] && key != inside) {\n            this[key] = ret;\n          }\n        });\n\n        return (root[inside] = ret);\n      },\n\n      // Traverse a language definition with Depth First Search\n      DFS: function (o, callback, type) {\n        for (var i in o) {\n          if (o.hasOwnProperty(i)) {\n            callback.call(o, i, o[i], type || i);\n\n            if (_.util.type(o[i]) === 'Object') {\n              _.languages.DFS(o[i], callback);\n            } else if (_.util.type(o[i]) === 'Array') {\n              _.languages.DFS(o[i], callback, i);\n            }\n          }\n        }\n      },\n    },\n\n    highlightAll: function (async, callback) {\n      var elements = document.querySelectorAll(\n        'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'\n      );\n\n      for (var i = 0, element; (element = elements[i++]); ) {\n        _.highlightElement(element, async === true, callback);\n      }\n    },\n\n    highlightElement: function (element, async, callback) {\n      // Find language\n      var language,\n        grammar,\n        parent = element;\n\n      while (parent && !lang.test(parent.className)) {\n        parent = parent.parentNode;\n      }\n\n      if (parent) {\n        language = (parent.className.match(lang) || [, ''])[1];\n        grammar = _.languages[language];\n      }\n\n      if (!grammar) {\n        return;\n      }\n\n      // Set language on the element, if not present\n      element.className =\n        element.className.replace(lang, '').replace(/\\s+/g, ' ') +\n        ' language-' +\n        language;\n\n      // Set language on the parent, for styling\n      parent = element.parentNode;\n\n      if (/pre/i.test(parent.nodeName)) {\n        parent.className =\n          parent.className.replace(lang, '').replace(/\\s+/g, ' ') +\n          ' language-' +\n          language;\n      }\n\n      var code = element.textContent;\n\n      if (!code) {\n        return;\n      }\n\n      var env = {\n        element: element,\n        language: language,\n        grammar: grammar,\n        code: code,\n      };\n\n      _.hooks.run('before-highlight', env);\n\n      if (async && self.Worker) {\n        var worker = new Worker(_.filename);\n\n        worker.onmessage = function (evt) {\n          env.highlightedCode = Token.stringify(JSON.parse(evt.data), language);\n\n          _.hooks.run('before-insert', env);\n\n          env.element.innerHTML = env.highlightedCode;\n\n          callback && callback.call(env.element);\n          _.hooks.run('after-highlight', env);\n        };\n\n        worker.postMessage(\n          JSON.stringify({\n            language: env.language,\n            code: env.code,\n          })\n        );\n      } else {\n        env.highlightedCode = _.highlight(env.code, env.grammar, env.language);\n\n        _.hooks.run('before-insert', env);\n\n        env.element.innerHTML = env.highlightedCode;\n\n        callback && callback.call(element);\n\n        _.hooks.run('after-highlight', env);\n      }\n    },\n\n    highlight: function (text, grammar, language) {\n      var tokens = _.tokenize(text, grammar);\n      return Token.stringify(_.util.encode(tokens), language);\n    },\n\n    tokenize: function (text, grammar, language) {\n      var Token = _.Token;\n\n      var strarr = [text];\n\n      var rest = grammar.rest;\n\n      if (rest) {\n        for (var token in rest) {\n          grammar[token] = rest[token];\n        }\n\n        delete grammar.rest;\n      }\n\n      tokenloop: for (var token in grammar) {\n        if (!grammar.hasOwnProperty(token) || !grammar[token]) {\n          continue;\n        }\n\n        var patterns = grammar[token];\n        patterns = _.util.type(patterns) === 'Array' ? patterns : [patterns];\n\n        for (var j = 0; j < patterns.length; ++j) {\n          var pattern = patterns[j],\n            inside = pattern.inside,\n            lookbehind = !!pattern.lookbehind,\n            lookbehindLength = 0,\n            alias = pattern.alias;\n\n          pattern = pattern.pattern || pattern;\n\n          for (var i = 0; i < strarr.length; i++) {\n            // Dont cache length as it changes during the loop\n\n            var str = strarr[i];\n\n            if (strarr.length > text.length) {\n              // Something went terribly wrong, ABORT, ABORT!\n              break tokenloop;\n            }\n\n            if (str instanceof Token) {\n              continue;\n            }\n\n            pattern.lastIndex = 0;\n\n            var match = pattern.exec(str);\n\n            if (match) {\n              if (lookbehind) {\n                lookbehindLength = match[1].length;\n              }\n\n              var from = match.index - 1 + lookbehindLength,\n                match = match[0].slice(lookbehindLength),\n                len = match.length,\n                to = from + len,\n                before = str.slice(0, from + 1),\n                after = str.slice(to + 1);\n\n              var args = [i, 1];\n\n              if (before) {\n                args.push(before);\n              }\n\n              var wrapped = new Token(\n                token,\n                inside ? _.tokenize(match, inside) : match,\n                alias\n              );\n\n              args.push(wrapped);\n\n              if (after) {\n                args.push(after);\n              }\n\n              Array.prototype.splice.apply(strarr, args);\n            }\n          }\n        }\n      }\n\n      return strarr;\n    },\n\n    hooks: {\n      all: {},\n\n      add: function (name, callback) {\n        var hooks = _.hooks.all;\n\n        hooks[name] = hooks[name] || [];\n\n        hooks[name].push(callback);\n      },\n\n      run: function (name, env) {\n        var callbacks = _.hooks.all[name];\n\n        if (!callbacks || !callbacks.length) {\n          return;\n        }\n\n        for (var i = 0, callback; (callback = callbacks[i++]); ) {\n          callback(env);\n        }\n      },\n    },\n  });\n\n  var Token = (_.Token = function (type, content, alias) {\n    this.type = type;\n    this.content = content;\n    this.alias = alias;\n  });\n\n  Token.stringify = function (o, language, parent) {\n    if (typeof o == 'string') {\n      return o;\n    }\n\n    if (Object.prototype.toString.call(o) == '[object Array]') {\n      return o\n        .map(function (element) {\n          return Token.stringify(element, language, o);\n        })\n        .join('');\n    }\n\n    var env = {\n      type: o.type,\n      content: Token.stringify(o.content, language, parent),\n      tag: 'span',\n      classes: ['token', o.type],\n      attributes: {},\n      language: language,\n      parent: parent,\n    };\n\n    if (env.type == 'comment') {\n      env.attributes['spellcheck'] = 'true';\n    }\n\n    if (o.alias) {\n      var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];\n      Array.prototype.push.apply(env.classes, aliases);\n    }\n\n    _.hooks.run('wrap', env);\n\n    var attributes = '';\n\n    for (var name in env.attributes) {\n      attributes += name + '=\"' + (env.attributes[name] || '') + '\"';\n    }\n\n    return (\n      '<' +\n      env.tag +\n      ' class=\"' +\n      env.classes.join(' ') +\n      '\" ' +\n      attributes +\n      '>' +\n      env.content +\n      '</' +\n      env.tag +\n      '>'\n    );\n  };\n\n  if (!self.document) {\n    if (!self.addEventListener) {\n      // in Node.js\n      return self.Prism;\n    }\n    // In worker\n    self.addEventListener(\n      'message',\n      function (evt) {\n        var message = JSON.parse(evt.data),\n          lang = message.language,\n          code = message.code;\n\n        self.postMessage(\n          JSON.stringify(_.util.encode(_.tokenize(code, _.languages[lang])))\n        );\n        self.close();\n      },\n      false\n    );\n\n    return self.Prism;\n  }\n\n  // Get current script and highlight\n  var script = document.getElementsByTagName('script');\n\n  script = script[script.length - 1];\n\n  if (script) {\n    _.filename = script.src;\n\n    if (document.addEventListener && !script.hasAttribute('data-manual')) {\n      document.addEventListener('DOMContentLoaded', _.highlightAll);\n    }\n  }\n\n  return self.Prism;\n})();\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = Prism;\n}\n\n/* **********************************************\n     Begin prism-markup.js\n********************************************** */\n\nPrism.languages.markup = {\n  comment: /<!--[\\w\\W]*?-->/g,\n  prolog: /<\\?.+?\\?>/,\n  doctype: /<!DOCTYPE.+?>/,\n  cdata: /<!\\[CDATA\\[[\\w\\W]*?]]>/i,\n  tag: {\n    pattern:\n      /<\\/?[\\w:-]+\\s*(?:\\s+[\\w:-]+(?:=(?:(\"|')(\\\\?[\\w\\W])*?\\1|[^\\s'\">=]+))?\\s*)*\\/?>/gi,\n    inside: {\n      tag: {\n        pattern: /^<\\/?[\\w:-]+/i,\n        inside: {\n          punctuation: /^<\\/?/,\n          namespace: /^[\\w-]+?:/,\n        },\n      },\n      'attr-value': {\n        pattern: /=(?:('|\")[\\w\\W]*?(\\1)|[^\\s>]+)/gi,\n        inside: {\n          punctuation: /=|>|\"/g,\n        },\n      },\n      punctuation: /\\/?>/g,\n      'attr-name': {\n        pattern: /[\\w:-]+/g,\n        inside: {\n          namespace: /^[\\w-]+?:/,\n        },\n      },\n    },\n  },\n  entity: /\\&#?[\\da-z]{1,8};/gi,\n};\n\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add('wrap', function (env) {\n  if (env.type === 'entity') {\n    env.attributes['title'] = env.content.replace(/&amp;/, '&');\n  }\n});\n\n/* **********************************************\n     Begin prism-css.js\n********************************************** */\n\nPrism.languages.css = {\n  comment: /\\/\\*[\\w\\W]*?\\*\\//g,\n  atrule: {\n    pattern: /@[\\w-]+?.*?(;|(?=\\s*{))/gi,\n    inside: {\n      punctuation: /[;:]/g,\n    },\n  },\n  url: /url\\(([\"']?).*?\\1\\)/gi,\n  selector: /[^\\{\\}\\s][^\\{\\};]*(?=\\s*\\{)/g,\n  property: /(\\b|\\B)[\\w-]+(?=\\s*:)/gi,\n  string: /(\"|')(\\\\?.)*?\\1/g,\n  important: /\\B!important\\b/gi,\n  punctuation: /[\\{\\};:]/g,\n  function: /[-a-z0-9]+(?=\\()/gi,\n};\n\nif (Prism.languages.markup) {\n  Prism.languages.insertBefore('markup', 'tag', {\n    style: {\n      pattern: /<style[\\w\\W]*?>[\\w\\W]*?<\\/style>/gi,\n      inside: {\n        tag: {\n          pattern: /<style[\\w\\W]*?>|<\\/style>/gi,\n          inside: Prism.languages.markup.tag.inside,\n        },\n        rest: Prism.languages.css,\n      },\n      alias: 'language-css',\n    },\n  });\n\n  Prism.languages.insertBefore(\n    'inside',\n    'attr-value',\n    {\n      'style-attr': {\n        pattern: /\\s*style=(\"|').+?\\1/gi,\n        inside: {\n          'attr-name': {\n            pattern: /^\\s*style/gi,\n            inside: Prism.languages.markup.tag.inside,\n          },\n          punctuation: /^\\s*=\\s*['\"]|['\"]\\s*$/,\n          'attr-value': {\n            pattern: /.+/gi,\n            inside: Prism.languages.css,\n          },\n        },\n        alias: 'language-css',\n      },\n    },\n    Prism.languages.markup.tag\n  );\n}\n\n/* **********************************************\n     Begin prism-clike.js\n********************************************** */\n\nPrism.languages.clike = {\n  comment: [\n    {\n      pattern: /(^|[^\\\\])\\/\\*[\\w\\W]*?\\*\\//g,\n      lookbehind: true,\n    },\n    {\n      pattern: /(^|[^\\\\:])\\/\\/.*?(\\r?\\n|$)/g,\n      lookbehind: true,\n    },\n  ],\n  string: /(\"|')(\\\\?.)*?\\1/g,\n  'class-name': {\n    pattern:\n      /((?:(?:class|interface|extends|implements|trait|instanceof|new)\\s+)|(?:catch\\s+\\())[a-z0-9_\\.\\\\]+/gi,\n    lookbehind: true,\n    inside: {\n      punctuation: /(\\.|\\\\)/,\n    },\n  },\n  keyword:\n    /\\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/g,\n  boolean: /\\b(true|false)\\b/g,\n  function: {\n    pattern: /[a-z0-9_]+\\(/gi,\n    inside: {\n      punctuation: /\\(/,\n    },\n  },\n  number: /\\b-?(0x[\\dA-Fa-f]+|\\d*\\.?\\d+([Ee]-?\\d+)?)\\b/g,\n  operator: /[-+]{1,2}|!|<=?|>=?|={1,3}|&{1,2}|\\|?\\||\\?|\\*|\\/|\\~|\\^|\\%/g,\n  ignore: /&(lt|gt|amp);/gi,\n  punctuation: /[{}[\\];(),.:]/g,\n};\n\n/* **********************************************\n     Begin prism-javascript.js\n********************************************** */\n\nPrism.languages.javascript = Prism.languages.extend('clike', {\n  keyword:\n    /\\b(break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|get|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|set|static|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\\b/g,\n  number: /\\b-?(0x[\\dA-Fa-f]+|\\d*\\.?\\d+([Ee]-?\\d+)?|NaN|-?Infinity)\\b/g,\n});\n\nPrism.languages.insertBefore('javascript', 'keyword', {\n  regex: {\n    pattern:\n      /(^|[^/])\\/(?!\\/)(\\[.+?]|\\\\.|[^/\\r\\n])+\\/[gim]{0,3}(?=\\s*($|[\\r\\n,.;})]))/g,\n    lookbehind: true,\n  },\n});\n\nif (Prism.languages.markup) {\n  Prism.languages.insertBefore('markup', 'tag', {\n    script: {\n      pattern: /<script[\\w\\W]*?>[\\w\\W]*?<\\/script>/gi,\n      inside: {\n        tag: {\n          pattern: /<script[\\w\\W]*?>|<\\/script>/gi,\n          inside: Prism.languages.markup.tag.inside,\n        },\n        rest: Prism.languages.javascript,\n      },\n      alias: 'language-javascript',\n    },\n  });\n}\n\n/* **********************************************\n     Begin prism-file-highlight.js\n********************************************** */\n\n(function () {\n  if (!self.Prism || !self.document || !document.querySelector) {\n    return;\n  }\n\n  var Extensions = {\n    js: 'javascript',\n    html: 'markup',\n    svg: 'markup',\n    xml: 'markup',\n    py: 'python',\n    rb: 'ruby',\n  };\n\n  Array.prototype.slice\n    .call(document.querySelectorAll('pre[data-src]'))\n    .forEach(function (pre) {\n      var src = pre.getAttribute('data-src');\n      var extension = (src.match(/\\.(\\w+)$/) || [, ''])[1];\n      var language = Extensions[extension] || extension;\n\n      var code = document.createElement('code');\n      code.className = 'language-' + language;\n\n      pre.textContent = '';\n\n      code.textContent = 'Loading';\n\n      pre.appendChild(code);\n\n      var xhr = new XMLHttpRequest();\n\n      xhr.open('GET', src, true);\n\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState == 4) {\n          if (xhr.status < 400 && xhr.responseText) {\n            code.textContent = xhr.responseText;\n\n            Prism.highlightElement(code);\n          } else if (xhr.status >= 400) {\n            code.textContent =\n              ' Error ' +\n              xhr.status +\n              ' while fetching file: ' +\n              xhr.statusText;\n          } else {\n            code.textContent = ' Error: File does not exist or is empty';\n          }\n        }\n      };\n\n      xhr.send(null);\n    });\n})();\n","global.runIt = function runIt(button) {\n  if (!global.RunKit) return;\n\n  var container = document.createElement('div');\n  var codeElement = button.parentNode;\n  var parent = codeElement.parentNode;\n\n  parent.insertBefore(container, codeElement);\n  parent.removeChild(codeElement);\n  codeElement.removeChild(button);\n\n  const options = JSON.parse(unescape(button.dataset.options));\n\n  function withCorrectVersion(code) {\n    return code.replace(\n      /require\\('immutable'\\)/g,\n      \"require('immutable@4.0.0-rc.9')\"\n    );\n  }\n\n  global.RunKit.createNotebook({\n    element: container,\n    nodeVersion: options.nodeVersion || '*',\n    preamble: withCorrectVersion(\n      'const assert = (' +\n        makeAssert +\n        \")(require('immutable'));\" +\n        (options.preamble || '')\n    ),\n    source: withCorrectVersion(\n      codeElement.textContent.replace(/\\n(>[^\\n]*\\n?)+$/g, '')\n    ),\n    minHeight: '52px',\n    onLoad: function (notebook) {\n      notebook.evaluate();\n    },\n  });\n};\n\nfunction makeAssert(I) {\n  var isIterable = I.isIterable || I.Iterable.isIterable;\n  var html = (\"\\n    <style>\\n      * {\\n        font-size: 14px;\\n        font-family: monospace;\\n      }\\n\\n      code {\\n        font-family: monospace;\\n        color: #4183C4;\\n        text-decoration: none;\\n        text-decoration: none;\\n        background: rgba(65, 131, 196, 0.1);\\n        border-radius: 2px;\\n        padding: 2px;\\n    }\\n\\n      .success {\\n        color: rgba(84,184,54,1.0);\\n      }\\n\\n      .success:before {\\n        content: \\\"\\\";\\n      }\\n\\n      .failure {\\n        color: rgba(220,47,33,1.0);\\n      }\\n\\n      .failure i {\\n        color: rgba(210,44,31,1.0);\\n      }\\n\\n      .failure:before {\\n        content: \\\"\\\";\\n      }\\n    </style>\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n);\n\n  function compare(lhs, rhs, same, identical) {\n    var both = !identical && isIterable(lhs) && isIterable(rhs);\n\n    if (both) return lhs.equals(rhs);\n\n    return lhs === rhs;\n  }\n\n  function message(lhs, rhs, same, identical) {\n    var result = compare(lhs, rhs, same, identical);\n    var comparison = result\n      ? identical\n        ? 'strict equal to'\n        : 'does equal'\n      : identical\n      ? 'not strict equal to'\n      : 'does not equal';\n    var className = result === same ? 'success' : 'failure';\n    var lhsString = isIterable(lhs) ? lhs + '' : JSON.stringify(lhs);\n    var rhsString = isIterable(rhs) ? rhs + '' : JSON.stringify(rhs);\n\n    return (html += (\"\\n      <span class=\\\"\" + \nclassName + \"\\\">\\n        <code>\" + \nlhsString + \"</code>\\n        \" + \ncomparison + \"\\n        <code>\" + \nrhsString + \"</code>\\n      </span><br/>\"\n));\n  }\n\n  function equal(lhs, rhs) {\n    return message(lhs, rhs, true);\n  }\n\n  function notEqual(lhs, rhs) {\n    return message(lhs, rhs, false);\n  }\n\n  function strictEqual(lhs, rhs) {\n    return message(lhs, rhs, true, true);\n  }\n\n  function notStrictEqual(lhs, rhs) {\n    return message(lhs, rhs, false, true);\n  }\n\n  return { equal:equal, notEqual:notEqual, strictEqual:strictEqual, notStrictEqual:notStrictEqual };\n}\n","var React = require('react');\nvar CSSCore = require('react/lib/CSSCore');\nvar Router = require('react-router');\nvar $__0=    require('../../../../'),Seq=$__0.Seq;\nvar TypeKind = require('../../../lib/TypeKind');\nvar defs = require('../../../lib/getTypeDefs');\n\nvar InterfaceDef = React.createClass({displayName: \"InterfaceDef\",\n  render:function() {\n    var name = this.props.name;\n    var def = this.props.def;\n    return (\n      React.createElement(\"span\", {className: \"t interfaceDef\"}, \n        React.createElement(\"span\", {className: \"t keyword\"}, \"type \"), \n        React.createElement(\"span\", {className: \"t typeName\"}, name), \n        def.typeParams && [\n          '<',\n          Seq(def.typeParams)\n            .map(function(t, k)  \n              {return React.createElement(\"span\", {className: \"t typeParam\", key: k}, \n                t\n              );}\n            )\n            .interpose(', ')\n            .toArray(),\n          '>',\n        ], \n        def.extends && [\n          React.createElement(\"span\", {className: \"t keyword\"}, \" extends \"),\n          Seq(def.extends)\n            .map(function(e, i)  {return React.createElement(TypeDef, {key: i, type: e});})\n            .interpose(', ')\n            .toArray(),\n        ], \n        def.implements && [\n          React.createElement(\"span\", {className: \"t keyword\"}, \" implements \"),\n          Seq(def.implements)\n            .map(function(e, i)  {return React.createElement(TypeDef, {key: i, type: e});})\n            .interpose(', ')\n            .toArray(),\n        ]\n      )\n    );\n  },\n});\n\nexports.InterfaceDef = InterfaceDef;\n\nvar CallSigDef = React.createClass({displayName: \"CallSigDef\",\n  render:function() {\n    var info = this.props.info;\n    var module = this.props.module;\n    var name = this.props.name;\n    var callSig = this.props.callSig || {};\n\n    var shouldWrap = callSigLength(info, module, name, callSig) > 80;\n\n    return (\n      React.createElement(\"span\", {className: \"t callSig\"}, \n        module && [React.createElement(\"span\", {className: \"t fnQualifier\"}, module), '.'], \n        React.createElement(\"span\", {className: \"t fnName\"}, name), \n        callSig.typeParams && [\n          '<',\n          Seq(callSig.typeParams)\n            .map(function(t)  {return React.createElement(\"span\", {className: \"t typeParam\"}, t);})\n            .interpose(', ')\n            .toArray(),\n          '>',\n        ], \n        '(', \n        callSig && functionParams(info, callSig.params, shouldWrap), \n        ')', \n        callSig.type && [': ', React.createElement(TypeDef, {info: info, type: callSig.type})]\n      )\n    );\n  },\n});\n\nexports.CallSigDef = CallSigDef;\n\nvar TypeDef = React.createClass({displayName: \"TypeDef\",\n  render:function() {\n    var info = this.props.info;\n    var type = this.props.type;\n    var prefix = this.props.prefix;\n    switch (type.k) {\n      case TypeKind.Never:\n        return this.wrap('primitive', 'never');\n      case TypeKind.Any:\n        return this.wrap('primitive', 'any');\n      case TypeKind.Unknown:\n        return this.wrap('primitive', 'unknown');\n      case TypeKind.This:\n        return this.wrap('primitive', 'this');\n      case TypeKind.Undefined:\n        return this.wrap('primitive', 'undefined');\n      case TypeKind.Boolean:\n        return this.wrap('primitive', 'boolean');\n      case TypeKind.Number:\n        return this.wrap('primitive', 'number');\n      case TypeKind.String:\n        return this.wrap('primitive', 'string');\n      case TypeKind.Union:\n        return this.wrap('union', [\n          Seq(type.types)\n            .map(function(t)  {return React.createElement(TypeDef, {info: info, type: t});})\n            .interpose(' | ')\n            .toArray(),\n        ]);\n      case TypeKind.Intersection:\n        return this.wrap('intersection', [\n          Seq(type.types)\n            .map(function(t)  {return React.createElement(TypeDef, {info: info, type: t});})\n            .interpose(' & ')\n            .toArray(),\n        ]);\n      case TypeKind.Tuple:\n        return this.wrap('tuple', [\n          '[',\n          Seq(type.types)\n            .map(function(t)  {return React.createElement(TypeDef, {info: info, type: t});})\n            .interpose(', ')\n            .toArray(),\n          ']',\n        ]);\n      case TypeKind.Object:\n        return this.wrap('object', [\n          '{',\n          Seq(type.members)\n            .map(function(t)  {return React.createElement(MemberDef, {member: t});})\n            .interpose(', ')\n            .toArray(),\n          '}',\n        ]);\n      case TypeKind.Indexed:\n        return this.wrap('indexed', [\n          React.createElement(TypeDef, {info: info, type: type.type}),\n          '[',\n          React.createElement(TypeDef, {info: info, type: type.index}),\n          ']',\n        ]);\n      case TypeKind.Operator:\n        return this.wrap('operator', [\n          this.wrap('primitive', type.operator),\n          ' ',\n          React.createElement(TypeDef, {info: info, type: type.type}),\n        ]);\n      case TypeKind.Array:\n        return this.wrap('array', [\n          React.createElement(TypeDef, {info: info, type: type.type}),\n          '[]',\n        ]);\n      case TypeKind.Function:\n        var shouldWrap = (prefix || 0) + funcLength(info, type) > 78;\n        return this.wrap('function', [\n          type.typeParams && [\n            '<',\n            Seq(type.typeParams)\n              .map(function(t, k)  \n                {return React.createElement(\"span\", {className: \"t typeParam\", key: k}, \n                  t\n                );}\n              )\n              .interpose(', ')\n              .toArray(),\n            '>',\n          ],\n          '(',\n          functionParams(info, type.params, shouldWrap),\n          ') => ',\n          React.createElement(TypeDef, {info: info, type: type.type}),\n        ]);\n      case TypeKind.Param:\n        return info && info.propMap[info.defining + '<' + type.param] ? (\n          React.createElement(TypeDef, {type: info.propMap[info.defining + '<' + type.param]})\n        ) : (\n          this.wrap('typeParam', type.param)\n        );\n      case TypeKind.Type:\n        var qualifiedType = (type.qualifier || []).concat([type.name]);\n        var qualifiedTypeName = qualifiedType.join('.');\n        var def = qualifiedTypeName\n          .split('.')\n          .reduce(\n            function(def, name)  {return def && def.module && def.module[name];},\n            defs.Immutable\n          );\n        var typeNameElement = [\n          type.qualifier && [\n            Seq(type.qualifier)\n              .map(function(q)  {return React.createElement(\"span\", {className: \"t typeQualifier\"}, q);})\n              .interpose('.')\n              .toArray(),\n            '.',\n          ],\n          React.createElement(\"span\", {className: \"t typeName\"}, type.name),\n        ];\n        if (def) {\n          typeNameElement = (\n            React.createElement(Router.Link, {to: '/' + qualifiedTypeName}, \n              typeNameElement\n            )\n          );\n        }\n        return this.wrap('type', [\n          typeNameElement,\n          type.args && [\n            '<',\n            Seq(type.args)\n              .map(function(a)  {return React.createElement(TypeDef, {info: info, type: a});})\n              .interpose(', ')\n              .toArray(),\n            '>',\n          ],\n        ]);\n    }\n    throw new Error('Unknown kind ' + type.k);\n  },\n\n  mouseOver:function(event) {\n    CSSCore.addClass(this.getDOMNode(), 'over');\n    event.stopPropagation();\n  },\n\n  mouseOut:function() {\n    CSSCore.removeClass(this.getDOMNode(), 'over');\n  },\n\n  wrap:function(className, child) {\n    return (\n      React.createElement(\"span\", {\n        className: 't ' + className, \n        onMouseOver: this.mouseOver, \n        onFocus: this.mouseOver, \n        onMouseOut: this.mouseOut, \n        onBlur: this.mouseOut\n      }, \n        child\n      )\n    );\n  },\n});\n\nexports.TypeDef = TypeDef;\n\nvar MemberDef = React.createClass({displayName: \"MemberDef\",\n  render:function() {\n    var module = this.props.module;\n    var member = this.props.member;\n    return (\n      React.createElement(\"span\", {className: \"t member\"}, \n        module && [React.createElement(\"span\", {className: \"t fnQualifier\"}, module), '.'], \n        member.index ? (\n          ['[', functionParams(null, member.params), ']']\n        ) : (\n          React.createElement(\"span\", {className: \"t memberName\"}, member.name)\n        ), \n        member.type && [': ', React.createElement(TypeDef, {type: member.type})]\n      )\n    );\n  },\n});\n\nexports.MemberDef = MemberDef;\n\nfunction functionParams(info, params, shouldWrap) {\n  var elements = Seq(params)\n    .map(function(t)  {return [\n      t.varArgs ? '...' : null,\n      React.createElement(\"span\", {className: \"t param\"}, t.name),\n      t.optional ? '?: ' : ': ',\n      React.createElement(TypeDef, {\n        prefix: t.name.length + (t.varArgs ? 3 : 0) + (t.optional ? 3 : 2), \n        info: info, \n        type: t.type}\n      ),\n    ];})\n    .interpose(shouldWrap ? [',', React.createElement(\"br\", null)] : ', ')\n    .toArray();\n  return shouldWrap ? (\n    React.createElement(\"div\", {className: \"t blockParams\"}, elements)\n  ) : (\n    elements\n  );\n}\n\nfunction callSigLength(info, module, name, sig) {\n  return (module ? module.length + 1 : 0) + name.length + funcLength(info, sig);\n}\n\nfunction funcLength(info, sig) {\n  return (\n    (sig.typeParams ? 2 + sig.typeParams.join(', ').length : 0) +\n    2 +\n    (sig.params ? paramLength(info, sig.params) : 0) +\n    (sig.type ? 2 + typeLength(info, sig.type) : 0)\n  );\n}\n\nfunction paramLength(info, params) {\n  return params.reduce(\n    function(s, p) \n      {return s +\n      (p.varArgs ? 3 : 0) +\n      p.name.length +\n      (p.optional ? 3 : 2) +\n      typeLength(info, p.type);},\n    (params.length - 1) * 2\n  );\n}\n\nfunction memberLength(info, members) {\n  return members.reduce(\n    function(s, m) \n      {return s +\n      (m.index ? paramLength(info, m.params) + 4 : m.name + 2) +\n      typeLength(info, m.type);},\n    (members.length - 1) * 2\n  );\n}\n\nfunction typeLength(info, type) {\n  if (!type) {\n    throw new Error('Expected type');\n  }\n  switch (type.k) {\n    case TypeKind.Never:\n      return 5;\n    case TypeKind.Any:\n      return 3;\n    case TypeKind.Unknown:\n      return 7;\n    case TypeKind.This:\n      return 4;\n    case TypeKind.Undefined:\n      return 9;\n    case TypeKind.Boolean:\n      return 7;\n    case TypeKind.Number:\n      return 6;\n    case TypeKind.String:\n      return 6;\n    case TypeKind.Union:\n    case TypeKind.Intersection:\n      return (\n        type.types.reduce(function(s, t)  {return s + typeLength(info, t);}, 0) +\n        (type.types.length - 1) * 3\n      );\n    case TypeKind.Tuple:\n      return (\n        2 +\n        type.types.reduce(function(s, t)  {return s + typeLength(info, t);}, 0) +\n        (type.types.length - 1) * 2\n      );\n    case TypeKind.Object:\n      return 2 + memberLength(info, type.members);\n    case TypeKind.Indexed:\n      return 2 + typeLength(info, type.type) + typeLength(info, type.index);\n    case TypeKind.Operator:\n      return 1 + type.operator.length + typeLength(info, type.type);\n    case TypeKind.Array:\n      return typeLength(info, type.type) + 2;\n    case TypeKind.Function:\n      return 2 + funcLength(info, type);\n    case TypeKind.Param:\n      return info && info.propMap[info.defining + '<' + type.param]\n        ? typeLength(null, info.propMap[info.defining + '<' + type.param])\n        : type.param.length;\n    case TypeKind.Type:\n      return (\n        (type.qualifier ? 1 + type.qualifier.join('.').length : 0) +\n        type.name.length +\n        (!type.args\n          ? 0\n          : type.args.reduce(\n              function(s, a)  {return s + typeLength(info, a);},\n              type.args.length * 2\n            ))\n      );\n  }\n  throw new Error('Type with unknown kind ' + JSON.stringify(type));\n}\n","var React = require('react');\nvar SVGSet = require('../../src/SVGSet');\nvar Logo = require('../../src/Logo');\nvar packageJson = require('../../../../package.json');\n\nvar DocHeader = React.createClass({displayName: \"DocHeader\",\n  render:function() {\n    return (\n      React.createElement(\"div\", {className: \"header\"}, \n        React.createElement(\"div\", {className: \"miniHeader\"}, \n          React.createElement(\"div\", {className: \"miniHeaderContents\"}, \n            React.createElement(\"a\", {href: \"../\", target: \"_self\", className: \"miniLogo\"}, \n              React.createElement(SVGSet, null, \n                React.createElement(Logo, {color: \"#FC4349\"}), \n                React.createElement(Logo, {color: \"#2C3E50\", inline: true})\n              )\n            ), \n            React.createElement(\"a\", {href: \"./\", target: \"_self\"}, \n              \"Docs (v\", \n              packageJson.version, \")\"\n            ), \n            React.createElement(\"a\", {href: \"https://stackoverflow.com/questions/tagged/immutable.js?sort=votes\"}, \n              \"Questions\"\n            ), \n            React.createElement(\"a\", {href: \"https://github.com/immutable-js/immutable-js/\"}, \"Github\")\n          )\n        )\n      )\n    );\n  },\n});\n\nmodule.exports = DocHeader;\n","var React = require('react');\nvar Router = require('react-router');\nvar $__0=    require('../../../../'),Seq=$__0.Seq;\nvar Markdown = require('./MarkDown');\n\nvar DocOverview = React.createClass({displayName: \"DocOverview\",\n  render:function() {\n    var def = this.props.def;\n    var doc = def.doc;\n\n    return (\n      React.createElement(\"div\", null, \n        doc && (\n          React.createElement(\"section\", null, \n            React.createElement(Markdown, {contents: doc.synopsis}), \n            doc.description && React.createElement(Markdown, {contents: doc.description})\n          )\n        ), \n\n        React.createElement(\"h4\", {className: \"groupTitle\"}, \"API\"), \n\n        Seq(def.module)\n          .map(function(t, name)  {\n            var isFunction = !t.interface && !t.module;\n            if (isFunction) {\n              t = t.call;\n            }\n            return (\n              React.createElement(\"section\", {key: name, className: \"interfaceMember\"}, \n                React.createElement(\"h3\", {className: \"memberLabel\"}, \n                  React.createElement(Router.Link, {to: '/' + name}, \n                    name + (isFunction ? '()' : '')\n                  )\n                ), \n                t.doc && (\n                  React.createElement(Markdown, {className: \"detail\", contents: t.doc.synopsis})\n                )\n              )\n            );\n          })\n          .valueSeq()\n          .toArray()\n      )\n    );\n  },\n});\n\nmodule.exports = DocOverview;\n","var React = require('react');\n\nvar DocSearch = React.createClass({displayName: \"DocSearch\",\n  getInitialState:function() {\n    return { enabled: true };\n  },\n  componentDidMount:function() {\n    var script = document.createElement('script');\n    var firstScript = document.getElementsByTagName('script')[0];\n    script.src =\n      'https://cdn.jsdelivr.net/npm/docsearch.js@2.5.2/dist/cdn/docsearch.min.js';\n    script.addEventListener(\n      'load',\n      function()  {\n        // Initialize Algolia search.\n        if (window.docsearch) {\n          window.docsearch({\n            apiKey: '83f61f865ef4cb682e0432410c2f7809',\n            indexName: 'immutable_js',\n            inputSelector: '#algolia-docsearch',\n          });\n        } else {\n          this.setState({ enabled: false });\n        }\n      }.bind(this),\n      false\n    );\n    firstScript.parentNode.insertBefore(script, firstScript);\n\n    var link = document.createElement('link');\n    var firstLink = document.getElementsByTagName('link')[0];\n    link.rel = 'stylesheet';\n    link.href =\n      'https://cdn.jsdelivr.net/npm/docsearch.js@2.5.2/dist/cdn/docsearch.min.css';\n    firstLink.parentNode.insertBefore(link, firstLink);\n  },\n  render:function() {\n    return this.state.enabled ? (\n      React.createElement(\"input\", {\n        id: \"algolia-docsearch\", \n        className: \"docSearch\", \n        type: \"search\", \n        placeholder: \"Search Immutable.js Documentation\"}\n      )\n    ) : null;\n  },\n});\n\nmodule.exports = DocSearch;\n","var React = require('react');\n\nvar MarkDown = React.createClass({displayName: \"MarkDown\",\n  shouldComponentUpdate:function() {\n    return false;\n  },\n\n  render:function() {\n    var html = this.props.contents;\n    return (\n      React.createElement(\"div\", {\n        className: this.props.className, \n        dangerouslySetInnerHTML: { __html: html}}\n      )\n    );\n  },\n});\n\nmodule.exports = MarkDown;\n","var React = require('react');\nvar ReactTransitionEvents = require('react/lib/ReactTransitionEvents');\nvar Router = require('react-router');\nvar $__0=     require('./Defs'),CallSigDef=$__0.CallSigDef,MemberDef=$__0.MemberDef;\nvar PageDataMixin = require('./PageDataMixin');\nvar isMobile = require('./isMobile');\nvar MarkDown = require('./MarkDown');\n\nvar $__1=    React.addons,TransitionGroup=$__1.TransitionGroup;\n\nvar MemberDoc = React.createClass({displayName: \"MemberDoc\",\n  mixins: [PageDataMixin, Router.Navigation],\n\n  getInitialState:function() {\n    var showDetail = this.props.showDetail;\n    return { detail: showDetail };\n  },\n\n  componentDidMount:function() {\n    if (this.props.showDetail) {\n      var node = this.getDOMNode();\n      var navType = this.getPageData().type;\n      if (navType === 'init' || navType === 'push') {\n        window.scrollTo(window.scrollX, offsetTop(node) - FIXED_HEADER_HEIGHT);\n      }\n    }\n  },\n\n  componentWillReceiveProps:function(nextProps) {\n    if (nextProps.showDetail && !this.props.showDetail) {\n      this.scrollTo = true;\n      this.setState({ detail: true });\n    }\n  },\n\n  componentDidUpdate:function() {\n    if (this.scrollTo) {\n      this.scrollTo = false;\n      var node = this.getDOMNode();\n      var navType = this.getPageData().type;\n      if (navType === 'init' || navType === 'push') {\n        window.scrollTo(window.scrollX, offsetTop(node) - FIXED_HEADER_HEIGHT);\n      }\n    }\n  },\n\n  toggleDetail:function() {\n    // Note: removed this because it drops the URL bar on mobile, and that's\n    // the only place it's currently being used.\n    // var member = this.props.member;\n    // var name = member.memberName;\n    // var typeName = this.props.parentName;\n    // var showDetail = this.props.showDetail;\n    // if (!this.state.detail) {\n    //   this.replaceWith('/' + (typeName ? typeName + '/' : '') + name );\n    // } else if (this.state.detail && showDetail) {\n    //   this.replaceWith('/' + (typeName || '') );\n    // }\n    this.setState({ detail: !this.state.detail });\n  },\n\n  render:function() {\n    var typePropMap = this.props.typePropMap;\n    var member = this.props.member;\n    var module = member.isStatic ? this.props.parentName : null;\n    var name = member.memberName;\n    var def = member.memberDef;\n    var doc = def.doc || {};\n    var isProp = !def.signatures;\n\n    var typeInfo = member.inherited && {\n      propMap: typePropMap,\n      defining: member.inherited.name,\n    };\n\n    var showDetail = isMobile ? this.state.detail : true;\n\n    var memberAnchorLink = this.props.parentName + '/' + name;\n\n    return (\n      React.createElement(\"div\", {className: \"interfaceMember\"}, \n        React.createElement(\"h3\", {className: \"memberLabel\"}, \n          React.createElement(Router.Link, {\n            to: '/' + memberAnchorLink, \n            onClick: isMobile ? this.toggleDetail : null\n          }, \n            (module ? module + '.' : '') + name + (isProp ? '' : '()')\n          )\n        ), \n        React.createElement(TransitionGroup, {childFactory: makeSlideDown}, \n          showDetail && (\n            React.createElement(\"div\", {key: \"detail\", className: \"detail\"}, \n              doc.synopsis && (\n                React.createElement(MarkDown, {className: \"synopsis\", contents: doc.synopsis})\n              ), \n              isProp ? (\n                React.createElement(\"code\", {className: \"codeBlock memberSignature\"}, \n                  React.createElement(MemberDef, {\n                    module: module, \n                    member: { name:name, type: def.type}}\n                  )\n                )\n              ) : (\n                React.createElement(\"code\", {className: \"codeBlock memberSignature\"}, \n                  def.signatures.map(function(callSig, i)  {return [\n                    React.createElement(CallSigDef, {\n                      key: i, \n                      info: typeInfo, \n                      module: module, \n                      name: name, \n                      callSig: callSig}\n                    ),\n                    '\\n',\n                  ];})\n                )\n              ), \n              member.inherited && (\n                React.createElement(\"section\", null, \n                  React.createElement(\"h4\", {className: \"infoHeader\"}, \"Inherited from\"), \n                  React.createElement(\"code\", null, \n                    React.createElement(Router.Link, {to: '/' + member.inherited.name + '/' + name}, \n                      member.inherited.name + '#' + name\n                    )\n                  )\n                )\n              ), \n              member.overrides && (\n                React.createElement(\"section\", null, \n                  React.createElement(\"h4\", {className: \"infoHeader\"}, \"Overrides\"), \n                  React.createElement(\"code\", null, \n                    React.createElement(Router.Link, {to: '/' + member.overrides.name + '/' + name}, \n                      member.overrides.name + '#' + name\n                    )\n                  )\n                )\n              ), \n              doc.notes &&\n                doc.notes.map(function(note, i)  \n                  {return React.createElement(\"section\", {key: i}, \n                    React.createElement(\"h4\", {className: \"infoHeader\"}, note.name), \n                    note.name === 'alias' ? (\n                      React.createElement(\"code\", null, \n                        React.createElement(CallSigDef, {name: note.body})\n                      )\n                    ) : (\n                      React.createElement(MarkDown, {className: \"discussion\", contents: note.body})\n                    )\n                  );}\n                ), \n              doc.description && (\n                React.createElement(\"section\", null, \n                  React.createElement(\"h4\", {className: \"infoHeader\"}, \n                    doc.description.substr(0, 5) === '<code'\n                      ? 'Example'\n                      : 'Discussion'\n                  ), \n                  React.createElement(MarkDown, {className: \"discussion\", contents: doc.description})\n                )\n              )\n            )\n          )\n        )\n      )\n    );\n  },\n});\n\nfunction makeSlideDown(child) {\n  return React.createElement(SlideDown, null, child);\n}\n\nvar SlideDown = React.createClass({displayName: \"SlideDown\",\n  componentWillEnter:function(done) {\n    this.slide(false, done);\n  },\n\n  componentWillLeave:function(done) {\n    this.slide(true, done);\n  },\n\n  slide:function(slidingUp, done) {\n    var node = this.getDOMNode();\n    node.style.height = 'auto';\n    var height = getComputedStyle(node).height;\n    var start = slidingUp ? height : 0;\n    var end = slidingUp ? 0 : height;\n    node.style.transition = '';\n    node.style.height = start;\n    node.style.transition = 'height 0.35s ease-in-out';\n    var endListener = function()  {\n      ReactTransitionEvents.removeEndEventListener(node, endListener);\n      done();\n    };\n    ReactTransitionEvents.addEndEventListener(node, endListener);\n    this.timeout = setTimeout(function()  {\n      node.style.height = end;\n    }, 17);\n  },\n\n  render:function() {\n    return this.props.children;\n  },\n});\n\nvar FIXED_HEADER_HEIGHT = 75;\n\nfunction offsetTop(node) {\n  var top = 0;\n  do {\n    top += node.offsetTop;\n  } while ((node = node.offsetParent));\n  return top;\n}\n\nmodule.exports = MemberDoc;\n","var React = require('react');\n\nmodule.exports = {\n  contextTypes: {\n    getPageData: React.PropTypes.func.isRequired,\n  },\n\n  /**\n   * Returns the most recent change event.\n   */\n  getPageData:function() {\n    return this.context.getPageData();\n  },\n};\n","var React = require('react');\nvar Router = require('react-router');\nvar $__0=     require('../../../../'),Map=$__0.Map,Seq=$__0.Seq;\nvar defs = require('../../../lib/getTypeDefs');\n\nvar SideBar = React.createClass({displayName: \"SideBar\",\n  render:function() {\n    var type = defs.Immutable;\n\n    return (\n      React.createElement(\"div\", {className: \"sideBar\"}, \n        React.createElement(\"div\", {className: \"toolBar\"}, \n          React.createElement(\"div\", {\n            onClick: this.props.toggleShowInGroups, \n            onKeyPress: this.props.toggleShowInGroups\n          }, \n            React.createElement(\"span\", {className: this.props.showInGroups && 'selected'}, \n              \"Grouped\"\n            ), \n            '  ', \n            React.createElement(\"span\", {className: this.props.showInGroups || 'selected'}, \n              \"Alphabetized\"\n            )\n          ), \n          React.createElement(\"div\", {\n            onClick: this.props.toggleShowInherited, \n            onKeyPress: this.props.toggleShowInherited\n          }, \n            React.createElement(\"span\", {className: this.props.showInherited && 'selected'}, \n              \"Inherited\"\n            ), \n            '  ', \n            React.createElement(\"span\", {className: this.props.showInherited || 'selected'}, \n              \"Defined\"\n            )\n          )\n        ), \n        React.createElement(\"div\", {className: \"scrollContent\"}, \n          React.createElement(\"h4\", {className: \"groupTitle\"}, \"API\"), \n          Seq(type.module)\n            .flatMap(function(t, name)  {return flattenSubmodules(Map(), t, name);})\n            .map(function(t, name)  {return this.renderSideBarType(name, t);}.bind(this))\n            .valueSeq()\n            .toArray()\n        )\n      )\n    );\n  },\n\n  renderSideBarType:function(typeName, type) {\n    var isFocus = this.props.focus === typeName;\n    var isFunction = !type.interface && !type.module;\n    var call = type.call;\n    var functions = Seq(type.module).filter(function(t)  {return !t.interface && !t.module;});\n\n    var label = typeName + (isFunction ? '()' : '');\n\n    if (!isFocus) {\n      label = React.createElement(Router.Link, {to: '/' + typeName}, label);\n    }\n\n    var memberGroups = this.props.memberGroups;\n\n    var members =\n      !isFocus || isFunction ? null : (\n        React.createElement(\"div\", {className: \"members\"}, \n          call && (\n            React.createElement(\"section\", null, \n              React.createElement(\"h4\", {className: \"groupTitle\"}, \"Construction\"), \n              React.createElement(\"div\", null, \n                React.createElement(Router.Link, {to: '/' + typeName + '/' + typeName}, \n                  typeName + '()'\n                )\n              )\n            )\n          ), \n\n          functions.count() > 0 && (\n            React.createElement(\"section\", null, \n              React.createElement(\"h4\", {className: \"groupTitle\"}, \"Static Methods\"), \n              functions\n                .map(function(t, name)  \n                  {return React.createElement(\"div\", {key: name}, \n                    React.createElement(Router.Link, {to: '/' + typeName + '/' + name}, \n                      typeName + '.' + name + '()'\n                    )\n                  );}\n                )\n                .valueSeq()\n                .toArray()\n            )\n          ), \n\n          React.createElement(\"section\", null, \n            Seq(memberGroups)\n              .map(function(members, title) \n                {return members.length === 0\n                  ? null\n                  : Seq([\n                      React.createElement(\"h4\", {key: title || 'Members', className: \"groupTitle\"}, \n                        title || 'Members'\n                      ),\n                      Seq(members).map(function(member)  \n                        {return React.createElement(\"div\", {key: member.memberName}, \n                          React.createElement(Router.Link, {\n                            to: '/' + typeName + '/' + member.memberName\n                          }, \n                            member.memberName +\n                              (member.memberDef.signatures ? '()' : '')\n                          )\n                        );}\n                      ),\n                    ]);}\n              )\n              .flatten()\n              .valueSeq()\n              .toArray()\n          )\n        )\n      );\n\n    return (\n      React.createElement(\"div\", {key: typeName}, \n        React.createElement(\"h2\", null, label), \n        members\n      )\n    );\n  },\n});\n\nfunction flattenSubmodules(modules, type, name) {\n  modules = modules.set(name, type);\n  return type.module\n    ? Seq(type.module)\n        .filter(function(t)  {return t.interface || t.module;})\n        .reduce(\n          function(modules, subT, subName) \n            {return flattenSubmodules(modules, subT, name + '.' + subName);},\n          modules\n        )\n    : modules;\n}\n\nmodule.exports = SideBar;\n","var React = require('react');\nvar Router = require('react-router');\nvar $__0=    require('../../../../'),Seq=$__0.Seq;\nvar $__1=     require('./Defs'),InterfaceDef=$__1.InterfaceDef,CallSigDef=$__1.CallSigDef;\nvar MemberDoc = require('./MemberDoc');\nvar isMobile = require('./isMobile');\nvar SideBar = require('./SideBar');\nvar MarkDown = require('./MarkDown');\nvar DocOverview = require('./DocOverview');\nvar collectMemberGroups = require('../../../lib/collectMemberGroups');\nvar TypeKind = require('../../../lib/TypeKind');\nvar defs = require('../../../lib/getTypeDefs');\n\nvar typeDefURL =\n  'https://github.com/immutable-js/immutable-js/blob/main/type-definitions/Immutable.d.ts';\nvar issuesURL = 'https://github.com/immutable-js/immutable-js/issues';\n\nvar Disclaimer = function () {\n  return (\n    React.createElement(\"section\", {className: \"disclaimer\"}, \n      \"This documentation is generated from\", ' ', \n      React.createElement(\"a\", {href: typeDefURL}, \"Immutable.d.ts\"), \". Pull requests and\", ' ', \n      React.createElement(\"a\", {href: issuesURL}, \"Issues\"), \" welcome.\"\n    )\n  );\n};\n\nvar TypeDocumentation = React.createClass({displayName: \"TypeDocumentation\",\n  getInitialState:function() {\n    return {\n      showInherited: true,\n      showInGroups: true,\n    };\n  },\n\n  toggleShowInGroups:function() {\n    this.setState({ showInGroups: !this.state.showInGroups });\n  },\n\n  toggleShowInherited:function() {\n    this.setState({ showInherited: !this.state.showInherited });\n  },\n\n  render:function() {\n    var name = this.props.name;\n    var memberName = this.props.memberName;\n    var def = this.props.def;\n\n    var memberGroups = collectMemberGroups(def && def.interface, {\n      showInGroups: this.state.showInGroups,\n      showInherited: this.state.showInherited,\n    });\n\n    return (\n      React.createElement(\"div\", null, \n        isMobile || (\n          React.createElement(SideBar, {\n            focus: name, \n            memberGroups: memberGroups, \n            toggleShowInherited: this.toggleShowInherited, \n            toggleShowInGroups: this.toggleShowInGroups, \n            showInGroups: this.state.showInGroups, \n            showInherited: this.state.showInherited}\n          )\n        ), \n        React.createElement(\"div\", {key: name, className: \"docContents\"}, \n          !def ? (\n            React.createElement(NotFound, null)\n          ) : !name ? (\n            React.createElement(DocOverview, {def: def})\n          ) : !def.interface && !def.module ? (\n            React.createElement(FunctionDoc, {name: name, def: def.call})\n          ) : (\n            React.createElement(TypeDoc, {\n              name: name, \n              def: def, \n              memberName: memberName, \n              memberGroups: memberGroups}\n            )\n          )\n        )\n      )\n    );\n  },\n});\n\nfunction NotFound() {\n  return React.createElement(\"div\", null, \"Not found\");\n}\n\nvar FunctionDoc = React.createClass({displayName: \"FunctionDoc\",\n  render:function() {\n    var name = this.props.name;\n    var def = this.props.def;\n    var doc = def.doc || {};\n\n    return (\n      React.createElement(\"div\", null, \n        React.createElement(\"h1\", {className: \"typeHeader\"}, name + '()'), \n        doc.synopsis && (\n          React.createElement(MarkDown, {className: \"synopsis\", contents: doc.synopsis})\n        ), \n        React.createElement(\"code\", {className: \"codeBlock memberSignature\"}, \n          def.signatures.map(function(callSig, i)  {return [\n            React.createElement(CallSigDef, {key: i, name: name, callSig: callSig}),\n            '\\n',\n          ];})\n        ), \n        doc.notes &&\n          doc.notes.map(function(note, i)  \n            {return React.createElement(\"section\", {key: i}, \n              React.createElement(\"h4\", {className: \"infoHeader\"}, note.name), \n              note.name === 'alias' ? (\n                React.createElement(CallSigDef, {name: note.body})\n              ) : (\n                note.body\n              )\n            );}\n          ), \n        doc.description && (\n          React.createElement(\"section\", null, \n            React.createElement(\"h4\", {className: \"infoHeader\"}, \n              doc.description.substr(0, 5) === '<code'\n                ? 'Example'\n                : 'Discussion'\n            ), \n            React.createElement(MarkDown, {className: \"discussion\", contents: doc.description})\n          )\n        ), \n        React.createElement(Disclaimer, null)\n      )\n    );\n  },\n});\n\nvar TypeDoc = React.createClass({displayName: \"TypeDoc\",\n  render:function() {\n    var name = this.props.name;\n    var def = this.props.def;\n    var memberName = this.props.memberName;\n    var memberGroups = this.props.memberGroups;\n\n    var doc = def.doc || {};\n    var call = def.call;\n    var functions = Seq(def.module).filter(function(t)  {return !t.interface && !t.module;});\n    var types = Seq(def.module).filter(function(t)  {return t.interface || t.module;});\n    var interfaceDef = def.interface;\n    var typePropMap = getTypePropMap(interfaceDef);\n\n    return (\n      React.createElement(\"div\", null, \n        React.createElement(\"h1\", {className: \"typeHeader\"}, name), \n        doc.synopsis && (\n          React.createElement(MarkDown, {className: \"synopsis\", contents: doc.synopsis})\n        ), \n        interfaceDef && (\n          React.createElement(\"code\", {className: \"codeBlock memberSignature\"}, \n            React.createElement(InterfaceDef, {name: name, def: interfaceDef})\n          )\n        ), \n\n        doc.notes &&\n          doc.notes.map(function(note, i)  \n            {return React.createElement(\"section\", {key: i}, \n              React.createElement(\"h4\", {className: \"infoHeader\"}, note.name), \n              note.name === 'alias' ? (\n                React.createElement(CallSigDef, {name: note.body})\n              ) : (\n                note.body\n              )\n            );}\n          ), \n\n        doc.description && (\n          React.createElement(\"section\", null, \n            React.createElement(\"h4\", {className: \"infoHeader\"}, \n              doc.description.substr(0, 5) === '<code'\n                ? 'Example'\n                : 'Discussion'\n            ), \n            React.createElement(MarkDown, {className: \"discussion\", contents: doc.description})\n          )\n        ), \n\n        types.count() > 0 && (\n          React.createElement(\"section\", null, \n            React.createElement(\"h4\", {className: \"groupTitle\"}, \"Sub-types\"), \n            types\n              .map(function(t, typeName)  \n                {return React.createElement(\"div\", {key: typeName}, \n                  React.createElement(Router.Link, {\n                    to: '/' + (name ? name + '.' + typeName : typeName)\n                  }, \n                    name ? name + '.' + typeName : typeName\n                  )\n                );}\n              )\n              .valueSeq()\n              .toArray()\n          )\n        ), \n\n        call && (\n          React.createElement(\"section\", null, \n            React.createElement(\"h4\", {className: \"groupTitle\"}, \"Construction\"), \n            React.createElement(MemberDoc, {\n              showDetail: name === memberName, \n              parentName: name, \n              member: {\n                memberName: name,\n                memberDef: call,\n              }}\n            )\n          )\n        ), \n\n        functions.count() > 0 && (\n          React.createElement(\"section\", null, \n            React.createElement(\"h4\", {className: \"groupTitle\"}, \"Static methods\"), \n            functions\n              .map(function(t, fnName)  \n                {return React.createElement(MemberDoc, {\n                  key: fnName, \n                  showDetail: fnName === memberName, \n                  parentName: name, \n                  member: {\n                    memberName: fnName,\n                    memberDef: t.call,\n                    isStatic: true,\n                  }}\n                );}\n              )\n              .valueSeq()\n              .toArray()\n          )\n        ), \n\n        React.createElement(\"section\", null, \n          Seq(memberGroups)\n            .map(function(members, title) \n              {return members.length === 0\n                ? null\n                : Seq([\n                    React.createElement(\"h4\", {key: title || 'Members', className: \"groupTitle\"}, \n                      title || 'Members'\n                    ),\n                    Seq(members).map(function(member)  \n                      {return React.createElement(MemberDoc, {\n                        typePropMap: typePropMap, \n                        key: member.memberName, \n                        showDetail: member.memberName === memberName, \n                        parentName: name, \n                        member: member}\n                      );}\n                    ),\n                  ]);}\n            )\n            .flatten()\n            .valueSeq()\n            .toArray()\n        ), \n\n        React.createElement(Disclaimer, null)\n      )\n    );\n  },\n});\n\n/**\n * Get a map from super type parameter to concrete type definition. This is\n * used when rendering inherited type definitions to ensure contextually\n * relevant information.\n *\n * Example:\n *\n *   type A<T> implements B<number, T>\n *   type B<K, V> implements C<K, V, V>\n *   type C<X, Y, Z>\n *\n * parse C:\n *   {}\n *\n * parse B:\n *   { C<X: K\n *     C<Y: V\n *     C<Z: V }\n *\n * parse A:\n *   { B<K: number\n *     B<V: T\n *     C<X: number\n *     C<Y: T\n *     C<Z: T }\n */\nfunction getTypePropMap(def) {\n  var map = {};\n  def &&\n    def.extends &&\n    def.extends.forEach(function(e)  {\n      var superModule = defs.Immutable;\n      e.name.split('.').forEach(function(part)  {\n        superModule =\n          superModule && superModule.module && superModule.module[part];\n      });\n      var superInterface = superModule && superModule.interface;\n      if (superInterface) {\n        var interfaceMap = Seq(superInterface.typeParams)\n          .toKeyedSeq()\n          .flip()\n          .map(function(i)  {return e.args[i];})\n          .toObject();\n        Seq(interfaceMap).forEach(function(v, k)  {\n          map[e.name + '<' + k] = v;\n        });\n        var superMap = getTypePropMap(superInterface);\n        Seq(superMap).forEach(function(v, k)  {\n          map[k] = v.k === TypeKind.Param ? interfaceMap[v.param] : v;\n        });\n      }\n    });\n  return map;\n}\n\nmodule.exports = TypeDocumentation;\n","var React = require('react');\nvar assign = require('react/lib/Object.assign');\nvar Router = require('react-router');\nvar DocHeader = require('./DocHeader');\nvar DocSearch = require('./DocSearch');\nvar TypeDocumentation = require('./TypeDocumentation');\nvar defs = require('../../../lib/getTypeDefs');\n\nvar $__0=      Router,Route=$__0.Route,DefaultRoute=$__0.DefaultRoute,RouteHandler=$__0.RouteHandler;\n\nrequire('../../../lib/runkit-embed');\n\nvar Documentation = React.createClass({displayName: \"Documentation\",\n  render:function() {\n    return (\n      React.createElement(\"div\", null, \n        React.createElement(DocHeader, null), \n        React.createElement(\"div\", {className: \"pageBody\", id: \"body\"}, \n          React.createElement(\"div\", {className: \"contents\"}, \n            React.createElement(DocSearch, null), \n            React.createElement(RouteHandler, null)\n          )\n        )\n      )\n    );\n  },\n});\n\nvar DocDeterminer = React.createClass({displayName: \"DocDeterminer\",\n  mixins: [Router.State],\n\n  render:function() {\n    var $__0=      determineDoc(this.getPath()),def=$__0.def,name=$__0.name,memberName=$__0.memberName;\n    return React.createElement(TypeDocumentation, {def: def, name: name, memberName: memberName});\n  },\n});\n\nfunction determineDoc(path) {\n  var $__0=    path.split('/'),name=$__0[1],memberName=$__0[2];\n\n  var namePath = name ? name.split('.') : [];\n  var def = namePath.reduce(\n    function(def, subName)  {return def && def.module && def.module[subName];},\n    defs.Immutable\n  );\n\n  return { def:def, name:name, memberName:memberName };\n}\n\nmodule.exports = React.createClass({displayName: \"exports\",\n  childContextTypes: {\n    getPageData: React.PropTypes.func.isRequired,\n  },\n\n  getChildContext:function() {\n    return {\n      getPageData: this.getPageData,\n    };\n  },\n\n  getPageData:function() {\n    return this.pageData;\n  },\n\n  componentWillMount:function() {\n    var location;\n    var scrollBehavior;\n\n    if (window.document) {\n      location = Router.HashLocation;\n      location.addChangeListener(function(change)  {\n        this.pageData = assign({}, change, determineDoc(change.path));\n      }.bind(this));\n\n      this.pageData = !window.document\n        ? {}\n        : assign(\n            {\n              path: location.getCurrentPath(),\n              type: 'init',\n            },\n            determineDoc(location.getCurrentPath())\n          );\n\n      scrollBehavior = {\n        updateScrollPosition: function(position, actionType)  {\n          switch (actionType) {\n            case 'push':\n              return this.getPageData().memberName\n                ? null\n                : window.scrollTo(0, 0);\n            case 'pop':\n              return window.scrollTo(\n                position ? position.x : 0,\n                position ? position.y : 0\n              );\n          }\n        }.bind(this),\n      };\n    }\n\n    Router.create({\n      routes: (\n        React.createElement(Route, {handler: Documentation, path: \"/\"}, \n          React.createElement(DefaultRoute, {handler: DocDeterminer}), \n          React.createElement(Route, {name: \"type\", path: \"/:name\", handler: DocDeterminer}), \n          React.createElement(Route, {\n            name: \"method\", \n            path: \"/:name/:memberName\", \n            handler: DocDeterminer}\n          )\n        )\n      ),\n      location: location,\n      scrollBehavior: scrollBehavior,\n    }).run(function(Handler)  {\n      this.setState({ handler: Handler });\n      if (window.document) {\n        window.document.title = (this.pageData.name + \"  Immutable.js\");\n      }\n    }.bind(this));\n  },\n\n  // TODO: replace this. this is hacky and probably wrong\n\n  componentDidMount:function() {\n    setTimeout(function()  {\n      this.pageData.type = '';\n    }.bind(this), 0);\n  },\n\n  componentDidUpdate:function() {\n    setTimeout(function()  {\n      this.pageData.type = '';\n    }.bind(this), 0);\n  },\n\n  render:function() {\n    var Handler = this.state.handler;\n    return React.createElement(Handler, null);\n  },\n});\n","var isMobile =\n  window.matchMedia && window.matchMedia('(max-device-width: 680px)');\nmodule.exports = false && !!(isMobile && isMobile.matches);\n","var React = require('react');\n\nvar Logo = React.createClass({displayName: \"Logo\",\n  shouldComponentUpdate: function (nextProps) {\n    return nextProps.opacity !== this.props.opacity;\n  },\n\n  render: function () {\n    var opacity = this.props.opacity;\n    if (opacity === undefined) {\n      opacity = 1;\n    }\n    return !this.props.inline ? (\n      React.createElement(\"g\", {fill: this.props.color, style: { opacity: this.props.opacity}}, \n        React.createElement(\"path\", {d: \"M0,0l13.9,0v41.1H0L0,0z\"}), \n        React.createElement(\"path\", {d: \"M18.2,0L29,0l10.7,15.8L50.4,0l10.9,0v41.1H48.1V26.3l-8.4,12.3l-8.4-12.3v14.8H18.2V0z\"}), \n        React.createElement(\"path\", {d: \"M65.5,0l10.9,0L87,15.8L97.7,0l10.9,0v41.1H95.4V26.3L87,38.7l-8.4-12.3v14.8H65.5V0z\"}), \n        React.createElement(\"path\", {\n          d: \"M128.6,42.2c-2.6,0-4.9-0.3-7-1c-2.1-0.7-3.9-1.6-5.4-3c-1.5-1.3-2.6-3-3.4-5c-0.8-2-1.2-4.4-1.2-7.1V0\" + ' ' +\n          \"l13.1,0v25.6c0,1.4,0.3,2.5,0.9,3.3c0.6,0.8,1.6,1.1,3,1.1c1.4,0,2.4-0.4,3-1.1c0.6-0.8,0.9-1.9,0.9-3.3V0l13.2,0v26.1\" + ' ' +\n          \"c0,2.7-0.4,5.1-1.2,7.1c-0.8,2-2,3.7-3.5,5c-1.5,1.3-3.3,2.3-5.4,3C133.5,41.8,131.2,42.2,128.6,42.2z\"}\n        ), \n        React.createElement(\"path\", {d: \"M155.4,10.8h-7.6V0l28.7,0v10.8h-7.6v30.3h-13.6V10.8z\"}), \n        React.createElement(\"path\", {\n          d: \"M186.4,0l9.9,0l15.6,41.1h-12.9l-1.4-3.7h-12.5l-1.4,3.7h-12.9L186.4,0z M194.1,28.4l-2.8-7.2l-2.8,7.2\" + ' ' +\n          \"H194.1z\"}\n        ), \n        React.createElement(\"path\", {\n          d: \"M212.9,0L229,0c2.1,0,3.9,0.2,5.6,0.7c1.7,0.5,3.2,1.2,4.4,2.1s2.2,2.1,2.8,3.5c0.7,1.4,1,3,1,4.8\" + ' ' +\n          \"c0,1.3-0.2,2.4-0.5,3.4c-0.3,0.9-0.7,1.7-1,2.3c-0.5,0.7-1,1.4-1.5,1.8c0.9,0.6,1.7,1.3,2.5,2.2c0.6,0.8,1.2,1.8,1.7,3\" + ' ' +\n          \"c0.5,1.2,0.8,2.7,0.8,4.4c0,2-0.3,3.8-1,5.4c-0.7,1.6-1.7,3-3,4.1c-1.3,1.1-2.9,2-4.7,2.6c-1.9,0.6-4,0.9-6.3,0.9h-16.8V0z\" + ' ' +\n           \"M230.2,12.5c0-1.9-1-2.8-3.1-2.8h-1.5v5.7h1.5C229.2,15.4,230.2,14.4,230.2,12.5z M227.1,31.4c3.1,0,4.7-1.2,4.7-3.6\" + ' ' +\n          \"c0-2.4-1.6-3.6-4.7-3.6h-1.5v7.2H227.1z\"}\n        ), \n        React.createElement(\"path\", {d: \"M248.3,0L262,0v30.3h11.3v10.8h-25V0z\"}), \n        React.createElement(\"path\", {d: \"M275.3,0l24.2,0v10.8h-11.1v4.6h10.9v10.2h-10.9v4.7H300v10.8h-24.7V0z\"})\n      )\n    ) : (\n      React.createElement(\"g\", {fill: this.props.color, style: { opacity: this.props.opacity}}, \n        React.createElement(\"path\", {d: \"M0,0l13.9,0v41.1H0L0,0z M7.8,36.2V4.9H6.2v31.3H7.8z\"}), \n        React.createElement(\"path\", {\n          d: \"M18.2,0L29,0l10.7,15.8L50.4,0l10.9,0v41.1H48.1V26.3l-8.4,12.3l-8.4-12.3v14.8H18.2V0z M25.9,36.2V7.9\" + ' ' +\n          \"L39.7,28L53.5,7.9v28.3h1.6V4.9h-1.6L39.7,25.2L25.9,4.9h-1.6v31.3H25.9z\"}\n        ), \n        React.createElement(\"path\", {\n          d: \"M65.5,0l10.9,0L87,15.8L97.7,0l10.9,0v41.1H95.4V26.3L87,38.7l-8.4-12.3v14.8H65.5V0z M73.2,36.2V7.9\" + ' ' +\n          \"L87,28l13.7-20.1v28.3h1.6V4.9h-1.6L87,25.2L73.2,4.9h-1.6v31.3H73.2z\"}\n        ), \n        React.createElement(\"path\", {\n          d: \"M128.6,42.2c-2.6,0-4.9-0.3-7-1c-2.1-0.7-3.9-1.6-5.4-3c-1.5-1.3-2.6-3-3.4-5c-0.8-2-1.2-4.4-1.2-7.1V0\" + ' ' +\n          \"l13.1,0v25.6c0,1.4,0.3,2.5,0.9,3.3c0.6,0.8,1.6,1.1,3,1.1c1.4,0,2.4-0.4,3-1.1c0.6-0.8,0.9-1.9,0.9-3.3V0l13.2,0v26.1\" + ' ' +\n          \"c0,2.7-0.4,5.1-1.2,7.1c-0.8,2-2,3.7-3.5,5c-1.5,1.3-3.3,2.3-5.4,3C133.5,41.8,131.2,42.2,128.6,42.2z M128.6,34.8\" + ' ' +\n          \"c-6.2,0-9.2-3-9.2-9.1V4.9h-1.6v20.8c0,3.5,0.9,6.1,2.8,7.9c1.9,1.8,4.6,2.7,8,2.7c3.5,0,6.2-0.9,8.1-2.7c1.9-1.8,2.8-4.5,2.8-7.9\" + ' ' +\n          \"V4.9h-1.7v20.8C137.8,31.7,134.8,34.8,128.6,34.8z\"}\n        ), \n        React.createElement(\"path\", {d: \"M155.4,10.8h-7.6V0l28.7,0v10.8h-7.6v30.3h-13.6V10.8z M163,36.2V6.4h8.8V4.9h-19.2v1.5h8.8v29.8H163z\"}), \n        React.createElement(\"path\", {\n          d: \"M186.4,0l9.9,0l15.6,41.1h-12.9l-1.4-3.7h-12.5l-1.4,3.7h-12.9L186.4,0z M180,36.2l1.2-3.1h20.3l1.2,3.1\" + ' ' +\n          \"h1.7L192.5,4.9h-2.3l-11.9,31.3H180z M191.3,6.4l9.6,25.2h-19.2L191.3,6.4z M194.1,28.4l-2.8-7.2l-2.8,7.2H194.1z\"}\n        ), \n        React.createElement(\"path\", {\n          d: \"M212.9,0L229,0c2.1,0,3.9,0.2,5.6,0.7c1.7,0.5,3.2,1.2,4.4,2.1s2.2,2.1,2.8,3.5c0.7,1.4,1,3,1,4.8\" + ' ' +\n          \"c0,1.3-0.2,2.4-0.5,3.4c-0.3,0.9-0.7,1.7-1,2.3c-0.5,0.7-1,1.4-1.5,1.8c0.9,0.6,1.7,1.3,2.5,2.2c0.6,0.8,1.2,1.8,1.7,3\" + ' ' +\n          \"c0.5,1.2,0.8,2.7,0.8,4.4c0,2-0.3,3.8-1,5.4c-0.7,1.6-1.7,3-3,4.1c-1.3,1.1-2.9,2-4.7,2.6c-1.9,0.6-4,0.9-6.3,0.9h-16.8V0z\" + ' ' +\n           \"M228,36.2c3.6,0,6.3-0.8,8-2.3c1.7-1.6,2.6-3.6,2.6-6.2c0-1.7-0.4-3-1.1-4c-0.7-1-1.5-1.8-2.3-2.4c-1-0.7-2.2-1.1-3.4-1.4\" + ' ' +\n          \"c1-0.3,1.9-0.7,2.7-1.4c0.7-0.5,1.3-1.3,1.9-2.2s0.8-2.1,0.8-3.5c0-2.6-0.8-4.5-2.5-5.9c-1.6-1.3-3.9-2-6.7-2h-8.9v31.3H228z\" + ' ' +\n           \"M220.7,19.1V6.4l7.3,0c2.7,0,4.6,0.6,5.8,1.8c1.2,1.2,1.8,2.7,1.8,4.6c0,1.9-0.6,3.4-1.8,4.6c-1.2,1.2-3.1,1.8-5.8,1.8H220.7z\" + ' ' +\n           \"M220.7,34.7V20.6h7.2c1.3,0,2.5,0.1,3.5,0.4c1.1,0.3,2,0.7,2.9,1.2c0.8,0.6,1.5,1.3,1.9,2.2c0.5,0.9,0.7,2,0.7,3.2\" + ' ' +\n          \"c0,2.5-0.8,4.3-2.5,5.4c-1.7,1.1-3.9,1.7-6.6,1.7H220.7z M230.2,12.5c0-1.9-1-2.8-3.1-2.8h-1.5v5.7h1.5\" + ' ' +\n          \"C229.2,15.4,230.2,14.4,230.2,12.5z M227.1,31.4c3.1,0,4.7-1.2,4.7-3.6c0-2.4-1.6-3.6-4.7-3.6h-1.5v7.2H227.1z\"}\n        ), \n        React.createElement(\"path\", {d: \"M248.3,0L262,0v30.3h11.3v10.8h-25V0z M269.9,36.2v-1.5h-13.8V4.9h-1.6v31.3H269.9z\"}), \n        React.createElement(\"path\", {\n          d: \"M275.3,0l24.2,0v10.8h-11.1v4.6h10.9v10.2h-10.9v4.7H300v10.8h-24.7V0z M295.4,36.2v-1.5h-12.3V21.2h11.7\" + ' ' +\n          \"v-1.5h-11.7V6.4h12.3V4.9h-13.9v31.3H295.4z\"}\n        )\n      )\n    );\n  },\n});\n\nmodule.exports = Logo;\n","var React = require('react');\n\nvar SVGSet = React.createClass({displayName: \"SVGSet\",\n  render: function () {\n    return (\n      React.createElement(\"svg\", {className: \"svg\", style: this.props.style, viewBox: \"0 0 300 42.2\"}, \n        this.props.children\n      )\n    );\n  },\n});\n\nmodule.exports = SVGSet;\n","module.exports = global.Immutable;\n","module.exports = global.React;\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi8uLi8uLi9kaXN0L2ltbXV0YWJsZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2FjdGlvbnMvTG9jYXRpb25BY3Rpb25zLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2JlaGF2aW9ycy9JbWl0YXRlQnJvd3NlckJlaGF2aW9yLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2JlaGF2aW9ycy9TY3JvbGxUb1RvcEJlaGF2aW9yLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2NvbXBvbmVudHMvRGVmYXVsdFJvdXRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2NvbXBvbmVudHMvTGluay5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy9jb21wb25lbnRzL05vdEZvdW5kUm91dGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvY29tcG9uZW50cy9SZWRpcmVjdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy9jb21wb25lbnRzL1JvdXRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2NvbXBvbmVudHMvUm91dGVIYW5kbGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2xvY2F0aW9ucy9IYXNoTG9jYXRpb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvbG9jYXRpb25zL0hpc3RvcnlMb2NhdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy9sb2NhdGlvbnMvUmVmcmVzaExvY2F0aW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL21peGlucy9GYWtlTm9kZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy9taXhpbnMvTmF2aWdhdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy9taXhpbnMvTmF2aWdhdGlvbkNvbnRleHQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvbWl4aW5zL1JvdXRlSGFuZGxlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy9taXhpbnMvU2Nyb2xsaW5nLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL21peGlucy9TdGF0ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy9taXhpbnMvU3RhdGVDb250ZXh0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL3V0aWxzL0NhbmNlbGxhdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy91dGlscy9IaXN0b3J5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL3V0aWxzL1BhdGguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvdXRpbHMvUHJvbWlzZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy91dGlscy9Qcm9wVHlwZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvdXRpbHMvUmVkaXJlY3QuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvdXRpbHMvVHJhbnNpdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy91dGlscy9jcmVhdGVSb3V0ZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvdXRpbHMvY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL3V0aWxzL2dldFdpbmRvd1Njcm9sbFBvc2l0aW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL3V0aWxzL3JldmVyc2VkQXJyYXkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvdXRpbHMvcnVuUm91dGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL3V0aWxzL3N1cHBvcnRzSGlzdG9yeS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL3FzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvcXMvbGliL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvcXMvbGliL3BhcnNlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvcXMvbGliL3N0cmluZ2lmeS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL3FzL2xpYi91dGlscy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL3doZW4vbGliL1Byb21pc2UuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL25vZGVfbW9kdWxlcy93aGVuL2xpYi9RdWV1ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL3doZW4vbGliL1NjaGVkdWxlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL3doZW4vbGliL2FzeW5jLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvd2hlbi9saWIvbWFrZVByb21pc2UuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL0NTU0NvcmUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9PYmplY3QuYXNzaWduLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFRyYW5zaXRpb25FdmVudHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2N4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9pbnZhcmlhbnQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL3dhcm5pbmcuanMiLCIuLi8uLi8uLi9wYWNrYWdlLmpzb24iLCIuLi8uLi9nZW5lcmF0ZWQvaW1tdXRhYmxlLmQuanNvbiIsIi4uLy4uL2xpYi9UeXBlS2luZC5qcyIsIi4uLy4uL2xpYi9jb2xsZWN0TWVtYmVyR3JvdXBzLmpzIiwiLi4vLi4vbGliL2dldFR5cGVEZWZzLmpzIiwiLi4vLi4vbGliL21hcmtkb3duLmpzIiwiLi4vLi4vbGliL21hcmtkb3duRG9jcy5qcyIsIi4uLy4uL2xpYi9wcmlzbS5qcyIsIi4uLy4uL2xpYi9ydW5raXQtZW1iZWQuanMiLCJzcmMvRGVmcy5qcyIsInNyYy9Eb2NIZWFkZXIuanMiLCJzcmMvRG9jT3ZlcnZpZXcuanMiLCJzcmMvRG9jU2VhcmNoLmpzIiwic3JjL01hcmtEb3duLmpzIiwic3JjL01lbWJlckRvYy5qcyIsInNyYy9QYWdlRGF0YU1peGluLmpzIiwic3JjL1NpZGVCYXIuanMiLCJzcmMvVHlwZURvY3VtZW50YXRpb24uanMiLCJzcmMvaW5kZXguanMiLCJzcmMvaXNNb2JpbGUuanMiLCIuLi9zcmMvTG9nby5qcyIsIi4uL3NyYy9TVkdTZXQuanMiLCIuLi8uLi8uLi9yZXNvdXJjZXMvaW1tdXRhYmxlLWdsb2JhbC5qcyIsIi4uLy4uLy4uL3Jlc291cmNlcy9yZWFjdC1nbG9iYWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL3RMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0bkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzllQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNXhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RJQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDYkE7QUFDQTs7Ozs7QUNEQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiLyoqXG4gKiBNSVQgTGljZW5zZVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgTGVlIEJ5cm9uIGFuZCBvdGhlciBjb250cmlidXRvcnMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5JbW11dGFibGUgPSB7fSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBERUxFVEUgPSAnZGVsZXRlJztcblxuICAvLyBDb25zdGFudHMgZGVzY3JpYmluZyB0aGUgc2l6ZSBvZiB0cmllIG5vZGVzLlxuICB2YXIgU0hJRlQgPSA1OyAvLyBSZXN1bHRlZCBpbiBiZXN0IHBlcmZvcm1hbmNlIGFmdGVyIF9fX19fXz9cbiAgdmFyIFNJWkUgPSAxIDw8IFNISUZUO1xuICB2YXIgTUFTSyA9IFNJWkUgLSAxO1xuXG4gIC8vIEEgY29uc2lzdGVudCBzaGFyZWQgdmFsdWUgcmVwcmVzZW50aW5nIFwibm90IHNldFwiIHdoaWNoIGVxdWFscyBub3RoaW5nIG90aGVyXG4gIC8vIHRoYW4gaXRzZWxmLCBhbmQgbm90aGluZyB0aGF0IGNvdWxkIGJlIHByb3ZpZGVkIGV4dGVybmFsbHkuXG4gIHZhciBOT1RfU0VUID0ge307XG5cbiAgLy8gQm9vbGVhbiByZWZlcmVuY2VzLCBSb3VnaCBlcXVpdmFsZW50IG9mIGBib29sICZgLlxuICBmdW5jdGlvbiBNYWtlUmVmKCkge1xuICAgIHJldHVybiB7IHZhbHVlOiBmYWxzZSB9O1xuICB9XG5cbiAgZnVuY3Rpb24gU2V0UmVmKHJlZikge1xuICAgIGlmIChyZWYpIHtcbiAgICAgIHJlZi52YWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gQSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgdmFsdWUgcmVwcmVzZW50aW5nIGFuIFwib3duZXJcIiBmb3IgdHJhbnNpZW50IHdyaXRlc1xuICAvLyB0byB0cmllcy4gVGhlIHJldHVybiB2YWx1ZSB3aWxsIG9ubHkgZXZlciBlcXVhbCBpdHNlbGYsIGFuZCB3aWxsIG5vdCBlcXVhbFxuICAvLyB0aGUgcmV0dXJuIG9mIGFueSBzdWJzZXF1ZW50IGNhbGwgb2YgdGhpcyBmdW5jdGlvbi5cbiAgZnVuY3Rpb24gT3duZXJJRCgpIHt9XG5cbiAgZnVuY3Rpb24gZW5zdXJlU2l6ZShpdGVyKSB7XG4gICAgaWYgKGl0ZXIuc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpdGVyLnNpemUgPSBpdGVyLl9faXRlcmF0ZShyZXR1cm5UcnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZXIuc2l6ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBJbmRleChpdGVyLCBpbmRleCkge1xuICAgIC8vIFRoaXMgaW1wbGVtZW50cyBcImlzIGFycmF5IGluZGV4XCIgd2hpY2ggdGhlIEVDTUFTdHJpbmcgc3BlYyBkZWZpbmVzIGFzOlxuICAgIC8vXG4gICAgLy8gICAgIEEgU3RyaW5nIHByb3BlcnR5IG5hbWUgUCBpcyBhbiBhcnJheSBpbmRleCBpZiBhbmQgb25seSBpZlxuICAgIC8vICAgICBUb1N0cmluZyhUb1VpbnQzMihQKSkgaXMgZXF1YWwgdG8gUCBhbmQgVG9VaW50MzIoUCkgaXMgbm90IGVxdWFsXG4gICAgLy8gICAgIHRvIDJeMzLiiJIxLlxuICAgIC8vXG4gICAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWFycmF5LWV4b3RpYy1vYmplY3RzXG4gICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHZhciB1aW50MzJJbmRleCA9IGluZGV4ID4+PiAwOyAvLyBOID4+PiAwIGlzIHNob3J0aGFuZCBmb3IgVG9VaW50MzJcbiAgICAgIGlmICgnJyArIHVpbnQzMkluZGV4ICE9PSBpbmRleCB8fCB1aW50MzJJbmRleCA9PT0gNDI5NDk2NzI5NSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgfVxuICAgICAgaW5kZXggPSB1aW50MzJJbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4IDwgMCA/IGVuc3VyZVNpemUoaXRlcikgKyBpbmRleCA6IGluZGV4O1xuICB9XG5cbiAgZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgc2l6ZSkge1xuICAgIHJldHVybiAoXG4gICAgICAoKGJlZ2luID09PSAwICYmICFpc05lZyhiZWdpbikpIHx8XG4gICAgICAgIChzaXplICE9PSB1bmRlZmluZWQgJiYgYmVnaW4gPD0gLXNpemUpKSAmJlxuICAgICAgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IChzaXplICE9PSB1bmRlZmluZWQgJiYgZW5kID49IHNpemUpKVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlQmVnaW4oYmVnaW4sIHNpemUpIHtcbiAgICByZXR1cm4gcmVzb2x2ZUluZGV4KGJlZ2luLCBzaXplLCAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVFbmQoZW5kLCBzaXplKSB7XG4gICAgcmV0dXJuIHJlc29sdmVJbmRleChlbmQsIHNpemUsIHNpemUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUluZGV4KGluZGV4LCBzaXplLCBkZWZhdWx0SW5kZXgpIHtcbiAgICAvLyBTYW5pdGl6ZSBpbmRpY2VzIHVzaW5nIHRoaXMgc2hvcnRoYW5kIGZvciBUb0ludDMyKGFyZ3VtZW50KVxuICAgIC8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2ludDMyXG4gICAgcmV0dXJuIGluZGV4ID09PSB1bmRlZmluZWRcbiAgICAgID8gZGVmYXVsdEluZGV4XG4gICAgICA6IGlzTmVnKGluZGV4KVxuICAgICAgPyBzaXplID09PSBJbmZpbml0eVxuICAgICAgICA/IHNpemVcbiAgICAgICAgOiBNYXRoLm1heCgwLCBzaXplICsgaW5kZXgpIHwgMFxuICAgICAgOiBzaXplID09PSB1bmRlZmluZWQgfHwgc2l6ZSA9PT0gaW5kZXhcbiAgICAgID8gaW5kZXhcbiAgICAgIDogTWF0aC5taW4oc2l6ZSwgaW5kZXgpIHwgMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTmVnKHZhbHVlKSB7XG4gICAgLy8gQWNjb3VudCBmb3IgLTAgd2hpY2ggaXMgbmVnYXRpdmUsIGJ1dCBub3QgbGVzcyB0aGFuIDAuXG4gICAgcmV0dXJuIHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlID09PSAtSW5maW5pdHkpO1xuICB9XG5cbiAgdmFyIElTX0NPTExFQ1RJT05fU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfSVRFUkFCTEVfX0BAJztcblxuICBmdW5jdGlvbiBpc0NvbGxlY3Rpb24obWF5YmVDb2xsZWN0aW9uKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4obWF5YmVDb2xsZWN0aW9uICYmIG1heWJlQ29sbGVjdGlvbltJU19DT0xMRUNUSU9OX1NZTUJPTF0pO1xuICB9XG5cbiAgdmFyIElTX0tFWUVEX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX0tFWUVEX19AQCc7XG5cbiAgZnVuY3Rpb24gaXNLZXllZChtYXliZUtleWVkKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4obWF5YmVLZXllZCAmJiBtYXliZUtleWVkW0lTX0tFWUVEX1NZTUJPTF0pO1xuICB9XG5cbiAgdmFyIElTX0lOREVYRURfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfSU5ERVhFRF9fQEAnO1xuXG4gIGZ1bmN0aW9uIGlzSW5kZXhlZChtYXliZUluZGV4ZWQpIHtcbiAgICByZXR1cm4gQm9vbGVhbihtYXliZUluZGV4ZWQgJiYgbWF5YmVJbmRleGVkW0lTX0lOREVYRURfU1lNQk9MXSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0Fzc29jaWF0aXZlKG1heWJlQXNzb2NpYXRpdmUpIHtcbiAgICByZXR1cm4gaXNLZXllZChtYXliZUFzc29jaWF0aXZlKSB8fCBpc0luZGV4ZWQobWF5YmVBc3NvY2lhdGl2ZSk7XG4gIH1cblxuICB2YXIgQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIENvbGxlY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gaXNDb2xsZWN0aW9uKHZhbHVlKSA/IHZhbHVlIDogU2VxKHZhbHVlKTtcbiAgfTtcblxuICB2YXIgS2V5ZWRDb2xsZWN0aW9uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQ29sbGVjdGlvbikge1xuICAgIGZ1bmN0aW9uIEtleWVkQ29sbGVjdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzS2V5ZWQodmFsdWUpID8gdmFsdWUgOiBLZXllZFNlcSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKCBDb2xsZWN0aW9uICkgS2V5ZWRDb2xsZWN0aW9uLl9fcHJvdG9fXyA9IENvbGxlY3Rpb247XG4gICAgS2V5ZWRDb2xsZWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGUgKTtcbiAgICBLZXllZENvbGxlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gS2V5ZWRDb2xsZWN0aW9uO1xuXG4gICAgcmV0dXJuIEtleWVkQ29sbGVjdGlvbjtcbiAgfShDb2xsZWN0aW9uKSk7XG5cbiAgdmFyIEluZGV4ZWRDb2xsZWN0aW9uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQ29sbGVjdGlvbikge1xuICAgIGZ1bmN0aW9uIEluZGV4ZWRDb2xsZWN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNJbmRleGVkKHZhbHVlKSA/IHZhbHVlIDogSW5kZXhlZFNlcSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKCBDb2xsZWN0aW9uICkgSW5kZXhlZENvbGxlY3Rpb24uX19wcm90b19fID0gQ29sbGVjdGlvbjtcbiAgICBJbmRleGVkQ29sbGVjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlICk7XG4gICAgSW5kZXhlZENvbGxlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW5kZXhlZENvbGxlY3Rpb247XG5cbiAgICByZXR1cm4gSW5kZXhlZENvbGxlY3Rpb247XG4gIH0oQ29sbGVjdGlvbikpO1xuXG4gIHZhciBTZXRDb2xsZWN0aW9uID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQ29sbGVjdGlvbikge1xuICAgIGZ1bmN0aW9uIFNldENvbGxlY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0NvbGxlY3Rpb24odmFsdWUpICYmICFpc0Fzc29jaWF0aXZlKHZhbHVlKSA/IHZhbHVlIDogU2V0U2VxKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoIENvbGxlY3Rpb24gKSBTZXRDb2xsZWN0aW9uLl9fcHJvdG9fXyA9IENvbGxlY3Rpb247XG4gICAgU2V0Q29sbGVjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlICk7XG4gICAgU2V0Q29sbGVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXRDb2xsZWN0aW9uO1xuXG4gICAgcmV0dXJuIFNldENvbGxlY3Rpb247XG4gIH0oQ29sbGVjdGlvbikpO1xuXG4gIENvbGxlY3Rpb24uS2V5ZWQgPSBLZXllZENvbGxlY3Rpb247XG4gIENvbGxlY3Rpb24uSW5kZXhlZCA9IEluZGV4ZWRDb2xsZWN0aW9uO1xuICBDb2xsZWN0aW9uLlNldCA9IFNldENvbGxlY3Rpb247XG5cbiAgdmFyIElTX1NFUV9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9TRVFfX0BAJztcblxuICBmdW5jdGlvbiBpc1NlcShtYXliZVNlcSkge1xuICAgIHJldHVybiBCb29sZWFuKG1heWJlU2VxICYmIG1heWJlU2VxW0lTX1NFUV9TWU1CT0xdKTtcbiAgfVxuXG4gIHZhciBJU19SRUNPUkRfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfUkVDT1JEX19AQCc7XG5cbiAgZnVuY3Rpb24gaXNSZWNvcmQobWF5YmVSZWNvcmQpIHtcbiAgICByZXR1cm4gQm9vbGVhbihtYXliZVJlY29yZCAmJiBtYXliZVJlY29yZFtJU19SRUNPUkRfU1lNQk9MXSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0ltbXV0YWJsZShtYXliZUltbXV0YWJsZSkge1xuICAgIHJldHVybiBpc0NvbGxlY3Rpb24obWF5YmVJbW11dGFibGUpIHx8IGlzUmVjb3JkKG1heWJlSW1tdXRhYmxlKTtcbiAgfVxuXG4gIHZhciBJU19PUkRFUkVEX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX09SREVSRURfX0BAJztcblxuICBmdW5jdGlvbiBpc09yZGVyZWQobWF5YmVPcmRlcmVkKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4obWF5YmVPcmRlcmVkICYmIG1heWJlT3JkZXJlZFtJU19PUkRFUkVEX1NZTUJPTF0pO1xuICB9XG5cbiAgdmFyIElURVJBVEVfS0VZUyA9IDA7XG4gIHZhciBJVEVSQVRFX1ZBTFVFUyA9IDE7XG4gIHZhciBJVEVSQVRFX0VOVFJJRVMgPSAyO1xuXG4gIHZhciBSRUFMX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IFJFQUxfSVRFUkFUT1JfU1lNQk9MIHx8IEZBVVhfSVRFUkFUT1JfU1lNQk9MO1xuXG4gIHZhciBJdGVyYXRvciA9IGZ1bmN0aW9uIEl0ZXJhdG9yKG5leHQpIHtcbiAgICB0aGlzLm5leHQgPSBuZXh0O1xuICB9O1xuXG4gIEl0ZXJhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gJ1tJdGVyYXRvcl0nO1xuICB9O1xuXG4gIEl0ZXJhdG9yLktFWVMgPSBJVEVSQVRFX0tFWVM7XG4gIEl0ZXJhdG9yLlZBTFVFUyA9IElURVJBVEVfVkFMVUVTO1xuICBJdGVyYXRvci5FTlRSSUVTID0gSVRFUkFURV9FTlRSSUVTO1xuXG4gIEl0ZXJhdG9yLnByb3RvdHlwZS5pbnNwZWN0ID0gSXRlcmF0b3IucHJvdG90eXBlLnRvU291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG4gIEl0ZXJhdG9yLnByb3RvdHlwZVtJVEVSQVRPUl9TWU1CT0xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGl0ZXJhdG9yVmFsdWUodHlwZSwgaywgdiwgaXRlcmF0b3JSZXN1bHQpIHtcbiAgICB2YXIgdmFsdWUgPSB0eXBlID09PSAwID8gayA6IHR5cGUgPT09IDEgPyB2IDogW2ssIHZdO1xuICAgIGl0ZXJhdG9yUmVzdWx0XG4gICAgICA/IChpdGVyYXRvclJlc3VsdC52YWx1ZSA9IHZhbHVlKVxuICAgICAgOiAoaXRlcmF0b3JSZXN1bHQgPSB7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICByZXR1cm4gaXRlcmF0b3JSZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBpdGVyYXRvckRvbmUoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzSXRlcmF0b3IobWF5YmVJdGVyYWJsZSkge1xuICAgIHJldHVybiAhIWdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0l0ZXJhdG9yKG1heWJlSXRlcmF0b3IpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvciAmJiB0eXBlb2YgbWF5YmVJdGVyYXRvci5uZXh0ID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3IoaXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oaXRlcmFibGUpO1xuICAgIHJldHVybiBpdGVyYXRvckZuICYmIGl0ZXJhdG9yRm4uY2FsbChpdGVyYWJsZSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKGl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPVxuICAgICAgaXRlcmFibGUgJiZcbiAgICAgICgoUkVBTF9JVEVSQVRPUl9TWU1CT0wgJiYgaXRlcmFibGVbUkVBTF9JVEVSQVRPUl9TWU1CT0xdKSB8fFxuICAgICAgICBpdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgdmFsdWUgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIE51bWJlci5pc0ludGVnZXIodmFsdWUubGVuZ3RoKSAmJlxuICAgICAgdmFsdWUubGVuZ3RoID49IDAgJiZcbiAgICAgICh2YWx1ZS5sZW5ndGggPT09IDBcbiAgICAgICAgPyAvLyBPbmx5IHtsZW5ndGg6IDB9IGlzIGNvbnNpZGVyZWQgQXJyYXktbGlrZS5cbiAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAxXG4gICAgICAgIDogLy8gQW4gb2JqZWN0IGlzIG9ubHkgQXJyYXktbGlrZSBpZiBpdCBoYXMgYSBwcm9wZXJ0eSB3aGVyZSB0aGUgbGFzdCB2YWx1ZVxuICAgICAgICAgIC8vIGluIHRoZSBhcnJheS1saWtlIG1heSBiZSBmb3VuZCAod2hpY2ggY291bGQgYmUgdW5kZWZpbmVkKS5cbiAgICAgICAgICB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZS5sZW5ndGggLSAxKSlcbiAgICApO1xuICB9XG5cbiAgdmFyIFNlcSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKENvbGxlY3Rpb24pIHtcbiAgICBmdW5jdGlvbiBTZXEodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gZW1wdHlTZXF1ZW5jZSgpXG4gICAgICAgIDogaXNJbW11dGFibGUodmFsdWUpXG4gICAgICAgID8gdmFsdWUudG9TZXEoKVxuICAgICAgICA6IHNlcUZyb21WYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKCBDb2xsZWN0aW9uICkgU2VxLl9fcHJvdG9fXyA9IENvbGxlY3Rpb247XG4gICAgU2VxLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGUgKTtcbiAgICBTZXEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2VxO1xuXG4gICAgU2VxLnByb3RvdHlwZS50b1NlcSA9IGZ1bmN0aW9uIHRvU2VxICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBTZXEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnU2VxIHsnLCAnfScpO1xuICAgIH07XG5cbiAgICBTZXEucHJvdG90eXBlLmNhY2hlUmVzdWx0ID0gZnVuY3Rpb24gY2FjaGVSZXN1bHQgKCkge1xuICAgICAgaWYgKCF0aGlzLl9jYWNoZSAmJiB0aGlzLl9faXRlcmF0ZVVuY2FjaGVkKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlID0gdGhpcy5lbnRyeVNlcSgpLnRvQXJyYXkoKTtcbiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5fY2FjaGUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8vIGFic3RyYWN0IF9faXRlcmF0ZVVuY2FjaGVkKGZuLCByZXZlcnNlKVxuXG4gICAgU2VxLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgY2FjaGUgPSB0aGlzLl9jYWNoZTtcbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICB2YXIgc2l6ZSA9IGNhY2hlLmxlbmd0aDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSAhPT0gc2l6ZSkge1xuICAgICAgICAgIHZhciBlbnRyeSA9IGNhY2hlW3JldmVyc2UgPyBzaXplIC0gKytpIDogaSsrXTtcbiAgICAgICAgICBpZiAoZm4oZW50cnlbMV0sIGVudHJ5WzBdLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9faXRlcmF0ZVVuY2FjaGVkKGZuLCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgLy8gYWJzdHJhY3QgX19pdGVyYXRvclVuY2FjaGVkKHR5cGUsIHJldmVyc2UpXG5cbiAgICBTZXEucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgY2FjaGUgPSB0aGlzLl9jYWNoZTtcbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICB2YXIgc2l6ZSA9IGNhY2hlLmxlbmd0aDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZW50cnkgPSBjYWNoZVtyZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrK107XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdG9yVW5jYWNoZWQodHlwZSwgcmV2ZXJzZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXE7XG4gIH0oQ29sbGVjdGlvbikpO1xuXG4gIHZhciBLZXllZFNlcSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNlcSkge1xuICAgIGZ1bmN0aW9uIEtleWVkU2VxKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IGVtcHR5U2VxdWVuY2UoKS50b0tleWVkU2VxKClcbiAgICAgICAgOiBpc0NvbGxlY3Rpb24odmFsdWUpXG4gICAgICAgID8gaXNLZXllZCh2YWx1ZSlcbiAgICAgICAgICA/IHZhbHVlLnRvU2VxKClcbiAgICAgICAgICA6IHZhbHVlLmZyb21FbnRyeVNlcSgpXG4gICAgICAgIDogaXNSZWNvcmQodmFsdWUpXG4gICAgICAgID8gdmFsdWUudG9TZXEoKVxuICAgICAgICA6IGtleWVkU2VxRnJvbVZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoIFNlcSApIEtleWVkU2VxLl9fcHJvdG9fXyA9IFNlcTtcbiAgICBLZXllZFNlcS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTZXEgJiYgU2VxLnByb3RvdHlwZSApO1xuICAgIEtleWVkU2VxLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEtleWVkU2VxO1xuXG4gICAgS2V5ZWRTZXEucHJvdG90eXBlLnRvS2V5ZWRTZXEgPSBmdW5jdGlvbiB0b0tleWVkU2VxICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICByZXR1cm4gS2V5ZWRTZXE7XG4gIH0oU2VxKSk7XG5cbiAgdmFyIEluZGV4ZWRTZXEgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTZXEpIHtcbiAgICBmdW5jdGlvbiBJbmRleGVkU2VxKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IGVtcHR5U2VxdWVuY2UoKVxuICAgICAgICA6IGlzQ29sbGVjdGlvbih2YWx1ZSlcbiAgICAgICAgPyBpc0tleWVkKHZhbHVlKVxuICAgICAgICAgID8gdmFsdWUuZW50cnlTZXEoKVxuICAgICAgICAgIDogdmFsdWUudG9JbmRleGVkU2VxKClcbiAgICAgICAgOiBpc1JlY29yZCh2YWx1ZSlcbiAgICAgICAgPyB2YWx1ZS50b1NlcSgpLmVudHJ5U2VxKClcbiAgICAgICAgOiBpbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoIFNlcSApIEluZGV4ZWRTZXEuX19wcm90b19fID0gU2VxO1xuICAgIEluZGV4ZWRTZXEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2VxICYmIFNlcS5wcm90b3R5cGUgKTtcbiAgICBJbmRleGVkU2VxLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEluZGV4ZWRTZXE7XG5cbiAgICBJbmRleGVkU2VxLm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiBJbmRleGVkU2VxKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIEluZGV4ZWRTZXEucHJvdG90eXBlLnRvSW5kZXhlZFNlcSA9IGZ1bmN0aW9uIHRvSW5kZXhlZFNlcSAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgSW5kZXhlZFNlcS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdTZXEgWycsICddJyk7XG4gICAgfTtcblxuICAgIHJldHVybiBJbmRleGVkU2VxO1xuICB9KFNlcSkpO1xuXG4gIHZhciBTZXRTZXEgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTZXEpIHtcbiAgICBmdW5jdGlvbiBTZXRTZXEodmFsdWUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGlzQ29sbGVjdGlvbih2YWx1ZSkgJiYgIWlzQXNzb2NpYXRpdmUodmFsdWUpID8gdmFsdWUgOiBJbmRleGVkU2VxKHZhbHVlKVxuICAgICAgKS50b1NldFNlcSgpO1xuICAgIH1cblxuICAgIGlmICggU2VxICkgU2V0U2VxLl9fcHJvdG9fXyA9IFNlcTtcbiAgICBTZXRTZXEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2VxICYmIFNlcS5wcm90b3R5cGUgKTtcbiAgICBTZXRTZXEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2V0U2VxO1xuXG4gICAgU2V0U2VxLm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiBTZXRTZXEoYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgU2V0U2VxLnByb3RvdHlwZS50b1NldFNlcSA9IGZ1bmN0aW9uIHRvU2V0U2VxICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2V0U2VxO1xuICB9KFNlcSkpO1xuXG4gIFNlcS5pc1NlcSA9IGlzU2VxO1xuICBTZXEuS2V5ZWQgPSBLZXllZFNlcTtcbiAgU2VxLlNldCA9IFNldFNlcTtcbiAgU2VxLkluZGV4ZWQgPSBJbmRleGVkU2VxO1xuXG4gIFNlcS5wcm90b3R5cGVbSVNfU0VRX1NZTUJPTF0gPSB0cnVlO1xuXG4gIC8vICNwcmFnbWEgUm9vdCBTZXF1ZW5jZXNcblxuICB2YXIgQXJyYXlTZXEgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbmRleGVkU2VxKSB7XG4gICAgZnVuY3Rpb24gQXJyYXlTZXEoYXJyYXkpIHtcbiAgICAgIHRoaXMuX2FycmF5ID0gYXJyYXk7XG4gICAgICB0aGlzLnNpemUgPSBhcnJheS5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKCBJbmRleGVkU2VxICkgQXJyYXlTZXEuX19wcm90b19fID0gSW5kZXhlZFNlcTtcbiAgICBBcnJheVNlcS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkU2VxICYmIEluZGV4ZWRTZXEucHJvdG90eXBlICk7XG4gICAgQXJyYXlTZXEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXJyYXlTZXE7XG5cbiAgICBBcnJheVNlcS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhpbmRleCkgPyB0aGlzLl9hcnJheVt3cmFwSW5kZXgodGhpcywgaW5kZXgpXSA6IG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICBBcnJheVNlcS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5fYXJyYXk7XG4gICAgICB2YXIgc2l6ZSA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChpICE9PSBzaXplKSB7XG4gICAgICAgIHZhciBpaSA9IHJldmVyc2UgPyBzaXplIC0gKytpIDogaSsrO1xuICAgICAgICBpZiAoZm4oYXJyYXlbaWldLCBpaSwgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpO1xuICAgIH07XG5cbiAgICBBcnJheVNlcS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBhcnJheSA9IHRoaXMuX2FycmF5O1xuICAgICAgdmFyIHNpemUgPSBhcnJheS5sZW5ndGg7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGkgPT09IHNpemUpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlpID0gcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKys7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGlpLCBhcnJheVtpaV0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBBcnJheVNlcTtcbiAgfShJbmRleGVkU2VxKSk7XG5cbiAgdmFyIE9iamVjdFNlcSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEtleWVkU2VxKSB7XG4gICAgZnVuY3Rpb24gT2JqZWN0U2VxKG9iamVjdCkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICAgICAgdGhpcy5fb2JqZWN0ID0gb2JqZWN0O1xuICAgICAgdGhpcy5fa2V5cyA9IGtleXM7XG4gICAgICB0aGlzLnNpemUgPSBrZXlzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAoIEtleWVkU2VxICkgT2JqZWN0U2VxLl9fcHJvdG9fXyA9IEtleWVkU2VxO1xuICAgIE9iamVjdFNlcS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBLZXllZFNlcSAmJiBLZXllZFNlcS5wcm90b3R5cGUgKTtcbiAgICBPYmplY3RTZXEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT2JqZWN0U2VxO1xuXG4gICAgT2JqZWN0U2VxLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICAgIGlmIChub3RTZXRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICF0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgIHJldHVybiBub3RTZXRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9vYmplY3Rba2V5XTtcbiAgICB9O1xuXG4gICAgT2JqZWN0U2VxLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwodGhpcy5fb2JqZWN0LCBrZXkpO1xuICAgIH07XG5cbiAgICBPYmplY3RTZXEucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciBvYmplY3QgPSB0aGlzLl9vYmplY3Q7XG4gICAgICB2YXIga2V5cyA9IHRoaXMuX2tleXM7XG4gICAgICB2YXIgc2l6ZSA9IGtleXMubGVuZ3RoO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgd2hpbGUgKGkgIT09IHNpemUpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKytdO1xuICAgICAgICBpZiAoZm4ob2JqZWN0W2tleV0sIGtleSwgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpO1xuICAgIH07XG5cbiAgICBPYmplY3RTZXEucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gdGhpcy5fb2JqZWN0O1xuICAgICAgdmFyIGtleXMgPSB0aGlzLl9rZXlzO1xuICAgICAgdmFyIHNpemUgPSBrZXlzLmxlbmd0aDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaSA9PT0gc2l6ZSkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5ID0ga2V5c1tyZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrK107XG4gICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGtleSwgb2JqZWN0W2tleV0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBPYmplY3RTZXE7XG4gIH0oS2V5ZWRTZXEpKTtcbiAgT2JqZWN0U2VxLnByb3RvdHlwZVtJU19PUkRFUkVEX1NZTUJPTF0gPSB0cnVlO1xuXG4gIHZhciBDb2xsZWN0aW9uU2VxID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW5kZXhlZFNlcSkge1xuICAgIGZ1bmN0aW9uIENvbGxlY3Rpb25TZXEoY29sbGVjdGlvbikge1xuICAgICAgdGhpcy5fY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgICB0aGlzLnNpemUgPSBjb2xsZWN0aW9uLmxlbmd0aCB8fCBjb2xsZWN0aW9uLnNpemU7XG4gICAgfVxuXG4gICAgaWYgKCBJbmRleGVkU2VxICkgQ29sbGVjdGlvblNlcS5fX3Byb3RvX18gPSBJbmRleGVkU2VxO1xuICAgIENvbGxlY3Rpb25TZXEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW5kZXhlZFNlcSAmJiBJbmRleGVkU2VxLnByb3RvdHlwZSApO1xuICAgIENvbGxlY3Rpb25TZXEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29sbGVjdGlvblNlcTtcblxuICAgIENvbGxlY3Rpb25TZXEucHJvdG90eXBlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24gX19pdGVyYXRlVW5jYWNoZWQgKGZuLCByZXZlcnNlKSB7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXMuX2NvbGxlY3Rpb247XG4gICAgICB2YXIgaXRlcmF0b3IgPSBnZXRJdGVyYXRvcihjb2xsZWN0aW9uKTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIGlmIChpc0l0ZXJhdG9yKGl0ZXJhdG9yKSkge1xuICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChmbihzdGVwLnZhbHVlLCBpdGVyYXRpb25zKyssIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuXG4gICAgQ29sbGVjdGlvblNlcS5wcm90b3R5cGUuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24gX19pdGVyYXRvclVuY2FjaGVkICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXMuX2NvbGxlY3Rpb247XG4gICAgICB2YXIgaXRlcmF0b3IgPSBnZXRJdGVyYXRvcihjb2xsZWN0aW9uKTtcbiAgICAgIGlmICghaXNJdGVyYXRvcihpdGVyYXRvcikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihpdGVyYXRvckRvbmUpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICByZXR1cm4gc3RlcC5kb25lID8gc3RlcCA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCBzdGVwLnZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ29sbGVjdGlvblNlcTtcbiAgfShJbmRleGVkU2VxKSk7XG5cbiAgLy8gIyBwcmFnbWEgSGVscGVyIGZ1bmN0aW9uc1xuXG4gIHZhciBFTVBUWV9TRVE7XG5cbiAgZnVuY3Rpb24gZW1wdHlTZXF1ZW5jZSgpIHtcbiAgICByZXR1cm4gRU1QVFlfU0VRIHx8IChFTVBUWV9TRVEgPSBuZXcgQXJyYXlTZXEoW10pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGtleWVkU2VxRnJvbVZhbHVlKHZhbHVlKSB7XG4gICAgdmFyIHNlcSA9IEFycmF5LmlzQXJyYXkodmFsdWUpXG4gICAgICA/IG5ldyBBcnJheVNlcSh2YWx1ZSlcbiAgICAgIDogaGFzSXRlcmF0b3IodmFsdWUpXG4gICAgICA/IG5ldyBDb2xsZWN0aW9uU2VxKHZhbHVlKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gICAgaWYgKHNlcSkge1xuICAgICAgcmV0dXJuIHNlcS5mcm9tRW50cnlTZXEoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBuZXcgT2JqZWN0U2VxKHZhbHVlKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdFeHBlY3RlZCBBcnJheSBvciBjb2xsZWN0aW9uIG9iamVjdCBvZiBbaywgdl0gZW50cmllcywgb3Iga2V5ZWQgb2JqZWN0OiAnICtcbiAgICAgICAgdmFsdWVcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSkge1xuICAgIHZhciBzZXEgPSBtYXliZUluZGV4ZWRTZXFGcm9tVmFsdWUodmFsdWUpO1xuICAgIGlmIChzZXEpIHtcbiAgICAgIHJldHVybiBzZXE7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnRXhwZWN0ZWQgQXJyYXkgb3IgY29sbGVjdGlvbiBvYmplY3Qgb2YgdmFsdWVzOiAnICsgdmFsdWVcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VxRnJvbVZhbHVlKHZhbHVlKSB7XG4gICAgdmFyIHNlcSA9IG1heWJlSW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSk7XG4gICAgaWYgKHNlcSkge1xuICAgICAgcmV0dXJuIHNlcTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBuZXcgT2JqZWN0U2VxKHZhbHVlKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdFeHBlY3RlZCBBcnJheSBvciBjb2xsZWN0aW9uIG9iamVjdCBvZiB2YWx1ZXMsIG9yIGtleWVkIG9iamVjdDogJyArIHZhbHVlXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlSW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBpc0FycmF5TGlrZSh2YWx1ZSlcbiAgICAgID8gbmV3IEFycmF5U2VxKHZhbHVlKVxuICAgICAgOiBoYXNJdGVyYXRvcih2YWx1ZSlcbiAgICAgID8gbmV3IENvbGxlY3Rpb25TZXEodmFsdWUpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBJU19NQVBfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfTUFQX19AQCc7XG5cbiAgZnVuY3Rpb24gaXNNYXAobWF5YmVNYXApIHtcbiAgICByZXR1cm4gQm9vbGVhbihtYXliZU1hcCAmJiBtYXliZU1hcFtJU19NQVBfU1lNQk9MXSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc09yZGVyZWRNYXAobWF5YmVPcmRlcmVkTWFwKSB7XG4gICAgcmV0dXJuIGlzTWFwKG1heWJlT3JkZXJlZE1hcCkgJiYgaXNPcmRlcmVkKG1heWJlT3JkZXJlZE1hcCk7XG4gIH1cblxuICBmdW5jdGlvbiBpc1ZhbHVlT2JqZWN0KG1heWJlVmFsdWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbihcbiAgICAgIG1heWJlVmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIG1heWJlVmFsdWUuZXF1YWxzID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIHR5cGVvZiBtYXliZVZhbHVlLmhhc2hDb2RlID09PSAnZnVuY3Rpb24nXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBleHRlbnNpb24gb2YgdGhlIFwic2FtZS12YWx1ZVwiIGFsZ29yaXRobSBhcyBbZGVzY3JpYmVkIGZvciB1c2UgYnkgRVM2IE1hcFxuICAgKiBhbmQgU2V0XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXAjS2V5X2VxdWFsaXR5KVxuICAgKlxuICAgKiBOYU4gaXMgY29uc2lkZXJlZCB0aGUgc2FtZSBhcyBOYU4sIGhvd2V2ZXIgLTAgYW5kIDAgYXJlIGNvbnNpZGVyZWQgdGhlIHNhbWVcbiAgICogdmFsdWUsIHdoaWNoIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBhbGdvcml0aG0gZGVzY3JpYmVkIGJ5XG4gICAqIFtgT2JqZWN0LmlzYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzKS5cbiAgICpcbiAgICogVGhpcyBpcyBleHRlbmRlZCBmdXJ0aGVyIHRvIGFsbG93IE9iamVjdHMgdG8gZGVzY3JpYmUgdGhlIHZhbHVlcyB0aGV5XG4gICAqIHJlcHJlc2VudCwgYnkgd2F5IG9mIGB2YWx1ZU9mYCBvciBgZXF1YWxzYCAoYW5kIGBoYXNoQ29kZWApLlxuICAgKlxuICAgKiBOb3RlOiBiZWNhdXNlIG9mIHRoaXMgZXh0ZW5zaW9uLCB0aGUga2V5IGVxdWFsaXR5IG9mIEltbXV0YWJsZS5NYXAgYW5kIHRoZVxuICAgKiB2YWx1ZSBlcXVhbGl0eSBvZiBJbW11dGFibGUuU2V0IHdpbGwgZGlmZmVyIGZyb20gRVM2IE1hcCBhbmQgU2V0LlxuICAgKlxuICAgKiAjIyMgRGVmaW5pbmcgY3VzdG9tIHZhbHVlc1xuICAgKlxuICAgKiBUaGUgZWFzaWVzdCB3YXkgdG8gZGVzY3JpYmUgdGhlIHZhbHVlIGFuIG9iamVjdCByZXByZXNlbnRzIGlzIGJ5IGltcGxlbWVudGluZ1xuICAgKiBgdmFsdWVPZmAuIEZvciBleGFtcGxlLCBgRGF0ZWAgcmVwcmVzZW50cyBhIHZhbHVlIGJ5IHJldHVybmluZyBhIHVuaXhcbiAgICogdGltZXN0YW1wIGZvciBgdmFsdWVPZmA6XG4gICAqXG4gICAqICAgICB2YXIgZGF0ZTEgPSBuZXcgRGF0ZSgxMjM0NTY3ODkwMDAwKTsgLy8gRnJpIEZlYiAxMyAyMDA5IC4uLlxuICAgKiAgICAgdmFyIGRhdGUyID0gbmV3IERhdGUoMTIzNDU2Nzg5MDAwMCk7XG4gICAqICAgICBkYXRlMS52YWx1ZU9mKCk7IC8vIDEyMzQ1Njc4OTAwMDBcbiAgICogICAgIGFzc2VydCggZGF0ZTEgIT09IGRhdGUyICk7XG4gICAqICAgICBhc3NlcnQoIEltbXV0YWJsZS5pcyggZGF0ZTEsIGRhdGUyICkgKTtcbiAgICpcbiAgICogTm90ZTogb3ZlcnJpZGluZyBgdmFsdWVPZmAgbWF5IGhhdmUgb3RoZXIgaW1wbGljYXRpb25zIGlmIHlvdSB1c2UgdGhpcyBvYmplY3RcbiAgICogd2hlcmUgSmF2YVNjcmlwdCBleHBlY3RzIGEgcHJpbWl0aXZlLCBzdWNoIGFzIGltcGxpY2l0IHN0cmluZyBjb2VyY2lvbi5cbiAgICpcbiAgICogRm9yIG1vcmUgY29tcGxleCB0eXBlcywgZXNwZWNpYWxseSBjb2xsZWN0aW9ucywgaW1wbGVtZW50aW5nIGB2YWx1ZU9mYCBtYXlcbiAgICogbm90IGJlIHBlcmZvcm1hbnQuIEFuIGFsdGVybmF0aXZlIGlzIHRvIGltcGxlbWVudCBgZXF1YWxzYCBhbmQgYGhhc2hDb2RlYC5cbiAgICpcbiAgICogYGVxdWFsc2AgdGFrZXMgYW5vdGhlciBvYmplY3QsIHByZXN1bWFibHkgb2Ygc2ltaWxhciB0eXBlLCBhbmQgcmV0dXJucyB0cnVlXG4gICAqIGlmIGl0IGlzIGVxdWFsLiBFcXVhbGl0eSBpcyBzeW1tZXRyaWNhbCwgc28gdGhlIHNhbWUgcmVzdWx0IHNob3VsZCBiZVxuICAgKiByZXR1cm5lZCBpZiB0aGlzIGFuZCB0aGUgYXJndW1lbnQgYXJlIGZsaXBwZWQuXG4gICAqXG4gICAqICAgICBhc3NlcnQoIGEuZXF1YWxzKGIpID09PSBiLmVxdWFscyhhKSApO1xuICAgKlxuICAgKiBgaGFzaENvZGVgIHJldHVybnMgYSAzMmJpdCBpbnRlZ2VyIG51bWJlciByZXByZXNlbnRpbmcgdGhlIG9iamVjdCB3aGljaCB3aWxsXG4gICAqIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGhvdyB0byBzdG9yZSB0aGUgdmFsdWUgb2JqZWN0IGluIGEgTWFwIG9yIFNldC4gWW91IG11c3RcbiAgICogcHJvdmlkZSBib3RoIG9yIG5laXRoZXIgbWV0aG9kcywgb25lIG11c3Qgbm90IGV4aXN0IHdpdGhvdXQgdGhlIG90aGVyLlxuICAgKlxuICAgKiBBbHNvLCBhbiBpbXBvcnRhbnQgcmVsYXRpb25zaGlwIGJldHdlZW4gdGhlc2UgbWV0aG9kcyBtdXN0IGJlIHVwaGVsZDogaWYgdHdvXG4gICAqIHZhbHVlcyBhcmUgZXF1YWwsIHRoZXkgKm11c3QqIHJldHVybiB0aGUgc2FtZSBoYXNoQ29kZS4gSWYgdGhlIHZhbHVlcyBhcmUgbm90XG4gICAqIGVxdWFsLCB0aGV5IG1pZ2h0IGhhdmUgdGhlIHNhbWUgaGFzaENvZGU7IHRoaXMgaXMgY2FsbGVkIGEgaGFzaCBjb2xsaXNpb24sXG4gICAqIGFuZCB3aGlsZSB1bmRlc2lyYWJsZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgaXQgaXMgYWNjZXB0YWJsZS5cbiAgICpcbiAgICogICAgIGlmIChhLmVxdWFscyhiKSkge1xuICAgKiAgICAgICBhc3NlcnQoIGEuaGFzaENvZGUoKSA9PT0gYi5oYXNoQ29kZSgpICk7XG4gICAqICAgICB9XG4gICAqXG4gICAqIEFsbCBJbW11dGFibGUgY29sbGVjdGlvbnMgYXJlIFZhbHVlIE9iamVjdHM6IHRoZXkgaW1wbGVtZW50IGBlcXVhbHMoKWBcbiAgICogYW5kIGBoYXNoQ29kZSgpYC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzKHZhbHVlQSwgdmFsdWVCKSB7XG4gICAgaWYgKHZhbHVlQSA9PT0gdmFsdWVCIHx8ICh2YWx1ZUEgIT09IHZhbHVlQSAmJiB2YWx1ZUIgIT09IHZhbHVlQikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXZhbHVlQSB8fCAhdmFsdWVCKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIHR5cGVvZiB2YWx1ZUEudmFsdWVPZiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdHlwZW9mIHZhbHVlQi52YWx1ZU9mID09PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICB2YWx1ZUEgPSB2YWx1ZUEudmFsdWVPZigpO1xuICAgICAgdmFsdWVCID0gdmFsdWVCLnZhbHVlT2YoKTtcbiAgICAgIGlmICh2YWx1ZUEgPT09IHZhbHVlQiB8fCAodmFsdWVBICE9PSB2YWx1ZUEgJiYgdmFsdWVCICE9PSB2YWx1ZUIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCF2YWx1ZUEgfHwgIXZhbHVlQikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAhIShcbiAgICAgIGlzVmFsdWVPYmplY3QodmFsdWVBKSAmJlxuICAgICAgaXNWYWx1ZU9iamVjdCh2YWx1ZUIpICYmXG4gICAgICB2YWx1ZUEuZXF1YWxzKHZhbHVlQilcbiAgICApO1xuICB9XG5cbiAgdmFyIGltdWwgPVxuICAgIHR5cGVvZiBNYXRoLmltdWwgPT09ICdmdW5jdGlvbicgJiYgTWF0aC5pbXVsKDB4ZmZmZmZmZmYsIDIpID09PSAtMlxuICAgICAgPyBNYXRoLmltdWxcbiAgICAgIDogZnVuY3Rpb24gaW11bChhLCBiKSB7XG4gICAgICAgICAgYSB8PSAwOyAvLyBpbnRcbiAgICAgICAgICBiIHw9IDA7IC8vIGludFxuICAgICAgICAgIHZhciBjID0gYSAmIDB4ZmZmZjtcbiAgICAgICAgICB2YXIgZCA9IGIgJiAweGZmZmY7XG4gICAgICAgICAgLy8gU2hpZnQgYnkgMCBmaXhlcyB0aGUgc2lnbiBvbiB0aGUgaGlnaCBwYXJ0LlxuICAgICAgICAgIHJldHVybiAoYyAqIGQgKyAoKCgoYSA+Pj4gMTYpICogZCArIGMgKiAoYiA+Pj4gMTYpKSA8PCAxNikgPj4+IDApKSB8IDA7IC8vIGludFxuICAgICAgICB9O1xuXG4gIC8vIHY4IGhhcyBhbiBvcHRpbWl6YXRpb24gZm9yIHN0b3JpbmcgMzEtYml0IHNpZ25lZCBudW1iZXJzLlxuICAvLyBWYWx1ZXMgd2hpY2ggaGF2ZSBlaXRoZXIgMDAgb3IgMTEgYXMgdGhlIGhpZ2ggb3JkZXIgYml0cyBxdWFsaWZ5LlxuICAvLyBUaGlzIGZ1bmN0aW9uIGRyb3BzIHRoZSBoaWdoZXN0IG9yZGVyIGJpdCBpbiBhIHNpZ25lZCBudW1iZXIsIG1haW50YWluaW5nXG4gIC8vIHRoZSBzaWduIGJpdC5cbiAgZnVuY3Rpb24gc21pKGkzMikge1xuICAgIHJldHVybiAoKGkzMiA+Pj4gMSkgJiAweDQwMDAwMDAwKSB8IChpMzIgJiAweGJmZmZmZmZmKTtcbiAgfVxuXG4gIHZhciBkZWZhdWx0VmFsdWVPZiA9IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZjtcblxuICBmdW5jdGlvbiBoYXNoKG8pIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBvKSB7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgLy8gVGhlIGhhc2ggdmFsdWVzIGZvciBidWlsdC1pbiBjb25zdGFudHMgYXJlIGEgMSB2YWx1ZSBmb3IgZWFjaCA1LWJ5dGVcbiAgICAgICAgLy8gc2hpZnQgcmVnaW9uIGV4cGVjdCBmb3IgdGhlIGZpcnN0LCB3aGljaCBlbmNvZGVzIHRoZSB2YWx1ZS4gVGhpc1xuICAgICAgICAvLyByZWR1Y2VzIHRoZSBvZGRzIG9mIGEgaGFzaCBjb2xsaXNpb24gZm9yIHRoZXNlIGNvbW1vbiB2YWx1ZXMuXG4gICAgICAgIHJldHVybiBvID8gMHg0MjEwODQyMSA6IDB4NDIxMDg0MjA7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICByZXR1cm4gaGFzaE51bWJlcihvKTtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHJldHVybiBvLmxlbmd0aCA+IFNUUklOR19IQVNIX0NBQ0hFX01JTl9TVFJMRU5cbiAgICAgICAgICA/IGNhY2hlZEhhc2hTdHJpbmcobylcbiAgICAgICAgICA6IGhhc2hTdHJpbmcobyk7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICBpZiAobyA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAweDQyMTA4NDIyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygby5oYXNoQ29kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIERyb3AgYW55IGhpZ2ggYml0cyBmcm9tIGFjY2lkZW50YWxseSBsb25nIGhhc2ggY29kZXMuXG4gICAgICAgICAgcmV0dXJuIHNtaShvLmhhc2hDb2RlKG8pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoby52YWx1ZU9mICE9PSBkZWZhdWx0VmFsdWVPZiAmJiB0eXBlb2Ygby52YWx1ZU9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgbyA9IG8udmFsdWVPZihvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzaEpTT2JqKG8pO1xuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIDB4NDIxMDg0MjM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodHlwZW9mIG8udG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gaGFzaFN0cmluZyhvLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgdHlwZSAnICsgdHlwZW9mIG8gKyAnIGNhbm5vdCBiZSBoYXNoZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tcHJlc3MgYXJiaXRyYXJpbHkgbGFyZ2UgbnVtYmVycyBpbnRvIHNtaSBoYXNoZXMuXG4gIGZ1bmN0aW9uIGhhc2hOdW1iZXIobikge1xuICAgIGlmIChuICE9PSBuIHx8IG4gPT09IEluZmluaXR5KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdmFyIGhhc2ggPSBuIHwgMDtcbiAgICBpZiAoaGFzaCAhPT0gbikge1xuICAgICAgaGFzaCBePSBuICogMHhmZmZmZmZmZjtcbiAgICB9XG4gICAgd2hpbGUgKG4gPiAweGZmZmZmZmZmKSB7XG4gICAgICBuIC89IDB4ZmZmZmZmZmY7XG4gICAgICBoYXNoIF49IG47XG4gICAgfVxuICAgIHJldHVybiBzbWkoaGFzaCk7XG4gIH1cblxuICBmdW5jdGlvbiBjYWNoZWRIYXNoU3RyaW5nKHN0cmluZykge1xuICAgIHZhciBoYXNoZWQgPSBzdHJpbmdIYXNoQ2FjaGVbc3RyaW5nXTtcbiAgICBpZiAoaGFzaGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGhhc2hlZCA9IGhhc2hTdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChTVFJJTkdfSEFTSF9DQUNIRV9TSVpFID09PSBTVFJJTkdfSEFTSF9DQUNIRV9NQVhfU0laRSkge1xuICAgICAgICBTVFJJTkdfSEFTSF9DQUNIRV9TSVpFID0gMDtcbiAgICAgICAgc3RyaW5nSGFzaENhY2hlID0ge307XG4gICAgICB9XG4gICAgICBTVFJJTkdfSEFTSF9DQUNIRV9TSVpFKys7XG4gICAgICBzdHJpbmdIYXNoQ2FjaGVbc3RyaW5nXSA9IGhhc2hlZDtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2hlZDtcbiAgfVxuXG4gIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2hhc2hpbmctc3RyaW5nc1xuICBmdW5jdGlvbiBoYXNoU3RyaW5nKHN0cmluZykge1xuICAgIC8vIFRoaXMgaXMgdGhlIGhhc2ggZnJvbSBKVk1cbiAgICAvLyBUaGUgaGFzaCBjb2RlIGZvciBhIHN0cmluZyBpcyBjb21wdXRlZCBhc1xuICAgIC8vIHNbMF0gKiAzMSBeIChuIC0gMSkgKyBzWzFdICogMzEgXiAobiAtIDIpICsgLi4uICsgc1tuIC0gMV0sXG4gICAgLy8gd2hlcmUgc1tpXSBpcyB0aGUgaXRoIGNoYXJhY3RlciBvZiB0aGUgc3RyaW5nIGFuZCBuIGlzIHRoZSBsZW5ndGggb2ZcbiAgICAvLyB0aGUgc3RyaW5nLiBXZSBcIm1vZFwiIHRoZSByZXN1bHQgdG8gbWFrZSBpdCBiZXR3ZWVuIDAgKGluY2x1c2l2ZSkgYW5kIDJeMzFcbiAgICAvLyAoZXhjbHVzaXZlKSBieSBkcm9wcGluZyBoaWdoIGJpdHMuXG4gICAgdmFyIGhhc2hlZCA9IDA7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHN0cmluZy5sZW5ndGg7IGlpKyspIHtcbiAgICAgIGhhc2hlZCA9ICgzMSAqIGhhc2hlZCArIHN0cmluZy5jaGFyQ29kZUF0KGlpKSkgfCAwO1xuICAgIH1cbiAgICByZXR1cm4gc21pKGhhc2hlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNoSlNPYmoob2JqKSB7XG4gICAgdmFyIGhhc2hlZDtcbiAgICBpZiAodXNpbmdXZWFrTWFwKSB7XG4gICAgICBoYXNoZWQgPSB3ZWFrTWFwLmdldChvYmopO1xuICAgICAgaWYgKGhhc2hlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBoYXNoZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFzaGVkID0gb2JqW1VJRF9IQVNIX0tFWV07XG4gICAgaWYgKGhhc2hlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gaGFzaGVkO1xuICAgIH1cblxuICAgIGlmICghY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIGhhc2hlZCA9IG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZSAmJiBvYmoucHJvcGVydHlJc0VudW1lcmFibGVbVUlEX0hBU0hfS0VZXTtcbiAgICAgIGlmIChoYXNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaGFzaGVkO1xuICAgICAgfVxuXG4gICAgICBoYXNoZWQgPSBnZXRJRU5vZGVIYXNoKG9iaik7XG4gICAgICBpZiAoaGFzaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGhhc2hlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNoZWQgPSArK29iakhhc2hVSUQ7XG4gICAgaWYgKG9iakhhc2hVSUQgJiAweDQwMDAwMDAwKSB7XG4gICAgICBvYmpIYXNoVUlEID0gMDtcbiAgICB9XG5cbiAgICBpZiAodXNpbmdXZWFrTWFwKSB7XG4gICAgICB3ZWFrTWFwLnNldChvYmosIGhhc2hlZCk7XG4gICAgfSBlbHNlIGlmIChpc0V4dGVuc2libGUgIT09IHVuZGVmaW5lZCAmJiBpc0V4dGVuc2libGUob2JqKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm9uLWV4dGVuc2libGUgb2JqZWN0cyBhcmUgbm90IGFsbG93ZWQgYXMga2V5cy4nKTtcbiAgICB9IGVsc2UgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBVSURfSEFTSF9LRVksIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IGhhc2hlZCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBvYmoucHJvcGVydHlJc0VudW1lcmFibGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgb2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlID09PSBvYmouY29uc3RydWN0b3IucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlXG4gICAgKSB7XG4gICAgICAvLyBTaW5jZSB3ZSBjYW4ndCBkZWZpbmUgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBvbiB0aGUgb2JqZWN0XG4gICAgICAvLyB3ZSdsbCBoaWphY2sgb25lIG9mIHRoZSBsZXNzLXVzZWQgbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyB0b1xuICAgICAgLy8gc2F2ZSBvdXIgaGFzaCBvbiBpdC4gU2luY2UgdGhpcyBpcyBhIGZ1bmN0aW9uIGl0IHdpbGwgbm90IHNob3cgdXAgaW5cbiAgICAgIC8vIGBKU09OLnN0cmluZ2lmeWAgd2hpY2ggaXMgd2hhdCB3ZSB3YW50LlxuICAgICAgb2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuYXBwbHkoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBhcmd1bWVudHNcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICBvYmoucHJvcGVydHlJc0VudW1lcmFibGVbVUlEX0hBU0hfS0VZXSA9IGhhc2hlZDtcbiAgICB9IGVsc2UgaWYgKG9iai5ub2RlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGNvdWxkbid0IGdldCB0aGUgSUUgYHVuaXF1ZUlEYCB0byB1c2UgYXMgYSBoYXNoXG4gICAgICAvLyBhbmQgd2UgY291bGRuJ3QgdXNlIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgdG8gZXhwbG9pdCB0aGVcbiAgICAgIC8vIGRvbnRFbnVtIGJ1ZyBzbyB3ZSBzaW1wbHkgYWRkIHRoZSBgVUlEX0hBU0hfS0VZYCBvbiB0aGUgbm9kZVxuICAgICAgLy8gaXRzZWxmLlxuICAgICAgb2JqW1VJRF9IQVNIX0tFWV0gPSBoYXNoZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHNldCBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IG9uIG9iamVjdC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaGVkO1xuICB9XG5cbiAgLy8gR2V0IHJlZmVyZW5jZXMgdG8gRVM1IG9iamVjdCBtZXRob2RzLlxuICB2YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcblxuICAvLyBUcnVlIGlmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB3b3JrcyBhcyBleHBlY3RlZC4gSUU4IGZhaWxzIHRoaXMgdGVzdC5cbiAgdmFyIGNhbkRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnQCcsIHt9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pKCk7XG5cbiAgLy8gSUUgaGFzIGEgYHVuaXF1ZUlEYCBwcm9wZXJ0eSBvbiBET00gbm9kZXMuIFdlIGNhbiBjb25zdHJ1Y3QgdGhlIGhhc2ggZnJvbSBpdFxuICAvLyBhbmQgYXZvaWQgbWVtb3J5IGxlYWtzIGZyb20gdGhlIElFIGNsb25lTm9kZSBidWcuXG4gIGZ1bmN0aW9uIGdldElFTm9kZUhhc2gobm9kZSkge1xuICAgIGlmIChub2RlICYmIG5vZGUubm9kZVR5cGUgPiAwKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgICAgICAgY2FzZSAxOiAvLyBFbGVtZW50XG4gICAgICAgICAgcmV0dXJuIG5vZGUudW5pcXVlSUQ7XG4gICAgICAgIGNhc2UgOTogLy8gRG9jdW1lbnRcbiAgICAgICAgICByZXR1cm4gbm9kZS5kb2N1bWVudEVsZW1lbnQgJiYgbm9kZS5kb2N1bWVudEVsZW1lbnQudW5pcXVlSUQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgcG9zc2libGUsIHVzZSBhIFdlYWtNYXAuXG4gIHZhciB1c2luZ1dlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJztcbiAgdmFyIHdlYWtNYXA7XG4gIGlmICh1c2luZ1dlYWtNYXApIHtcbiAgICB3ZWFrTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgfVxuXG4gIHZhciBvYmpIYXNoVUlEID0gMDtcblxuICB2YXIgVUlEX0hBU0hfS0VZID0gJ19faW1tdXRhYmxlaGFzaF9fJztcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgICBVSURfSEFTSF9LRVkgPSBTeW1ib2woVUlEX0hBU0hfS0VZKTtcbiAgfVxuXG4gIHZhciBTVFJJTkdfSEFTSF9DQUNIRV9NSU5fU1RSTEVOID0gMTY7XG4gIHZhciBTVFJJTkdfSEFTSF9DQUNIRV9NQVhfU0laRSA9IDI1NTtcbiAgdmFyIFNUUklOR19IQVNIX0NBQ0hFX1NJWkUgPSAwO1xuICB2YXIgc3RyaW5nSGFzaENhY2hlID0ge307XG5cbiAgdmFyIFRvS2V5ZWRTZXF1ZW5jZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEtleWVkU2VxKSB7XG4gICAgZnVuY3Rpb24gVG9LZXllZFNlcXVlbmNlKGluZGV4ZWQsIHVzZUtleXMpIHtcbiAgICAgIHRoaXMuX2l0ZXIgPSBpbmRleGVkO1xuICAgICAgdGhpcy5fdXNlS2V5cyA9IHVzZUtleXM7XG4gICAgICB0aGlzLnNpemUgPSBpbmRleGVkLnNpemU7XG4gICAgfVxuXG4gICAgaWYgKCBLZXllZFNlcSApIFRvS2V5ZWRTZXF1ZW5jZS5fX3Byb3RvX18gPSBLZXllZFNlcTtcbiAgICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggS2V5ZWRTZXEgJiYgS2V5ZWRTZXEucHJvdG90eXBlICk7XG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRvS2V5ZWRTZXF1ZW5jZTtcblxuICAgIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci5nZXQoa2V5LCBub3RTZXRWYWx1ZSk7XG4gICAgfTtcblxuICAgIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLmhhcyhrZXkpO1xuICAgIH07XG5cbiAgICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLnZhbHVlU2VxID0gZnVuY3Rpb24gdmFsdWVTZXEgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIudmFsdWVTZXEoKTtcbiAgICB9O1xuXG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZSAoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdmFyIHJldmVyc2VkU2VxdWVuY2UgPSByZXZlcnNlRmFjdG9yeSh0aGlzLCB0cnVlKTtcbiAgICAgIGlmICghdGhpcy5fdXNlS2V5cykge1xuICAgICAgICByZXZlcnNlZFNlcXVlbmNlLnZhbHVlU2VxID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLl9pdGVyLnRvU2VxKCkucmV2ZXJzZSgpOyB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldmVyc2VkU2VxdWVuY2U7XG4gICAgfTtcblxuICAgIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwZXIsIGNvbnRleHQpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB2YXIgbWFwcGVkU2VxdWVuY2UgPSBtYXBGYWN0b3J5KHRoaXMsIG1hcHBlciwgY29udGV4dCk7XG4gICAgICBpZiAoIXRoaXMuX3VzZUtleXMpIHtcbiAgICAgICAgbWFwcGVkU2VxdWVuY2UudmFsdWVTZXEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuX2l0ZXIudG9TZXEoKS5tYXAobWFwcGVyLCBjb250ZXh0KTsgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXBwZWRTZXF1ZW5jZTtcbiAgICB9O1xuXG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIuX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBmbih2LCBrLCB0aGlzJDEpOyB9LCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRvS2V5ZWRTZXF1ZW5jZTtcbiAgfShLZXllZFNlcSkpO1xuICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlW0lTX09SREVSRURfU1lNQk9MXSA9IHRydWU7XG5cbiAgdmFyIFRvSW5kZXhlZFNlcXVlbmNlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW5kZXhlZFNlcSkge1xuICAgIGZ1bmN0aW9uIFRvSW5kZXhlZFNlcXVlbmNlKGl0ZXIpIHtcbiAgICAgIHRoaXMuX2l0ZXIgPSBpdGVyO1xuICAgICAgdGhpcy5zaXplID0gaXRlci5zaXplO1xuICAgIH1cblxuICAgIGlmICggSW5kZXhlZFNlcSApIFRvSW5kZXhlZFNlcXVlbmNlLl9fcHJvdG9fXyA9IEluZGV4ZWRTZXE7XG4gICAgVG9JbmRleGVkU2VxdWVuY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW5kZXhlZFNlcSAmJiBJbmRleGVkU2VxLnByb3RvdHlwZSApO1xuICAgIFRvSW5kZXhlZFNlcXVlbmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRvSW5kZXhlZFNlcXVlbmNlO1xuXG4gICAgVG9JbmRleGVkU2VxdWVuY2UucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci5pbmNsdWRlcyh2YWx1ZSk7XG4gICAgfTtcblxuICAgIFRvSW5kZXhlZFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgcmV2ZXJzZSAmJiBlbnN1cmVTaXplKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIuX19pdGVyYXRlKFxuICAgICAgICBmdW5jdGlvbiAodikgeyByZXR1cm4gZm4odiwgcmV2ZXJzZSA/IHRoaXMkMS5zaXplIC0gKytpIDogaSsrLCB0aGlzJDEpOyB9LFxuICAgICAgICByZXZlcnNlXG4gICAgICApO1xuICAgIH07XG5cbiAgICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9pdGVyLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMsIHJldmVyc2UpO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgcmV2ZXJzZSAmJiBlbnN1cmVTaXplKHRoaXMpO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICByZXR1cm4gc3RlcC5kb25lXG4gICAgICAgICAgPyBzdGVwXG4gICAgICAgICAgOiBpdGVyYXRvclZhbHVlKFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICByZXZlcnNlID8gdGhpcyQxLnNpemUgLSArK2kgOiBpKyssXG4gICAgICAgICAgICAgIHN0ZXAudmFsdWUsXG4gICAgICAgICAgICAgIHN0ZXBcbiAgICAgICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRvSW5kZXhlZFNlcXVlbmNlO1xuICB9KEluZGV4ZWRTZXEpKTtcblxuICB2YXIgVG9TZXRTZXF1ZW5jZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNldFNlcSkge1xuICAgIGZ1bmN0aW9uIFRvU2V0U2VxdWVuY2UoaXRlcikge1xuICAgICAgdGhpcy5faXRlciA9IGl0ZXI7XG4gICAgICB0aGlzLnNpemUgPSBpdGVyLnNpemU7XG4gICAgfVxuXG4gICAgaWYgKCBTZXRTZXEgKSBUb1NldFNlcXVlbmNlLl9fcHJvdG9fXyA9IFNldFNlcTtcbiAgICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNldFNlcSAmJiBTZXRTZXEucHJvdG90eXBlICk7XG4gICAgVG9TZXRTZXF1ZW5jZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUb1NldFNlcXVlbmNlO1xuXG4gICAgVG9TZXRTZXF1ZW5jZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLmluY2x1ZGVzKGtleSk7XG4gICAgfTtcblxuICAgIFRvU2V0U2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5faXRlci5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGZuKHYsIHYsIHRoaXMkMSk7IH0sIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5faXRlci5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHN0ZXAuZG9uZVxuICAgICAgICAgID8gc3RlcFxuICAgICAgICAgIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCBzdGVwLnZhbHVlLCBzdGVwLnZhbHVlLCBzdGVwKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gVG9TZXRTZXF1ZW5jZTtcbiAgfShTZXRTZXEpKTtcblxuICB2YXIgRnJvbUVudHJpZXNTZXF1ZW5jZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEtleWVkU2VxKSB7XG4gICAgZnVuY3Rpb24gRnJvbUVudHJpZXNTZXF1ZW5jZShlbnRyaWVzKSB7XG4gICAgICB0aGlzLl9pdGVyID0gZW50cmllcztcbiAgICAgIHRoaXMuc2l6ZSA9IGVudHJpZXMuc2l6ZTtcbiAgICB9XG5cbiAgICBpZiAoIEtleWVkU2VxICkgRnJvbUVudHJpZXNTZXF1ZW5jZS5fX3Byb3RvX18gPSBLZXllZFNlcTtcbiAgICBGcm9tRW50cmllc1NlcXVlbmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEtleWVkU2VxICYmIEtleWVkU2VxLnByb3RvdHlwZSApO1xuICAgIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRnJvbUVudHJpZXNTZXF1ZW5jZTtcblxuICAgIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlLmVudHJ5U2VxID0gZnVuY3Rpb24gZW50cnlTZXEgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIudG9TZXEoKTtcbiAgICB9O1xuXG4gICAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLl9faXRlcmF0ZShmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgZW50cnkgZXhpc3RzIGZpcnN0IHNvIGFycmF5IGFjY2VzcyBkb2Vzbid0IHRocm93IGZvciBob2xlc1xuICAgICAgICAvLyBpbiB0aGUgcGFyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFsaWRhdGVFbnRyeShlbnRyeSk7XG4gICAgICAgICAgdmFyIGluZGV4ZWRDb2xsZWN0aW9uID0gaXNDb2xsZWN0aW9uKGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gZm4oXG4gICAgICAgICAgICBpbmRleGVkQ29sbGVjdGlvbiA/IGVudHJ5LmdldCgxKSA6IGVudHJ5WzFdLFxuICAgICAgICAgICAgaW5kZXhlZENvbGxlY3Rpb24gPyBlbnRyeS5nZXQoMCkgOiBlbnRyeVswXSxcbiAgICAgICAgICAgIHRoaXMkMVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICBGcm9tRW50cmllc1NlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5faXRlci5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIC8vIENoZWNrIGlmIGVudHJ5IGV4aXN0cyBmaXJzdCBzbyBhcnJheSBhY2Nlc3MgZG9lc24ndCB0aHJvdyBmb3IgaG9sZXNcbiAgICAgICAgICAvLyBpbiB0aGUgcGFyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRW50cnkoZW50cnkpO1xuICAgICAgICAgICAgdmFyIGluZGV4ZWRDb2xsZWN0aW9uID0gaXNDb2xsZWN0aW9uKGVudHJ5KTtcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBpbmRleGVkQ29sbGVjdGlvbiA/IGVudHJ5LmdldCgwKSA6IGVudHJ5WzBdLFxuICAgICAgICAgICAgICBpbmRleGVkQ29sbGVjdGlvbiA/IGVudHJ5LmdldCgxKSA6IGVudHJ5WzFdLFxuICAgICAgICAgICAgICBzdGVwXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBGcm9tRW50cmllc1NlcXVlbmNlO1xuICB9KEtleWVkU2VxKSk7XG5cbiAgVG9JbmRleGVkU2VxdWVuY2UucHJvdG90eXBlLmNhY2hlUmVzdWx0ID1cbiAgICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLmNhY2hlUmVzdWx0ID1cbiAgICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9XG4gICAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuY2FjaGVSZXN1bHQgPVxuICAgICAgY2FjaGVSZXN1bHRUaHJvdWdoO1xuXG4gIGZ1bmN0aW9uIGZsaXBGYWN0b3J5KGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgZmxpcFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGNvbGxlY3Rpb24pO1xuICAgIGZsaXBTZXF1ZW5jZS5faXRlciA9IGNvbGxlY3Rpb247XG4gICAgZmxpcFNlcXVlbmNlLnNpemUgPSBjb2xsZWN0aW9uLnNpemU7XG4gICAgZmxpcFNlcXVlbmNlLmZsaXAgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2xsZWN0aW9uOyB9O1xuICAgIGZsaXBTZXF1ZW5jZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJldmVyc2VkU2VxdWVuY2UgPSBjb2xsZWN0aW9uLnJldmVyc2UuYXBwbHkodGhpcyk7IC8vIHN1cGVyLnJldmVyc2UoKVxuICAgICAgcmV2ZXJzZWRTZXF1ZW5jZS5mbGlwID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29sbGVjdGlvbi5yZXZlcnNlKCk7IH07XG4gICAgICByZXR1cm4gcmV2ZXJzZWRTZXF1ZW5jZTtcbiAgICB9O1xuICAgIGZsaXBTZXF1ZW5jZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBjb2xsZWN0aW9uLmluY2x1ZGVzKGtleSk7IH07XG4gICAgZmxpcFNlcXVlbmNlLmluY2x1ZGVzID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gY29sbGVjdGlvbi5oYXMoa2V5KTsgfTtcbiAgICBmbGlwU2VxdWVuY2UuY2FjaGVSZXN1bHQgPSBjYWNoZVJlc3VsdFRocm91Z2g7XG4gICAgZmxpcFNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBmbihrLCB2LCB0aGlzJDEpICE9PSBmYWxzZTsgfSwgcmV2ZXJzZSk7XG4gICAgfTtcbiAgICBmbGlwU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24gKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIGlmICh0eXBlID09PSBJVEVSQVRFX0VOVFJJRVMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoIXN0ZXAuZG9uZSkge1xuICAgICAgICAgICAgdmFyIGsgPSBzdGVwLnZhbHVlWzBdO1xuICAgICAgICAgICAgc3RlcC52YWx1ZVswXSA9IHN0ZXAudmFsdWVbMV07XG4gICAgICAgICAgICBzdGVwLnZhbHVlWzFdID0gaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uX19pdGVyYXRvcihcbiAgICAgICAgdHlwZSA9PT0gSVRFUkFURV9WQUxVRVMgPyBJVEVSQVRFX0tFWVMgOiBJVEVSQVRFX1ZBTFVFUyxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgKTtcbiAgICB9O1xuICAgIHJldHVybiBmbGlwU2VxdWVuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBtYXBGYWN0b3J5KGNvbGxlY3Rpb24sIG1hcHBlciwgY29udGV4dCkge1xuICAgIHZhciBtYXBwZWRTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcbiAgICBtYXBwZWRTZXF1ZW5jZS5zaXplID0gY29sbGVjdGlvbi5zaXplO1xuICAgIG1hcHBlZFNlcXVlbmNlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGNvbGxlY3Rpb24uaGFzKGtleSk7IH07XG4gICAgbWFwcGVkU2VxdWVuY2UuZ2V0ID0gZnVuY3Rpb24gKGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHZhciB2ID0gY29sbGVjdGlvbi5nZXQoa2V5LCBOT1RfU0VUKTtcbiAgICAgIHJldHVybiB2ID09PSBOT1RfU0VUXG4gICAgICAgID8gbm90U2V0VmFsdWVcbiAgICAgICAgOiBtYXBwZXIuY2FsbChjb250ZXh0LCB2LCBrZXksIGNvbGxlY3Rpb24pO1xuICAgIH07XG4gICAgbWFwcGVkU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5fX2l0ZXJhdGUoXG4gICAgICAgIGZ1bmN0aW9uICh2LCBrLCBjKSB7IHJldHVybiBmbihtYXBwZXIuY2FsbChjb250ZXh0LCB2LCBrLCBjKSwgaywgdGhpcyQxKSAhPT0gZmFsc2U7IH0sXG4gICAgICAgIHJldmVyc2VcbiAgICAgICk7XG4gICAgfTtcbiAgICBtYXBwZWRTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbiAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICB2YXIga2V5ID0gZW50cnlbMF07XG4gICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIG1hcHBlci5jYWxsKGNvbnRleHQsIGVudHJ5WzFdLCBrZXksIGNvbGxlY3Rpb24pLFxuICAgICAgICAgIHN0ZXBcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIG1hcHBlZFNlcXVlbmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmV2ZXJzZUZhY3RvcnkoY29sbGVjdGlvbiwgdXNlS2V5cykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJldmVyc2VkU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5faXRlciA9IGNvbGxlY3Rpb247XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5zaXplID0gY29sbGVjdGlvbi5zaXplO1xuICAgIHJldmVyc2VkU2VxdWVuY2UucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbGxlY3Rpb247IH07XG4gICAgaWYgKGNvbGxlY3Rpb24uZmxpcCkge1xuICAgICAgcmV2ZXJzZWRTZXF1ZW5jZS5mbGlwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZmxpcFNlcXVlbmNlID0gZmxpcEZhY3RvcnkoY29sbGVjdGlvbik7XG4gICAgICAgIGZsaXBTZXF1ZW5jZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29sbGVjdGlvbi5mbGlwKCk7IH07XG4gICAgICAgIHJldHVybiBmbGlwU2VxdWVuY2U7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXZlcnNlZFNlcXVlbmNlLmdldCA9IGZ1bmN0aW9uIChrZXksIG5vdFNldFZhbHVlKSB7IHJldHVybiBjb2xsZWN0aW9uLmdldCh1c2VLZXlzID8ga2V5IDogLTEgLSBrZXksIG5vdFNldFZhbHVlKTsgfTtcbiAgICByZXZlcnNlZFNlcXVlbmNlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGNvbGxlY3Rpb24uaGFzKHVzZUtleXMgPyBrZXkgOiAtMSAtIGtleSk7IH07XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5pbmNsdWRlcyA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gY29sbGVjdGlvbi5pbmNsdWRlcyh2YWx1ZSk7IH07XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5jYWNoZVJlc3VsdCA9IGNhY2hlUmVzdWx0VGhyb3VnaDtcbiAgICByZXZlcnNlZFNlcXVlbmNlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHJldmVyc2UgJiYgZW5zdXJlU2l6ZShjb2xsZWN0aW9uKTtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLl9faXRlcmF0ZShcbiAgICAgICAgZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIGZuKHYsIHVzZUtleXMgPyBrIDogcmV2ZXJzZSA/IHRoaXMkMS5zaXplIC0gKytpIDogaSsrLCB0aGlzJDEpOyB9LFxuICAgICAgICAhcmV2ZXJzZVxuICAgICAgKTtcbiAgICB9O1xuICAgIHJldmVyc2VkU2VxdWVuY2UuX19pdGVyYXRvciA9IGZ1bmN0aW9uICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICByZXZlcnNlICYmIGVuc3VyZVNpemUoY29sbGVjdGlvbik7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCAhcmV2ZXJzZSk7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZShcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHVzZUtleXMgPyBlbnRyeVswXSA6IHJldmVyc2UgPyB0aGlzJDEuc2l6ZSAtICsraSA6IGkrKyxcbiAgICAgICAgICBlbnRyeVsxXSxcbiAgICAgICAgICBzdGVwXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiByZXZlcnNlZFNlcXVlbmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlsdGVyRmFjdG9yeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGNvbnRleHQsIHVzZUtleXMpIHtcbiAgICB2YXIgZmlsdGVyU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gICAgaWYgKHVzZUtleXMpIHtcbiAgICAgIGZpbHRlclNlcXVlbmNlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHYgPSBjb2xsZWN0aW9uLmdldChrZXksIE5PVF9TRVQpO1xuICAgICAgICByZXR1cm4gdiAhPT0gTk9UX1NFVCAmJiAhIXByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGtleSwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgZmlsdGVyU2VxdWVuY2UuZ2V0ID0gZnVuY3Rpb24gKGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICAgICAgdmFyIHYgPSBjb2xsZWN0aW9uLmdldChrZXksIE5PVF9TRVQpO1xuICAgICAgICByZXR1cm4gdiAhPT0gTk9UX1NFVCAmJiBwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrZXksIGNvbGxlY3Rpb24pXG4gICAgICAgICAgPyB2XG4gICAgICAgICAgOiBub3RTZXRWYWx1ZTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZpbHRlclNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGssIGMpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIGMpKSB7XG4gICAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICAgIHJldHVybiBmbih2LCB1c2VLZXlzID8gayA6IGl0ZXJhdGlvbnMgLSAxLCB0aGlzJDEpO1xuICAgICAgICB9XG4gICAgICB9LCByZXZlcnNlKTtcbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG4gICAgZmlsdGVyU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24gKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IGNvbGxlY3Rpb24uX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMsIHJldmVyc2UpO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIGtleSA9IGVudHJ5WzBdO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGVudHJ5WzFdO1xuICAgICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgdXNlS2V5cyA/IGtleSA6IGl0ZXJhdGlvbnMrKywgdmFsdWUsIHN0ZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gZmlsdGVyU2VxdWVuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBjb3VudEJ5RmFjdG9yeShjb2xsZWN0aW9uLCBncm91cGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIGdyb3VwcyA9IE1hcCgpLmFzTXV0YWJsZSgpO1xuICAgIGNvbGxlY3Rpb24uX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICBncm91cHMudXBkYXRlKGdyb3VwZXIuY2FsbChjb250ZXh0LCB2LCBrLCBjb2xsZWN0aW9uKSwgMCwgZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgKyAxOyB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZ3JvdXBzLmFzSW1tdXRhYmxlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBncm91cEJ5RmFjdG9yeShjb2xsZWN0aW9uLCBncm91cGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIGlzS2V5ZWRJdGVyID0gaXNLZXllZChjb2xsZWN0aW9uKTtcbiAgICB2YXIgZ3JvdXBzID0gKGlzT3JkZXJlZChjb2xsZWN0aW9uKSA/IE9yZGVyZWRNYXAoKSA6IE1hcCgpKS5hc011dGFibGUoKTtcbiAgICBjb2xsZWN0aW9uLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykge1xuICAgICAgZ3JvdXBzLnVwZGF0ZShcbiAgICAgICAgZ3JvdXBlci5jYWxsKGNvbnRleHQsIHYsIGssIGNvbGxlY3Rpb24pLFxuICAgICAgICBmdW5jdGlvbiAoYSkgeyByZXR1cm4gKChhID0gYSB8fCBbXSksIGEucHVzaChpc0tleWVkSXRlciA/IFtrLCB2XSA6IHYpLCBhKTsgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgICB2YXIgY29lcmNlID0gY29sbGVjdGlvbkNsYXNzKGNvbGxlY3Rpb24pO1xuICAgIHJldHVybiBncm91cHMubWFwKGZ1bmN0aW9uIChhcnIpIHsgcmV0dXJuIHJlaWZ5KGNvbGxlY3Rpb24sIGNvZXJjZShhcnIpKTsgfSkuYXNJbW11dGFibGUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNsaWNlRmFjdG9yeShjb2xsZWN0aW9uLCBiZWdpbiwgZW5kLCB1c2VLZXlzKSB7XG4gICAgdmFyIG9yaWdpbmFsU2l6ZSA9IGNvbGxlY3Rpb24uc2l6ZTtcblxuICAgIGlmICh3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIG9yaWdpbmFsU2l6ZSkpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cblxuICAgIHZhciByZXNvbHZlZEJlZ2luID0gcmVzb2x2ZUJlZ2luKGJlZ2luLCBvcmlnaW5hbFNpemUpO1xuICAgIHZhciByZXNvbHZlZEVuZCA9IHJlc29sdmVFbmQoZW5kLCBvcmlnaW5hbFNpemUpO1xuXG4gICAgLy8gYmVnaW4gb3IgZW5kIHdpbGwgYmUgTmFOIGlmIHRoZXkgd2VyZSBwcm92aWRlZCBhcyBuZWdhdGl2ZSBudW1iZXJzIGFuZFxuICAgIC8vIHRoaXMgY29sbGVjdGlvbidzIHNpemUgaXMgdW5rbm93bi4gSW4gdGhhdCBjYXNlLCBjYWNoZSBmaXJzdCBzbyB0aGVyZSBpc1xuICAgIC8vIGEga25vd24gc2l6ZSBhbmQgdGhlc2UgZG8gbm90IHJlc29sdmUgdG8gTmFOLlxuICAgIGlmIChyZXNvbHZlZEJlZ2luICE9PSByZXNvbHZlZEJlZ2luIHx8IHJlc29sdmVkRW5kICE9PSByZXNvbHZlZEVuZCkge1xuICAgICAgcmV0dXJuIHNsaWNlRmFjdG9yeShjb2xsZWN0aW9uLnRvU2VxKCkuY2FjaGVSZXN1bHQoKSwgYmVnaW4sIGVuZCwgdXNlS2V5cyk7XG4gICAgfVxuXG4gICAgLy8gTm90ZTogcmVzb2x2ZWRFbmQgaXMgdW5kZWZpbmVkIHdoZW4gdGhlIG9yaWdpbmFsIHNlcXVlbmNlJ3MgbGVuZ3RoIGlzXG4gICAgLy8gdW5rbm93biBhbmQgdGhpcyBzbGljZSBkaWQgbm90IHN1cHBseSBhbiBlbmQgYW5kIHNob3VsZCBjb250YWluIGFsbFxuICAgIC8vIGVsZW1lbnRzIGFmdGVyIHJlc29sdmVkQmVnaW4uXG4gICAgLy8gSW4gdGhhdCBjYXNlLCByZXNvbHZlZFNpemUgd2lsbCBiZSBOYU4gYW5kIHNsaWNlU2l6ZSB3aWxsIHJlbWFpbiB1bmRlZmluZWQuXG4gICAgdmFyIHJlc29sdmVkU2l6ZSA9IHJlc29sdmVkRW5kIC0gcmVzb2x2ZWRCZWdpbjtcbiAgICB2YXIgc2xpY2VTaXplO1xuICAgIGlmIChyZXNvbHZlZFNpemUgPT09IHJlc29sdmVkU2l6ZSkge1xuICAgICAgc2xpY2VTaXplID0gcmVzb2x2ZWRTaXplIDwgMCA/IDAgOiByZXNvbHZlZFNpemU7XG4gICAgfVxuXG4gICAgdmFyIHNsaWNlU2VxID0gbWFrZVNlcXVlbmNlKGNvbGxlY3Rpb24pO1xuXG4gICAgLy8gSWYgY29sbGVjdGlvbi5zaXplIGlzIHVuZGVmaW5lZCwgdGhlIHNpemUgb2YgdGhlIHJlYWxpemVkIHNsaWNlU2VxIGlzXG4gICAgLy8gdW5rbm93biBhdCB0aGlzIHBvaW50IHVubGVzcyB0aGUgbnVtYmVyIG9mIGl0ZW1zIHRvIHNsaWNlIGlzIDBcbiAgICBzbGljZVNlcS5zaXplID1cbiAgICAgIHNsaWNlU2l6ZSA9PT0gMCA/IHNsaWNlU2l6ZSA6IChjb2xsZWN0aW9uLnNpemUgJiYgc2xpY2VTaXplKSB8fCB1bmRlZmluZWQ7XG5cbiAgICBpZiAoIXVzZUtleXMgJiYgaXNTZXEoY29sbGVjdGlvbikgJiYgc2xpY2VTaXplID49IDApIHtcbiAgICAgIHNsaWNlU2VxLmdldCA9IGZ1bmN0aW9uIChpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICAgICAgaW5kZXggPSB3cmFwSW5kZXgodGhpcywgaW5kZXgpO1xuICAgICAgICByZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA8IHNsaWNlU2l6ZVxuICAgICAgICAgID8gY29sbGVjdGlvbi5nZXQoaW5kZXggKyByZXNvbHZlZEJlZ2luLCBub3RTZXRWYWx1ZSlcbiAgICAgICAgICA6IG5vdFNldFZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBzbGljZVNlcS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIGlmIChzbGljZVNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgc2tpcHBlZCA9IDA7XG4gICAgICB2YXIgaXNTa2lwcGluZyA9IHRydWU7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICBjb2xsZWN0aW9uLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykge1xuICAgICAgICBpZiAoIShpc1NraXBwaW5nICYmIChpc1NraXBwaW5nID0gc2tpcHBlZCsrIDwgcmVzb2x2ZWRCZWdpbikpKSB7XG4gICAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBmbih2LCB1c2VLZXlzID8gayA6IGl0ZXJhdGlvbnMgLSAxLCB0aGlzJDEpICE9PSBmYWxzZSAmJlxuICAgICAgICAgICAgaXRlcmF0aW9ucyAhPT0gc2xpY2VTaXplXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuXG4gICAgc2xpY2VTZXEuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24gKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIGlmIChzbGljZVNpemUgIT09IDAgJiYgcmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICAvLyBEb24ndCBib3RoZXIgaW5zdGFudGlhdGluZyBwYXJlbnQgaXRlcmF0b3IgaWYgdGFraW5nIDAuXG4gICAgICBpZiAoc2xpY2VTaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoaXRlcmF0b3JEb25lKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRvciA9IGNvbGxlY3Rpb24uX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgIHZhciBza2lwcGVkID0gMDtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAoc2tpcHBlZCsrIDwgcmVzb2x2ZWRCZWdpbikge1xuICAgICAgICAgIGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKytpdGVyYXRpb25zID4gc2xpY2VTaXplKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAodXNlS2V5cyB8fCB0eXBlID09PSBJVEVSQVRFX1ZBTFVFUyB8fCBzdGVwLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gSVRFUkFURV9LRVlTKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucyAtIDEsIHVuZGVmaW5lZCwgc3RlcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucyAtIDEsIHN0ZXAudmFsdWVbMV0sIHN0ZXApO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBzbGljZVNlcTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRha2VXaGlsZUZhY3RvcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHRha2VTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcbiAgICB0YWtlU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICBjb2xsZWN0aW9uLl9faXRlcmF0ZShcbiAgICAgICAgZnVuY3Rpb24gKHYsIGssIGMpIHsgcmV0dXJuIHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIGMpICYmICsraXRlcmF0aW9ucyAmJiBmbih2LCBrLCB0aGlzJDEpOyB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcbiAgICB0YWtlU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24gKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCByZXZlcnNlKTtcbiAgICAgIHZhciBpdGVyYXRpbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXRlcmF0aW5nKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgdmFyIGsgPSBlbnRyeVswXTtcbiAgICAgICAgdmFyIHYgPSBlbnRyeVsxXTtcbiAgICAgICAgaWYgKCFwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCB0aGlzJDEpKSB7XG4gICAgICAgICAgaXRlcmF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlID09PSBJVEVSQVRFX0VOVFJJRVMgPyBzdGVwIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCBrLCB2LCBzdGVwKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHRha2VTZXF1ZW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBXaGlsZUZhY3RvcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBjb250ZXh0LCB1c2VLZXlzKSB7XG4gICAgdmFyIHNraXBTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcbiAgICBza2lwU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXNTa2lwcGluZyA9IHRydWU7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICBjb2xsZWN0aW9uLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaywgYykge1xuICAgICAgICBpZiAoIShpc1NraXBwaW5nICYmIChpc1NraXBwaW5nID0gcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgYykpKSkge1xuICAgICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgICByZXR1cm4gZm4odiwgdXNlS2V5cyA/IGsgOiBpdGVyYXRpb25zIC0gMSwgdGhpcyQxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuICAgIHNraXBTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbiAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRvciA9IGNvbGxlY3Rpb24uX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMsIHJldmVyc2UpO1xuICAgICAgdmFyIHNraXBwaW5nID0gdHJ1ZTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgdmFyIGs7XG4gICAgICAgIHZhciB2O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgICBpZiAodXNlS2V5cyB8fCB0eXBlID09PSBJVEVSQVRFX1ZBTFVFUykge1xuICAgICAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09PSBJVEVSQVRFX0tFWVMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCB1bmRlZmluZWQsIHN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCBzdGVwLnZhbHVlWzFdLCBzdGVwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBrID0gZW50cnlbMF07XG4gICAgICAgICAgdiA9IGVudHJ5WzFdO1xuICAgICAgICAgIHNraXBwaW5nICYmIChza2lwcGluZyA9IHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIHRoaXMkMSkpO1xuICAgICAgICB9IHdoaWxlIChza2lwcGluZyk7XG4gICAgICAgIHJldHVybiB0eXBlID09PSBJVEVSQVRFX0VOVFJJRVMgPyBzdGVwIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCBrLCB2LCBzdGVwKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHNraXBTZXF1ZW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmNhdEZhY3RvcnkoY29sbGVjdGlvbiwgdmFsdWVzKSB7XG4gICAgdmFyIGlzS2V5ZWRDb2xsZWN0aW9uID0gaXNLZXllZChjb2xsZWN0aW9uKTtcbiAgICB2YXIgaXRlcnMgPSBbY29sbGVjdGlvbl1cbiAgICAgIC5jb25jYXQodmFsdWVzKVxuICAgICAgLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICBpZiAoIWlzQ29sbGVjdGlvbih2KSkge1xuICAgICAgICAgIHYgPSBpc0tleWVkQ29sbGVjdGlvblxuICAgICAgICAgICAgPyBrZXllZFNlcUZyb21WYWx1ZSh2KVxuICAgICAgICAgICAgOiBpbmRleGVkU2VxRnJvbVZhbHVlKEFycmF5LmlzQXJyYXkodikgPyB2IDogW3ZdKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0tleWVkQ29sbGVjdGlvbikge1xuICAgICAgICAgIHYgPSBLZXllZENvbGxlY3Rpb24odik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcihmdW5jdGlvbiAodikgeyByZXR1cm4gdi5zaXplICE9PSAwOyB9KTtcblxuICAgIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cblxuICAgIGlmIChpdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBzaW5nbGV0b24gPSBpdGVyc1swXTtcbiAgICAgIGlmIChcbiAgICAgICAgc2luZ2xldG9uID09PSBjb2xsZWN0aW9uIHx8XG4gICAgICAgIChpc0tleWVkQ29sbGVjdGlvbiAmJiBpc0tleWVkKHNpbmdsZXRvbikpIHx8XG4gICAgICAgIChpc0luZGV4ZWQoY29sbGVjdGlvbikgJiYgaXNJbmRleGVkKHNpbmdsZXRvbikpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHNpbmdsZXRvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY29uY2F0U2VxID0gbmV3IEFycmF5U2VxKGl0ZXJzKTtcbiAgICBpZiAoaXNLZXllZENvbGxlY3Rpb24pIHtcbiAgICAgIGNvbmNhdFNlcSA9IGNvbmNhdFNlcS50b0tleWVkU2VxKCk7XG4gICAgfSBlbHNlIGlmICghaXNJbmRleGVkKGNvbGxlY3Rpb24pKSB7XG4gICAgICBjb25jYXRTZXEgPSBjb25jYXRTZXEudG9TZXRTZXEoKTtcbiAgICB9XG4gICAgY29uY2F0U2VxID0gY29uY2F0U2VxLmZsYXR0ZW4odHJ1ZSk7XG4gICAgY29uY2F0U2VxLnNpemUgPSBpdGVycy5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgc2VxKSB7XG4gICAgICBpZiAoc3VtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHNpemUgPSBzZXEuc2l6ZTtcbiAgICAgICAgaWYgKHNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBzdW0gKyBzaXplO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuIGNvbmNhdFNlcTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsYXR0ZW5GYWN0b3J5KGNvbGxlY3Rpb24sIGRlcHRoLCB1c2VLZXlzKSB7XG4gICAgdmFyIGZsYXRTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcbiAgICBmbGF0U2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHZhciBzdG9wcGVkID0gZmFsc2U7XG4gICAgICBmdW5jdGlvbiBmbGF0RGVlcChpdGVyLCBjdXJyZW50RGVwdGgpIHtcbiAgICAgICAgaXRlci5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgICBpZiAoKCFkZXB0aCB8fCBjdXJyZW50RGVwdGggPCBkZXB0aCkgJiYgaXNDb2xsZWN0aW9uKHYpKSB7XG4gICAgICAgICAgICBmbGF0RGVlcCh2LCBjdXJyZW50RGVwdGggKyAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICAgICAgaWYgKGZuKHYsIHVzZUtleXMgPyBrIDogaXRlcmF0aW9ucyAtIDEsIGZsYXRTZXF1ZW5jZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gIXN0b3BwZWQ7XG4gICAgICAgIH0sIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgZmxhdERlZXAoY29sbGVjdGlvbiwgMCk7XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuICAgIGZsYXRTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbiAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgdmFyIHN0YWNrID0gW107XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKGl0ZXJhdG9yKSB7XG4gICAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKHN0ZXAuZG9uZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHYgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIGlmICh0eXBlID09PSBJVEVSQVRFX0VOVFJJRVMpIHtcbiAgICAgICAgICAgIHYgPSB2WzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKCFkZXB0aCB8fCBzdGFjay5sZW5ndGggPCBkZXB0aCkgJiYgaXNDb2xsZWN0aW9uKHYpKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGl0ZXJhdG9yKTtcbiAgICAgICAgICAgIGl0ZXJhdG9yID0gdi5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlS2V5cyA/IHN0ZXAgOiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgdiwgc3RlcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIGZsYXRTZXF1ZW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsYXRNYXBGYWN0b3J5KGNvbGxlY3Rpb24sIG1hcHBlciwgY29udGV4dCkge1xuICAgIHZhciBjb2VyY2UgPSBjb2xsZWN0aW9uQ2xhc3MoY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb25cbiAgICAgIC50b1NlcSgpXG4gICAgICAubWFwKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBjb2VyY2UobWFwcGVyLmNhbGwoY29udGV4dCwgdiwgaywgY29sbGVjdGlvbikpOyB9KVxuICAgICAgLmZsYXR0ZW4odHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcnBvc2VGYWN0b3J5KGNvbGxlY3Rpb24sIHNlcGFyYXRvcikge1xuICAgIHZhciBpbnRlcnBvc2VkU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gICAgaW50ZXJwb3NlZFNlcXVlbmNlLnNpemUgPSBjb2xsZWN0aW9uLnNpemUgJiYgY29sbGVjdGlvbi5zaXplICogMiAtIDE7XG4gICAgaW50ZXJwb3NlZFNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoXG4gICAgICAgIGZ1bmN0aW9uICh2KSB7IHJldHVybiAoIWl0ZXJhdGlvbnMgfHwgZm4oc2VwYXJhdG9yLCBpdGVyYXRpb25zKyssIHRoaXMkMSkgIT09IGZhbHNlKSAmJlxuICAgICAgICAgIGZuKHYsIGl0ZXJhdGlvbnMrKywgdGhpcyQxKSAhPT0gZmFsc2U7IH0sXG4gICAgICAgIHJldmVyc2VcbiAgICAgICk7XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuICAgIGludGVycG9zZWRTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbiAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghc3RlcCB8fCBpdGVyYXRpb25zICUgMikge1xuICAgICAgICAgIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVyYXRpb25zICUgMlxuICAgICAgICAgID8gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHNlcGFyYXRvcilcbiAgICAgICAgICA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCBzdGVwLnZhbHVlLCBzdGVwKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIGludGVycG9zZWRTZXF1ZW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNvcnRGYWN0b3J5KGNvbGxlY3Rpb24sIGNvbXBhcmF0b3IsIG1hcHBlcikge1xuICAgIGlmICghY29tcGFyYXRvcikge1xuICAgICAgY29tcGFyYXRvciA9IGRlZmF1bHRDb21wYXJhdG9yO1xuICAgIH1cbiAgICB2YXIgaXNLZXllZENvbGxlY3Rpb24gPSBpc0tleWVkKGNvbGxlY3Rpb24pO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGVudHJpZXMgPSBjb2xsZWN0aW9uXG4gICAgICAudG9TZXEoKVxuICAgICAgLm1hcChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gW2ssIHYsIGluZGV4KyssIG1hcHBlciA/IG1hcHBlcih2LCBrLCBjb2xsZWN0aW9uKSA6IHZdOyB9KVxuICAgICAgLnZhbHVlU2VxKClcbiAgICAgIC50b0FycmF5KCk7XG4gICAgZW50cmllc1xuICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGNvbXBhcmF0b3IoYVszXSwgYlszXSkgfHwgYVsyXSAtIGJbMl07IH0pXG4gICAgICAuZm9yRWFjaChcbiAgICAgICAgaXNLZXllZENvbGxlY3Rpb25cbiAgICAgICAgICA/IGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgICAgICAgIGVudHJpZXNbaV0ubGVuZ3RoID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgICAgICAgIGVudHJpZXNbaV0gPSB2WzFdO1xuICAgICAgICAgICAgfVxuICAgICAgKTtcbiAgICByZXR1cm4gaXNLZXllZENvbGxlY3Rpb25cbiAgICAgID8gS2V5ZWRTZXEoZW50cmllcylcbiAgICAgIDogaXNJbmRleGVkKGNvbGxlY3Rpb24pXG4gICAgICA/IEluZGV4ZWRTZXEoZW50cmllcylcbiAgICAgIDogU2V0U2VxKGVudHJpZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF4RmFjdG9yeShjb2xsZWN0aW9uLCBjb21wYXJhdG9yLCBtYXBwZXIpIHtcbiAgICBpZiAoIWNvbXBhcmF0b3IpIHtcbiAgICAgIGNvbXBhcmF0b3IgPSBkZWZhdWx0Q29tcGFyYXRvcjtcbiAgICB9XG4gICAgaWYgKG1hcHBlcikge1xuICAgICAgdmFyIGVudHJ5ID0gY29sbGVjdGlvblxuICAgICAgICAudG9TZXEoKVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBbdiwgbWFwcGVyKHYsIGssIGNvbGxlY3Rpb24pXTsgfSlcbiAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gKG1heENvbXBhcmUoY29tcGFyYXRvciwgYVsxXSwgYlsxXSkgPyBiIDogYSk7IH0pO1xuICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5WzBdO1xuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbi5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChtYXhDb21wYXJlKGNvbXBhcmF0b3IsIGEsIGIpID8gYiA6IGEpOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1heENvbXBhcmUoY29tcGFyYXRvciwgYSwgYikge1xuICAgIHZhciBjb21wID0gY29tcGFyYXRvcihiLCBhKTtcbiAgICAvLyBiIGlzIGNvbnNpZGVyZWQgdGhlIG5ldyBtYXggaWYgdGhlIGNvbXBhcmF0b3IgZGVjbGFyZXMgdGhlbSBlcXVhbCwgYnV0XG4gICAgLy8gdGhleSBhcmUgbm90IGVxdWFsIGFuZCBiIGlzIGluIGZhY3QgYSBudWxsaXNoIHZhbHVlLlxuICAgIHJldHVybiAoXG4gICAgICAoY29tcCA9PT0gMCAmJiBiICE9PSBhICYmIChiID09PSB1bmRlZmluZWQgfHwgYiA9PT0gbnVsbCB8fCBiICE9PSBiKSkgfHxcbiAgICAgIGNvbXAgPiAwXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHppcFdpdGhGYWN0b3J5KGtleUl0ZXIsIHppcHBlciwgaXRlcnMsIHppcEFsbCkge1xuICAgIHZhciB6aXBTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShrZXlJdGVyKTtcbiAgICB2YXIgc2l6ZXMgPSBuZXcgQXJyYXlTZXEoaXRlcnMpLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gaS5zaXplOyB9KTtcbiAgICB6aXBTZXF1ZW5jZS5zaXplID0gemlwQWxsID8gc2l6ZXMubWF4KCkgOiBzaXplcy5taW4oKTtcbiAgICAvLyBOb3RlOiB0aGlzIGEgZ2VuZXJpYyBiYXNlIGltcGxlbWVudGF0aW9uIG9mIF9faXRlcmF0ZSBpbiB0ZXJtcyBvZlxuICAgIC8vIF9faXRlcmF0b3Igd2hpY2ggbWF5IGJlIG1vcmUgZ2VuZXJpY2FsbHkgdXNlZnVsIGluIHRoZSBmdXR1cmUuXG4gICAgemlwU2VxdWVuY2UuX19pdGVyYXRlID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7XG4gICAgICAvKiBnZW5lcmljOlxuICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICBpZiAoZm4oc3RlcC52YWx1ZVsxXSwgc3RlcC52YWx1ZVswXSwgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgICAgKi9cbiAgICAgIC8vIGluZGV4ZWQ6XG4gICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMsIHJldmVyc2UpO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGlmIChmbihzdGVwLnZhbHVlLCBpdGVyYXRpb25zKyssIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuICAgIHppcFNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JzID0gaXRlcnMubWFwKFxuICAgICAgICBmdW5jdGlvbiAoaSkgeyByZXR1cm4gKChpID0gQ29sbGVjdGlvbihpKSksIGdldEl0ZXJhdG9yKHJldmVyc2UgPyBpLnJldmVyc2UoKSA6IGkpKTsgfVxuICAgICAgKTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHZhciBpc0RvbmUgPSBmYWxzZTtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RlcHM7XG4gICAgICAgIGlmICghaXNEb25lKSB7XG4gICAgICAgICAgc3RlcHMgPSBpdGVyYXRvcnMubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBpLm5leHQoKTsgfSk7XG4gICAgICAgICAgaXNEb25lID0gemlwQWxsID8gc3RlcHMuZXZlcnkoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMuZG9uZTsgfSkgOiBzdGVwcy5zb21lKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLmRvbmU7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RvbmUpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBpdGVyYXRpb25zKyssXG4gICAgICAgICAgemlwcGVyLmFwcGx5KFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHN0ZXBzLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gcy52YWx1ZTsgfSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiB6aXBTZXF1ZW5jZTtcbiAgfVxuXG4gIC8vICNwcmFnbWEgSGVscGVyIEZ1bmN0aW9uc1xuXG4gIGZ1bmN0aW9uIHJlaWZ5KGl0ZXIsIHNlcSkge1xuICAgIHJldHVybiBpdGVyID09PSBzZXEgPyBpdGVyIDogaXNTZXEoaXRlcikgPyBzZXEgOiBpdGVyLmNvbnN0cnVjdG9yKHNlcSk7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZUVudHJ5KGVudHJ5KSB7XG4gICAgaWYgKGVudHJ5ICE9PSBPYmplY3QoZW50cnkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBbSywgVl0gdHVwbGU6ICcgKyBlbnRyeSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29sbGVjdGlvbkNsYXNzKGNvbGxlY3Rpb24pIHtcbiAgICByZXR1cm4gaXNLZXllZChjb2xsZWN0aW9uKVxuICAgICAgPyBLZXllZENvbGxlY3Rpb25cbiAgICAgIDogaXNJbmRleGVkKGNvbGxlY3Rpb24pXG4gICAgICA/IEluZGV4ZWRDb2xsZWN0aW9uXG4gICAgICA6IFNldENvbGxlY3Rpb247XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbikge1xuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKFxuICAgICAgKGlzS2V5ZWQoY29sbGVjdGlvbilcbiAgICAgICAgPyBLZXllZFNlcVxuICAgICAgICA6IGlzSW5kZXhlZChjb2xsZWN0aW9uKVxuICAgICAgICA/IEluZGV4ZWRTZXFcbiAgICAgICAgOiBTZXRTZXFcbiAgICAgICkucHJvdG90eXBlXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhY2hlUmVzdWx0VGhyb3VnaCgpIHtcbiAgICBpZiAodGhpcy5faXRlci5jYWNoZVJlc3VsdCkge1xuICAgICAgdGhpcy5faXRlci5jYWNoZVJlc3VsdCgpO1xuICAgICAgdGhpcy5zaXplID0gdGhpcy5faXRlci5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBTZXEucHJvdG90eXBlLmNhY2hlUmVzdWx0LmNhbGwodGhpcyk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0Q29tcGFyYXRvcihhLCBiKSB7XG4gICAgaWYgKGEgPT09IHVuZGVmaW5lZCAmJiBiID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDA7XG4gIH1cblxuICBmdW5jdGlvbiBhcnJDb3B5KGFyciwgb2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgdmFyIGxlbiA9IE1hdGgubWF4KDAsIGFyci5sZW5ndGggLSBvZmZzZXQpO1xuICAgIHZhciBuZXdBcnIgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbGVuOyBpaSsrKSB7XG4gICAgICBuZXdBcnJbaWldID0gYXJyW2lpICsgb2Zmc2V0XTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0FycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGVycm9yKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHsgdGhyb3cgbmV3IEVycm9yKGVycm9yKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm90SW5maW5pdGUoc2l6ZSkge1xuICAgIGludmFyaWFudChcbiAgICAgIHNpemUgIT09IEluZmluaXR5LFxuICAgICAgJ0Nhbm5vdCBwZXJmb3JtIHRoaXMgYWN0aW9uIHdpdGggYW4gaW5maW5pdGUgc2l6ZS4nXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvZXJjZUtleVBhdGgoa2V5UGF0aCkge1xuICAgIGlmIChpc0FycmF5TGlrZShrZXlQYXRoKSAmJiB0eXBlb2Yga2V5UGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBrZXlQYXRoO1xuICAgIH1cbiAgICBpZiAoaXNPcmRlcmVkKGtleVBhdGgpKSB7XG4gICAgICByZXR1cm4ga2V5UGF0aC50b0FycmF5KCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnSW52YWxpZCBrZXlQYXRoOiBleHBlY3RlZCBPcmRlcmVkIENvbGxlY3Rpb24gb3IgQXJyYXk6ICcgKyBrZXlQYXRoXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGxhaW5PYmoodmFsdWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdmFsdWUgJiZcbiAgICAgICh0eXBlb2YgdmFsdWUuY29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgcG90ZW50aWFsbHktcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZSwgZWl0aGVyXG4gICAqIHByb3ZpZGVkIGJ5IEltbXV0YWJsZS5qcyBvciBhIHBsYWluIEFycmF5IG9yIE9iamVjdC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzRGF0YVN0cnVjdHVyZSh2YWx1ZSkge1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAoaXNJbW11dGFibGUodmFsdWUpIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmoodmFsdWUpKVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBxdW90ZVN0cmluZyh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IFN0cmluZyh2YWx1ZSk7XG4gICAgfSBjYXRjaCAoX2lnbm9yZUVycm9yKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhcyhjb2xsZWN0aW9uLCBrZXkpIHtcbiAgICByZXR1cm4gaXNJbW11dGFibGUoY29sbGVjdGlvbilcbiAgICAgID8gY29sbGVjdGlvbi5oYXMoa2V5KVxuICAgICAgOiBpc0RhdGFTdHJ1Y3R1cmUoY29sbGVjdGlvbikgJiYgaGFzT3duUHJvcGVydHkuY2FsbChjb2xsZWN0aW9uLCBrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0KGNvbGxlY3Rpb24sIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICByZXR1cm4gaXNJbW11dGFibGUoY29sbGVjdGlvbilcbiAgICAgID8gY29sbGVjdGlvbi5nZXQoa2V5LCBub3RTZXRWYWx1ZSlcbiAgICAgIDogIWhhcyhjb2xsZWN0aW9uLCBrZXkpXG4gICAgICA/IG5vdFNldFZhbHVlXG4gICAgICA6IHR5cGVvZiBjb2xsZWN0aW9uLmdldCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBjb2xsZWN0aW9uLmdldChrZXkpXG4gICAgICA6IGNvbGxlY3Rpb25ba2V5XTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNoYWxsb3dDb3B5KGZyb20pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmcm9tKSkge1xuICAgICAgcmV0dXJuIGFyckNvcHkoZnJvbSk7XG4gICAgfVxuICAgIHZhciB0byA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG4gICAgICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0bztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZShjb2xsZWN0aW9uLCBrZXkpIHtcbiAgICBpZiAoIWlzRGF0YVN0cnVjdHVyZShjb2xsZWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCB1cGRhdGUgbm9uLWRhdGEtc3RydWN0dXJlIHZhbHVlOiAnICsgY29sbGVjdGlvblxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGlzSW1tdXRhYmxlKGNvbGxlY3Rpb24pKSB7XG4gICAgICBpZiAoIWNvbGxlY3Rpb24ucmVtb3ZlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ0Nhbm5vdCB1cGRhdGUgaW1tdXRhYmxlIHZhbHVlIHdpdGhvdXQgLnJlbW92ZSgpIG1ldGhvZDogJyArIGNvbGxlY3Rpb25cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLnJlbW92ZShrZXkpO1xuICAgIH1cbiAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoY29sbGVjdGlvbiwga2V5KSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIHZhciBjb2xsZWN0aW9uQ29weSA9IHNoYWxsb3dDb3B5KGNvbGxlY3Rpb24pO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbGxlY3Rpb25Db3B5KSkge1xuICAgICAgY29sbGVjdGlvbkNvcHkuc3BsaWNlKGtleSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBjb2xsZWN0aW9uQ29weVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbkNvcHk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXQoY29sbGVjdGlvbiwga2V5LCB2YWx1ZSkge1xuICAgIGlmICghaXNEYXRhU3RydWN0dXJlKGNvbGxlY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnQ2Fubm90IHVwZGF0ZSBub24tZGF0YS1zdHJ1Y3R1cmUgdmFsdWU6ICcgKyBjb2xsZWN0aW9uXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoaXNJbW11dGFibGUoY29sbGVjdGlvbikpIHtcbiAgICAgIGlmICghY29sbGVjdGlvbi5zZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnQ2Fubm90IHVwZGF0ZSBpbW11dGFibGUgdmFsdWUgd2l0aG91dCAuc2V0KCkgbWV0aG9kOiAnICsgY29sbGVjdGlvblxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb2xsZWN0aW9uLCBrZXkpICYmIHZhbHVlID09PSBjb2xsZWN0aW9uW2tleV0pIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cbiAgICB2YXIgY29sbGVjdGlvbkNvcHkgPSBzaGFsbG93Q29weShjb2xsZWN0aW9uKTtcbiAgICBjb2xsZWN0aW9uQ29weVtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb25Db3B5O1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlSW4oY29sbGVjdGlvbiwga2V5UGF0aCwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpIHtcbiAgICBpZiAoIXVwZGF0ZXIpIHtcbiAgICAgIHVwZGF0ZXIgPSBub3RTZXRWYWx1ZTtcbiAgICAgIG5vdFNldFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIgdXBkYXRlZFZhbHVlID0gdXBkYXRlSW5EZWVwbHkoXG4gICAgICBpc0ltbXV0YWJsZShjb2xsZWN0aW9uKSxcbiAgICAgIGNvbGxlY3Rpb24sXG4gICAgICBjb2VyY2VLZXlQYXRoKGtleVBhdGgpLFxuICAgICAgMCxcbiAgICAgIG5vdFNldFZhbHVlLFxuICAgICAgdXBkYXRlclxuICAgICk7XG4gICAgcmV0dXJuIHVwZGF0ZWRWYWx1ZSA9PT0gTk9UX1NFVCA/IG5vdFNldFZhbHVlIDogdXBkYXRlZFZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlSW5EZWVwbHkoXG4gICAgaW5JbW11dGFibGUsXG4gICAgZXhpc3RpbmcsXG4gICAga2V5UGF0aCxcbiAgICBpLFxuICAgIG5vdFNldFZhbHVlLFxuICAgIHVwZGF0ZXJcbiAgKSB7XG4gICAgdmFyIHdhc05vdFNldCA9IGV4aXN0aW5nID09PSBOT1RfU0VUO1xuICAgIGlmIChpID09PSBrZXlQYXRoLmxlbmd0aCkge1xuICAgICAgdmFyIGV4aXN0aW5nVmFsdWUgPSB3YXNOb3RTZXQgPyBub3RTZXRWYWx1ZSA6IGV4aXN0aW5nO1xuICAgICAgdmFyIG5ld1ZhbHVlID0gdXBkYXRlcihleGlzdGluZ1ZhbHVlKTtcbiAgICAgIHJldHVybiBuZXdWYWx1ZSA9PT0gZXhpc3RpbmdWYWx1ZSA/IGV4aXN0aW5nIDogbmV3VmFsdWU7XG4gICAgfVxuICAgIGlmICghd2FzTm90U2V0ICYmICFpc0RhdGFTdHJ1Y3R1cmUoZXhpc3RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnQ2Fubm90IHVwZGF0ZSB3aXRoaW4gbm9uLWRhdGEtc3RydWN0dXJlIHZhbHVlIGluIHBhdGggWycgK1xuICAgICAgICAgIGtleVBhdGguc2xpY2UoMCwgaSkubWFwKHF1b3RlU3RyaW5nKSArXG4gICAgICAgICAgJ106ICcgK1xuICAgICAgICAgIGV4aXN0aW5nXG4gICAgICApO1xuICAgIH1cbiAgICB2YXIga2V5ID0ga2V5UGF0aFtpXTtcbiAgICB2YXIgbmV4dEV4aXN0aW5nID0gd2FzTm90U2V0ID8gTk9UX1NFVCA6IGdldChleGlzdGluZywga2V5LCBOT1RfU0VUKTtcbiAgICB2YXIgbmV4dFVwZGF0ZWQgPSB1cGRhdGVJbkRlZXBseShcbiAgICAgIG5leHRFeGlzdGluZyA9PT0gTk9UX1NFVCA/IGluSW1tdXRhYmxlIDogaXNJbW11dGFibGUobmV4dEV4aXN0aW5nKSxcbiAgICAgIG5leHRFeGlzdGluZyxcbiAgICAgIGtleVBhdGgsXG4gICAgICBpICsgMSxcbiAgICAgIG5vdFNldFZhbHVlLFxuICAgICAgdXBkYXRlclxuICAgICk7XG4gICAgcmV0dXJuIG5leHRVcGRhdGVkID09PSBuZXh0RXhpc3RpbmdcbiAgICAgID8gZXhpc3RpbmdcbiAgICAgIDogbmV4dFVwZGF0ZWQgPT09IE5PVF9TRVRcbiAgICAgID8gcmVtb3ZlKGV4aXN0aW5nLCBrZXkpXG4gICAgICA6IHNldChcbiAgICAgICAgICB3YXNOb3RTZXQgPyAoaW5JbW11dGFibGUgPyBlbXB0eU1hcCgpIDoge30pIDogZXhpc3RpbmcsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIG5leHRVcGRhdGVkXG4gICAgICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRJbihjb2xsZWN0aW9uLCBrZXlQYXRoLCB2YWx1ZSkge1xuICAgIHJldHVybiB1cGRhdGVJbihjb2xsZWN0aW9uLCBrZXlQYXRoLCBOT1RfU0VULCBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZTsgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRJbiQxKGtleVBhdGgsIHYpIHtcbiAgICByZXR1cm4gc2V0SW4odGhpcywga2V5UGF0aCwgdik7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVJbihjb2xsZWN0aW9uLCBrZXlQYXRoKSB7XG4gICAgcmV0dXJuIHVwZGF0ZUluKGNvbGxlY3Rpb24sIGtleVBhdGgsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5PVF9TRVQ7IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlSW4oa2V5UGF0aCkge1xuICAgIHJldHVybiByZW1vdmVJbih0aGlzLCBrZXlQYXRoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZShjb2xsZWN0aW9uLCBrZXksIG5vdFNldFZhbHVlLCB1cGRhdGVyKSB7XG4gICAgcmV0dXJuIHVwZGF0ZUluKGNvbGxlY3Rpb24sIFtrZXldLCBub3RTZXRWYWx1ZSwgdXBkYXRlcik7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGUkMShrZXksIG5vdFNldFZhbHVlLCB1cGRhdGVyKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDFcbiAgICAgID8ga2V5KHRoaXMpXG4gICAgICA6IHVwZGF0ZSh0aGlzLCBrZXksIG5vdFNldFZhbHVlLCB1cGRhdGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUluJDEoa2V5UGF0aCwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpIHtcbiAgICByZXR1cm4gdXBkYXRlSW4odGhpcywga2V5UGF0aCwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2UoKSB7XG4gICAgdmFyIGl0ZXJzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGl0ZXJzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICByZXR1cm4gbWVyZ2VJbnRvS2V5ZWRXaXRoKHRoaXMsIGl0ZXJzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlV2l0aChtZXJnZXIpIHtcbiAgICB2YXIgaXRlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKCBsZW4tLSA+IDAgKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICAgIGlmICh0eXBlb2YgbWVyZ2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1lcmdlciBmdW5jdGlvbjogJyArIG1lcmdlcik7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZUludG9LZXllZFdpdGgodGhpcywgaXRlcnMsIG1lcmdlcik7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUludG9LZXllZFdpdGgoY29sbGVjdGlvbiwgY29sbGVjdGlvbnMsIG1lcmdlcikge1xuICAgIHZhciBpdGVycyA9IFtdO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBjb2xsZWN0aW9ucy5sZW5ndGg7IGlpKyspIHtcbiAgICAgIHZhciBjb2xsZWN0aW9uJDEgPSBLZXllZENvbGxlY3Rpb24oY29sbGVjdGlvbnNbaWldKTtcbiAgICAgIGlmIChjb2xsZWN0aW9uJDEuc2l6ZSAhPT0gMCkge1xuICAgICAgICBpdGVycy5wdXNoKGNvbGxlY3Rpb24kMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBjb2xsZWN0aW9uLnRvU2VxKCkuc2l6ZSA9PT0gMCAmJlxuICAgICAgIWNvbGxlY3Rpb24uX19vd25lcklEICYmXG4gICAgICBpdGVycy5sZW5ndGggPT09IDFcbiAgICApIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmNvbnN0cnVjdG9yKGl0ZXJzWzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24ud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgICAgdmFyIG1lcmdlSW50b0NvbGxlY3Rpb24gPSBtZXJnZXJcbiAgICAgICAgPyBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgdXBkYXRlKGNvbGxlY3Rpb24sIGtleSwgTk9UX1NFVCwgZnVuY3Rpb24gKG9sZFZhbCkgeyByZXR1cm4gb2xkVmFsID09PSBOT1RfU0VUID8gdmFsdWUgOiBtZXJnZXIob2xkVmFsLCB2YWx1ZSwga2V5KTsgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIDogZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24uc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgIH07XG4gICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgaXRlcnMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgIGl0ZXJzW2lpXS5mb3JFYWNoKG1lcmdlSW50b0NvbGxlY3Rpb24pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2UkMShjb2xsZWN0aW9uKSB7XG4gICAgdmFyIHNvdXJjZXMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKCBsZW4tLSA+IDAgKSBzb3VyY2VzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gICAgcmV0dXJuIG1lcmdlV2l0aFNvdXJjZXMoY29sbGVjdGlvbiwgc291cmNlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZVdpdGgkMShtZXJnZXIsIGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgc291cmNlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICB3aGlsZSAoIGxlbi0tID4gMCApIHNvdXJjZXNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAyIF07XG5cbiAgICByZXR1cm4gbWVyZ2VXaXRoU291cmNlcyhjb2xsZWN0aW9uLCBzb3VyY2VzLCBtZXJnZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VEZWVwKGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgc291cmNlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoIGxlbi0tID4gMCApIHNvdXJjZXNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgICByZXR1cm4gbWVyZ2VEZWVwV2l0aFNvdXJjZXMoY29sbGVjdGlvbiwgc291cmNlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZURlZXBXaXRoKG1lcmdlciwgY29sbGVjdGlvbikge1xuICAgIHZhciBzb3VyY2VzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgIHdoaWxlICggbGVuLS0gPiAwICkgc291cmNlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDIgXTtcblxuICAgIHJldHVybiBtZXJnZURlZXBXaXRoU291cmNlcyhjb2xsZWN0aW9uLCBzb3VyY2VzLCBtZXJnZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VEZWVwV2l0aFNvdXJjZXMoY29sbGVjdGlvbiwgc291cmNlcywgbWVyZ2VyKSB7XG4gICAgcmV0dXJuIG1lcmdlV2l0aFNvdXJjZXMoY29sbGVjdGlvbiwgc291cmNlcywgZGVlcE1lcmdlcldpdGgobWVyZ2VyKSk7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZVdpdGhTb3VyY2VzKGNvbGxlY3Rpb24sIHNvdXJjZXMsIG1lcmdlcikge1xuICAgIGlmICghaXNEYXRhU3RydWN0dXJlKGNvbGxlY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnQ2Fubm90IG1lcmdlIGludG8gbm9uLWRhdGEtc3RydWN0dXJlIHZhbHVlOiAnICsgY29sbGVjdGlvblxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGlzSW1tdXRhYmxlKGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG1lcmdlciA9PT0gJ2Z1bmN0aW9uJyAmJiBjb2xsZWN0aW9uLm1lcmdlV2l0aFxuICAgICAgICA/IGNvbGxlY3Rpb24ubWVyZ2VXaXRoLmFwcGx5KGNvbGxlY3Rpb24sIFsgbWVyZ2VyIF0uY29uY2F0KCBzb3VyY2VzICkpXG4gICAgICAgIDogY29sbGVjdGlvbi5tZXJnZVxuICAgICAgICA/IGNvbGxlY3Rpb24ubWVyZ2UuYXBwbHkoY29sbGVjdGlvbiwgc291cmNlcylcbiAgICAgICAgOiBjb2xsZWN0aW9uLmNvbmNhdC5hcHBseShjb2xsZWN0aW9uLCBzb3VyY2VzKTtcbiAgICB9XG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGNvbGxlY3Rpb24pO1xuICAgIHZhciBtZXJnZWQgPSBjb2xsZWN0aW9uO1xuICAgIHZhciBDb2xsZWN0aW9uID0gaXNBcnJheSA/IEluZGV4ZWRDb2xsZWN0aW9uIDogS2V5ZWRDb2xsZWN0aW9uO1xuICAgIHZhciBtZXJnZUl0ZW0gPSBpc0FycmF5XG4gICAgICA/IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIC8vIENvcHkgb24gd3JpdGVcbiAgICAgICAgICBpZiAobWVyZ2VkID09PSBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICBtZXJnZWQgPSBzaGFsbG93Q29weShtZXJnZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZXJnZWQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIDogZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICB2YXIgaGFzVmFsID0gaGFzT3duUHJvcGVydHkuY2FsbChtZXJnZWQsIGtleSk7XG4gICAgICAgICAgdmFyIG5leHRWYWwgPVxuICAgICAgICAgICAgaGFzVmFsICYmIG1lcmdlciA/IG1lcmdlcihtZXJnZWRba2V5XSwgdmFsdWUsIGtleSkgOiB2YWx1ZTtcbiAgICAgICAgICBpZiAoIWhhc1ZhbCB8fCBuZXh0VmFsICE9PSBtZXJnZWRba2V5XSkge1xuICAgICAgICAgICAgLy8gQ29weSBvbiB3cml0ZVxuICAgICAgICAgICAgaWYgKG1lcmdlZCA9PT0gY29sbGVjdGlvbikge1xuICAgICAgICAgICAgICBtZXJnZWQgPSBzaGFsbG93Q29weShtZXJnZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVyZ2VkW2tleV0gPSBuZXh0VmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIENvbGxlY3Rpb24oc291cmNlc1tpXSkuZm9yRWFjaChtZXJnZUl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVlcE1lcmdlcldpdGgobWVyZ2VyKSB7XG4gICAgZnVuY3Rpb24gZGVlcE1lcmdlcihvbGRWYWx1ZSwgbmV3VmFsdWUsIGtleSkge1xuICAgICAgcmV0dXJuIGlzRGF0YVN0cnVjdHVyZShvbGRWYWx1ZSkgJiYgaXNEYXRhU3RydWN0dXJlKG5ld1ZhbHVlKVxuICAgICAgICA/IG1lcmdlV2l0aFNvdXJjZXMob2xkVmFsdWUsIFtuZXdWYWx1ZV0sIGRlZXBNZXJnZXIpXG4gICAgICAgIDogbWVyZ2VyXG4gICAgICAgID8gbWVyZ2VyKG9sZFZhbHVlLCBuZXdWYWx1ZSwga2V5KVxuICAgICAgICA6IG5ld1ZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gZGVlcE1lcmdlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcCQxKCkge1xuICAgIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgcmV0dXJuIG1lcmdlRGVlcFdpdGhTb3VyY2VzKHRoaXMsIGl0ZXJzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcFdpdGgkMShtZXJnZXIpIHtcbiAgICB2YXIgaXRlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKCBsZW4tLSA+IDAgKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICAgIHJldHVybiBtZXJnZURlZXBXaXRoU291cmNlcyh0aGlzLCBpdGVycywgbWVyZ2VyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlSW4oa2V5UGF0aCkge1xuICAgIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoIGxlbi0tID4gMCApIGl0ZXJzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gICAgcmV0dXJuIHVwZGF0ZUluKHRoaXMsIGtleVBhdGgsIGVtcHR5TWFwKCksIGZ1bmN0aW9uIChtKSB7IHJldHVybiBtZXJnZVdpdGhTb3VyY2VzKG0sIGl0ZXJzKTsgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZURlZXBJbihrZXlQYXRoKSB7XG4gICAgdmFyIGl0ZXJzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgIHdoaWxlICggbGVuLS0gPiAwICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgICByZXR1cm4gdXBkYXRlSW4odGhpcywga2V5UGF0aCwgZW1wdHlNYXAoKSwgZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1lcmdlRGVlcFdpdGhTb3VyY2VzKG0sIGl0ZXJzKTsgfVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiB3aXRoTXV0YXRpb25zKGZuKSB7XG4gICAgdmFyIG11dGFibGUgPSB0aGlzLmFzTXV0YWJsZSgpO1xuICAgIGZuKG11dGFibGUpO1xuICAgIHJldHVybiBtdXRhYmxlLndhc0FsdGVyZWQoKSA/IG11dGFibGUuX19lbnN1cmVPd25lcih0aGlzLl9fb3duZXJJRCkgOiB0aGlzO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNNdXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9fb3duZXJJRCA/IHRoaXMgOiB0aGlzLl9fZW5zdXJlT3duZXIobmV3IE93bmVySUQoKSk7XG4gIH1cblxuICBmdW5jdGlvbiBhc0ltbXV0YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2Vuc3VyZU93bmVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiB3YXNBbHRlcmVkKCkge1xuICAgIHJldHVybiB0aGlzLl9fYWx0ZXJlZDtcbiAgfVxuXG4gIHZhciBNYXAgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChLZXllZENvbGxlY3Rpb24pIHtcbiAgICBmdW5jdGlvbiBNYXAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gZW1wdHlNYXAoKVxuICAgICAgICA6IGlzTWFwKHZhbHVlKSAmJiAhaXNPcmRlcmVkKHZhbHVlKVxuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogZW1wdHlNYXAoKS53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICAgIHZhciBpdGVyID0gS2V5ZWRDb2xsZWN0aW9uKHZhbHVlKTtcbiAgICAgICAgICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG4gICAgICAgICAgICBpdGVyLmZvckVhY2goZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIG1hcC5zZXQoaywgdik7IH0pO1xuICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICggS2V5ZWRDb2xsZWN0aW9uICkgTWFwLl9fcHJvdG9fXyA9IEtleWVkQ29sbGVjdGlvbjtcbiAgICBNYXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggS2V5ZWRDb2xsZWN0aW9uICYmIEtleWVkQ29sbGVjdGlvbi5wcm90b3R5cGUgKTtcbiAgICBNYXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWFwO1xuXG4gICAgTWFwLm9mID0gZnVuY3Rpb24gb2YgKCkge1xuICAgICAgdmFyIGtleVZhbHVlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIGtleVZhbHVlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICByZXR1cm4gZW1wdHlNYXAoKS53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlWYWx1ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICBpZiAoaSArIDEgPj0ga2V5VmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHZhbHVlIGZvciBrZXk6ICcgKyBrZXlWYWx1ZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXAuc2V0KGtleVZhbHVlc1tpXSwga2V5VmFsdWVzW2kgKyAxXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnTWFwIHsnLCAnfScpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIEFjY2Vzc1xuXG4gICAgTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGssIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcm9vdFxuICAgICAgICA/IHRoaXMuX3Jvb3QuZ2V0KDAsIHVuZGVmaW5lZCwgaywgbm90U2V0VmFsdWUpXG4gICAgICAgIDogbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgICBNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoaywgdikge1xuICAgICAgcmV0dXJuIHVwZGF0ZU1hcCh0aGlzLCBrLCB2KTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKGspIHtcbiAgICAgIHJldHVybiB1cGRhdGVNYXAodGhpcywgaywgTk9UX1NFVCk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuZGVsZXRlQWxsID0gZnVuY3Rpb24gZGVsZXRlQWxsIChrZXlzKSB7XG4gICAgICB2YXIgY29sbGVjdGlvbiA9IENvbGxlY3Rpb24oa2V5cyk7XG5cbiAgICAgIGlmIChjb2xsZWN0aW9uLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICBjb2xsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gbWFwLnJlbW92ZShrZXkpOyB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlNYXAoKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBDb21wb3NpdGlvblxuXG4gICAgTWFwLnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gc29ydCAoY29tcGFyYXRvcikge1xuICAgICAgLy8gTGF0ZSBiaW5kaW5nXG4gICAgICByZXR1cm4gT3JkZXJlZE1hcChzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yKSk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuc29ydEJ5ID0gZnVuY3Rpb24gc29ydEJ5IChtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICAgIC8vIExhdGUgYmluZGluZ1xuICAgICAgcmV0dXJuIE9yZGVyZWRNYXAoc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvciwgbWFwcGVyKSk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwZXIsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICBtYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgIG1hcC5zZXQoa2V5LCBtYXBwZXIuY2FsbChjb250ZXh0LCB2YWx1ZSwga2V5LCBtYXApKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBNdXRhYmlsaXR5XG5cbiAgICBNYXAucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKHRoaXMsIHR5cGUsIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB0aGlzLl9yb290ICYmXG4gICAgICAgIHRoaXMuX3Jvb3QuaXRlcmF0ZShmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgICAgcmV0dXJuIGZuKGVudHJ5WzFdLCBlbnRyeVswXSwgdGhpcyQxKTtcbiAgICAgICAgfSwgcmV2ZXJzZSk7XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24gX19lbnN1cmVPd25lciAob3duZXJJRCkge1xuICAgICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKCFvd25lcklEKSB7XG4gICAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZW1wdHlNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ha2VNYXAodGhpcy5zaXplLCB0aGlzLl9yb290LCBvd25lcklELCB0aGlzLl9faGFzaCk7XG4gICAgfTtcblxuICAgIHJldHVybiBNYXA7XG4gIH0oS2V5ZWRDb2xsZWN0aW9uKSk7XG5cbiAgTWFwLmlzTWFwID0gaXNNYXA7XG5cbiAgdmFyIE1hcFByb3RvdHlwZSA9IE1hcC5wcm90b3R5cGU7XG4gIE1hcFByb3RvdHlwZVtJU19NQVBfU1lNQk9MXSA9IHRydWU7XG4gIE1hcFByb3RvdHlwZVtERUxFVEVdID0gTWFwUHJvdG90eXBlLnJlbW92ZTtcbiAgTWFwUHJvdG90eXBlLnJlbW92ZUFsbCA9IE1hcFByb3RvdHlwZS5kZWxldGVBbGw7XG4gIE1hcFByb3RvdHlwZS5zZXRJbiA9IHNldEluJDE7XG4gIE1hcFByb3RvdHlwZS5yZW1vdmVJbiA9IE1hcFByb3RvdHlwZS5kZWxldGVJbiA9IGRlbGV0ZUluO1xuICBNYXBQcm90b3R5cGUudXBkYXRlID0gdXBkYXRlJDE7XG4gIE1hcFByb3RvdHlwZS51cGRhdGVJbiA9IHVwZGF0ZUluJDE7XG4gIE1hcFByb3RvdHlwZS5tZXJnZSA9IE1hcFByb3RvdHlwZS5jb25jYXQgPSBtZXJnZTtcbiAgTWFwUHJvdG90eXBlLm1lcmdlV2l0aCA9IG1lcmdlV2l0aDtcbiAgTWFwUHJvdG90eXBlLm1lcmdlRGVlcCA9IG1lcmdlRGVlcCQxO1xuICBNYXBQcm90b3R5cGUubWVyZ2VEZWVwV2l0aCA9IG1lcmdlRGVlcFdpdGgkMTtcbiAgTWFwUHJvdG90eXBlLm1lcmdlSW4gPSBtZXJnZUluO1xuICBNYXBQcm90b3R5cGUubWVyZ2VEZWVwSW4gPSBtZXJnZURlZXBJbjtcbiAgTWFwUHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSB3aXRoTXV0YXRpb25zO1xuICBNYXBQcm90b3R5cGUud2FzQWx0ZXJlZCA9IHdhc0FsdGVyZWQ7XG4gIE1hcFByb3RvdHlwZS5hc0ltbXV0YWJsZSA9IGFzSW1tdXRhYmxlO1xuICBNYXBQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBNYXBQcm90b3R5cGUuYXNNdXRhYmxlID0gYXNNdXRhYmxlO1xuICBNYXBQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBhcnIpIHtcbiAgICByZXR1cm4gcmVzdWx0LnNldChhcnJbMF0sIGFyclsxXSk7XG4gIH07XG4gIE1hcFByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmouYXNJbW11dGFibGUoKTtcbiAgfTtcblxuICAvLyAjcHJhZ21hIFRyaWUgTm9kZXNcblxuICB2YXIgQXJyYXlNYXBOb2RlID0gZnVuY3Rpb24gQXJyYXlNYXBOb2RlKG93bmVySUQsIGVudHJpZXMpIHtcbiAgICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xuICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gIH07XG5cbiAgQXJyYXlNYXBOb2RlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKHNoaWZ0LCBrZXlIYXNoLCBrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG4gICAgZm9yICh2YXIgaWkgPSAwLCBsZW4gPSBlbnRyaWVzLmxlbmd0aDsgaWkgPCBsZW47IGlpKyspIHtcbiAgICAgIGlmIChpcyhrZXksIGVudHJpZXNbaWldWzBdKSkge1xuICAgICAgICByZXR1cm4gZW50cmllc1tpaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub3RTZXRWYWx1ZTtcbiAgfTtcblxuICBBcnJheU1hcE5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAob3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKSB7XG4gICAgdmFyIHJlbW92ZWQgPSB2YWx1ZSA9PT0gTk9UX1NFVDtcblxuICAgIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICAgIHZhciBpZHggPSAwO1xuICAgIHZhciBsZW4gPSBlbnRyaWVzLmxlbmd0aDtcbiAgICBmb3IgKDsgaWR4IDwgbGVuOyBpZHgrKykge1xuICAgICAgaWYgKGlzKGtleSwgZW50cmllc1tpZHhdWzBdKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGV4aXN0cyA9IGlkeCA8IGxlbjtcblxuICAgIGlmIChleGlzdHMgPyBlbnRyaWVzW2lkeF1bMV0gPT09IHZhbHVlIDogcmVtb3ZlZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgU2V0UmVmKGRpZEFsdGVyKTtcbiAgICAocmVtb3ZlZCB8fCAhZXhpc3RzKSAmJiBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG5cbiAgICBpZiAocmVtb3ZlZCAmJiBlbnRyaWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBpZiAoIWV4aXN0cyAmJiAhcmVtb3ZlZCAmJiBlbnRyaWVzLmxlbmd0aCA+PSBNQVhfQVJSQVlfTUFQX1NJWkUpIHtcbiAgICAgIHJldHVybiBjcmVhdGVOb2Rlcyhvd25lcklELCBlbnRyaWVzLCBrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICB2YXIgaXNFZGl0YWJsZSA9IG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEO1xuICAgIHZhciBuZXdFbnRyaWVzID0gaXNFZGl0YWJsZSA/IGVudHJpZXMgOiBhcnJDb3B5KGVudHJpZXMpO1xuXG4gICAgaWYgKGV4aXN0cykge1xuICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgaWR4ID09PSBsZW4gLSAxXG4gICAgICAgICAgPyBuZXdFbnRyaWVzLnBvcCgpXG4gICAgICAgICAgOiAobmV3RW50cmllc1tpZHhdID0gbmV3RW50cmllcy5wb3AoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdFbnRyaWVzW2lkeF0gPSBba2V5LCB2YWx1ZV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0VudHJpZXMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgIH1cblxuICAgIGlmIChpc0VkaXRhYmxlKSB7XG4gICAgICB0aGlzLmVudHJpZXMgPSBuZXdFbnRyaWVzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBBcnJheU1hcE5vZGUob3duZXJJRCwgbmV3RW50cmllcyk7XG4gIH07XG5cbiAgdmFyIEJpdG1hcEluZGV4ZWROb2RlID0gZnVuY3Rpb24gQml0bWFwSW5kZXhlZE5vZGUob3duZXJJRCwgYml0bWFwLCBub2Rlcykge1xuICAgIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gICAgdGhpcy5iaXRtYXAgPSBiaXRtYXA7XG4gICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICB9O1xuXG4gIEJpdG1hcEluZGV4ZWROb2RlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKHNoaWZ0LCBrZXlIYXNoLCBrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgaWYgKGtleUhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5SGFzaCA9IGhhc2goa2V5KTtcbiAgICB9XG4gICAgdmFyIGJpdCA9IDEgPDwgKChzaGlmdCA9PT0gMCA/IGtleUhhc2ggOiBrZXlIYXNoID4+PiBzaGlmdCkgJiBNQVNLKTtcbiAgICB2YXIgYml0bWFwID0gdGhpcy5iaXRtYXA7XG4gICAgcmV0dXJuIChiaXRtYXAgJiBiaXQpID09PSAwXG4gICAgICA/IG5vdFNldFZhbHVlXG4gICAgICA6IHRoaXMubm9kZXNbcG9wQ291bnQoYml0bWFwICYgKGJpdCAtIDEpKV0uZ2V0KFxuICAgICAgICAgIHNoaWZ0ICsgU0hJRlQsXG4gICAgICAgICAga2V5SGFzaCxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgbm90U2V0VmFsdWVcbiAgICAgICAgKTtcbiAgfTtcblxuICBCaXRtYXBJbmRleGVkTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXlIYXNoID0gaGFzaChrZXkpO1xuICAgIH1cbiAgICB2YXIga2V5SGFzaEZyYWcgPSAoc2hpZnQgPT09IDAgPyBrZXlIYXNoIDoga2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcbiAgICB2YXIgYml0ID0gMSA8PCBrZXlIYXNoRnJhZztcbiAgICB2YXIgYml0bWFwID0gdGhpcy5iaXRtYXA7XG4gICAgdmFyIGV4aXN0cyA9IChiaXRtYXAgJiBiaXQpICE9PSAwO1xuXG4gICAgaWYgKCFleGlzdHMgJiYgdmFsdWUgPT09IE5PVF9TRVQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBpZHggPSBwb3BDb3VudChiaXRtYXAgJiAoYml0IC0gMSkpO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXM7XG4gICAgdmFyIG5vZGUgPSBleGlzdHMgPyBub2Rlc1tpZHhdIDogdW5kZWZpbmVkO1xuICAgIHZhciBuZXdOb2RlID0gdXBkYXRlTm9kZShcbiAgICAgIG5vZGUsXG4gICAgICBvd25lcklELFxuICAgICAgc2hpZnQgKyBTSElGVCxcbiAgICAgIGtleUhhc2gsXG4gICAgICBrZXksXG4gICAgICB2YWx1ZSxcbiAgICAgIGRpZENoYW5nZVNpemUsXG4gICAgICBkaWRBbHRlclxuICAgICk7XG5cbiAgICBpZiAobmV3Tm9kZSA9PT0gbm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKCFleGlzdHMgJiYgbmV3Tm9kZSAmJiBub2Rlcy5sZW5ndGggPj0gTUFYX0JJVE1BUF9JTkRFWEVEX1NJWkUpIHtcbiAgICAgIHJldHVybiBleHBhbmROb2Rlcyhvd25lcklELCBub2RlcywgYml0bWFwLCBrZXlIYXNoRnJhZywgbmV3Tm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgZXhpc3RzICYmXG4gICAgICAhbmV3Tm9kZSAmJlxuICAgICAgbm9kZXMubGVuZ3RoID09PSAyICYmXG4gICAgICBpc0xlYWZOb2RlKG5vZGVzW2lkeCBeIDFdKVxuICAgICkge1xuICAgICAgcmV0dXJuIG5vZGVzW2lkeCBeIDFdO1xuICAgIH1cblxuICAgIGlmIChleGlzdHMgJiYgbmV3Tm9kZSAmJiBub2Rlcy5sZW5ndGggPT09IDEgJiYgaXNMZWFmTm9kZShuZXdOb2RlKSkge1xuICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgfVxuXG4gICAgdmFyIGlzRWRpdGFibGUgPSBvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRDtcbiAgICB2YXIgbmV3Qml0bWFwID0gZXhpc3RzID8gKG5ld05vZGUgPyBiaXRtYXAgOiBiaXRtYXAgXiBiaXQpIDogYml0bWFwIHwgYml0O1xuICAgIHZhciBuZXdOb2RlcyA9IGV4aXN0c1xuICAgICAgPyBuZXdOb2RlXG4gICAgICAgID8gc2V0QXQobm9kZXMsIGlkeCwgbmV3Tm9kZSwgaXNFZGl0YWJsZSlcbiAgICAgICAgOiBzcGxpY2VPdXQobm9kZXMsIGlkeCwgaXNFZGl0YWJsZSlcbiAgICAgIDogc3BsaWNlSW4obm9kZXMsIGlkeCwgbmV3Tm9kZSwgaXNFZGl0YWJsZSk7XG5cbiAgICBpZiAoaXNFZGl0YWJsZSkge1xuICAgICAgdGhpcy5iaXRtYXAgPSBuZXdCaXRtYXA7XG4gICAgICB0aGlzLm5vZGVzID0gbmV3Tm9kZXM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEJpdG1hcEluZGV4ZWROb2RlKG93bmVySUQsIG5ld0JpdG1hcCwgbmV3Tm9kZXMpO1xuICB9O1xuXG4gIHZhciBIYXNoQXJyYXlNYXBOb2RlID0gZnVuY3Rpb24gSGFzaEFycmF5TWFwTm9kZShvd25lcklELCBjb3VudCwgbm9kZXMpIHtcbiAgICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xuICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICB0aGlzLm5vZGVzID0gbm9kZXM7XG4gIH07XG5cbiAgSGFzaEFycmF5TWFwTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICAgIGlmIChrZXlIYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG4gICAgfVxuICAgIHZhciBpZHggPSAoc2hpZnQgPT09IDAgPyBrZXlIYXNoIDoga2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcbiAgICB2YXIgbm9kZSA9IHRoaXMubm9kZXNbaWR4XTtcbiAgICByZXR1cm4gbm9kZVxuICAgICAgPyBub2RlLmdldChzaGlmdCArIFNISUZULCBrZXlIYXNoLCBrZXksIG5vdFNldFZhbHVlKVxuICAgICAgOiBub3RTZXRWYWx1ZTtcbiAgfTtcblxuICBIYXNoQXJyYXlNYXBOb2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcikge1xuICAgIGlmIChrZXlIYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG4gICAgfVxuICAgIHZhciBpZHggPSAoc2hpZnQgPT09IDAgPyBrZXlIYXNoIDoga2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcbiAgICB2YXIgcmVtb3ZlZCA9IHZhbHVlID09PSBOT1RfU0VUO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXM7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1tpZHhdO1xuXG4gICAgaWYgKHJlbW92ZWQgJiYgIW5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBuZXdOb2RlID0gdXBkYXRlTm9kZShcbiAgICAgIG5vZGUsXG4gICAgICBvd25lcklELFxuICAgICAgc2hpZnQgKyBTSElGVCxcbiAgICAgIGtleUhhc2gsXG4gICAgICBrZXksXG4gICAgICB2YWx1ZSxcbiAgICAgIGRpZENoYW5nZVNpemUsXG4gICAgICBkaWRBbHRlclxuICAgICk7XG4gICAgaWYgKG5ld05vZGUgPT09IG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBuZXdDb3VudCA9IHRoaXMuY291bnQ7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICBuZXdDb3VudCsrO1xuICAgIH0gZWxzZSBpZiAoIW5ld05vZGUpIHtcbiAgICAgIG5ld0NvdW50LS07XG4gICAgICBpZiAobmV3Q291bnQgPCBNSU5fSEFTSF9BUlJBWV9NQVBfU0laRSkge1xuICAgICAgICByZXR1cm4gcGFja05vZGVzKG93bmVySUQsIG5vZGVzLCBuZXdDb3VudCwgaWR4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaXNFZGl0YWJsZSA9IG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEO1xuICAgIHZhciBuZXdOb2RlcyA9IHNldEF0KG5vZGVzLCBpZHgsIG5ld05vZGUsIGlzRWRpdGFibGUpO1xuXG4gICAgaWYgKGlzRWRpdGFibGUpIHtcbiAgICAgIHRoaXMuY291bnQgPSBuZXdDb3VudDtcbiAgICAgIHRoaXMubm9kZXMgPSBuZXdOb2RlcztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSGFzaEFycmF5TWFwTm9kZShvd25lcklELCBuZXdDb3VudCwgbmV3Tm9kZXMpO1xuICB9O1xuXG4gIHZhciBIYXNoQ29sbGlzaW9uTm9kZSA9IGZ1bmN0aW9uIEhhc2hDb2xsaXNpb25Ob2RlKG93bmVySUQsIGtleUhhc2gsIGVudHJpZXMpIHtcbiAgICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xuICAgIHRoaXMua2V5SGFzaCA9IGtleUhhc2g7XG4gICAgdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgfTtcblxuICBIYXNoQ29sbGlzaW9uTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICAgIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICAgIGZvciAodmFyIGlpID0gMCwgbGVuID0gZW50cmllcy5sZW5ndGg7IGlpIDwgbGVuOyBpaSsrKSB7XG4gICAgICBpZiAoaXMoa2V5LCBlbnRyaWVzW2lpXVswXSkpIHtcbiAgICAgICAgcmV0dXJuIGVudHJpZXNbaWldWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm90U2V0VmFsdWU7XG4gIH07XG5cbiAgSGFzaENvbGxpc2lvbk5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAob3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKSB7XG4gICAgaWYgKGtleUhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5SGFzaCA9IGhhc2goa2V5KTtcbiAgICB9XG5cbiAgICB2YXIgcmVtb3ZlZCA9IHZhbHVlID09PSBOT1RfU0VUO1xuXG4gICAgaWYgKGtleUhhc2ggIT09IHRoaXMua2V5SGFzaCkge1xuICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBTZXRSZWYoZGlkQWx0ZXIpO1xuICAgICAgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuICAgICAgcmV0dXJuIG1lcmdlSW50b05vZGUodGhpcywgb3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIFtrZXksIHZhbHVlXSk7XG4gICAgfVxuXG4gICAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgdmFyIGxlbiA9IGVudHJpZXMubGVuZ3RoO1xuICAgIGZvciAoOyBpZHggPCBsZW47IGlkeCsrKSB7XG4gICAgICBpZiAoaXMoa2V5LCBlbnRyaWVzW2lkeF1bMF0pKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZXhpc3RzID0gaWR4IDwgbGVuO1xuXG4gICAgaWYgKGV4aXN0cyA/IGVudHJpZXNbaWR4XVsxXSA9PT0gdmFsdWUgOiByZW1vdmVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBTZXRSZWYoZGlkQWx0ZXIpO1xuICAgIChyZW1vdmVkIHx8ICFleGlzdHMpICYmIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcblxuICAgIGlmIChyZW1vdmVkICYmIGxlbiA9PT0gMikge1xuICAgICAgcmV0dXJuIG5ldyBWYWx1ZU5vZGUob3duZXJJRCwgdGhpcy5rZXlIYXNoLCBlbnRyaWVzW2lkeCBeIDFdKTtcbiAgICB9XG5cbiAgICB2YXIgaXNFZGl0YWJsZSA9IG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEO1xuICAgIHZhciBuZXdFbnRyaWVzID0gaXNFZGl0YWJsZSA/IGVudHJpZXMgOiBhcnJDb3B5KGVudHJpZXMpO1xuXG4gICAgaWYgKGV4aXN0cykge1xuICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgaWR4ID09PSBsZW4gLSAxXG4gICAgICAgICAgPyBuZXdFbnRyaWVzLnBvcCgpXG4gICAgICAgICAgOiAobmV3RW50cmllc1tpZHhdID0gbmV3RW50cmllcy5wb3AoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdFbnRyaWVzW2lkeF0gPSBba2V5LCB2YWx1ZV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0VudHJpZXMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgIH1cblxuICAgIGlmIChpc0VkaXRhYmxlKSB7XG4gICAgICB0aGlzLmVudHJpZXMgPSBuZXdFbnRyaWVzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBIYXNoQ29sbGlzaW9uTm9kZShvd25lcklELCB0aGlzLmtleUhhc2gsIG5ld0VudHJpZXMpO1xuICB9O1xuXG4gIHZhciBWYWx1ZU5vZGUgPSBmdW5jdGlvbiBWYWx1ZU5vZGUob3duZXJJRCwga2V5SGFzaCwgZW50cnkpIHtcbiAgICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xuICAgIHRoaXMua2V5SGFzaCA9IGtleUhhc2g7XG4gICAgdGhpcy5lbnRyeSA9IGVudHJ5O1xuICB9O1xuXG4gIFZhbHVlTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiBpcyhrZXksIHRoaXMuZW50cnlbMF0pID8gdGhpcy5lbnRyeVsxXSA6IG5vdFNldFZhbHVlO1xuICB9O1xuXG4gIFZhbHVlTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgICB2YXIgcmVtb3ZlZCA9IHZhbHVlID09PSBOT1RfU0VUO1xuICAgIHZhciBrZXlNYXRjaCA9IGlzKGtleSwgdGhpcy5lbnRyeVswXSk7XG4gICAgaWYgKGtleU1hdGNoID8gdmFsdWUgPT09IHRoaXMuZW50cnlbMV0gOiByZW1vdmVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBTZXRSZWYoZGlkQWx0ZXIpO1xuXG4gICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcbiAgICAgIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgaWYgKGtleU1hdGNoKSB7XG4gICAgICBpZiAob3duZXJJRCAmJiBvd25lcklEID09PSB0aGlzLm93bmVySUQpIHtcbiAgICAgICAgdGhpcy5lbnRyeVsxXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgVmFsdWVOb2RlKG93bmVySUQsIHRoaXMua2V5SGFzaCwgW2tleSwgdmFsdWVdKTtcbiAgICB9XG5cbiAgICBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG4gICAgcmV0dXJuIG1lcmdlSW50b05vZGUodGhpcywgb3duZXJJRCwgc2hpZnQsIGhhc2goa2V5KSwgW2tleSwgdmFsdWVdKTtcbiAgfTtcblxuICAvLyAjcHJhZ21hIEl0ZXJhdG9yc1xuXG4gIEFycmF5TWFwTm9kZS5wcm90b3R5cGUuaXRlcmF0ZSA9IEhhc2hDb2xsaXNpb25Ob2RlLnByb3RvdHlwZS5pdGVyYXRlID1cbiAgICBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICAgICAgZm9yICh2YXIgaWkgPSAwLCBtYXhJbmRleCA9IGVudHJpZXMubGVuZ3RoIC0gMTsgaWkgPD0gbWF4SW5kZXg7IGlpKyspIHtcbiAgICAgICAgaWYgKGZuKGVudHJpZXNbcmV2ZXJzZSA/IG1heEluZGV4IC0gaWkgOiBpaV0pID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgQml0bWFwSW5kZXhlZE5vZGUucHJvdG90eXBlLml0ZXJhdGUgPSBIYXNoQXJyYXlNYXBOb2RlLnByb3RvdHlwZS5pdGVyYXRlID1cbiAgICBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXM7XG4gICAgICBmb3IgKHZhciBpaSA9IDAsIG1heEluZGV4ID0gbm9kZXMubGVuZ3RoIC0gMTsgaWkgPD0gbWF4SW5kZXg7IGlpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tyZXZlcnNlID8gbWF4SW5kZXggLSBpaSA6IGlpXTtcbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5pdGVyYXRlKGZuLCByZXZlcnNlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBWYWx1ZU5vZGUucHJvdG90eXBlLml0ZXJhdGUgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgICByZXR1cm4gZm4odGhpcy5lbnRyeSk7XG4gIH07XG5cbiAgdmFyIE1hcEl0ZXJhdG9yID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSXRlcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBNYXBJdGVyYXRvcihtYXAsIHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgICAgdGhpcy5fcmV2ZXJzZSA9IHJldmVyc2U7XG4gICAgICB0aGlzLl9zdGFjayA9IG1hcC5fcm9vdCAmJiBtYXBJdGVyYXRvckZyYW1lKG1hcC5fcm9vdCk7XG4gICAgfVxuXG4gICAgaWYgKCBJdGVyYXRvciApIE1hcEl0ZXJhdG9yLl9fcHJvdG9fXyA9IEl0ZXJhdG9yO1xuICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEl0ZXJhdG9yICYmIEl0ZXJhdG9yLnByb3RvdHlwZSApO1xuICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1hcEl0ZXJhdG9yO1xuXG4gICAgTWFwSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiBuZXh0ICgpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy5fdHlwZTtcbiAgICAgIHZhciBzdGFjayA9IHRoaXMuX3N0YWNrO1xuICAgICAgd2hpbGUgKHN0YWNrKSB7XG4gICAgICAgIHZhciBub2RlID0gc3RhY2subm9kZTtcbiAgICAgICAgdmFyIGluZGV4ID0gc3RhY2suaW5kZXgrKztcbiAgICAgICAgdmFyIG1heEluZGV4ID0gKHZvaWQgMCk7XG4gICAgICAgIGlmIChub2RlLmVudHJ5KSB7XG4gICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwSXRlcmF0b3JWYWx1ZSh0eXBlLCBub2RlLmVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgbWF4SW5kZXggPSBub2RlLmVudHJpZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICBpZiAoaW5kZXggPD0gbWF4SW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXBJdGVyYXRvclZhbHVlKFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBub2RlLmVudHJpZXNbdGhpcy5fcmV2ZXJzZSA/IG1heEluZGV4IC0gaW5kZXggOiBpbmRleF1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1heEluZGV4ID0gbm9kZS5ub2Rlcy5sZW5ndGggLSAxO1xuICAgICAgICAgIGlmIChpbmRleCA8PSBtYXhJbmRleCkge1xuICAgICAgICAgICAgdmFyIHN1Yk5vZGUgPSBub2RlLm5vZGVzW3RoaXMuX3JldmVyc2UgPyBtYXhJbmRleCAtIGluZGV4IDogaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHN1Yk5vZGUpIHtcbiAgICAgICAgICAgICAgaWYgKHN1Yk5vZGUuZW50cnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwSXRlcmF0b3JWYWx1ZSh0eXBlLCBzdWJOb2RlLmVudHJ5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdGFjayA9IHRoaXMuX3N0YWNrID0gbWFwSXRlcmF0b3JGcmFtZShzdWJOb2RlLCBzdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sgPSB0aGlzLl9zdGFjayA9IHRoaXMuX3N0YWNrLl9fcHJldjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1hcEl0ZXJhdG9yO1xuICB9KEl0ZXJhdG9yKSk7XG5cbiAgZnVuY3Rpb24gbWFwSXRlcmF0b3JWYWx1ZSh0eXBlLCBlbnRyeSkge1xuICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXBJdGVyYXRvckZyYW1lKG5vZGUsIHByZXYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogbm9kZSxcbiAgICAgIGluZGV4OiAwLFxuICAgICAgX19wcmV2OiBwcmV2LFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlTWFwKHNpemUsIHJvb3QsIG93bmVySUQsIGhhc2gpIHtcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShNYXBQcm90b3R5cGUpO1xuICAgIG1hcC5zaXplID0gc2l6ZTtcbiAgICBtYXAuX3Jvb3QgPSByb290O1xuICAgIG1hcC5fX293bmVySUQgPSBvd25lcklEO1xuICAgIG1hcC5fX2hhc2ggPSBoYXNoO1xuICAgIG1hcC5fX2FsdGVyZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gbWFwO1xuICB9XG5cbiAgdmFyIEVNUFRZX01BUDtcbiAgZnVuY3Rpb24gZW1wdHlNYXAoKSB7XG4gICAgcmV0dXJuIEVNUFRZX01BUCB8fCAoRU1QVFlfTUFQID0gbWFrZU1hcCgwKSk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVNYXAobWFwLCBrLCB2KSB7XG4gICAgdmFyIG5ld1Jvb3Q7XG4gICAgdmFyIG5ld1NpemU7XG4gICAgaWYgKCFtYXAuX3Jvb3QpIHtcbiAgICAgIGlmICh2ID09PSBOT1RfU0VUKSB7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgICB9XG4gICAgICBuZXdTaXplID0gMTtcbiAgICAgIG5ld1Jvb3QgPSBuZXcgQXJyYXlNYXBOb2RlKG1hcC5fX293bmVySUQsIFtbaywgdl1dKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRpZENoYW5nZVNpemUgPSBNYWtlUmVmKCk7XG4gICAgICB2YXIgZGlkQWx0ZXIgPSBNYWtlUmVmKCk7XG4gICAgICBuZXdSb290ID0gdXBkYXRlTm9kZShcbiAgICAgICAgbWFwLl9yb290LFxuICAgICAgICBtYXAuX19vd25lcklELFxuICAgICAgICAwLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIGssXG4gICAgICAgIHYsXG4gICAgICAgIGRpZENoYW5nZVNpemUsXG4gICAgICAgIGRpZEFsdGVyXG4gICAgICApO1xuICAgICAgaWYgKCFkaWRBbHRlci52YWx1ZSkge1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgfVxuICAgICAgbmV3U2l6ZSA9IG1hcC5zaXplICsgKGRpZENoYW5nZVNpemUudmFsdWUgPyAodiA9PT0gTk9UX1NFVCA/IC0xIDogMSkgOiAwKTtcbiAgICB9XG4gICAgaWYgKG1hcC5fX293bmVySUQpIHtcbiAgICAgIG1hcC5zaXplID0gbmV3U2l6ZTtcbiAgICAgIG1hcC5fcm9vdCA9IG5ld1Jvb3Q7XG4gICAgICBtYXAuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgbWFwLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICByZXR1cm4gbmV3Um9vdCA/IG1ha2VNYXAobmV3U2l6ZSwgbmV3Um9vdCkgOiBlbXB0eU1hcCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTm9kZShcbiAgICBub2RlLFxuICAgIG93bmVySUQsXG4gICAgc2hpZnQsXG4gICAga2V5SGFzaCxcbiAgICBrZXksXG4gICAgdmFsdWUsXG4gICAgZGlkQ2hhbmdlU2l6ZSxcbiAgICBkaWRBbHRlclxuICApIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gTk9UX1NFVCkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIFNldFJlZihkaWRBbHRlcik7XG4gICAgICBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG4gICAgICByZXR1cm4gbmV3IFZhbHVlTm9kZShvd25lcklELCBrZXlIYXNoLCBba2V5LCB2YWx1ZV0pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS51cGRhdGUoXG4gICAgICBvd25lcklELFxuICAgICAgc2hpZnQsXG4gICAgICBrZXlIYXNoLFxuICAgICAga2V5LFxuICAgICAgdmFsdWUsXG4gICAgICBkaWRDaGFuZ2VTaXplLFxuICAgICAgZGlkQWx0ZXJcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNMZWFmTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIG5vZGUuY29uc3RydWN0b3IgPT09IFZhbHVlTm9kZSB8fCBub2RlLmNvbnN0cnVjdG9yID09PSBIYXNoQ29sbGlzaW9uTm9kZVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUludG9Ob2RlKG5vZGUsIG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBlbnRyeSkge1xuICAgIGlmIChub2RlLmtleUhhc2ggPT09IGtleUhhc2gpIHtcbiAgICAgIHJldHVybiBuZXcgSGFzaENvbGxpc2lvbk5vZGUob3duZXJJRCwga2V5SGFzaCwgW25vZGUuZW50cnksIGVudHJ5XSk7XG4gICAgfVxuXG4gICAgdmFyIGlkeDEgPSAoc2hpZnQgPT09IDAgPyBub2RlLmtleUhhc2ggOiBub2RlLmtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG4gICAgdmFyIGlkeDIgPSAoc2hpZnQgPT09IDAgPyBrZXlIYXNoIDoga2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcblxuICAgIHZhciBuZXdOb2RlO1xuICAgIHZhciBub2RlcyA9XG4gICAgICBpZHgxID09PSBpZHgyXG4gICAgICAgID8gW21lcmdlSW50b05vZGUobm9kZSwgb3duZXJJRCwgc2hpZnQgKyBTSElGVCwga2V5SGFzaCwgZW50cnkpXVxuICAgICAgICA6ICgobmV3Tm9kZSA9IG5ldyBWYWx1ZU5vZGUob3duZXJJRCwga2V5SGFzaCwgZW50cnkpKSxcbiAgICAgICAgICBpZHgxIDwgaWR4MiA/IFtub2RlLCBuZXdOb2RlXSA6IFtuZXdOb2RlLCBub2RlXSk7XG5cbiAgICByZXR1cm4gbmV3IEJpdG1hcEluZGV4ZWROb2RlKG93bmVySUQsICgxIDw8IGlkeDEpIHwgKDEgPDwgaWR4MiksIG5vZGVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVzKG93bmVySUQsIGVudHJpZXMsIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgIG93bmVySUQgPSBuZXcgT3duZXJJRCgpO1xuICAgIH1cbiAgICB2YXIgbm9kZSA9IG5ldyBWYWx1ZU5vZGUob3duZXJJRCwgaGFzaChrZXkpLCBba2V5LCB2YWx1ZV0pO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBlbnRyaWVzLmxlbmd0aDsgaWkrKykge1xuICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpaV07XG4gICAgICBub2RlID0gbm9kZS51cGRhdGUob3duZXJJRCwgMCwgdW5kZWZpbmVkLCBlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhY2tOb2Rlcyhvd25lcklELCBub2RlcywgY291bnQsIGV4Y2x1ZGluZykge1xuICAgIHZhciBiaXRtYXAgPSAwO1xuICAgIHZhciBwYWNrZWRJSSA9IDA7XG4gICAgdmFyIHBhY2tlZE5vZGVzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKHZhciBpaSA9IDAsIGJpdCA9IDEsIGxlbiA9IG5vZGVzLmxlbmd0aDsgaWkgPCBsZW47IGlpKyssIGJpdCA8PD0gMSkge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpaV07XG4gICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkICYmIGlpICE9PSBleGNsdWRpbmcpIHtcbiAgICAgICAgYml0bWFwIHw9IGJpdDtcbiAgICAgICAgcGFja2VkTm9kZXNbcGFja2VkSUkrK10gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEJpdG1hcEluZGV4ZWROb2RlKG93bmVySUQsIGJpdG1hcCwgcGFja2VkTm9kZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXhwYW5kTm9kZXMob3duZXJJRCwgbm9kZXMsIGJpdG1hcCwgaW5jbHVkaW5nLCBub2RlKSB7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgZXhwYW5kZWROb2RlcyA9IG5ldyBBcnJheShTSVpFKTtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGJpdG1hcCAhPT0gMDsgaWkrKywgYml0bWFwID4+Pj0gMSkge1xuICAgICAgZXhwYW5kZWROb2Rlc1tpaV0gPSBiaXRtYXAgJiAxID8gbm9kZXNbY291bnQrK10gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGV4cGFuZGVkTm9kZXNbaW5jbHVkaW5nXSA9IG5vZGU7XG4gICAgcmV0dXJuIG5ldyBIYXNoQXJyYXlNYXBOb2RlKG93bmVySUQsIGNvdW50ICsgMSwgZXhwYW5kZWROb2Rlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BDb3VudCh4KSB7XG4gICAgeCAtPSAoeCA+PiAxKSAmIDB4NTU1NTU1NTU7XG4gICAgeCA9ICh4ICYgMHgzMzMzMzMzMykgKyAoKHggPj4gMikgJiAweDMzMzMzMzMzKTtcbiAgICB4ID0gKHggKyAoeCA+PiA0KSkgJiAweDBmMGYwZjBmO1xuICAgIHggKz0geCA+PiA4O1xuICAgIHggKz0geCA+PiAxNjtcbiAgICByZXR1cm4geCAmIDB4N2Y7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRBdChhcnJheSwgaWR4LCB2YWwsIGNhbkVkaXQpIHtcbiAgICB2YXIgbmV3QXJyYXkgPSBjYW5FZGl0ID8gYXJyYXkgOiBhcnJDb3B5KGFycmF5KTtcbiAgICBuZXdBcnJheVtpZHhdID0gdmFsO1xuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNwbGljZUluKGFycmF5LCBpZHgsIHZhbCwgY2FuRWRpdCkge1xuICAgIHZhciBuZXdMZW4gPSBhcnJheS5sZW5ndGggKyAxO1xuICAgIGlmIChjYW5FZGl0ICYmIGlkeCArIDEgPT09IG5ld0xlbikge1xuICAgICAgYXJyYXlbaWR4XSA9IHZhbDtcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG4gICAgdmFyIG5ld0FycmF5ID0gbmV3IEFycmF5KG5ld0xlbik7XG4gICAgdmFyIGFmdGVyID0gMDtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbmV3TGVuOyBpaSsrKSB7XG4gICAgICBpZiAoaWkgPT09IGlkeCkge1xuICAgICAgICBuZXdBcnJheVtpaV0gPSB2YWw7XG4gICAgICAgIGFmdGVyID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdBcnJheVtpaV0gPSBhcnJheVtpaSArIGFmdGVyXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9XG5cbiAgZnVuY3Rpb24gc3BsaWNlT3V0KGFycmF5LCBpZHgsIGNhbkVkaXQpIHtcbiAgICB2YXIgbmV3TGVuID0gYXJyYXkubGVuZ3RoIC0gMTtcbiAgICBpZiAoY2FuRWRpdCAmJiBpZHggPT09IG5ld0xlbikge1xuICAgICAgYXJyYXkucG9wKCk7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIHZhciBuZXdBcnJheSA9IG5ldyBBcnJheShuZXdMZW4pO1xuICAgIHZhciBhZnRlciA9IDA7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG5ld0xlbjsgaWkrKykge1xuICAgICAgaWYgKGlpID09PSBpZHgpIHtcbiAgICAgICAgYWZ0ZXIgPSAxO1xuICAgICAgfVxuICAgICAgbmV3QXJyYXlbaWldID0gYXJyYXlbaWkgKyBhZnRlcl07XG4gICAgfVxuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfVxuXG4gIHZhciBNQVhfQVJSQVlfTUFQX1NJWkUgPSBTSVpFIC8gNDtcbiAgdmFyIE1BWF9CSVRNQVBfSU5ERVhFRF9TSVpFID0gU0laRSAvIDI7XG4gIHZhciBNSU5fSEFTSF9BUlJBWV9NQVBfU0laRSA9IFNJWkUgLyA0O1xuXG4gIHZhciBJU19MSVNUX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX0xJU1RfX0BAJztcblxuICBmdW5jdGlvbiBpc0xpc3QobWF5YmVMaXN0KSB7XG4gICAgcmV0dXJuIEJvb2xlYW4obWF5YmVMaXN0ICYmIG1heWJlTGlzdFtJU19MSVNUX1NZTUJPTF0pO1xuICB9XG5cbiAgdmFyIExpc3QgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbmRleGVkQ29sbGVjdGlvbikge1xuICAgIGZ1bmN0aW9uIExpc3QodmFsdWUpIHtcbiAgICAgIHZhciBlbXB0eSA9IGVtcHR5TGlzdCgpO1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgICAgfVxuICAgICAgaWYgKGlzTGlzdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXIgPSBJbmRleGVkQ29sbGVjdGlvbih2YWx1ZSk7XG4gICAgICB2YXIgc2l6ZSA9IGl0ZXIuc2l6ZTtcbiAgICAgIGlmIChzaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBlbXB0eTtcbiAgICAgIH1cbiAgICAgIGFzc2VydE5vdEluZmluaXRlKHNpemUpO1xuICAgICAgaWYgKHNpemUgPiAwICYmIHNpemUgPCBTSVpFKSB7XG4gICAgICAgIHJldHVybiBtYWtlTGlzdCgwLCBzaXplLCBTSElGVCwgbnVsbCwgbmV3IFZOb2RlKGl0ZXIudG9BcnJheSgpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICBsaXN0LnNldFNpemUoc2l6ZSk7XG4gICAgICAgIGl0ZXIuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkgeyByZXR1cm4gbGlzdC5zZXQoaSwgdik7IH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCBJbmRleGVkQ29sbGVjdGlvbiApIExpc3QuX19wcm90b19fID0gSW5kZXhlZENvbGxlY3Rpb247XG4gICAgTGlzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkQ29sbGVjdGlvbiAmJiBJbmRleGVkQ29sbGVjdGlvbi5wcm90b3R5cGUgKTtcbiAgICBMaXN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpc3Q7XG5cbiAgICBMaXN0Lm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnTGlzdCBbJywgJ10nKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICAgIExpc3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgICBpbmRleCA9IHdyYXBJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuc2l6ZSkge1xuICAgICAgICBpbmRleCArPSB0aGlzLl9vcmlnaW47XG4gICAgICAgIHZhciBub2RlID0gbGlzdE5vZGVGb3IodGhpcywgaW5kZXgpO1xuICAgICAgICByZXR1cm4gbm9kZSAmJiBub2RlLmFycmF5W2luZGV4ICYgTUFTS107XG4gICAgICB9XG4gICAgICByZXR1cm4gbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgICBMaXN0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKGluZGV4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHVwZGF0ZUxpc3QodGhpcywgaW5kZXgsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlIChpbmRleCkge1xuICAgICAgcmV0dXJuICF0aGlzLmhhcyhpbmRleClcbiAgICAgICAgPyB0aGlzXG4gICAgICAgIDogaW5kZXggPT09IDBcbiAgICAgICAgPyB0aGlzLnNoaWZ0KClcbiAgICAgICAgOiBpbmRleCA9PT0gdGhpcy5zaXplIC0gMVxuICAgICAgICA/IHRoaXMucG9wKClcbiAgICAgICAgOiB0aGlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIGluc2VydCAoaW5kZXgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGxpY2UoaW5kZXgsIDAsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuX29yaWdpbiA9IHRoaXMuX2NhcGFjaXR5ID0gMDtcbiAgICAgICAgdGhpcy5fbGV2ZWwgPSBTSElGVDtcbiAgICAgICAgdGhpcy5fcm9vdCA9IHRoaXMuX3RhaWwgPSBudWxsO1xuICAgICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eUxpc3QoKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgb2xkU2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgc2V0TGlzdEJvdW5kcyhsaXN0LCAwLCBvbGRTaXplICsgdmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCB2YWx1ZXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgbGlzdC5zZXQob2xkU2l6ZSArIGlpLCB2YWx1ZXNbaWldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uIHBvcCAoKSB7XG4gICAgICByZXR1cm4gc2V0TGlzdEJvdW5kcyh0aGlzLCAwLCAtMSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0ICgvKi4uLnZhbHVlcyovKSB7XG4gICAgICB2YXIgdmFsdWVzID0gYXJndW1lbnRzO1xuICAgICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICBzZXRMaXN0Qm91bmRzKGxpc3QsIC12YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHZhbHVlcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICBsaXN0LnNldChpaSwgdmFsdWVzW2lpXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uIHNoaWZ0ICgpIHtcbiAgICAgIHJldHVybiBzZXRMaXN0Qm91bmRzKHRoaXMsIDEpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIENvbXBvc2l0aW9uXG5cbiAgICBMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKC8qLi4uY29sbGVjdGlvbnMqLykge1xuICAgICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgICB2YXIgc2VxcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGFyZ3VtZW50ID0gYXJndW1lbnRzJDFbaV07XG4gICAgICAgIHZhciBzZXEgPSBJbmRleGVkQ29sbGVjdGlvbihcbiAgICAgICAgICB0eXBlb2YgYXJndW1lbnQgIT09ICdzdHJpbmcnICYmIGhhc0l0ZXJhdG9yKGFyZ3VtZW50KVxuICAgICAgICAgICAgPyBhcmd1bWVudFxuICAgICAgICAgICAgOiBbYXJndW1lbnRdXG4gICAgICAgICk7XG4gICAgICAgIGlmIChzZXEuc2l6ZSAhPT0gMCkge1xuICAgICAgICAgIHNlcXMucHVzaChzZXEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2Vxcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwICYmICF0aGlzLl9fb3duZXJJRCAmJiBzZXFzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RvcihzZXFzWzBdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgc2Vxcy5mb3JFYWNoKGZ1bmN0aW9uIChzZXEpIHsgcmV0dXJuIHNlcS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbGlzdC5wdXNoKHZhbHVlKTsgfSk7IH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbiBzZXRTaXplIChzaXplKSB7XG4gICAgICByZXR1cm4gc2V0TGlzdEJvdW5kcyh0aGlzLCAwLCBzaXplKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwZXIsIGNvbnRleHQpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcyQxLnNpemU7IGkrKykge1xuICAgICAgICAgIGxpc3Quc2V0KGksIG1hcHBlci5jYWxsKGNvbnRleHQsIGxpc3QuZ2V0KGkpLCBpLCBsaXN0KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIEl0ZXJhdGlvblxuXG4gICAgTGlzdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoYmVnaW4sIGVuZCkge1xuICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgICBpZiAod2hvbGVTbGljZShiZWdpbiwgZW5kLCBzaXplKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXRMaXN0Qm91bmRzKFxuICAgICAgICB0aGlzLFxuICAgICAgICByZXNvbHZlQmVnaW4oYmVnaW4sIHNpemUpLFxuICAgICAgICByZXNvbHZlRW5kKGVuZCwgc2l6ZSlcbiAgICAgICk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaW5kZXggPSByZXZlcnNlID8gdGhpcy5zaXplIDogMDtcbiAgICAgIHZhciB2YWx1ZXMgPSBpdGVyYXRlTGlzdCh0aGlzLCByZXZlcnNlKTtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXMoKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBET05FXG4gICAgICAgICAgPyBpdGVyYXRvckRvbmUoKVxuICAgICAgICAgIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCByZXZlcnNlID8gLS1pbmRleCA6IGluZGV4KyssIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaW5kZXggPSByZXZlcnNlID8gdGhpcy5zaXplIDogMDtcbiAgICAgIHZhciB2YWx1ZXMgPSBpdGVyYXRlTGlzdCh0aGlzLCByZXZlcnNlKTtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIHdoaWxlICgodmFsdWUgPSB2YWx1ZXMoKSkgIT09IERPTkUpIHtcbiAgICAgICAgaWYgKGZuKHZhbHVlLCByZXZlcnNlID8gLS1pbmRleCA6IGluZGV4KyssIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbiBfX2Vuc3VyZU93bmVyIChvd25lcklEKSB7XG4gICAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBlbXB0eUxpc3QoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ha2VMaXN0KFxuICAgICAgICB0aGlzLl9vcmlnaW4sXG4gICAgICAgIHRoaXMuX2NhcGFjaXR5LFxuICAgICAgICB0aGlzLl9sZXZlbCxcbiAgICAgICAgdGhpcy5fcm9vdCxcbiAgICAgICAgdGhpcy5fdGFpbCxcbiAgICAgICAgb3duZXJJRCxcbiAgICAgICAgdGhpcy5fX2hhc2hcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHJldHVybiBMaXN0O1xuICB9KEluZGV4ZWRDb2xsZWN0aW9uKSk7XG5cbiAgTGlzdC5pc0xpc3QgPSBpc0xpc3Q7XG5cbiAgdmFyIExpc3RQcm90b3R5cGUgPSBMaXN0LnByb3RvdHlwZTtcbiAgTGlzdFByb3RvdHlwZVtJU19MSVNUX1NZTUJPTF0gPSB0cnVlO1xuICBMaXN0UHJvdG90eXBlW0RFTEVURV0gPSBMaXN0UHJvdG90eXBlLnJlbW92ZTtcbiAgTGlzdFByb3RvdHlwZS5tZXJnZSA9IExpc3RQcm90b3R5cGUuY29uY2F0O1xuICBMaXN0UHJvdG90eXBlLnNldEluID0gc2V0SW4kMTtcbiAgTGlzdFByb3RvdHlwZS5kZWxldGVJbiA9IExpc3RQcm90b3R5cGUucmVtb3ZlSW4gPSBkZWxldGVJbjtcbiAgTGlzdFByb3RvdHlwZS51cGRhdGUgPSB1cGRhdGUkMTtcbiAgTGlzdFByb3RvdHlwZS51cGRhdGVJbiA9IHVwZGF0ZUluJDE7XG4gIExpc3RQcm90b3R5cGUubWVyZ2VJbiA9IG1lcmdlSW47XG4gIExpc3RQcm90b3R5cGUubWVyZ2VEZWVwSW4gPSBtZXJnZURlZXBJbjtcbiAgTGlzdFByb3RvdHlwZS53aXRoTXV0YXRpb25zID0gd2l0aE11dGF0aW9ucztcbiAgTGlzdFByb3RvdHlwZS53YXNBbHRlcmVkID0gd2FzQWx0ZXJlZDtcbiAgTGlzdFByb3RvdHlwZS5hc0ltbXV0YWJsZSA9IGFzSW1tdXRhYmxlO1xuICBMaXN0UHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gTGlzdFByb3RvdHlwZS5hc011dGFibGUgPSBhc011dGFibGU7XG4gIExpc3RQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBhcnIpIHtcbiAgICByZXR1cm4gcmVzdWx0LnB1c2goYXJyKTtcbiAgfTtcbiAgTGlzdFByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmouYXNJbW11dGFibGUoKTtcbiAgfTtcblxuICB2YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZShhcnJheSwgb3duZXJJRCkge1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xuICB9O1xuXG4gIC8vIFRPRE86IHNlZW1zIGxpa2UgdGhlc2UgbWV0aG9kcyBhcmUgdmVyeSBzaW1pbGFyXG5cbiAgVk5vZGUucHJvdG90eXBlLnJlbW92ZUJlZm9yZSA9IGZ1bmN0aW9uIHJlbW92ZUJlZm9yZSAob3duZXJJRCwgbGV2ZWwsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSBsZXZlbCA/IDEgPDwgbGV2ZWwgOiAgdGhpcy5hcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgb3JpZ2luSW5kZXggPSAoaW5kZXggPj4+IGxldmVsKSAmIE1BU0s7XG4gICAgaWYgKG9yaWdpbkluZGV4ID49IHRoaXMuYXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbmV3IFZOb2RlKFtdLCBvd25lcklEKTtcbiAgICB9XG4gICAgdmFyIHJlbW92aW5nRmlyc3QgPSBvcmlnaW5JbmRleCA9PT0gMDtcbiAgICB2YXIgbmV3Q2hpbGQ7XG4gICAgaWYgKGxldmVsID4gMCkge1xuICAgICAgdmFyIG9sZENoaWxkID0gdGhpcy5hcnJheVtvcmlnaW5JbmRleF07XG4gICAgICBuZXdDaGlsZCA9XG4gICAgICAgIG9sZENoaWxkICYmIG9sZENoaWxkLnJlbW92ZUJlZm9yZShvd25lcklELCBsZXZlbCAtIFNISUZULCBpbmRleCk7XG4gICAgICBpZiAobmV3Q2hpbGQgPT09IG9sZENoaWxkICYmIHJlbW92aW5nRmlyc3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZW1vdmluZ0ZpcnN0ICYmICFuZXdDaGlsZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBlZGl0YWJsZSA9IGVkaXRhYmxlVk5vZGUodGhpcywgb3duZXJJRCk7XG4gICAgaWYgKCFyZW1vdmluZ0ZpcnN0KSB7XG4gICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgb3JpZ2luSW5kZXg7IGlpKyspIHtcbiAgICAgICAgZWRpdGFibGUuYXJyYXlbaWldID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV3Q2hpbGQpIHtcbiAgICAgIGVkaXRhYmxlLmFycmF5W29yaWdpbkluZGV4XSA9IG5ld0NoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gZWRpdGFibGU7XG4gIH07XG5cbiAgVk5vZGUucHJvdG90eXBlLnJlbW92ZUFmdGVyID0gZnVuY3Rpb24gcmVtb3ZlQWZ0ZXIgKG93bmVySUQsIGxldmVsLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gKGxldmVsID8gMSA8PCBsZXZlbCA6IDApIHx8IHRoaXMuYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIHNpemVJbmRleCA9ICgoaW5kZXggLSAxKSA+Pj4gbGV2ZWwpICYgTUFTSztcbiAgICBpZiAoc2l6ZUluZGV4ID49IHRoaXMuYXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgbmV3Q2hpbGQ7XG4gICAgaWYgKGxldmVsID4gMCkge1xuICAgICAgdmFyIG9sZENoaWxkID0gdGhpcy5hcnJheVtzaXplSW5kZXhdO1xuICAgICAgbmV3Q2hpbGQgPVxuICAgICAgICBvbGRDaGlsZCAmJiBvbGRDaGlsZC5yZW1vdmVBZnRlcihvd25lcklELCBsZXZlbCAtIFNISUZULCBpbmRleCk7XG4gICAgICBpZiAobmV3Q2hpbGQgPT09IG9sZENoaWxkICYmIHNpemVJbmRleCA9PT0gdGhpcy5hcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBlZGl0YWJsZSA9IGVkaXRhYmxlVk5vZGUodGhpcywgb3duZXJJRCk7XG4gICAgZWRpdGFibGUuYXJyYXkuc3BsaWNlKHNpemVJbmRleCArIDEpO1xuICAgIGlmIChuZXdDaGlsZCkge1xuICAgICAgZWRpdGFibGUuYXJyYXlbc2l6ZUluZGV4XSA9IG5ld0NoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gZWRpdGFibGU7XG4gIH07XG5cbiAgdmFyIERPTkUgPSB7fTtcblxuICBmdW5jdGlvbiBpdGVyYXRlTGlzdChsaXN0LCByZXZlcnNlKSB7XG4gICAgdmFyIGxlZnQgPSBsaXN0Ll9vcmlnaW47XG4gICAgdmFyIHJpZ2h0ID0gbGlzdC5fY2FwYWNpdHk7XG4gICAgdmFyIHRhaWxQb3MgPSBnZXRUYWlsT2Zmc2V0KHJpZ2h0KTtcbiAgICB2YXIgdGFpbCA9IGxpc3QuX3RhaWw7XG5cbiAgICByZXR1cm4gaXRlcmF0ZU5vZGVPckxlYWYobGlzdC5fcm9vdCwgbGlzdC5fbGV2ZWwsIDApO1xuXG4gICAgZnVuY3Rpb24gaXRlcmF0ZU5vZGVPckxlYWYobm9kZSwgbGV2ZWwsIG9mZnNldCkge1xuICAgICAgcmV0dXJuIGxldmVsID09PSAwXG4gICAgICAgID8gaXRlcmF0ZUxlYWYobm9kZSwgb2Zmc2V0KVxuICAgICAgICA6IGl0ZXJhdGVOb2RlKG5vZGUsIGxldmVsLCBvZmZzZXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGl0ZXJhdGVMZWFmKG5vZGUsIG9mZnNldCkge1xuICAgICAgdmFyIGFycmF5ID0gb2Zmc2V0ID09PSB0YWlsUG9zID8gdGFpbCAmJiB0YWlsLmFycmF5IDogbm9kZSAmJiBub2RlLmFycmF5O1xuICAgICAgdmFyIGZyb20gPSBvZmZzZXQgPiBsZWZ0ID8gMCA6IGxlZnQgLSBvZmZzZXQ7XG4gICAgICB2YXIgdG8gPSByaWdodCAtIG9mZnNldDtcbiAgICAgIGlmICh0byA+IFNJWkUpIHtcbiAgICAgICAgdG8gPSBTSVpFO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAgICAgcmV0dXJuIERPTkU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlkeCA9IHJldmVyc2UgPyAtLXRvIDogZnJvbSsrO1xuICAgICAgICByZXR1cm4gYXJyYXkgJiYgYXJyYXlbaWR4XTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXRlcmF0ZU5vZGUobm9kZSwgbGV2ZWwsIG9mZnNldCkge1xuICAgICAgdmFyIHZhbHVlcztcbiAgICAgIHZhciBhcnJheSA9IG5vZGUgJiYgbm9kZS5hcnJheTtcbiAgICAgIHZhciBmcm9tID0gb2Zmc2V0ID4gbGVmdCA/IDAgOiAobGVmdCAtIG9mZnNldCkgPj4gbGV2ZWw7XG4gICAgICB2YXIgdG8gPSAoKHJpZ2h0IC0gb2Zmc2V0KSA+PiBsZXZlbCkgKyAxO1xuICAgICAgaWYgKHRvID4gU0laRSkge1xuICAgICAgICB0byA9IFNJWkU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlcygpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBET05FKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlcyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgICAgICAgcmV0dXJuIERPTkU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpZHggPSByZXZlcnNlID8gLS10byA6IGZyb20rKztcbiAgICAgICAgICB2YWx1ZXMgPSBpdGVyYXRlTm9kZU9yTGVhZihcbiAgICAgICAgICAgIGFycmF5ICYmIGFycmF5W2lkeF0sXG4gICAgICAgICAgICBsZXZlbCAtIFNISUZULFxuICAgICAgICAgICAgb2Zmc2V0ICsgKGlkeCA8PCBsZXZlbClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VMaXN0KG9yaWdpbiwgY2FwYWNpdHksIGxldmVsLCByb290LCB0YWlsLCBvd25lcklELCBoYXNoKSB7XG4gICAgdmFyIGxpc3QgPSBPYmplY3QuY3JlYXRlKExpc3RQcm90b3R5cGUpO1xuICAgIGxpc3Quc2l6ZSA9IGNhcGFjaXR5IC0gb3JpZ2luO1xuICAgIGxpc3QuX29yaWdpbiA9IG9yaWdpbjtcbiAgICBsaXN0Ll9jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgIGxpc3QuX2xldmVsID0gbGV2ZWw7XG4gICAgbGlzdC5fcm9vdCA9IHJvb3Q7XG4gICAgbGlzdC5fdGFpbCA9IHRhaWw7XG4gICAgbGlzdC5fX293bmVySUQgPSBvd25lcklEO1xuICAgIGxpc3QuX19oYXNoID0gaGFzaDtcbiAgICBsaXN0Ll9fYWx0ZXJlZCA9IGZhbHNlO1xuICAgIHJldHVybiBsaXN0O1xuICB9XG5cbiAgdmFyIEVNUFRZX0xJU1Q7XG4gIGZ1bmN0aW9uIGVtcHR5TGlzdCgpIHtcbiAgICByZXR1cm4gRU1QVFlfTElTVCB8fCAoRU1QVFlfTElTVCA9IG1ha2VMaXN0KDAsIDAsIFNISUZUKSk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMaXN0KGxpc3QsIGluZGV4LCB2YWx1ZSkge1xuICAgIGluZGV4ID0gd3JhcEluZGV4KGxpc3QsIGluZGV4KTtcblxuICAgIGlmIChpbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cblxuICAgIGlmIChpbmRleCA+PSBsaXN0LnNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gbGlzdC53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgIGluZGV4IDwgMFxuICAgICAgICAgID8gc2V0TGlzdEJvdW5kcyhsaXN0LCBpbmRleCkuc2V0KDAsIHZhbHVlKVxuICAgICAgICAgIDogc2V0TGlzdEJvdW5kcyhsaXN0LCAwLCBpbmRleCArIDEpLnNldChpbmRleCwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaW5kZXggKz0gbGlzdC5fb3JpZ2luO1xuXG4gICAgdmFyIG5ld1RhaWwgPSBsaXN0Ll90YWlsO1xuICAgIHZhciBuZXdSb290ID0gbGlzdC5fcm9vdDtcbiAgICB2YXIgZGlkQWx0ZXIgPSBNYWtlUmVmKCk7XG4gICAgaWYgKGluZGV4ID49IGdldFRhaWxPZmZzZXQobGlzdC5fY2FwYWNpdHkpKSB7XG4gICAgICBuZXdUYWlsID0gdXBkYXRlVk5vZGUobmV3VGFpbCwgbGlzdC5fX293bmVySUQsIDAsIGluZGV4LCB2YWx1ZSwgZGlkQWx0ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdSb290ID0gdXBkYXRlVk5vZGUoXG4gICAgICAgIG5ld1Jvb3QsXG4gICAgICAgIGxpc3QuX19vd25lcklELFxuICAgICAgICBsaXN0Ll9sZXZlbCxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkaWRBbHRlclxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWRpZEFsdGVyLnZhbHVlKSB7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICBpZiAobGlzdC5fX293bmVySUQpIHtcbiAgICAgIGxpc3QuX3Jvb3QgPSBuZXdSb290O1xuICAgICAgbGlzdC5fdGFpbCA9IG5ld1RhaWw7XG4gICAgICBsaXN0Ll9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgIGxpc3QuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgICByZXR1cm4gbWFrZUxpc3QobGlzdC5fb3JpZ2luLCBsaXN0Ll9jYXBhY2l0eSwgbGlzdC5fbGV2ZWwsIG5ld1Jvb3QsIG5ld1RhaWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVk5vZGUobm9kZSwgb3duZXJJRCwgbGV2ZWwsIGluZGV4LCB2YWx1ZSwgZGlkQWx0ZXIpIHtcbiAgICB2YXIgaWR4ID0gKGluZGV4ID4+PiBsZXZlbCkgJiBNQVNLO1xuICAgIHZhciBub2RlSGFzID0gbm9kZSAmJiBpZHggPCBub2RlLmFycmF5Lmxlbmd0aDtcbiAgICBpZiAoIW5vZGVIYXMgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgdmFyIG5ld05vZGU7XG5cbiAgICBpZiAobGV2ZWwgPiAwKSB7XG4gICAgICB2YXIgbG93ZXJOb2RlID0gbm9kZSAmJiBub2RlLmFycmF5W2lkeF07XG4gICAgICB2YXIgbmV3TG93ZXJOb2RlID0gdXBkYXRlVk5vZGUoXG4gICAgICAgIGxvd2VyTm9kZSxcbiAgICAgICAgb3duZXJJRCxcbiAgICAgICAgbGV2ZWwgLSBTSElGVCxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkaWRBbHRlclxuICAgICAgKTtcbiAgICAgIGlmIChuZXdMb3dlck5vZGUgPT09IGxvd2VyTm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIG5ld05vZGUgPSBlZGl0YWJsZVZOb2RlKG5vZGUsIG93bmVySUQpO1xuICAgICAgbmV3Tm9kZS5hcnJheVtpZHhdID0gbmV3TG93ZXJOb2RlO1xuICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGVIYXMgJiYgbm9kZS5hcnJheVtpZHhdID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgaWYgKGRpZEFsdGVyKSB7XG4gICAgICBTZXRSZWYoZGlkQWx0ZXIpO1xuICAgIH1cblxuICAgIG5ld05vZGUgPSBlZGl0YWJsZVZOb2RlKG5vZGUsIG93bmVySUQpO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGlkeCA9PT0gbmV3Tm9kZS5hcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICBuZXdOb2RlLmFycmF5LnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdOb2RlLmFycmF5W2lkeF0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld05vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBlZGl0YWJsZVZOb2RlKG5vZGUsIG93bmVySUQpIHtcbiAgICBpZiAob3duZXJJRCAmJiBub2RlICYmIG93bmVySUQgPT09IG5vZGUub3duZXJJRCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZSA/IG5vZGUuYXJyYXkuc2xpY2UoKSA6IFtdLCBvd25lcklEKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpc3ROb2RlRm9yKGxpc3QsIHJhd0luZGV4KSB7XG4gICAgaWYgKHJhd0luZGV4ID49IGdldFRhaWxPZmZzZXQobGlzdC5fY2FwYWNpdHkpKSB7XG4gICAgICByZXR1cm4gbGlzdC5fdGFpbDtcbiAgICB9XG4gICAgaWYgKHJhd0luZGV4IDwgMSA8PCAobGlzdC5fbGV2ZWwgKyBTSElGVCkpIHtcbiAgICAgIHZhciBub2RlID0gbGlzdC5fcm9vdDtcbiAgICAgIHZhciBsZXZlbCA9IGxpc3QuX2xldmVsO1xuICAgICAgd2hpbGUgKG5vZGUgJiYgbGV2ZWwgPiAwKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLmFycmF5WyhyYXdJbmRleCA+Pj4gbGV2ZWwpICYgTUFTS107XG4gICAgICAgIGxldmVsIC09IFNISUZUO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0TGlzdEJvdW5kcyhsaXN0LCBiZWdpbiwgZW5kKSB7XG4gICAgLy8gU2FuaXRpemUgYmVnaW4gJiBlbmQgdXNpbmcgdGhpcyBzaG9ydGhhbmQgZm9yIFRvSW50MzIoYXJndW1lbnQpXG4gICAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvaW50MzJcbiAgICBpZiAoYmVnaW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgYmVnaW4gfD0gMDtcbiAgICB9XG4gICAgaWYgKGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmQgfD0gMDtcbiAgICB9XG4gICAgdmFyIG93bmVyID0gbGlzdC5fX293bmVySUQgfHwgbmV3IE93bmVySUQoKTtcbiAgICB2YXIgb2xkT3JpZ2luID0gbGlzdC5fb3JpZ2luO1xuICAgIHZhciBvbGRDYXBhY2l0eSA9IGxpc3QuX2NhcGFjaXR5O1xuICAgIHZhciBuZXdPcmlnaW4gPSBvbGRPcmlnaW4gKyBiZWdpbjtcbiAgICB2YXIgbmV3Q2FwYWNpdHkgPVxuICAgICAgZW5kID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBvbGRDYXBhY2l0eVxuICAgICAgICA6IGVuZCA8IDBcbiAgICAgICAgPyBvbGRDYXBhY2l0eSArIGVuZFxuICAgICAgICA6IG9sZE9yaWdpbiArIGVuZDtcbiAgICBpZiAobmV3T3JpZ2luID09PSBvbGRPcmlnaW4gJiYgbmV3Q2FwYWNpdHkgPT09IG9sZENhcGFjaXR5KSB7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICAvLyBJZiBpdCdzIGdvaW5nIHRvIGVuZCBhZnRlciBpdCBzdGFydHMsIGl0J3MgZW1wdHkuXG4gICAgaWYgKG5ld09yaWdpbiA+PSBuZXdDYXBhY2l0eSkge1xuICAgICAgcmV0dXJuIGxpc3QuY2xlYXIoKTtcbiAgICB9XG5cbiAgICB2YXIgbmV3TGV2ZWwgPSBsaXN0Ll9sZXZlbDtcbiAgICB2YXIgbmV3Um9vdCA9IGxpc3QuX3Jvb3Q7XG5cbiAgICAvLyBOZXcgb3JpZ2luIG1pZ2h0IG5lZWQgY3JlYXRpbmcgYSBoaWdoZXIgcm9vdC5cbiAgICB2YXIgb2Zmc2V0U2hpZnQgPSAwO1xuICAgIHdoaWxlIChuZXdPcmlnaW4gKyBvZmZzZXRTaGlmdCA8IDApIHtcbiAgICAgIG5ld1Jvb3QgPSBuZXcgVk5vZGUoXG4gICAgICAgIG5ld1Jvb3QgJiYgbmV3Um9vdC5hcnJheS5sZW5ndGggPyBbdW5kZWZpbmVkLCBuZXdSb290XSA6IFtdLFxuICAgICAgICBvd25lclxuICAgICAgKTtcbiAgICAgIG5ld0xldmVsICs9IFNISUZUO1xuICAgICAgb2Zmc2V0U2hpZnQgKz0gMSA8PCBuZXdMZXZlbDtcbiAgICB9XG4gICAgaWYgKG9mZnNldFNoaWZ0KSB7XG4gICAgICBuZXdPcmlnaW4gKz0gb2Zmc2V0U2hpZnQ7XG4gICAgICBvbGRPcmlnaW4gKz0gb2Zmc2V0U2hpZnQ7XG4gICAgICBuZXdDYXBhY2l0eSArPSBvZmZzZXRTaGlmdDtcbiAgICAgIG9sZENhcGFjaXR5ICs9IG9mZnNldFNoaWZ0O1xuICAgIH1cblxuICAgIHZhciBvbGRUYWlsT2Zmc2V0ID0gZ2V0VGFpbE9mZnNldChvbGRDYXBhY2l0eSk7XG4gICAgdmFyIG5ld1RhaWxPZmZzZXQgPSBnZXRUYWlsT2Zmc2V0KG5ld0NhcGFjaXR5KTtcblxuICAgIC8vIE5ldyBzaXplIG1pZ2h0IG5lZWQgY3JlYXRpbmcgYSBoaWdoZXIgcm9vdC5cbiAgICB3aGlsZSAobmV3VGFpbE9mZnNldCA+PSAxIDw8IChuZXdMZXZlbCArIFNISUZUKSkge1xuICAgICAgbmV3Um9vdCA9IG5ldyBWTm9kZShcbiAgICAgICAgbmV3Um9vdCAmJiBuZXdSb290LmFycmF5Lmxlbmd0aCA/IFtuZXdSb290XSA6IFtdLFxuICAgICAgICBvd25lclxuICAgICAgKTtcbiAgICAgIG5ld0xldmVsICs9IFNISUZUO1xuICAgIH1cblxuICAgIC8vIExvY2F0ZSBvciBjcmVhdGUgdGhlIG5ldyB0YWlsLlxuICAgIHZhciBvbGRUYWlsID0gbGlzdC5fdGFpbDtcbiAgICB2YXIgbmV3VGFpbCA9XG4gICAgICBuZXdUYWlsT2Zmc2V0IDwgb2xkVGFpbE9mZnNldFxuICAgICAgICA/IGxpc3ROb2RlRm9yKGxpc3QsIG5ld0NhcGFjaXR5IC0gMSlcbiAgICAgICAgOiBuZXdUYWlsT2Zmc2V0ID4gb2xkVGFpbE9mZnNldFxuICAgICAgICA/IG5ldyBWTm9kZShbXSwgb3duZXIpXG4gICAgICAgIDogb2xkVGFpbDtcblxuICAgIC8vIE1lcmdlIFRhaWwgaW50byB0cmVlLlxuICAgIGlmIChcbiAgICAgIG9sZFRhaWwgJiZcbiAgICAgIG5ld1RhaWxPZmZzZXQgPiBvbGRUYWlsT2Zmc2V0ICYmXG4gICAgICBuZXdPcmlnaW4gPCBvbGRDYXBhY2l0eSAmJlxuICAgICAgb2xkVGFpbC5hcnJheS5sZW5ndGhcbiAgICApIHtcbiAgICAgIG5ld1Jvb3QgPSBlZGl0YWJsZVZOb2RlKG5ld1Jvb3QsIG93bmVyKTtcbiAgICAgIHZhciBub2RlID0gbmV3Um9vdDtcbiAgICAgIGZvciAodmFyIGxldmVsID0gbmV3TGV2ZWw7IGxldmVsID4gU0hJRlQ7IGxldmVsIC09IFNISUZUKSB7XG4gICAgICAgIHZhciBpZHggPSAob2xkVGFpbE9mZnNldCA+Pj4gbGV2ZWwpICYgTUFTSztcbiAgICAgICAgbm9kZSA9IG5vZGUuYXJyYXlbaWR4XSA9IGVkaXRhYmxlVk5vZGUobm9kZS5hcnJheVtpZHhdLCBvd25lcik7XG4gICAgICB9XG4gICAgICBub2RlLmFycmF5WyhvbGRUYWlsT2Zmc2V0ID4+PiBTSElGVCkgJiBNQVNLXSA9IG9sZFRhaWw7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHNpemUgaGFzIGJlZW4gcmVkdWNlZCwgdGhlcmUncyBhIGNoYW5jZSB0aGUgdGFpbCBuZWVkcyB0byBiZSB0cmltbWVkLlxuICAgIGlmIChuZXdDYXBhY2l0eSA8IG9sZENhcGFjaXR5KSB7XG4gICAgICBuZXdUYWlsID0gbmV3VGFpbCAmJiBuZXdUYWlsLnJlbW92ZUFmdGVyKG93bmVyLCAwLCBuZXdDYXBhY2l0eSk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIG5ldyBvcmlnaW4gaXMgd2l0aGluIHRoZSB0YWlsLCB0aGVuIHdlIGRvIG5vdCBuZWVkIGEgcm9vdC5cbiAgICBpZiAobmV3T3JpZ2luID49IG5ld1RhaWxPZmZzZXQpIHtcbiAgICAgIG5ld09yaWdpbiAtPSBuZXdUYWlsT2Zmc2V0O1xuICAgICAgbmV3Q2FwYWNpdHkgLT0gbmV3VGFpbE9mZnNldDtcbiAgICAgIG5ld0xldmVsID0gU0hJRlQ7XG4gICAgICBuZXdSb290ID0gbnVsbDtcbiAgICAgIG5ld1RhaWwgPSBuZXdUYWlsICYmIG5ld1RhaWwucmVtb3ZlQmVmb3JlKG93bmVyLCAwLCBuZXdPcmlnaW4pO1xuXG4gICAgICAvLyBPdGhlcndpc2UsIGlmIHRoZSByb290IGhhcyBiZWVuIHRyaW1tZWQsIGdhcmJhZ2UgY29sbGVjdC5cbiAgICB9IGVsc2UgaWYgKG5ld09yaWdpbiA+IG9sZE9yaWdpbiB8fCBuZXdUYWlsT2Zmc2V0IDwgb2xkVGFpbE9mZnNldCkge1xuICAgICAgb2Zmc2V0U2hpZnQgPSAwO1xuXG4gICAgICAvLyBJZGVudGlmeSB0aGUgbmV3IHRvcCByb290IG5vZGUgb2YgdGhlIHN1YnRyZWUgb2YgdGhlIG9sZCByb290LlxuICAgICAgd2hpbGUgKG5ld1Jvb3QpIHtcbiAgICAgICAgdmFyIGJlZ2luSW5kZXggPSAobmV3T3JpZ2luID4+PiBuZXdMZXZlbCkgJiBNQVNLO1xuICAgICAgICBpZiAoKGJlZ2luSW5kZXggIT09IG5ld1RhaWxPZmZzZXQgPj4+IG5ld0xldmVsKSAmIE1BU0spIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmVnaW5JbmRleCkge1xuICAgICAgICAgIG9mZnNldFNoaWZ0ICs9ICgxIDw8IG5ld0xldmVsKSAqIGJlZ2luSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgbmV3TGV2ZWwgLT0gU0hJRlQ7XG4gICAgICAgIG5ld1Jvb3QgPSBuZXdSb290LmFycmF5W2JlZ2luSW5kZXhdO1xuICAgICAgfVxuXG4gICAgICAvLyBUcmltIHRoZSBuZXcgc2lkZXMgb2YgdGhlIG5ldyByb290LlxuICAgICAgaWYgKG5ld1Jvb3QgJiYgbmV3T3JpZ2luID4gb2xkT3JpZ2luKSB7XG4gICAgICAgIG5ld1Jvb3QgPSBuZXdSb290LnJlbW92ZUJlZm9yZShvd25lciwgbmV3TGV2ZWwsIG5ld09yaWdpbiAtIG9mZnNldFNoaWZ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdSb290ICYmIG5ld1RhaWxPZmZzZXQgPCBvbGRUYWlsT2Zmc2V0KSB7XG4gICAgICAgIG5ld1Jvb3QgPSBuZXdSb290LnJlbW92ZUFmdGVyKFxuICAgICAgICAgIG93bmVyLFxuICAgICAgICAgIG5ld0xldmVsLFxuICAgICAgICAgIG5ld1RhaWxPZmZzZXQgLSBvZmZzZXRTaGlmdFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKG9mZnNldFNoaWZ0KSB7XG4gICAgICAgIG5ld09yaWdpbiAtPSBvZmZzZXRTaGlmdDtcbiAgICAgICAgbmV3Q2FwYWNpdHkgLT0gb2Zmc2V0U2hpZnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxpc3QuX19vd25lcklEKSB7XG4gICAgICBsaXN0LnNpemUgPSBuZXdDYXBhY2l0eSAtIG5ld09yaWdpbjtcbiAgICAgIGxpc3QuX29yaWdpbiA9IG5ld09yaWdpbjtcbiAgICAgIGxpc3QuX2NhcGFjaXR5ID0gbmV3Q2FwYWNpdHk7XG4gICAgICBsaXN0Ll9sZXZlbCA9IG5ld0xldmVsO1xuICAgICAgbGlzdC5fcm9vdCA9IG5ld1Jvb3Q7XG4gICAgICBsaXN0Ll90YWlsID0gbmV3VGFpbDtcbiAgICAgIGxpc3QuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgbGlzdC5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICAgIHJldHVybiBtYWtlTGlzdChuZXdPcmlnaW4sIG5ld0NhcGFjaXR5LCBuZXdMZXZlbCwgbmV3Um9vdCwgbmV3VGFpbCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUYWlsT2Zmc2V0KHNpemUpIHtcbiAgICByZXR1cm4gc2l6ZSA8IFNJWkUgPyAwIDogKChzaXplIC0gMSkgPj4+IFNISUZUKSA8PCBTSElGVDtcbiAgfVxuXG4gIHZhciBPcmRlcmVkTWFwID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoTWFwKSB7XG4gICAgZnVuY3Rpb24gT3JkZXJlZE1hcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBlbXB0eU9yZGVyZWRNYXAoKVxuICAgICAgICA6IGlzT3JkZXJlZE1hcCh2YWx1ZSlcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IGVtcHR5T3JkZXJlZE1hcCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgdmFyIGl0ZXIgPSBLZXllZENvbGxlY3Rpb24odmFsdWUpO1xuICAgICAgICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICAgICAgICAgIGl0ZXIuZm9yRWFjaChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gbWFwLnNldChrLCB2KTsgfSk7XG4gICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCBNYXAgKSBPcmRlcmVkTWFwLl9fcHJvdG9fXyA9IE1hcDtcbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hcCAmJiBNYXAucHJvdG90eXBlICk7XG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPcmRlcmVkTWFwO1xuXG4gICAgT3JkZXJlZE1hcC5vZiA9IGZ1bmN0aW9uIG9mICgvKi4uLnZhbHVlcyovKSB7XG4gICAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ09yZGVyZWRNYXAgeycsICd9Jyk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGssIG5vdFNldFZhbHVlKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9tYXAuZ2V0KGspO1xuICAgICAgcmV0dXJuIGluZGV4ICE9PSB1bmRlZmluZWQgPyB0aGlzLl9saXN0LmdldChpbmRleClbMV0gOiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB0aGlzLl9tYXAuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fbGlzdC5jbGVhcigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eU9yZGVyZWRNYXAoKTtcbiAgICB9O1xuXG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0IChrLCB2KSB7XG4gICAgICByZXR1cm4gdXBkYXRlT3JkZXJlZE1hcCh0aGlzLCBrLCB2KTtcbiAgICB9O1xuXG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlIChrKSB7XG4gICAgICByZXR1cm4gdXBkYXRlT3JkZXJlZE1hcCh0aGlzLCBrLCBOT1RfU0VUKTtcbiAgICB9O1xuXG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUud2FzQWx0ZXJlZCA9IGZ1bmN0aW9uIHdhc0FsdGVyZWQgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hcC53YXNBbHRlcmVkKCkgfHwgdGhpcy5fbGlzdC53YXNBbHRlcmVkKCk7XG4gICAgfTtcblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5fbGlzdC5fX2l0ZXJhdGUoXG4gICAgICAgIGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZW50cnkgJiYgZm4oZW50cnlbMV0sIGVudHJ5WzBdLCB0aGlzJDEpOyB9LFxuICAgICAgICByZXZlcnNlXG4gICAgICApO1xuICAgIH07XG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xpc3QuZnJvbUVudHJ5U2VxKCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uIF9fZW5zdXJlT3duZXIgKG93bmVySUQpIHtcbiAgICAgIGlmIChvd25lcklEID09PSB0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdNYXAgPSB0aGlzLl9tYXAuX19lbnN1cmVPd25lcihvd25lcklEKTtcbiAgICAgIHZhciBuZXdMaXN0ID0gdGhpcy5fbGlzdC5fX2Vuc3VyZU93bmVyKG93bmVySUQpO1xuICAgICAgaWYgKCFvd25lcklEKSB7XG4gICAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZW1wdHlPcmRlcmVkTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuICAgICAgICB0aGlzLl9tYXAgPSBuZXdNYXA7XG4gICAgICAgIHRoaXMuX2xpc3QgPSBuZXdMaXN0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlT3JkZXJlZE1hcChuZXdNYXAsIG5ld0xpc3QsIG93bmVySUQsIHRoaXMuX19oYXNoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE9yZGVyZWRNYXA7XG4gIH0oTWFwKSk7XG5cbiAgT3JkZXJlZE1hcC5pc09yZGVyZWRNYXAgPSBpc09yZGVyZWRNYXA7XG5cbiAgT3JkZXJlZE1hcC5wcm90b3R5cGVbSVNfT1JERVJFRF9TWU1CT0xdID0gdHJ1ZTtcbiAgT3JkZXJlZE1hcC5wcm90b3R5cGVbREVMRVRFXSA9IE9yZGVyZWRNYXAucHJvdG90eXBlLnJlbW92ZTtcblxuICBmdW5jdGlvbiBtYWtlT3JkZXJlZE1hcChtYXAsIGxpc3QsIG93bmVySUQsIGhhc2gpIHtcbiAgICB2YXIgb21hcCA9IE9iamVjdC5jcmVhdGUoT3JkZXJlZE1hcC5wcm90b3R5cGUpO1xuICAgIG9tYXAuc2l6ZSA9IG1hcCA/IG1hcC5zaXplIDogMDtcbiAgICBvbWFwLl9tYXAgPSBtYXA7XG4gICAgb21hcC5fbGlzdCA9IGxpc3Q7XG4gICAgb21hcC5fX293bmVySUQgPSBvd25lcklEO1xuICAgIG9tYXAuX19oYXNoID0gaGFzaDtcbiAgICByZXR1cm4gb21hcDtcbiAgfVxuXG4gIHZhciBFTVBUWV9PUkRFUkVEX01BUDtcbiAgZnVuY3Rpb24gZW1wdHlPcmRlcmVkTWFwKCkge1xuICAgIHJldHVybiAoXG4gICAgICBFTVBUWV9PUkRFUkVEX01BUCB8fFxuICAgICAgKEVNUFRZX09SREVSRURfTUFQID0gbWFrZU9yZGVyZWRNYXAoZW1wdHlNYXAoKSwgZW1wdHlMaXN0KCkpKVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVPcmRlcmVkTWFwKG9tYXAsIGssIHYpIHtcbiAgICB2YXIgbWFwID0gb21hcC5fbWFwO1xuICAgIHZhciBsaXN0ID0gb21hcC5fbGlzdDtcbiAgICB2YXIgaSA9IG1hcC5nZXQoayk7XG4gICAgdmFyIGhhcyA9IGkgIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgbmV3TWFwO1xuICAgIHZhciBuZXdMaXN0O1xuICAgIGlmICh2ID09PSBOT1RfU0VUKSB7XG4gICAgICAvLyByZW1vdmVkXG4gICAgICBpZiAoIWhhcykge1xuICAgICAgICByZXR1cm4gb21hcDtcbiAgICAgIH1cbiAgICAgIGlmIChsaXN0LnNpemUgPj0gU0laRSAmJiBsaXN0LnNpemUgPj0gbWFwLnNpemUgKiAyKSB7XG4gICAgICAgIG5ld0xpc3QgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAoZW50cnksIGlkeCkgeyByZXR1cm4gZW50cnkgIT09IHVuZGVmaW5lZCAmJiBpICE9PSBpZHg7IH0pO1xuICAgICAgICBuZXdNYXAgPSBuZXdMaXN0XG4gICAgICAgICAgLnRvS2V5ZWRTZXEoKVxuICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeVswXTsgfSlcbiAgICAgICAgICAuZmxpcCgpXG4gICAgICAgICAgLnRvTWFwKCk7XG4gICAgICAgIGlmIChvbWFwLl9fb3duZXJJRCkge1xuICAgICAgICAgIG5ld01hcC5fX293bmVySUQgPSBuZXdMaXN0Ll9fb3duZXJJRCA9IG9tYXAuX19vd25lcklEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdNYXAgPSBtYXAucmVtb3ZlKGspO1xuICAgICAgICBuZXdMaXN0ID0gaSA9PT0gbGlzdC5zaXplIC0gMSA/IGxpc3QucG9wKCkgOiBsaXN0LnNldChpLCB1bmRlZmluZWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGFzKSB7XG4gICAgICBpZiAodiA9PT0gbGlzdC5nZXQoaSlbMV0pIHtcbiAgICAgICAgcmV0dXJuIG9tYXA7XG4gICAgICB9XG4gICAgICBuZXdNYXAgPSBtYXA7XG4gICAgICBuZXdMaXN0ID0gbGlzdC5zZXQoaSwgW2ssIHZdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3TWFwID0gbWFwLnNldChrLCBsaXN0LnNpemUpO1xuICAgICAgbmV3TGlzdCA9IGxpc3Quc2V0KGxpc3Quc2l6ZSwgW2ssIHZdKTtcbiAgICB9XG4gICAgaWYgKG9tYXAuX19vd25lcklEKSB7XG4gICAgICBvbWFwLnNpemUgPSBuZXdNYXAuc2l6ZTtcbiAgICAgIG9tYXAuX21hcCA9IG5ld01hcDtcbiAgICAgIG9tYXAuX2xpc3QgPSBuZXdMaXN0O1xuICAgICAgb21hcC5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gb21hcDtcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VPcmRlcmVkTWFwKG5ld01hcCwgbmV3TGlzdCk7XG4gIH1cblxuICB2YXIgSVNfU1RBQ0tfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfU1RBQ0tfX0BAJztcblxuICBmdW5jdGlvbiBpc1N0YWNrKG1heWJlU3RhY2spIHtcbiAgICByZXR1cm4gQm9vbGVhbihtYXliZVN0YWNrICYmIG1heWJlU3RhY2tbSVNfU1RBQ0tfU1lNQk9MXSk7XG4gIH1cblxuICB2YXIgU3RhY2sgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbmRleGVkQ29sbGVjdGlvbikge1xuICAgIGZ1bmN0aW9uIFN0YWNrKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IGVtcHR5U3RhY2soKVxuICAgICAgICA6IGlzU3RhY2sodmFsdWUpXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiBlbXB0eVN0YWNrKCkucHVzaEFsbCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKCBJbmRleGVkQ29sbGVjdGlvbiApIFN0YWNrLl9fcHJvdG9fXyA9IEluZGV4ZWRDb2xsZWN0aW9uO1xuICAgIFN0YWNrLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEluZGV4ZWRDb2xsZWN0aW9uICYmIEluZGV4ZWRDb2xsZWN0aW9uLnByb3RvdHlwZSApO1xuICAgIFN0YWNrLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN0YWNrO1xuXG4gICAgU3RhY2sub2YgPSBmdW5jdGlvbiBvZiAoLyouLi52YWx1ZXMqLykge1xuICAgICAgcmV0dXJuIHRoaXMoYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgU3RhY2sucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnU3RhY2sgWycsICddJyk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgICBTdGFjay5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHZhciBoZWFkID0gdGhpcy5faGVhZDtcbiAgICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICAgIHdoaWxlIChoZWFkICYmIGluZGV4LS0pIHtcbiAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoZWFkID8gaGVhZC52YWx1ZSA6IG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICBTdGFjay5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uIHBlZWsgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hlYWQgJiYgdGhpcy5faGVhZC52YWx1ZTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICAgIFN0YWNrLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAoLyouLi52YWx1ZXMqLykge1xuICAgICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdTaXplID0gdGhpcy5zaXplICsgYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHZhciBoZWFkID0gdGhpcy5faGVhZDtcbiAgICAgIGZvciAodmFyIGlpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGlpID49IDA7IGlpLS0pIHtcbiAgICAgICAgaGVhZCA9IHtcbiAgICAgICAgICB2YWx1ZTogYXJndW1lbnRzJDFbaWldLFxuICAgICAgICAgIG5leHQ6IGhlYWQsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgdGhpcy5zaXplID0gbmV3U2l6ZTtcbiAgICAgICAgdGhpcy5faGVhZCA9IGhlYWQ7XG4gICAgICAgIHRoaXMuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ha2VTdGFjayhuZXdTaXplLCBoZWFkKTtcbiAgICB9O1xuXG4gICAgU3RhY2sucHJvdG90eXBlLnB1c2hBbGwgPSBmdW5jdGlvbiBwdXNoQWxsIChpdGVyKSB7XG4gICAgICBpdGVyID0gSW5kZXhlZENvbGxlY3Rpb24oaXRlcik7XG4gICAgICBpZiAoaXRlci5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCAmJiBpc1N0YWNrKGl0ZXIpKSB7XG4gICAgICAgIHJldHVybiBpdGVyO1xuICAgICAgfVxuICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICAgIHZhciBuZXdTaXplID0gdGhpcy5zaXplO1xuICAgICAgdmFyIGhlYWQgPSB0aGlzLl9oZWFkO1xuICAgICAgaXRlci5fX2l0ZXJhdGUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIG5ld1NpemUrKztcbiAgICAgICAgaGVhZCA9IHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgbmV4dDogaGVhZCxcbiAgICAgICAgfTtcbiAgICAgIH0sIC8qIHJldmVyc2UgKi8gdHJ1ZSk7XG4gICAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgdGhpcy5zaXplID0gbmV3U2l6ZTtcbiAgICAgICAgdGhpcy5faGVhZCA9IGhlYWQ7XG4gICAgICAgIHRoaXMuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ha2VTdGFjayhuZXdTaXplLCBoZWFkKTtcbiAgICB9O1xuXG4gICAgU3RhY2sucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uIHBvcCAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zbGljZSgxKTtcbiAgICB9O1xuXG4gICAgU3RhY2sucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB0aGlzLl9oZWFkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eVN0YWNrKCk7XG4gICAgfTtcblxuICAgIFN0YWNrLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChiZWdpbiwgZW5kKSB7XG4gICAgICBpZiAod2hvbGVTbGljZShiZWdpbiwgZW5kLCB0aGlzLnNpemUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIHJlc29sdmVkQmVnaW4gPSByZXNvbHZlQmVnaW4oYmVnaW4sIHRoaXMuc2l6ZSk7XG4gICAgICB2YXIgcmVzb2x2ZWRFbmQgPSByZXNvbHZlRW5kKGVuZCwgdGhpcy5zaXplKTtcbiAgICAgIGlmIChyZXNvbHZlZEVuZCAhPT0gdGhpcy5zaXplKSB7XG4gICAgICAgIC8vIHN1cGVyLnNsaWNlKGJlZ2luLCBlbmQpO1xuICAgICAgICByZXR1cm4gSW5kZXhlZENvbGxlY3Rpb24ucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcywgYmVnaW4sIGVuZCk7XG4gICAgICB9XG4gICAgICB2YXIgbmV3U2l6ZSA9IHRoaXMuc2l6ZSAtIHJlc29sdmVkQmVnaW47XG4gICAgICB2YXIgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgICB3aGlsZSAocmVzb2x2ZWRCZWdpbi0tKSB7XG4gICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgdGhpcy5zaXplID0gbmV3U2l6ZTtcbiAgICAgICAgdGhpcy5faGVhZCA9IGhlYWQ7XG4gICAgICAgIHRoaXMuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ha2VTdGFjayhuZXdTaXplLCBoZWFkKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBNdXRhYmlsaXR5XG5cbiAgICBTdGFjay5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uIF9fZW5zdXJlT3duZXIgKG93bmVySUQpIHtcbiAgICAgIGlmIChvd25lcklEID09PSB0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICghb3duZXJJRCkge1xuICAgICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGVtcHR5U3RhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ha2VTdGFjayh0aGlzLnNpemUsIHRoaXMuX2hlYWQsIG93bmVySUQsIHRoaXMuX19oYXNoKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBJdGVyYXRpb25cblxuICAgIFN0YWNrLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheVNlcSh0aGlzLnRvQXJyYXkoKSkuX19pdGVyYXRlKFxuICAgICAgICAgIGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBmbih2LCBrLCB0aGlzJDEpOyB9LFxuICAgICAgICAgIHJldmVyc2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHZhciBub2RlID0gdGhpcy5faGVhZDtcbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChmbihub2RlLnZhbHVlLCBpdGVyYXRpb25zKyssIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuXG4gICAgU3RhY2sucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5U2VxKHRoaXMudG9BcnJheSgpKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLl9oZWFkO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gU3RhY2s7XG4gIH0oSW5kZXhlZENvbGxlY3Rpb24pKTtcblxuICBTdGFjay5pc1N0YWNrID0gaXNTdGFjaztcblxuICB2YXIgU3RhY2tQcm90b3R5cGUgPSBTdGFjay5wcm90b3R5cGU7XG4gIFN0YWNrUHJvdG90eXBlW0lTX1NUQUNLX1NZTUJPTF0gPSB0cnVlO1xuICBTdGFja1Byb3RvdHlwZS5zaGlmdCA9IFN0YWNrUHJvdG90eXBlLnBvcDtcbiAgU3RhY2tQcm90b3R5cGUudW5zaGlmdCA9IFN0YWNrUHJvdG90eXBlLnB1c2g7XG4gIFN0YWNrUHJvdG90eXBlLnVuc2hpZnRBbGwgPSBTdGFja1Byb3RvdHlwZS5wdXNoQWxsO1xuICBTdGFja1Byb3RvdHlwZS53aXRoTXV0YXRpb25zID0gd2l0aE11dGF0aW9ucztcbiAgU3RhY2tQcm90b3R5cGUud2FzQWx0ZXJlZCA9IHdhc0FsdGVyZWQ7XG4gIFN0YWNrUHJvdG90eXBlLmFzSW1tdXRhYmxlID0gYXNJbW11dGFibGU7XG4gIFN0YWNrUHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gU3RhY2tQcm90b3R5cGUuYXNNdXRhYmxlID0gYXNNdXRhYmxlO1xuICBTdGFja1Byb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGFycikge1xuICAgIHJldHVybiByZXN1bHQudW5zaGlmdChhcnIpO1xuICB9O1xuICBTdGFja1Byb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmouYXNJbW11dGFibGUoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlU3RhY2soc2l6ZSwgaGVhZCwgb3duZXJJRCwgaGFzaCkge1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKFN0YWNrUHJvdG90eXBlKTtcbiAgICBtYXAuc2l6ZSA9IHNpemU7XG4gICAgbWFwLl9oZWFkID0gaGVhZDtcbiAgICBtYXAuX19vd25lcklEID0gb3duZXJJRDtcbiAgICBtYXAuX19oYXNoID0gaGFzaDtcbiAgICBtYXAuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuXG4gIHZhciBFTVBUWV9TVEFDSztcbiAgZnVuY3Rpb24gZW1wdHlTdGFjaygpIHtcbiAgICByZXR1cm4gRU1QVFlfU1RBQ0sgfHwgKEVNUFRZX1NUQUNLID0gbWFrZVN0YWNrKDApKTtcbiAgfVxuXG4gIHZhciBJU19TRVRfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfU0VUX19AQCc7XG5cbiAgZnVuY3Rpb24gaXNTZXQobWF5YmVTZXQpIHtcbiAgICByZXR1cm4gQm9vbGVhbihtYXliZVNldCAmJiBtYXliZVNldFtJU19TRVRfU1lNQk9MXSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc09yZGVyZWRTZXQobWF5YmVPcmRlcmVkU2V0KSB7XG4gICAgcmV0dXJuIGlzU2V0KG1heWJlT3JkZXJlZFNldCkgJiYgaXNPcmRlcmVkKG1heWJlT3JkZXJlZFNldCk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAhaXNDb2xsZWN0aW9uKGIpIHx8XG4gICAgICAoYS5zaXplICE9PSB1bmRlZmluZWQgJiYgYi5zaXplICE9PSB1bmRlZmluZWQgJiYgYS5zaXplICE9PSBiLnNpemUpIHx8XG4gICAgICAoYS5fX2hhc2ggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBiLl9faGFzaCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGEuX19oYXNoICE9PSBiLl9faGFzaCkgfHxcbiAgICAgIGlzS2V5ZWQoYSkgIT09IGlzS2V5ZWQoYikgfHxcbiAgICAgIGlzSW5kZXhlZChhKSAhPT0gaXNJbmRleGVkKGIpIHx8XG4gICAgICBpc09yZGVyZWQoYSkgIT09IGlzT3JkZXJlZChiKVxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChhLnNpemUgPT09IDAgJiYgYi5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgbm90QXNzb2NpYXRpdmUgPSAhaXNBc3NvY2lhdGl2ZShhKTtcblxuICAgIGlmIChpc09yZGVyZWQoYSkpIHtcbiAgICAgIHZhciBlbnRyaWVzID0gYS5lbnRyaWVzKCk7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBiLmV2ZXJ5KGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllcy5uZXh0KCkudmFsdWU7XG4gICAgICAgICAgcmV0dXJuIGVudHJ5ICYmIGlzKGVudHJ5WzFdLCB2KSAmJiAobm90QXNzb2NpYXRpdmUgfHwgaXMoZW50cnlbMF0sIGspKTtcbiAgICAgICAgfSkgJiYgZW50cmllcy5uZXh0KCkuZG9uZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgZmxpcHBlZCA9IGZhbHNlO1xuXG4gICAgaWYgKGEuc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoYi5zaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhLmNhY2hlUmVzdWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgYS5jYWNoZVJlc3VsdCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbGlwcGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIF8gPSBhO1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYiA9IF87XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFsbEVxdWFsID0gdHJ1ZTtcbiAgICB2YXIgYlNpemUgPSBiLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykge1xuICAgICAgaWYgKFxuICAgICAgICBub3RBc3NvY2lhdGl2ZVxuICAgICAgICAgID8gIWEuaGFzKHYpXG4gICAgICAgICAgOiBmbGlwcGVkXG4gICAgICAgICAgPyAhaXModiwgYS5nZXQoaywgTk9UX1NFVCkpXG4gICAgICAgICAgOiAhaXMoYS5nZXQoaywgTk9UX1NFVCksIHYpXG4gICAgICApIHtcbiAgICAgICAgYWxsRXF1YWwgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFsbEVxdWFsICYmIGEuc2l6ZSA9PT0gYlNpemU7XG4gIH1cblxuICBmdW5jdGlvbiBtaXhpbihjdG9yLCBtZXRob2RzKSB7XG4gICAgdmFyIGtleUNvcGllciA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGN0b3IucHJvdG90eXBlW2tleV0gPSBtZXRob2RzW2tleV07XG4gICAgfTtcbiAgICBPYmplY3Qua2V5cyhtZXRob2RzKS5mb3JFYWNoKGtleUNvcGllcik7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJlxuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhtZXRob2RzKS5mb3JFYWNoKGtleUNvcGllcik7XG4gICAgcmV0dXJuIGN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiB0b0pTKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICghaXNDb2xsZWN0aW9uKHZhbHVlKSkge1xuICAgICAgaWYgKCFpc0RhdGFTdHJ1Y3R1cmUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gU2VxKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGlzS2V5ZWQodmFsdWUpKSB7XG4gICAgICB2YXIgcmVzdWx0JDEgPSB7fTtcbiAgICAgIHZhbHVlLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykge1xuICAgICAgICByZXN1bHQkMVtrXSA9IHRvSlModik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQkMTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhbHVlLl9faXRlcmF0ZShmdW5jdGlvbiAodikge1xuICAgICAgcmVzdWx0LnB1c2godG9KUyh2KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBTZXQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTZXRDb2xsZWN0aW9uKSB7XG4gICAgZnVuY3Rpb24gU2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IGVtcHR5U2V0KClcbiAgICAgICAgOiBpc1NldCh2YWx1ZSkgJiYgIWlzT3JkZXJlZCh2YWx1ZSlcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IGVtcHR5U2V0KCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgICAgICB2YXIgaXRlciA9IFNldENvbGxlY3Rpb24odmFsdWUpO1xuICAgICAgICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICAgICAgICAgIGl0ZXIuZm9yRWFjaChmdW5jdGlvbiAodikgeyByZXR1cm4gc2V0LmFkZCh2KTsgfSk7XG4gICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCBTZXRDb2xsZWN0aW9uICkgU2V0Ll9fcHJvdG9fXyA9IFNldENvbGxlY3Rpb247XG4gICAgU2V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNldENvbGxlY3Rpb24gJiYgU2V0Q29sbGVjdGlvbi5wcm90b3R5cGUgKTtcbiAgICBTZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2V0O1xuXG4gICAgU2V0Lm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIFNldC5mcm9tS2V5cyA9IGZ1bmN0aW9uIGZyb21LZXlzICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMoS2V5ZWRDb2xsZWN0aW9uKHZhbHVlKS5rZXlTZXEoKSk7XG4gICAgfTtcblxuICAgIFNldC5pbnRlcnNlY3QgPSBmdW5jdGlvbiBpbnRlcnNlY3QgKHNldHMpIHtcbiAgICAgIHNldHMgPSBDb2xsZWN0aW9uKHNldHMpLnRvQXJyYXkoKTtcbiAgICAgIHJldHVybiBzZXRzLmxlbmd0aFxuICAgICAgICA/IFNldFByb3RvdHlwZS5pbnRlcnNlY3QuYXBwbHkoU2V0KHNldHMucG9wKCkpLCBzZXRzKVxuICAgICAgICA6IGVtcHR5U2V0KCk7XG4gICAgfTtcblxuICAgIFNldC51bmlvbiA9IGZ1bmN0aW9uIHVuaW9uIChzZXRzKSB7XG4gICAgICBzZXRzID0gQ29sbGVjdGlvbihzZXRzKS50b0FycmF5KCk7XG4gICAgICByZXR1cm4gc2V0cy5sZW5ndGhcbiAgICAgICAgPyBTZXRQcm90b3R5cGUudW5pb24uYXBwbHkoU2V0KHNldHMucG9wKCkpLCBzZXRzKVxuICAgICAgICA6IGVtcHR5U2V0KCk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdTZXQgeycsICd9Jyk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAuaGFzKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHVwZGF0ZVNldCh0aGlzLCB0aGlzLl9tYXAuc2V0KHZhbHVlLCB2YWx1ZSkpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAodmFsdWUpIHtcbiAgICAgIHJldHVybiB1cGRhdGVTZXQodGhpcywgdGhpcy5fbWFwLnJlbW92ZSh2YWx1ZSkpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgcmV0dXJuIHVwZGF0ZVNldCh0aGlzLCB0aGlzLl9tYXAuY2xlYXIoKSk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQ29tcG9zaXRpb25cblxuICAgIFNldC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChtYXBwZXIsIGNvbnRleHQpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB2YXIgcmVtb3ZlcyA9IFtdO1xuICAgICAgdmFyIGFkZHMgPSBbXTtcbiAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIG1hcHBlZCA9IG1hcHBlci5jYWxsKGNvbnRleHQsIHZhbHVlLCB2YWx1ZSwgdGhpcyQxKTtcbiAgICAgICAgaWYgKG1hcHBlZCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICByZW1vdmVzLnB1c2godmFsdWUpO1xuICAgICAgICAgIGFkZHMucHVzaChtYXBwZWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKHNldCkge1xuICAgICAgICByZW1vdmVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBzZXQucmVtb3ZlKHZhbHVlKTsgfSk7XG4gICAgICAgIGFkZHMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHNldC5hZGQodmFsdWUpOyB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLnVuaW9uID0gZnVuY3Rpb24gdW5pb24gKCkge1xuICAgICAgdmFyIGl0ZXJzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgaXRlcnMgPSBpdGVycy5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguc2l6ZSAhPT0gMDsgfSk7XG4gICAgICBpZiAoaXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCAmJiAhdGhpcy5fX293bmVySUQgJiYgaXRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKGl0ZXJzWzBdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKHNldCkge1xuICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgaXRlcnMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgU2V0Q29sbGVjdGlvbihpdGVyc1tpaV0pLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBzZXQuYWRkKHZhbHVlKTsgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLmludGVyc2VjdCA9IGZ1bmN0aW9uIGludGVyc2VjdCAoKSB7XG4gICAgICB2YXIgaXRlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICBpZiAoaXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaXRlcnMgPSBpdGVycy5tYXAoZnVuY3Rpb24gKGl0ZXIpIHsgcmV0dXJuIFNldENvbGxlY3Rpb24oaXRlcik7IH0pO1xuICAgICAgdmFyIHRvUmVtb3ZlID0gW107XG4gICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXRlcnMuZXZlcnkoZnVuY3Rpb24gKGl0ZXIpIHsgcmV0dXJuIGl0ZXIuaW5jbHVkZXModmFsdWUpOyB9KSkge1xuICAgICAgICAgIHRvUmVtb3ZlLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKHNldCkge1xuICAgICAgICB0b1JlbW92ZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHNldC5yZW1vdmUodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3QgKCkge1xuICAgICAgdmFyIGl0ZXJzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGl0ZXJzID0gaXRlcnMubWFwKGZ1bmN0aW9uIChpdGVyKSB7IHJldHVybiBTZXRDb2xsZWN0aW9uKGl0ZXIpOyB9KTtcbiAgICAgIHZhciB0b1JlbW92ZSA9IFtdO1xuICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoaXRlcnMuc29tZShmdW5jdGlvbiAoaXRlcikgeyByZXR1cm4gaXRlci5pbmNsdWRlcyh2YWx1ZSk7IH0pKSB7XG4gICAgICAgICAgdG9SZW1vdmUucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgIHRvUmVtb3ZlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgc2V0LnJlbW92ZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uIHNvcnQgKGNvbXBhcmF0b3IpIHtcbiAgICAgIC8vIExhdGUgYmluZGluZ1xuICAgICAgcmV0dXJuIE9yZGVyZWRTZXQoc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvcikpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLnNvcnRCeSA9IGZ1bmN0aW9uIHNvcnRCeSAobWFwcGVyLCBjb21wYXJhdG9yKSB7XG4gICAgICAvLyBMYXRlIGJpbmRpbmdcbiAgICAgIHJldHVybiBPcmRlcmVkU2V0KHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IsIG1hcHBlcikpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLndhc0FsdGVyZWQgPSBmdW5jdGlvbiB3YXNBbHRlcmVkICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAud2FzQWx0ZXJlZCgpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5fbWFwLl9faXRlcmF0ZShmdW5jdGlvbiAoaykgeyByZXR1cm4gZm4oaywgaywgdGhpcyQxKTsgfSwgcmV2ZXJzZSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24gX19lbnN1cmVPd25lciAob3duZXJJRCkge1xuICAgICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIG5ld01hcCA9IHRoaXMuX21hcC5fX2Vuc3VyZU93bmVyKG93bmVySUQpO1xuICAgICAgaWYgKCFvd25lcklEKSB7XG4gICAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fX2VtcHR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuICAgICAgICB0aGlzLl9tYXAgPSBuZXdNYXA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX19tYWtlKG5ld01hcCwgb3duZXJJRCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXQ7XG4gIH0oU2V0Q29sbGVjdGlvbikpO1xuXG4gIFNldC5pc1NldCA9IGlzU2V0O1xuXG4gIHZhciBTZXRQcm90b3R5cGUgPSBTZXQucHJvdG90eXBlO1xuICBTZXRQcm90b3R5cGVbSVNfU0VUX1NZTUJPTF0gPSB0cnVlO1xuICBTZXRQcm90b3R5cGVbREVMRVRFXSA9IFNldFByb3RvdHlwZS5yZW1vdmU7XG4gIFNldFByb3RvdHlwZS5tZXJnZSA9IFNldFByb3RvdHlwZS5jb25jYXQgPSBTZXRQcm90b3R5cGUudW5pb247XG4gIFNldFByb3RvdHlwZS53aXRoTXV0YXRpb25zID0gd2l0aE11dGF0aW9ucztcbiAgU2V0UHJvdG90eXBlLmFzSW1tdXRhYmxlID0gYXNJbW11dGFibGU7XG4gIFNldFByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IFNldFByb3RvdHlwZS5hc011dGFibGUgPSBhc011dGFibGU7XG4gIFNldFByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGFycikge1xuICAgIHJldHVybiByZXN1bHQuYWRkKGFycik7XG4gIH07XG4gIFNldFByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmouYXNJbW11dGFibGUoKTtcbiAgfTtcblxuICBTZXRQcm90b3R5cGUuX19lbXB0eSA9IGVtcHR5U2V0O1xuICBTZXRQcm90b3R5cGUuX19tYWtlID0gbWFrZVNldDtcblxuICBmdW5jdGlvbiB1cGRhdGVTZXQoc2V0LCBuZXdNYXApIHtcbiAgICBpZiAoc2V0Ll9fb3duZXJJRCkge1xuICAgICAgc2V0LnNpemUgPSBuZXdNYXAuc2l6ZTtcbiAgICAgIHNldC5fbWFwID0gbmV3TWFwO1xuICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gICAgcmV0dXJuIG5ld01hcCA9PT0gc2V0Ll9tYXBcbiAgICAgID8gc2V0XG4gICAgICA6IG5ld01hcC5zaXplID09PSAwXG4gICAgICA/IHNldC5fX2VtcHR5KClcbiAgICAgIDogc2V0Ll9fbWFrZShuZXdNYXApO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFrZVNldChtYXAsIG93bmVySUQpIHtcbiAgICB2YXIgc2V0ID0gT2JqZWN0LmNyZWF0ZShTZXRQcm90b3R5cGUpO1xuICAgIHNldC5zaXplID0gbWFwID8gbWFwLnNpemUgOiAwO1xuICAgIHNldC5fbWFwID0gbWFwO1xuICAgIHNldC5fX293bmVySUQgPSBvd25lcklEO1xuICAgIHJldHVybiBzZXQ7XG4gIH1cblxuICB2YXIgRU1QVFlfU0VUO1xuICBmdW5jdGlvbiBlbXB0eVNldCgpIHtcbiAgICByZXR1cm4gRU1QVFlfU0VUIHx8IChFTVBUWV9TRVQgPSBtYWtlU2V0KGVtcHR5TWFwKCkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGF6eSBzZXEgb2YgbnVtcyBmcm9tIHN0YXJ0IChpbmNsdXNpdmUpIHRvIGVuZFxuICAgKiAoZXhjbHVzaXZlKSwgYnkgc3RlcCwgd2hlcmUgc3RhcnQgZGVmYXVsdHMgdG8gMCwgc3RlcCB0byAxLCBhbmQgZW5kIHRvXG4gICAqIGluZmluaXR5LiBXaGVuIHN0YXJ0IGlzIGVxdWFsIHRvIGVuZCwgcmV0dXJucyBlbXB0eSBsaXN0LlxuICAgKi9cbiAgdmFyIFJhbmdlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW5kZXhlZFNlcSkge1xuICAgIGZ1bmN0aW9uIFJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSYW5nZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kLCBzdGVwKTtcbiAgICAgIH1cbiAgICAgIGludmFyaWFudChzdGVwICE9PSAwLCAnQ2Fubm90IHN0ZXAgYSBSYW5nZSBieSAwJyk7XG4gICAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5kID0gSW5maW5pdHk7XG4gICAgICB9XG4gICAgICBzdGVwID0gc3RlcCA9PT0gdW5kZWZpbmVkID8gMSA6IE1hdGguYWJzKHN0ZXApO1xuICAgICAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgIHN0ZXAgPSAtc3RlcDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0YXJ0ID0gc3RhcnQ7XG4gICAgICB0aGlzLl9lbmQgPSBlbmQ7XG4gICAgICB0aGlzLl9zdGVwID0gc3RlcDtcbiAgICAgIHRoaXMuc2l6ZSA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgoZW5kIC0gc3RhcnQpIC8gc3RlcCAtIDEpICsgMSk7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIGlmIChFTVBUWV9SQU5HRSkge1xuICAgICAgICAgIHJldHVybiBFTVBUWV9SQU5HRTtcbiAgICAgICAgfVxuICAgICAgICBFTVBUWV9SQU5HRSA9IHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCBJbmRleGVkU2VxICkgUmFuZ2UuX19wcm90b19fID0gSW5kZXhlZFNlcTtcbiAgICBSYW5nZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkU2VxICYmIEluZGV4ZWRTZXEucHJvdG90eXBlICk7XG4gICAgUmFuZ2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmFuZ2U7XG5cbiAgICBSYW5nZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnUmFuZ2UgW10nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgJ1JhbmdlIFsgJyArXG4gICAgICAgIHRoaXMuX3N0YXJ0ICtcbiAgICAgICAgJy4uLicgK1xuICAgICAgICB0aGlzLl9lbmQgK1xuICAgICAgICAodGhpcy5fc3RlcCAhPT0gMSA/ICcgYnkgJyArIHRoaXMuX3N0ZXAgOiAnJykgK1xuICAgICAgICAnIF0nXG4gICAgICApO1xuICAgIH07XG5cbiAgICBSYW5nZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhpbmRleClcbiAgICAgICAgPyB0aGlzLl9zdGFydCArIHdyYXBJbmRleCh0aGlzLCBpbmRleCkgKiB0aGlzLl9zdGVwXG4gICAgICAgIDogbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIFJhbmdlLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzIChzZWFyY2hWYWx1ZSkge1xuICAgICAgdmFyIHBvc3NpYmxlSW5kZXggPSAoc2VhcmNoVmFsdWUgLSB0aGlzLl9zdGFydCkgLyB0aGlzLl9zdGVwO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgcG9zc2libGVJbmRleCA+PSAwICYmXG4gICAgICAgIHBvc3NpYmxlSW5kZXggPCB0aGlzLnNpemUgJiZcbiAgICAgICAgcG9zc2libGVJbmRleCA9PT0gTWF0aC5mbG9vcihwb3NzaWJsZUluZGV4KVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKGJlZ2luLCBlbmQpIHtcbiAgICAgIGlmICh3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIHRoaXMuc2l6ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBiZWdpbiA9IHJlc29sdmVCZWdpbihiZWdpbiwgdGhpcy5zaXplKTtcbiAgICAgIGVuZCA9IHJlc29sdmVFbmQoZW5kLCB0aGlzLnNpemUpO1xuICAgICAgaWYgKGVuZCA8PSBiZWdpbikge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKDAsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYW5nZShcbiAgICAgICAgdGhpcy5nZXQoYmVnaW4sIHRoaXMuX2VuZCksXG4gICAgICAgIHRoaXMuZ2V0KGVuZCwgdGhpcy5fZW5kKSxcbiAgICAgICAgdGhpcy5fc3RlcFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mIChzZWFyY2hWYWx1ZSkge1xuICAgICAgdmFyIG9mZnNldFZhbHVlID0gc2VhcmNoVmFsdWUgLSB0aGlzLl9zdGFydDtcbiAgICAgIGlmIChvZmZzZXRWYWx1ZSAlIHRoaXMuX3N0ZXAgPT09IDApIHtcbiAgICAgICAgdmFyIGluZGV4ID0gb2Zmc2V0VmFsdWUgLyB0aGlzLl9zdGVwO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuc2l6ZSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbiAgICBSYW5nZS5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAoc2VhcmNoVmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmluZGV4T2Yoc2VhcmNoVmFsdWUpO1xuICAgIH07XG5cbiAgICBSYW5nZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgICB2YXIgc3RlcCA9IHRoaXMuX3N0ZXA7XG4gICAgICB2YXIgdmFsdWUgPSByZXZlcnNlID8gdGhpcy5fc3RhcnQgKyAoc2l6ZSAtIDEpICogc3RlcCA6IHRoaXMuX3N0YXJ0O1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgd2hpbGUgKGkgIT09IHNpemUpIHtcbiAgICAgICAgaWYgKGZuKHZhbHVlLCByZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgKz0gcmV2ZXJzZSA/IC1zdGVwIDogc3RlcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpO1xuICAgIH07XG5cbiAgICBSYW5nZS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBzaXplID0gdGhpcy5zaXplO1xuICAgICAgdmFyIHN0ZXAgPSB0aGlzLl9zdGVwO1xuICAgICAgdmFyIHZhbHVlID0gcmV2ZXJzZSA/IHRoaXMuX3N0YXJ0ICsgKHNpemUgLSAxKSAqIHN0ZXAgOiB0aGlzLl9zdGFydDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaSA9PT0gc2l6ZSkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdiA9IHZhbHVlO1xuICAgICAgICB2YWx1ZSArPSByZXZlcnNlID8gLXN0ZXAgOiBzdGVwO1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCByZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrKywgdik7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAob3RoZXIpIHtcbiAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFJhbmdlXG4gICAgICAgID8gdGhpcy5fc3RhcnQgPT09IG90aGVyLl9zdGFydCAmJlxuICAgICAgICAgICAgdGhpcy5fZW5kID09PSBvdGhlci5fZW5kICYmXG4gICAgICAgICAgICB0aGlzLl9zdGVwID09PSBvdGhlci5fc3RlcFxuICAgICAgICA6IGRlZXBFcXVhbCh0aGlzLCBvdGhlcik7XG4gICAgfTtcblxuICAgIHJldHVybiBSYW5nZTtcbiAgfShJbmRleGVkU2VxKSk7XG5cbiAgdmFyIEVNUFRZX1JBTkdFO1xuXG4gIGZ1bmN0aW9uIGdldEluKGNvbGxlY3Rpb24sIHNlYXJjaEtleVBhdGgsIG5vdFNldFZhbHVlKSB7XG4gICAgdmFyIGtleVBhdGggPSBjb2VyY2VLZXlQYXRoKHNlYXJjaEtleVBhdGgpO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSAhPT0ga2V5UGF0aC5sZW5ndGgpIHtcbiAgICAgIGNvbGxlY3Rpb24gPSBnZXQoY29sbGVjdGlvbiwga2V5UGF0aFtpKytdLCBOT1RfU0VUKTtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09PSBOT1RfU0VUKSB7XG4gICAgICAgIHJldHVybiBub3RTZXRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJbiQxKHNlYXJjaEtleVBhdGgsIG5vdFNldFZhbHVlKSB7XG4gICAgcmV0dXJuIGdldEluKHRoaXMsIHNlYXJjaEtleVBhdGgsIG5vdFNldFZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0luKGNvbGxlY3Rpb24sIGtleVBhdGgpIHtcbiAgICByZXR1cm4gZ2V0SW4oY29sbGVjdGlvbiwga2V5UGF0aCwgTk9UX1NFVCkgIT09IE5PVF9TRVQ7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNJbiQxKHNlYXJjaEtleVBhdGgpIHtcbiAgICByZXR1cm4gaGFzSW4odGhpcywgc2VhcmNoS2V5UGF0aCk7XG4gIH1cblxuICBmdW5jdGlvbiB0b09iamVjdCgpIHtcbiAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICB0aGlzLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykge1xuICAgICAgb2JqZWN0W2tdID0gdjtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgLy8gTm90ZTogYWxsIG9mIHRoZXNlIG1ldGhvZHMgYXJlIGRlcHJlY2F0ZWQuXG4gIENvbGxlY3Rpb24uaXNJdGVyYWJsZSA9IGlzQ29sbGVjdGlvbjtcbiAgQ29sbGVjdGlvbi5pc0tleWVkID0gaXNLZXllZDtcbiAgQ29sbGVjdGlvbi5pc0luZGV4ZWQgPSBpc0luZGV4ZWQ7XG4gIENvbGxlY3Rpb24uaXNBc3NvY2lhdGl2ZSA9IGlzQXNzb2NpYXRpdmU7XG4gIENvbGxlY3Rpb24uaXNPcmRlcmVkID0gaXNPcmRlcmVkO1xuXG4gIENvbGxlY3Rpb24uSXRlcmF0b3IgPSBJdGVyYXRvcjtcblxuICBtaXhpbihDb2xsZWN0aW9uLCB7XG4gICAgLy8gIyMjIENvbnZlcnNpb24gdG8gb3RoZXIgdHlwZXNcblxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICAgICAgdmFyIGFycmF5ID0gbmV3IEFycmF5KHRoaXMuc2l6ZSB8fCAwKTtcbiAgICAgIHZhciB1c2VUdXBsZXMgPSBpc0tleWVkKHRoaXMpO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgLy8gS2V5ZWQgY29sbGVjdGlvbnMgcHJvZHVjZSBhbiBhcnJheSBvZiB0dXBsZXMuXG4gICAgICAgIGFycmF5W2krK10gPSB1c2VUdXBsZXMgPyBbaywgdl0gOiB2O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfSxcblxuICAgIHRvSW5kZXhlZFNlcTogZnVuY3Rpb24gdG9JbmRleGVkU2VxKCkge1xuICAgICAgcmV0dXJuIG5ldyBUb0luZGV4ZWRTZXF1ZW5jZSh0aGlzKTtcbiAgICB9LFxuXG4gICAgdG9KUzogZnVuY3Rpb24gdG9KUyQxKCkge1xuICAgICAgcmV0dXJuIHRvSlModGhpcyk7XG4gICAgfSxcblxuICAgIHRvS2V5ZWRTZXE6IGZ1bmN0aW9uIHRvS2V5ZWRTZXEoKSB7XG4gICAgICByZXR1cm4gbmV3IFRvS2V5ZWRTZXF1ZW5jZSh0aGlzLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgdG9NYXA6IGZ1bmN0aW9uIHRvTWFwKCkge1xuICAgICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgICAgcmV0dXJuIE1hcCh0aGlzLnRvS2V5ZWRTZXEoKSk7XG4gICAgfSxcblxuICAgIHRvT2JqZWN0OiB0b09iamVjdCxcblxuICAgIHRvT3JkZXJlZE1hcDogZnVuY3Rpb24gdG9PcmRlcmVkTWFwKCkge1xuICAgICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgICAgcmV0dXJuIE9yZGVyZWRNYXAodGhpcy50b0tleWVkU2VxKCkpO1xuICAgIH0sXG5cbiAgICB0b09yZGVyZWRTZXQ6IGZ1bmN0aW9uIHRvT3JkZXJlZFNldCgpIHtcbiAgICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICAgIHJldHVybiBPcmRlcmVkU2V0KGlzS2V5ZWQodGhpcykgPyB0aGlzLnZhbHVlU2VxKCkgOiB0aGlzKTtcbiAgICB9LFxuXG4gICAgdG9TZXQ6IGZ1bmN0aW9uIHRvU2V0KCkge1xuICAgICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgICAgcmV0dXJuIFNldChpc0tleWVkKHRoaXMpID8gdGhpcy52YWx1ZVNlcSgpIDogdGhpcyk7XG4gICAgfSxcblxuICAgIHRvU2V0U2VxOiBmdW5jdGlvbiB0b1NldFNlcSgpIHtcbiAgICAgIHJldHVybiBuZXcgVG9TZXRTZXF1ZW5jZSh0aGlzKTtcbiAgICB9LFxuXG4gICAgdG9TZXE6IGZ1bmN0aW9uIHRvU2VxKCkge1xuICAgICAgcmV0dXJuIGlzSW5kZXhlZCh0aGlzKVxuICAgICAgICA/IHRoaXMudG9JbmRleGVkU2VxKClcbiAgICAgICAgOiBpc0tleWVkKHRoaXMpXG4gICAgICAgID8gdGhpcy50b0tleWVkU2VxKClcbiAgICAgICAgOiB0aGlzLnRvU2V0U2VxKCk7XG4gICAgfSxcblxuICAgIHRvU3RhY2s6IGZ1bmN0aW9uIHRvU3RhY2soKSB7XG4gICAgICAvLyBVc2UgTGF0ZSBCaW5kaW5nIGhlcmUgdG8gc29sdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgICByZXR1cm4gU3RhY2soaXNLZXllZCh0aGlzKSA/IHRoaXMudmFsdWVTZXEoKSA6IHRoaXMpO1xuICAgIH0sXG5cbiAgICB0b0xpc3Q6IGZ1bmN0aW9uIHRvTGlzdCgpIHtcbiAgICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICAgIHJldHVybiBMaXN0KGlzS2V5ZWQodGhpcykgPyB0aGlzLnZhbHVlU2VxKCkgOiB0aGlzKTtcbiAgICB9LFxuXG4gICAgLy8gIyMjIENvbW1vbiBKYXZhU2NyaXB0IG1ldGhvZHMgYW5kIHByb3BlcnRpZXNcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAnW0NvbGxlY3Rpb25dJztcbiAgICB9LFxuXG4gICAgX190b1N0cmluZzogZnVuY3Rpb24gX190b1N0cmluZyhoZWFkLCB0YWlsKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoXG4gICAgICAgIGhlYWQgK1xuICAgICAgICAnICcgK1xuICAgICAgICB0aGlzLnRvU2VxKCkubWFwKHRoaXMuX190b1N0cmluZ01hcHBlcikuam9pbignLCAnKSArXG4gICAgICAgICcgJyArXG4gICAgICAgIHRhaWxcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8vICMjIyBFUzYgQ29sbGVjdGlvbiBtZXRob2RzIChFUzYgQXJyYXkgYW5kIE1hcClcblxuICAgIGNvbmNhdDogZnVuY3Rpb24gY29uY2F0KCkge1xuICAgICAgdmFyIHZhbHVlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIHZhbHVlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgY29uY2F0RmFjdG9yeSh0aGlzLCB2YWx1ZXMpKTtcbiAgICB9LFxuXG4gICAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb21lKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gaXModmFsdWUsIHNlYXJjaFZhbHVlKTsgfSk7XG4gICAgfSxcblxuICAgIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUyk7XG4gICAgfSxcblxuICAgIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMuc2l6ZSk7XG4gICAgICB2YXIgcmV0dXJuVmFsdWUgPSB0cnVlO1xuICAgICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGssIGMpIHtcbiAgICAgICAgaWYgKCFwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCBjKSkge1xuICAgICAgICAgIHJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9LFxuXG4gICAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgZmlsdGVyRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQsIHRydWUpKTtcbiAgICB9LFxuXG4gICAgZmluZDogZnVuY3Rpb24gZmluZChwcmVkaWNhdGUsIGNvbnRleHQsIG5vdFNldFZhbHVlKSB7XG4gICAgICB2YXIgZW50cnkgPSB0aGlzLmZpbmRFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgcmV0dXJuIGVudHJ5ID8gZW50cnlbMV0gOiBub3RTZXRWYWx1ZTtcbiAgICB9LFxuXG4gICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChzaWRlRWZmZWN0LCBjb250ZXh0KSB7XG4gICAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICAgICAgcmV0dXJuIHRoaXMuX19pdGVyYXRlKGNvbnRleHQgPyBzaWRlRWZmZWN0LmJpbmQoY29udGV4dCkgOiBzaWRlRWZmZWN0KTtcbiAgICB9LFxuXG4gICAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHtcbiAgICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMuc2l6ZSk7XG4gICAgICBzZXBhcmF0b3IgPSBzZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/ICcnICsgc2VwYXJhdG9yIDogJywnO1xuICAgICAgdmFyIGpvaW5lZCA9ICcnO1xuICAgICAgdmFyIGlzRmlyc3QgPSB0cnVlO1xuICAgICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaXNGaXJzdCA/IChpc0ZpcnN0ID0gZmFsc2UpIDogKGpvaW5lZCArPSBzZXBhcmF0b3IpO1xuICAgICAgICBqb2luZWQgKz0gdiAhPT0gbnVsbCAmJiB2ICE9PSB1bmRlZmluZWQgPyB2LnRvU3RyaW5nKCkgOiAnJztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGpvaW5lZDtcbiAgICB9LFxuXG4gICAga2V5czogZnVuY3Rpb24ga2V5cygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9faXRlcmF0b3IoSVRFUkFURV9LRVlTKTtcbiAgICB9LFxuXG4gICAgbWFwOiBmdW5jdGlvbiBtYXAobWFwcGVyLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgbWFwRmFjdG9yeSh0aGlzLCBtYXBwZXIsIGNvbnRleHQpKTtcbiAgICB9LFxuXG4gICAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UkMShyZWR1Y2VyLCBpbml0aWFsUmVkdWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVkdWNlKFxuICAgICAgICB0aGlzLFxuICAgICAgICByZWR1Y2VyLFxuICAgICAgICBpbml0aWFsUmVkdWN0aW9uLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoIDwgMixcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgfSxcblxuICAgIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChyZWR1Y2VyLCBpbml0aWFsUmVkdWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVkdWNlKFxuICAgICAgICB0aGlzLFxuICAgICAgICByZWR1Y2VyLFxuICAgICAgICBpbml0aWFsUmVkdWN0aW9uLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoIDwgMixcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCByZXZlcnNlRmFjdG9yeSh0aGlzLCB0cnVlKSk7XG4gICAgfSxcblxuICAgIHNsaWNlOiBmdW5jdGlvbiBzbGljZShiZWdpbiwgZW5kKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgc2xpY2VGYWN0b3J5KHRoaXMsIGJlZ2luLCBlbmQsIHRydWUpKTtcbiAgICB9LFxuXG4gICAgc29tZTogZnVuY3Rpb24gc29tZShwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiAhdGhpcy5ldmVyeShub3QocHJlZGljYXRlKSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IpKTtcbiAgICB9LFxuXG4gICAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTKTtcbiAgICB9LFxuXG4gICAgLy8gIyMjIE1vcmUgc2VxdWVudGlhbCBtZXRob2RzXG5cbiAgICBidXRMYXN0OiBmdW5jdGlvbiBidXRMYXN0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoMCwgLTEpO1xuICAgIH0sXG5cbiAgICBpc0VtcHR5OiBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2l6ZSAhPT0gdW5kZWZpbmVkID8gdGhpcy5zaXplID09PSAwIDogIXRoaXMuc29tZShmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9KTtcbiAgICB9LFxuXG4gICAgY291bnQ6IGZ1bmN0aW9uIGNvdW50KHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIGVuc3VyZVNpemUoXG4gICAgICAgIHByZWRpY2F0ZSA/IHRoaXMudG9TZXEoKS5maWx0ZXIocHJlZGljYXRlLCBjb250ZXh0KSA6IHRoaXNcbiAgICAgICk7XG4gICAgfSxcblxuICAgIGNvdW50Qnk6IGZ1bmN0aW9uIGNvdW50QnkoZ3JvdXBlciwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIGNvdW50QnlGYWN0b3J5KHRoaXMsIGdyb3VwZXIsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgICAgcmV0dXJuIGRlZXBFcXVhbCh0aGlzLCBvdGhlcik7XG4gICAgfSxcblxuICAgIGVudHJ5U2VxOiBmdW5jdGlvbiBlbnRyeVNlcSgpIHtcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcztcbiAgICAgIGlmIChjb2xsZWN0aW9uLl9jYWNoZSkge1xuICAgICAgICAvLyBXZSBjYWNoZSBhcyBhbiBlbnRyaWVzIGFycmF5LCBzbyB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGNhY2hlIVxuICAgICAgICByZXR1cm4gbmV3IEFycmF5U2VxKGNvbGxlY3Rpb24uX2NhY2hlKTtcbiAgICAgIH1cbiAgICAgIHZhciBlbnRyaWVzU2VxdWVuY2UgPSBjb2xsZWN0aW9uLnRvU2VxKCkubWFwKGVudHJ5TWFwcGVyKS50b0luZGV4ZWRTZXEoKTtcbiAgICAgIGVudHJpZXNTZXF1ZW5jZS5mcm9tRW50cnlTZXEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2xsZWN0aW9uLnRvU2VxKCk7IH07XG4gICAgICByZXR1cm4gZW50cmllc1NlcXVlbmNlO1xuICAgIH0sXG5cbiAgICBmaWx0ZXJOb3Q6IGZ1bmN0aW9uIGZpbHRlck5vdChwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihub3QocHJlZGljYXRlKSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIGZpbmRFbnRyeTogZnVuY3Rpb24gZmluZEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHZhciBmb3VuZCA9IG5vdFNldFZhbHVlO1xuICAgICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGssIGMpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIGMpKSB7XG4gICAgICAgICAgZm91bmQgPSBbaywgdl07XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9LFxuXG4gICAgZmluZEtleTogZnVuY3Rpb24gZmluZEtleShwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBlbnRyeSA9IHRoaXMuZmluZEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgICByZXR1cm4gZW50cnkgJiYgZW50cnlbMF07XG4gICAgfSxcblxuICAgIGZpbmRMYXN0OiBmdW5jdGlvbiBmaW5kTGFzdChwcmVkaWNhdGUsIGNvbnRleHQsIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0tleWVkU2VxKCkucmV2ZXJzZSgpLmZpbmQocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSk7XG4gICAgfSxcblxuICAgIGZpbmRMYXN0RW50cnk6IGZ1bmN0aW9uIGZpbmRMYXN0RW50cnkocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9LZXllZFNlcSgpXG4gICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgLmZpbmRFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQsIG5vdFNldFZhbHVlKTtcbiAgICB9LFxuXG4gICAgZmluZExhc3RLZXk6IGZ1bmN0aW9uIGZpbmRMYXN0S2V5KHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9LZXllZFNlcSgpLnJldmVyc2UoKS5maW5kS2V5KHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIGZpcnN0OiBmdW5jdGlvbiBmaXJzdChub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZChyZXR1cm5UcnVlLCBudWxsLCBub3RTZXRWYWx1ZSk7XG4gICAgfSxcblxuICAgIGZsYXRNYXA6IGZ1bmN0aW9uIGZsYXRNYXAobWFwcGVyLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgZmxhdE1hcEZhY3RvcnkodGhpcywgbWFwcGVyLCBjb250ZXh0KSk7XG4gICAgfSxcblxuICAgIGZsYXR0ZW46IGZ1bmN0aW9uIGZsYXR0ZW4oZGVwdGgpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBmbGF0dGVuRmFjdG9yeSh0aGlzLCBkZXB0aCwgdHJ1ZSkpO1xuICAgIH0sXG5cbiAgICBmcm9tRW50cnlTZXE6IGZ1bmN0aW9uIGZyb21FbnRyeVNlcSgpIHtcbiAgICAgIHJldHVybiBuZXcgRnJvbUVudHJpZXNTZXF1ZW5jZSh0aGlzKTtcbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoc2VhcmNoS2V5LCBub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZChmdW5jdGlvbiAoXywga2V5KSB7IHJldHVybiBpcyhrZXksIHNlYXJjaEtleSk7IH0sIHVuZGVmaW5lZCwgbm90U2V0VmFsdWUpO1xuICAgIH0sXG5cbiAgICBnZXRJbjogZ2V0SW4kMSxcblxuICAgIGdyb3VwQnk6IGZ1bmN0aW9uIGdyb3VwQnkoZ3JvdXBlciwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIGdyb3VwQnlGYWN0b3J5KHRoaXMsIGdyb3VwZXIsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyhzZWFyY2hLZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldChzZWFyY2hLZXksIE5PVF9TRVQpICE9PSBOT1RfU0VUO1xuICAgIH0sXG5cbiAgICBoYXNJbjogaGFzSW4kMSxcblxuICAgIGlzU3Vic2V0OiBmdW5jdGlvbiBpc1N1YnNldChpdGVyKSB7XG4gICAgICBpdGVyID0gdHlwZW9mIGl0ZXIuaW5jbHVkZXMgPT09ICdmdW5jdGlvbicgPyBpdGVyIDogQ29sbGVjdGlvbihpdGVyKTtcbiAgICAgIHJldHVybiB0aGlzLmV2ZXJ5KGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gaXRlci5pbmNsdWRlcyh2YWx1ZSk7IH0pO1xuICAgIH0sXG5cbiAgICBpc1N1cGVyc2V0OiBmdW5jdGlvbiBpc1N1cGVyc2V0KGl0ZXIpIHtcbiAgICAgIGl0ZXIgPSB0eXBlb2YgaXRlci5pc1N1YnNldCA9PT0gJ2Z1bmN0aW9uJyA/IGl0ZXIgOiBDb2xsZWN0aW9uKGl0ZXIpO1xuICAgICAgcmV0dXJuIGl0ZXIuaXNTdWJzZXQodGhpcyk7XG4gICAgfSxcblxuICAgIGtleU9mOiBmdW5jdGlvbiBrZXlPZihzZWFyY2hWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZEtleShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGlzKHZhbHVlLCBzZWFyY2hWYWx1ZSk7IH0pO1xuICAgIH0sXG5cbiAgICBrZXlTZXE6IGZ1bmN0aW9uIGtleVNlcSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvU2VxKCkubWFwKGtleU1hcHBlcikudG9JbmRleGVkU2VxKCk7XG4gICAgfSxcblxuICAgIGxhc3Q6IGZ1bmN0aW9uIGxhc3Qobm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvU2VxKCkucmV2ZXJzZSgpLmZpcnN0KG5vdFNldFZhbHVlKTtcbiAgICB9LFxuXG4gICAgbGFzdEtleU9mOiBmdW5jdGlvbiBsYXN0S2V5T2Yoc2VhcmNoVmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvS2V5ZWRTZXEoKS5yZXZlcnNlKCkua2V5T2Yoc2VhcmNoVmFsdWUpO1xuICAgIH0sXG5cbiAgICBtYXg6IGZ1bmN0aW9uIG1heChjb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gbWF4RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yKTtcbiAgICB9LFxuXG4gICAgbWF4Qnk6IGZ1bmN0aW9uIG1heEJ5KG1hcHBlciwgY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIG1heEZhY3RvcnkodGhpcywgY29tcGFyYXRvciwgbWFwcGVyKTtcbiAgICB9LFxuXG4gICAgbWluOiBmdW5jdGlvbiBtaW4oY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIG1heEZhY3RvcnkoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIGNvbXBhcmF0b3IgPyBuZWcoY29tcGFyYXRvcikgOiBkZWZhdWx0TmVnQ29tcGFyYXRvclxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgbWluQnk6IGZ1bmN0aW9uIG1pbkJ5KG1hcHBlciwgY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIG1heEZhY3RvcnkoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIGNvbXBhcmF0b3IgPyBuZWcoY29tcGFyYXRvcikgOiBkZWZhdWx0TmVnQ29tcGFyYXRvcixcbiAgICAgICAgbWFwcGVyXG4gICAgICApO1xuICAgIH0sXG5cbiAgICByZXN0OiBmdW5jdGlvbiByZXN0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoMSk7XG4gICAgfSxcblxuICAgIHNraXA6IGZ1bmN0aW9uIHNraXAoYW1vdW50KSB7XG4gICAgICByZXR1cm4gYW1vdW50ID09PSAwID8gdGhpcyA6IHRoaXMuc2xpY2UoTWF0aC5tYXgoMCwgYW1vdW50KSk7XG4gICAgfSxcblxuICAgIHNraXBMYXN0OiBmdW5jdGlvbiBza2lwTGFzdChhbW91bnQpIHtcbiAgICAgIHJldHVybiBhbW91bnQgPT09IDAgPyB0aGlzIDogdGhpcy5zbGljZSgwLCAtTWF0aC5tYXgoMCwgYW1vdW50KSk7XG4gICAgfSxcblxuICAgIHNraXBXaGlsZTogZnVuY3Rpb24gc2tpcFdoaWxlKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHNraXBXaGlsZUZhY3RvcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0LCB0cnVlKSk7XG4gICAgfSxcblxuICAgIHNraXBVbnRpbDogZnVuY3Rpb24gc2tpcFVudGlsKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2tpcFdoaWxlKG5vdChwcmVkaWNhdGUpLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgc29ydEJ5OiBmdW5jdGlvbiBzb3J0QnkobWFwcGVyLCBjb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvciwgbWFwcGVyKSk7XG4gICAgfSxcblxuICAgIHRha2U6IGZ1bmN0aW9uIHRha2UoYW1vdW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5zbGljZSgwLCBNYXRoLm1heCgwLCBhbW91bnQpKTtcbiAgICB9LFxuXG4gICAgdGFrZUxhc3Q6IGZ1bmN0aW9uIHRha2VMYXN0KGFtb3VudCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoLU1hdGgubWF4KDAsIGFtb3VudCkpO1xuICAgIH0sXG5cbiAgICB0YWtlV2hpbGU6IGZ1bmN0aW9uIHRha2VXaGlsZShwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCB0YWtlV2hpbGVGYWN0b3J5KHRoaXMsIHByZWRpY2F0ZSwgY29udGV4dCkpO1xuICAgIH0sXG5cbiAgICB0YWtlVW50aWw6IGZ1bmN0aW9uIHRha2VVbnRpbChwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRha2VXaGlsZShub3QocHJlZGljYXRlKSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGZuKSB7XG4gICAgICByZXR1cm4gZm4odGhpcyk7XG4gICAgfSxcblxuICAgIHZhbHVlU2VxOiBmdW5jdGlvbiB2YWx1ZVNlcSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvSW5kZXhlZFNlcSgpO1xuICAgIH0sXG5cbiAgICAvLyAjIyMgSGFzaGFibGUgT2JqZWN0XG5cbiAgICBoYXNoQ29kZTogZnVuY3Rpb24gaGFzaENvZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2hhc2ggfHwgKHRoaXMuX19oYXNoID0gaGFzaENvbGxlY3Rpb24odGhpcykpO1xuICAgIH0sXG5cbiAgICAvLyAjIyMgSW50ZXJuYWxcblxuICAgIC8vIGFic3RyYWN0IF9faXRlcmF0ZShmbiwgcmV2ZXJzZSlcblxuICAgIC8vIGFic3RyYWN0IF9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSlcbiAgfSk7XG5cbiAgdmFyIENvbGxlY3Rpb25Qcm90b3R5cGUgPSBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgQ29sbGVjdGlvblByb3RvdHlwZVtJU19DT0xMRUNUSU9OX1NZTUJPTF0gPSB0cnVlO1xuICBDb2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SX1NZTUJPTF0gPSBDb2xsZWN0aW9uUHJvdG90eXBlLnZhbHVlcztcbiAgQ29sbGVjdGlvblByb3RvdHlwZS50b0pTT04gPSBDb2xsZWN0aW9uUHJvdG90eXBlLnRvQXJyYXk7XG4gIENvbGxlY3Rpb25Qcm90b3R5cGUuX190b1N0cmluZ01hcHBlciA9IHF1b3RlU3RyaW5nO1xuICBDb2xsZWN0aW9uUHJvdG90eXBlLmluc3BlY3QgPSBDb2xsZWN0aW9uUHJvdG90eXBlLnRvU291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG4gIENvbGxlY3Rpb25Qcm90b3R5cGUuY2hhaW4gPSBDb2xsZWN0aW9uUHJvdG90eXBlLmZsYXRNYXA7XG4gIENvbGxlY3Rpb25Qcm90b3R5cGUuY29udGFpbnMgPSBDb2xsZWN0aW9uUHJvdG90eXBlLmluY2x1ZGVzO1xuXG4gIG1peGluKEtleWVkQ29sbGVjdGlvbiwge1xuICAgIC8vICMjIyBNb3JlIHNlcXVlbnRpYWwgbWV0aG9kc1xuXG4gICAgZmxpcDogZnVuY3Rpb24gZmxpcCgpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBmbGlwRmFjdG9yeSh0aGlzKSk7XG4gICAgfSxcblxuICAgIG1hcEVudHJpZXM6IGZ1bmN0aW9uIG1hcEVudHJpZXMobWFwcGVyLCBjb250ZXh0KSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgcmV0dXJuIHJlaWZ5KFxuICAgICAgICB0aGlzLFxuICAgICAgICB0aGlzLnRvU2VxKClcbiAgICAgICAgICAubWFwKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBtYXBwZXIuY2FsbChjb250ZXh0LCBbaywgdl0sIGl0ZXJhdGlvbnMrKywgdGhpcyQxKTsgfSlcbiAgICAgICAgICAuZnJvbUVudHJ5U2VxKClcbiAgICAgICk7XG4gICAgfSxcblxuICAgIG1hcEtleXM6IGZ1bmN0aW9uIG1hcEtleXMobWFwcGVyLCBjb250ZXh0KSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgcmV0dXJuIHJlaWZ5KFxuICAgICAgICB0aGlzLFxuICAgICAgICB0aGlzLnRvU2VxKClcbiAgICAgICAgICAuZmxpcCgpXG4gICAgICAgICAgLm1hcChmdW5jdGlvbiAoaywgdikgeyByZXR1cm4gbWFwcGVyLmNhbGwoY29udGV4dCwgaywgdiwgdGhpcyQxKTsgfSlcbiAgICAgICAgICAuZmxpcCgpXG4gICAgICApO1xuICAgIH0sXG4gIH0pO1xuXG4gIHZhciBLZXllZENvbGxlY3Rpb25Qcm90b3R5cGUgPSBLZXllZENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICBLZXllZENvbGxlY3Rpb25Qcm90b3R5cGVbSVNfS0VZRURfU1lNQk9MXSA9IHRydWU7XG4gIEtleWVkQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUl9TWU1CT0xdID0gQ29sbGVjdGlvblByb3RvdHlwZS5lbnRyaWVzO1xuICBLZXllZENvbGxlY3Rpb25Qcm90b3R5cGUudG9KU09OID0gdG9PYmplY3Q7XG4gIEtleWVkQ29sbGVjdGlvblByb3RvdHlwZS5fX3RvU3RyaW5nTWFwcGVyID0gZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIHF1b3RlU3RyaW5nKGspICsgJzogJyArIHF1b3RlU3RyaW5nKHYpOyB9O1xuXG4gIG1peGluKEluZGV4ZWRDb2xsZWN0aW9uLCB7XG4gICAgLy8gIyMjIENvbnZlcnNpb24gdG8gb3RoZXIgdHlwZXNcblxuICAgIHRvS2V5ZWRTZXE6IGZ1bmN0aW9uIHRvS2V5ZWRTZXEoKSB7XG4gICAgICByZXR1cm4gbmV3IFRvS2V5ZWRTZXF1ZW5jZSh0aGlzLCBmYWxzZSk7XG4gICAgfSxcblxuICAgIC8vICMjIyBFUzYgQ29sbGVjdGlvbiBtZXRob2RzIChFUzYgQXJyYXkgYW5kIE1hcClcblxuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGZpbHRlckZhY3RvcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0LCBmYWxzZSkpO1xuICAgIH0sXG5cbiAgICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBlbnRyeSA9IHRoaXMuZmluZEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgICByZXR1cm4gZW50cnkgPyBlbnRyeVswXSA6IC0xO1xuICAgIH0sXG5cbiAgICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaFZhbHVlKSB7XG4gICAgICB2YXIga2V5ID0gdGhpcy5rZXlPZihzZWFyY2hWYWx1ZSk7XG4gICAgICByZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgPyAtMSA6IGtleTtcbiAgICB9LFxuXG4gICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaFZhbHVlKSB7XG4gICAgICB2YXIga2V5ID0gdGhpcy5sYXN0S2V5T2Yoc2VhcmNoVmFsdWUpO1xuICAgICAgcmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID8gLTEgOiBrZXk7XG4gICAgfSxcblxuICAgIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgcmV2ZXJzZUZhY3RvcnkodGhpcywgZmFsc2UpKTtcbiAgICB9LFxuXG4gICAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKGJlZ2luLCBlbmQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBzbGljZUZhY3RvcnkodGhpcywgYmVnaW4sIGVuZCwgZmFsc2UpKTtcbiAgICB9LFxuXG4gICAgc3BsaWNlOiBmdW5jdGlvbiBzcGxpY2UoaW5kZXgsIHJlbW92ZU51bSAvKiwgLi4udmFsdWVzKi8pIHtcbiAgICAgIHZhciBudW1BcmdzID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHJlbW92ZU51bSA9IE1hdGgubWF4KHJlbW92ZU51bSB8fCAwLCAwKTtcbiAgICAgIGlmIChudW1BcmdzID09PSAwIHx8IChudW1BcmdzID09PSAyICYmICFyZW1vdmVOdW0pKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgLy8gSWYgaW5kZXggaXMgbmVnYXRpdmUsIGl0IHNob3VsZCByZXNvbHZlIHJlbGF0aXZlIHRvIHRoZSBzaXplIG9mIHRoZVxuICAgICAgLy8gY29sbGVjdGlvbi4gSG93ZXZlciBzaXplIG1heSBiZSBleHBlbnNpdmUgdG8gY29tcHV0ZSBpZiBub3QgY2FjaGVkLCBzb1xuICAgICAgLy8gb25seSBjYWxsIGNvdW50KCkgaWYgdGhlIG51bWJlciBpcyBpbiBmYWN0IG5lZ2F0aXZlLlxuICAgICAgaW5kZXggPSByZXNvbHZlQmVnaW4oaW5kZXgsIGluZGV4IDwgMCA/IHRoaXMuY291bnQoKSA6IHRoaXMuc2l6ZSk7XG4gICAgICB2YXIgc3BsaWNlZCA9IHRoaXMuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgcmV0dXJuIHJlaWZ5KFxuICAgICAgICB0aGlzLFxuICAgICAgICBudW1BcmdzID09PSAxXG4gICAgICAgICAgPyBzcGxpY2VkXG4gICAgICAgICAgOiBzcGxpY2VkLmNvbmNhdChhcnJDb3B5KGFyZ3VtZW50cywgMiksIHRoaXMuc2xpY2UoaW5kZXggKyByZW1vdmVOdW0pKVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLy8gIyMjIE1vcmUgY29sbGVjdGlvbiBtZXRob2RzXG5cbiAgICBmaW5kTGFzdEluZGV4OiBmdW5jdGlvbiBmaW5kTGFzdEluZGV4KHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgdmFyIGVudHJ5ID0gdGhpcy5maW5kTGFzdEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgICByZXR1cm4gZW50cnkgPyBlbnRyeVswXSA6IC0xO1xuICAgIH0sXG5cbiAgICBmaXJzdDogZnVuY3Rpb24gZmlyc3Qobm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgwLCBub3RTZXRWYWx1ZSk7XG4gICAgfSxcblxuICAgIGZsYXR0ZW46IGZ1bmN0aW9uIGZsYXR0ZW4oZGVwdGgpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBmbGF0dGVuRmFjdG9yeSh0aGlzLCBkZXB0aCwgZmFsc2UpKTtcbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgICBpbmRleCA9IHdyYXBJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgICByZXR1cm4gaW5kZXggPCAwIHx8XG4gICAgICAgIHRoaXMuc2l6ZSA9PT0gSW5maW5pdHkgfHxcbiAgICAgICAgKHRoaXMuc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGluZGV4ID4gdGhpcy5zaXplKVxuICAgICAgICA/IG5vdFNldFZhbHVlXG4gICAgICAgIDogdGhpcy5maW5kKGZ1bmN0aW9uIChfLCBrZXkpIHsgcmV0dXJuIGtleSA9PT0gaW5kZXg7IH0sIHVuZGVmaW5lZCwgbm90U2V0VmFsdWUpO1xuICAgIH0sXG5cbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyhpbmRleCkge1xuICAgICAgaW5kZXggPSB3cmFwSW5kZXgodGhpcywgaW5kZXgpO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgaW5kZXggPj0gMCAmJlxuICAgICAgICAodGhpcy5zaXplICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IHRoaXMuc2l6ZSA9PT0gSW5maW5pdHkgfHwgaW5kZXggPCB0aGlzLnNpemVcbiAgICAgICAgICA6IHRoaXMuaW5kZXhPZihpbmRleCkgIT09IC0xKVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgaW50ZXJwb3NlOiBmdW5jdGlvbiBpbnRlcnBvc2Uoc2VwYXJhdG9yKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgaW50ZXJwb3NlRmFjdG9yeSh0aGlzLCBzZXBhcmF0b3IpKTtcbiAgICB9LFxuXG4gICAgaW50ZXJsZWF2ZTogZnVuY3Rpb24gaW50ZXJsZWF2ZSgvKi4uLmNvbGxlY3Rpb25zKi8pIHtcbiAgICAgIHZhciBjb2xsZWN0aW9ucyA9IFt0aGlzXS5jb25jYXQoYXJyQ29weShhcmd1bWVudHMpKTtcbiAgICAgIHZhciB6aXBwZWQgPSB6aXBXaXRoRmFjdG9yeSh0aGlzLnRvU2VxKCksIEluZGV4ZWRTZXEub2YsIGNvbGxlY3Rpb25zKTtcbiAgICAgIHZhciBpbnRlcmxlYXZlZCA9IHppcHBlZC5mbGF0dGVuKHRydWUpO1xuICAgICAgaWYgKHppcHBlZC5zaXplKSB7XG4gICAgICAgIGludGVybGVhdmVkLnNpemUgPSB6aXBwZWQuc2l6ZSAqIGNvbGxlY3Rpb25zLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBpbnRlcmxlYXZlZCk7XG4gICAgfSxcblxuICAgIGtleVNlcTogZnVuY3Rpb24ga2V5U2VxKCkge1xuICAgICAgcmV0dXJuIFJhbmdlKDAsIHRoaXMuc2l6ZSk7XG4gICAgfSxcblxuICAgIGxhc3Q6IGZ1bmN0aW9uIGxhc3Qobm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgtMSwgbm90U2V0VmFsdWUpO1xuICAgIH0sXG5cbiAgICBza2lwV2hpbGU6IGZ1bmN0aW9uIHNraXBXaGlsZShwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBza2lwV2hpbGVGYWN0b3J5KHRoaXMsIHByZWRpY2F0ZSwgY29udGV4dCwgZmFsc2UpKTtcbiAgICB9LFxuXG4gICAgemlwOiBmdW5jdGlvbiB6aXAoLyosIC4uLmNvbGxlY3Rpb25zICovKSB7XG4gICAgICB2YXIgY29sbGVjdGlvbnMgPSBbdGhpc10uY29uY2F0KGFyckNvcHkoYXJndW1lbnRzKSk7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgemlwV2l0aEZhY3RvcnkodGhpcywgZGVmYXVsdFppcHBlciwgY29sbGVjdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgemlwQWxsOiBmdW5jdGlvbiB6aXBBbGwoLyosIC4uLmNvbGxlY3Rpb25zICovKSB7XG4gICAgICB2YXIgY29sbGVjdGlvbnMgPSBbdGhpc10uY29uY2F0KGFyckNvcHkoYXJndW1lbnRzKSk7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgemlwV2l0aEZhY3RvcnkodGhpcywgZGVmYXVsdFppcHBlciwgY29sbGVjdGlvbnMsIHRydWUpKTtcbiAgICB9LFxuXG4gICAgemlwV2l0aDogZnVuY3Rpb24gemlwV2l0aCh6aXBwZXIgLyosIC4uLmNvbGxlY3Rpb25zICovKSB7XG4gICAgICB2YXIgY29sbGVjdGlvbnMgPSBhcnJDb3B5KGFyZ3VtZW50cyk7XG4gICAgICBjb2xsZWN0aW9uc1swXSA9IHRoaXM7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgemlwV2l0aEZhY3RvcnkodGhpcywgemlwcGVyLCBjb2xsZWN0aW9ucykpO1xuICAgIH0sXG4gIH0pO1xuXG4gIHZhciBJbmRleGVkQ29sbGVjdGlvblByb3RvdHlwZSA9IEluZGV4ZWRDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgSW5kZXhlZENvbGxlY3Rpb25Qcm90b3R5cGVbSVNfSU5ERVhFRF9TWU1CT0xdID0gdHJ1ZTtcbiAgSW5kZXhlZENvbGxlY3Rpb25Qcm90b3R5cGVbSVNfT1JERVJFRF9TWU1CT0xdID0gdHJ1ZTtcblxuICBtaXhpbihTZXRDb2xsZWN0aW9uLCB7XG4gICAgLy8gIyMjIEVTNiBDb2xsZWN0aW9uIG1ldGhvZHMgKEVTNiBBcnJheSBhbmQgTWFwKVxuXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQodmFsdWUsIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXModmFsdWUpID8gdmFsdWUgOiBub3RTZXRWYWx1ZTtcbiAgICB9LFxuXG4gICAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXModmFsdWUpO1xuICAgIH0sXG5cbiAgICAvLyAjIyMgTW9yZSBzZXF1ZW50aWFsIG1ldGhvZHNcblxuICAgIGtleVNlcTogZnVuY3Rpb24ga2V5U2VxKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVTZXEoKTtcbiAgICB9LFxuICB9KTtcblxuICBTZXRDb2xsZWN0aW9uLnByb3RvdHlwZS5oYXMgPSBDb2xsZWN0aW9uUHJvdG90eXBlLmluY2x1ZGVzO1xuICBTZXRDb2xsZWN0aW9uLnByb3RvdHlwZS5jb250YWlucyA9IFNldENvbGxlY3Rpb24ucHJvdG90eXBlLmluY2x1ZGVzO1xuXG4gIC8vIE1peGluIHN1YmNsYXNzZXNcblxuICBtaXhpbihLZXllZFNlcSwgS2V5ZWRDb2xsZWN0aW9uLnByb3RvdHlwZSk7XG4gIG1peGluKEluZGV4ZWRTZXEsIEluZGV4ZWRDb2xsZWN0aW9uLnByb3RvdHlwZSk7XG4gIG1peGluKFNldFNlcSwgU2V0Q29sbGVjdGlvbi5wcm90b3R5cGUpO1xuXG4gIC8vICNwcmFnbWEgSGVscGVyIGZ1bmN0aW9uc1xuXG4gIGZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCByZWR1Y2VyLCByZWR1Y3Rpb24sIGNvbnRleHQsIHVzZUZpcnN0LCByZXZlcnNlKSB7XG4gICAgYXNzZXJ0Tm90SW5maW5pdGUoY29sbGVjdGlvbi5zaXplKTtcbiAgICBjb2xsZWN0aW9uLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaywgYykge1xuICAgICAgaWYgKHVzZUZpcnN0KSB7XG4gICAgICAgIHVzZUZpcnN0ID0gZmFsc2U7XG4gICAgICAgIHJlZHVjdGlvbiA9IHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWR1Y3Rpb24gPSByZWR1Y2VyLmNhbGwoY29udGV4dCwgcmVkdWN0aW9uLCB2LCBrLCBjKTtcbiAgICAgIH1cbiAgICB9LCByZXZlcnNlKTtcbiAgICByZXR1cm4gcmVkdWN0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24ga2V5TWFwcGVyKHYsIGspIHtcbiAgICByZXR1cm4gaztcbiAgfVxuXG4gIGZ1bmN0aW9uIGVudHJ5TWFwcGVyKHYsIGspIHtcbiAgICByZXR1cm4gW2ssIHZdO1xuICB9XG5cbiAgZnVuY3Rpb24gbm90KHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBuZWcocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAtcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHRaaXBwZXIoKSB7XG4gICAgcmV0dXJuIGFyckNvcHkoYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHROZWdDb21wYXJhdG9yKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8IGIgPyAxIDogYSA+IGIgPyAtMSA6IDA7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNoQ29sbGVjdGlvbihjb2xsZWN0aW9uKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24uc2l6ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIgb3JkZXJlZCA9IGlzT3JkZXJlZChjb2xsZWN0aW9uKTtcbiAgICB2YXIga2V5ZWQgPSBpc0tleWVkKGNvbGxlY3Rpb24pO1xuICAgIHZhciBoID0gb3JkZXJlZCA/IDEgOiAwO1xuICAgIHZhciBzaXplID0gY29sbGVjdGlvbi5fX2l0ZXJhdGUoXG4gICAgICBrZXllZFxuICAgICAgICA/IG9yZGVyZWRcbiAgICAgICAgICA/IGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgICAgICAgIGggPSAoMzEgKiBoICsgaGFzaE1lcmdlKGhhc2godiksIGhhc2goaykpKSB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiBmdW5jdGlvbiAodiwgaykge1xuICAgICAgICAgICAgICBoID0gKGggKyBoYXNoTWVyZ2UoaGFzaCh2KSwgaGFzaChrKSkpIHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgOiBvcmRlcmVkXG4gICAgICAgID8gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGggPSAoMzEgKiBoICsgaGFzaCh2KSkgfCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgaCA9IChoICsgaGFzaCh2KSkgfCAwO1xuICAgICAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBtdXJtdXJIYXNoT2ZTaXplKHNpemUsIGgpO1xuICB9XG5cbiAgZnVuY3Rpb24gbXVybXVySGFzaE9mU2l6ZShzaXplLCBoKSB7XG4gICAgaCA9IGltdWwoaCwgMHhjYzllMmQ1MSk7XG4gICAgaCA9IGltdWwoKGggPDwgMTUpIHwgKGggPj4+IC0xNSksIDB4MWI4NzM1OTMpO1xuICAgIGggPSBpbXVsKChoIDw8IDEzKSB8IChoID4+PiAtMTMpLCA1KTtcbiAgICBoID0gKChoICsgMHhlNjU0NmI2NCkgfCAwKSBeIHNpemU7XG4gICAgaCA9IGltdWwoaCBeIChoID4+PiAxNiksIDB4ODVlYmNhNmIpO1xuICAgIGggPSBpbXVsKGggXiAoaCA+Pj4gMTMpLCAweGMyYjJhZTM1KTtcbiAgICBoID0gc21pKGggXiAoaCA+Pj4gMTYpKTtcbiAgICByZXR1cm4gaDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc2hNZXJnZShhLCBiKSB7XG4gICAgcmV0dXJuIChhIF4gKGIgKyAweDllMzc3OWI5ICsgKGEgPDwgNikgKyAoYSA+PiAyKSkpIHwgMDsgLy8gaW50XG4gIH1cblxuICB2YXIgT3JkZXJlZFNldCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNldCkge1xuICAgIGZ1bmN0aW9uIE9yZGVyZWRTZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gZW1wdHlPcmRlcmVkU2V0KClcbiAgICAgICAgOiBpc09yZGVyZWRTZXQodmFsdWUpXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiBlbXB0eU9yZGVyZWRTZXQoKS53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgICAgICAgIHZhciBpdGVyID0gU2V0Q29sbGVjdGlvbih2YWx1ZSk7XG4gICAgICAgICAgICBhc3NlcnROb3RJbmZpbml0ZShpdGVyLnNpemUpO1xuICAgICAgICAgICAgaXRlci5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHJldHVybiBzZXQuYWRkKHYpOyB9KTtcbiAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIFNldCApIE9yZGVyZWRTZXQuX19wcm90b19fID0gU2V0O1xuICAgIE9yZGVyZWRTZXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2V0ICYmIFNldC5wcm90b3R5cGUgKTtcbiAgICBPcmRlcmVkU2V0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE9yZGVyZWRTZXQ7XG5cbiAgICBPcmRlcmVkU2V0Lm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIE9yZGVyZWRTZXQuZnJvbUtleXMgPSBmdW5jdGlvbiBmcm9tS2V5cyAodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzKEtleWVkQ29sbGVjdGlvbih2YWx1ZSkua2V5U2VxKCkpO1xuICAgIH07XG5cbiAgICBPcmRlcmVkU2V0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ09yZGVyZWRTZXQgeycsICd9Jyk7XG4gICAgfTtcblxuICAgIHJldHVybiBPcmRlcmVkU2V0O1xuICB9KFNldCkpO1xuXG4gIE9yZGVyZWRTZXQuaXNPcmRlcmVkU2V0ID0gaXNPcmRlcmVkU2V0O1xuXG4gIHZhciBPcmRlcmVkU2V0UHJvdG90eXBlID0gT3JkZXJlZFNldC5wcm90b3R5cGU7XG4gIE9yZGVyZWRTZXRQcm90b3R5cGVbSVNfT1JERVJFRF9TWU1CT0xdID0gdHJ1ZTtcbiAgT3JkZXJlZFNldFByb3RvdHlwZS56aXAgPSBJbmRleGVkQ29sbGVjdGlvblByb3RvdHlwZS56aXA7XG4gIE9yZGVyZWRTZXRQcm90b3R5cGUuemlwV2l0aCA9IEluZGV4ZWRDb2xsZWN0aW9uUHJvdG90eXBlLnppcFdpdGg7XG5cbiAgT3JkZXJlZFNldFByb3RvdHlwZS5fX2VtcHR5ID0gZW1wdHlPcmRlcmVkU2V0O1xuICBPcmRlcmVkU2V0UHJvdG90eXBlLl9fbWFrZSA9IG1ha2VPcmRlcmVkU2V0O1xuXG4gIGZ1bmN0aW9uIG1ha2VPcmRlcmVkU2V0KG1hcCwgb3duZXJJRCkge1xuICAgIHZhciBzZXQgPSBPYmplY3QuY3JlYXRlKE9yZGVyZWRTZXRQcm90b3R5cGUpO1xuICAgIHNldC5zaXplID0gbWFwID8gbWFwLnNpemUgOiAwO1xuICAgIHNldC5fbWFwID0gbWFwO1xuICAgIHNldC5fX293bmVySUQgPSBvd25lcklEO1xuICAgIHJldHVybiBzZXQ7XG4gIH1cblxuICB2YXIgRU1QVFlfT1JERVJFRF9TRVQ7XG4gIGZ1bmN0aW9uIGVtcHR5T3JkZXJlZFNldCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgRU1QVFlfT1JERVJFRF9TRVQgfHwgKEVNUFRZX09SREVSRURfU0VUID0gbWFrZU9yZGVyZWRTZXQoZW1wdHlPcmRlcmVkTWFwKCkpKVxuICAgICk7XG4gIH1cblxuICB2YXIgUmVjb3JkID0gZnVuY3Rpb24gUmVjb3JkKGRlZmF1bHRWYWx1ZXMsIG5hbWUpIHtcbiAgICB2YXIgaGFzSW5pdGlhbGl6ZWQ7XG5cbiAgICB2YXIgUmVjb3JkVHlwZSA9IGZ1bmN0aW9uIFJlY29yZCh2YWx1ZXMpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICBpZiAodmFsdWVzIGluc3RhbmNlb2YgUmVjb3JkVHlwZSkge1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfVxuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlY29yZFR5cGUpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjb3JkVHlwZSh2YWx1ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKCFoYXNJbml0aWFsaXplZCkge1xuICAgICAgICBoYXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGVmYXVsdFZhbHVlcyk7XG4gICAgICAgIHZhciBpbmRpY2VzID0gKFJlY29yZFR5cGVQcm90b3R5cGUuX2luZGljZXMgPSB7fSk7XG4gICAgICAgIC8vIERlcHJlY2F0ZWQ6IGxlZnQgdG8gYXR0ZW1wdCBub3QgdG8gYnJlYWsgYW55IGV4dGVybmFsIGNvZGUgd2hpY2hcbiAgICAgICAgLy8gcmVsaWVzIG9uIGEgLl9uYW1lIHByb3BlcnR5IGV4aXN0aW5nIG9uIHJlY29yZCBpbnN0YW5jZXMuXG4gICAgICAgIC8vIFVzZSBSZWNvcmQuZ2V0RGVzY3JpcHRpdmVOYW1lKCkgaW5zdGVhZFxuICAgICAgICBSZWNvcmRUeXBlUHJvdG90eXBlLl9uYW1lID0gbmFtZTtcbiAgICAgICAgUmVjb3JkVHlwZVByb3RvdHlwZS5fa2V5cyA9IGtleXM7XG4gICAgICAgIFJlY29yZFR5cGVQcm90b3R5cGUuX2RlZmF1bHRWYWx1ZXMgPSBkZWZhdWx0VmFsdWVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcHJvcE5hbWUgPSBrZXlzW2ldO1xuICAgICAgICAgIGluZGljZXNbcHJvcE5hbWVdID0gaTtcbiAgICAgICAgICBpZiAoUmVjb3JkVHlwZVByb3RvdHlwZVtwcm9wTmFtZV0pIHtcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4gJiZcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICdDYW5ub3QgZGVmaW5lICcgK1xuICAgICAgICAgICAgICAgICAgcmVjb3JkTmFtZSh0aGlzKSArXG4gICAgICAgICAgICAgICAgICAnIHdpdGggcHJvcGVydHkgXCInICtcbiAgICAgICAgICAgICAgICAgIHByb3BOYW1lICtcbiAgICAgICAgICAgICAgICAgICdcIiBzaW5jZSB0aGF0IHByb3BlcnR5IG5hbWUgaXMgcGFydCBvZiB0aGUgUmVjb3JkIEFQSS4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0UHJvcChSZWNvcmRUeXBlUHJvdG90eXBlLCBwcm9wTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9fb3duZXJJRCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX3ZhbHVlcyA9IExpc3QoKS53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgIGwuc2V0U2l6ZSh0aGlzJDEuX2tleXMubGVuZ3RoKTtcbiAgICAgICAgS2V5ZWRDb2xsZWN0aW9uKHZhbHVlcykuZm9yRWFjaChmdW5jdGlvbiAodiwgaykge1xuICAgICAgICAgIGwuc2V0KHRoaXMkMS5faW5kaWNlc1trXSwgdiA9PT0gdGhpcyQxLl9kZWZhdWx0VmFsdWVzW2tdID8gdW5kZWZpbmVkIDogdik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBSZWNvcmRUeXBlUHJvdG90eXBlID0gKFJlY29yZFR5cGUucHJvdG90eXBlID1cbiAgICAgIE9iamVjdC5jcmVhdGUoUmVjb3JkUHJvdG90eXBlKSk7XG4gICAgUmVjb3JkVHlwZVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlY29yZFR5cGU7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgUmVjb3JkVHlwZS5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlY29yZFR5cGU7XG4gIH07XG5cbiAgUmVjb3JkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICB2YXIgc3RyID0gcmVjb3JkTmFtZSh0aGlzKSArICcgeyAnO1xuICAgIHZhciBrZXlzID0gdGhpcy5fa2V5cztcbiAgICB2YXIgaztcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpICE9PSBsOyBpKyspIHtcbiAgICAgIGsgPSBrZXlzW2ldO1xuICAgICAgc3RyICs9IChpID8gJywgJyA6ICcnKSArIGsgKyAnOiAnICsgcXVvdGVTdHJpbmcodGhpcy5nZXQoaykpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyICsgJyB9JztcbiAgfTtcblxuICBSZWNvcmQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAob3RoZXIpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcyA9PT0gb3RoZXIgfHxcbiAgICAgIChvdGhlciAmJlxuICAgICAgICB0aGlzLl9rZXlzID09PSBvdGhlci5fa2V5cyAmJlxuICAgICAgICByZWNvcmRTZXEodGhpcykuZXF1YWxzKHJlY29yZFNlcShvdGhlcikpKVxuICAgICk7XG4gIH07XG5cbiAgUmVjb3JkLnByb3RvdHlwZS5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlICgpIHtcbiAgICByZXR1cm4gcmVjb3JkU2VxKHRoaXMpLmhhc2hDb2RlKCk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICBSZWNvcmQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoaykge1xuICAgIHJldHVybiB0aGlzLl9pbmRpY2VzLmhhc093blByb3BlcnR5KGspO1xuICB9O1xuXG4gIFJlY29yZC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChrLCBub3RTZXRWYWx1ZSkge1xuICAgIGlmICghdGhpcy5oYXMoaykpIHtcbiAgICAgIHJldHVybiBub3RTZXRWYWx1ZTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gdGhpcy5faW5kaWNlc1trXTtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLl92YWx1ZXMuZ2V0KGluZGV4KTtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHRoaXMuX2RlZmF1bHRWYWx1ZXNba10gOiB2YWx1ZTtcbiAgfTtcblxuICAvLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG4gIFJlY29yZC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0IChrLCB2KSB7XG4gICAgaWYgKHRoaXMuaGFzKGspKSB7XG4gICAgICB2YXIgbmV3VmFsdWVzID0gdGhpcy5fdmFsdWVzLnNldChcbiAgICAgICAgdGhpcy5faW5kaWNlc1trXSxcbiAgICAgICAgdiA9PT0gdGhpcy5fZGVmYXVsdFZhbHVlc1trXSA/IHVuZGVmaW5lZCA6IHZcbiAgICAgICk7XG4gICAgICBpZiAobmV3VmFsdWVzICE9PSB0aGlzLl92YWx1ZXMgJiYgIXRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHJldHVybiBtYWtlUmVjb3JkKHRoaXMsIG5ld1ZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFJlY29yZC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlIChrKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0KGspO1xuICB9O1xuXG4gIFJlY29yZC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgdmFyIG5ld1ZhbHVlcyA9IHRoaXMuX3ZhbHVlcy5jbGVhcigpLnNldFNpemUodGhpcy5fa2V5cy5sZW5ndGgpO1xuICAgIHJldHVybiB0aGlzLl9fb3duZXJJRCA/IHRoaXMgOiBtYWtlUmVjb3JkKHRoaXMsIG5ld1ZhbHVlcyk7XG4gIH07XG5cbiAgUmVjb3JkLnByb3RvdHlwZS53YXNBbHRlcmVkID0gZnVuY3Rpb24gd2FzQWx0ZXJlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlcy53YXNBbHRlcmVkKCk7XG4gIH07XG5cbiAgUmVjb3JkLnByb3RvdHlwZS50b1NlcSA9IGZ1bmN0aW9uIHRvU2VxICgpIHtcbiAgICByZXR1cm4gcmVjb3JkU2VxKHRoaXMpO1xuICB9O1xuXG4gIFJlY29yZC5wcm90b3R5cGUudG9KUyA9IGZ1bmN0aW9uIHRvSlMkMSAoKSB7XG4gICAgcmV0dXJuIHRvSlModGhpcyk7XG4gIH07XG5cbiAgUmVjb3JkLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24gZW50cmllcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMpO1xuICB9O1xuXG4gIFJlY29yZC5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICByZXR1cm4gcmVjb3JkU2VxKHRoaXMpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gIH07XG5cbiAgUmVjb3JkLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgcmV0dXJuIHJlY29yZFNlcSh0aGlzKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xuICB9O1xuXG4gIFJlY29yZC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uIF9fZW5zdXJlT3duZXIgKG93bmVySUQpIHtcbiAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgbmV3VmFsdWVzID0gdGhpcy5fdmFsdWVzLl9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gICAgaWYgKCFvd25lcklEKSB7XG4gICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICB0aGlzLl92YWx1ZXMgPSBuZXdWYWx1ZXM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VSZWNvcmQodGhpcywgbmV3VmFsdWVzLCBvd25lcklEKTtcbiAgfTtcblxuICBSZWNvcmQuaXNSZWNvcmQgPSBpc1JlY29yZDtcbiAgUmVjb3JkLmdldERlc2NyaXB0aXZlTmFtZSA9IHJlY29yZE5hbWU7XG4gIHZhciBSZWNvcmRQcm90b3R5cGUgPSBSZWNvcmQucHJvdG90eXBlO1xuICBSZWNvcmRQcm90b3R5cGVbSVNfUkVDT1JEX1NZTUJPTF0gPSB0cnVlO1xuICBSZWNvcmRQcm90b3R5cGVbREVMRVRFXSA9IFJlY29yZFByb3RvdHlwZS5yZW1vdmU7XG4gIFJlY29yZFByb3RvdHlwZS5kZWxldGVJbiA9IFJlY29yZFByb3RvdHlwZS5yZW1vdmVJbiA9IGRlbGV0ZUluO1xuICBSZWNvcmRQcm90b3R5cGUuZ2V0SW4gPSBnZXRJbiQxO1xuICBSZWNvcmRQcm90b3R5cGUuaGFzSW4gPSBDb2xsZWN0aW9uUHJvdG90eXBlLmhhc0luO1xuICBSZWNvcmRQcm90b3R5cGUubWVyZ2UgPSBtZXJnZTtcbiAgUmVjb3JkUHJvdG90eXBlLm1lcmdlV2l0aCA9IG1lcmdlV2l0aDtcbiAgUmVjb3JkUHJvdG90eXBlLm1lcmdlSW4gPSBtZXJnZUluO1xuICBSZWNvcmRQcm90b3R5cGUubWVyZ2VEZWVwID0gbWVyZ2VEZWVwJDE7XG4gIFJlY29yZFByb3RvdHlwZS5tZXJnZURlZXBXaXRoID0gbWVyZ2VEZWVwV2l0aCQxO1xuICBSZWNvcmRQcm90b3R5cGUubWVyZ2VEZWVwSW4gPSBtZXJnZURlZXBJbjtcbiAgUmVjb3JkUHJvdG90eXBlLnNldEluID0gc2V0SW4kMTtcbiAgUmVjb3JkUHJvdG90eXBlLnVwZGF0ZSA9IHVwZGF0ZSQxO1xuICBSZWNvcmRQcm90b3R5cGUudXBkYXRlSW4gPSB1cGRhdGVJbiQxO1xuICBSZWNvcmRQcm90b3R5cGUud2l0aE11dGF0aW9ucyA9IHdpdGhNdXRhdGlvbnM7XG4gIFJlY29yZFByb3RvdHlwZS5hc011dGFibGUgPSBhc011dGFibGU7XG4gIFJlY29yZFByb3RvdHlwZS5hc0ltbXV0YWJsZSA9IGFzSW1tdXRhYmxlO1xuICBSZWNvcmRQcm90b3R5cGVbSVRFUkFUT1JfU1lNQk9MXSA9IFJlY29yZFByb3RvdHlwZS5lbnRyaWVzO1xuICBSZWNvcmRQcm90b3R5cGUudG9KU09OID0gUmVjb3JkUHJvdG90eXBlLnRvT2JqZWN0ID1cbiAgICBDb2xsZWN0aW9uUHJvdG90eXBlLnRvT2JqZWN0O1xuICBSZWNvcmRQcm90b3R5cGUuaW5zcGVjdCA9IFJlY29yZFByb3RvdHlwZS50b1NvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VSZWNvcmQobGlrZVJlY29yZCwgdmFsdWVzLCBvd25lcklEKSB7XG4gICAgdmFyIHJlY29yZCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKGxpa2VSZWNvcmQpKTtcbiAgICByZWNvcmQuX3ZhbHVlcyA9IHZhbHVlcztcbiAgICByZWNvcmQuX19vd25lcklEID0gb3duZXJJRDtcbiAgICByZXR1cm4gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkTmFtZShyZWNvcmQpIHtcbiAgICByZXR1cm4gcmVjb3JkLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IHJlY29yZC5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdSZWNvcmQnO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkU2VxKHJlY29yZCkge1xuICAgIHJldHVybiBrZXllZFNlcUZyb21WYWx1ZShyZWNvcmQuX2tleXMubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBbaywgcmVjb3JkLmdldChrKV07IH0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFByb3AocHJvdG90eXBlLCBuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIG5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KG5hbWUpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGludmFyaWFudCh0aGlzLl9fb3duZXJJRCwgJ0Nhbm5vdCBzZXQgb24gYW4gaW1tdXRhYmxlIHJlY29yZC4nKTtcbiAgICAgICAgICB0aGlzLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gT2JqZWN0LmRlZmluZVByb3BlcnR5IGZhaWxlZC4gUHJvYmFibHkgSUU4LlxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGF6eSBTZXEgb2YgYHZhbHVlYCByZXBlYXRlZCBgdGltZXNgIHRpbWVzLiBXaGVuIGB0aW1lc2AgaXNcbiAgICogdW5kZWZpbmVkLCByZXR1cm5zIGFuIGluZmluaXRlIHNlcXVlbmNlIG9mIGB2YWx1ZWAuXG4gICAqL1xuICB2YXIgUmVwZWF0ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW5kZXhlZFNlcSkge1xuICAgIGZ1bmN0aW9uIFJlcGVhdCh2YWx1ZSwgdGltZXMpIHtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXBlYXQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVwZWF0KHZhbHVlLCB0aW1lcyk7XG4gICAgICB9XG4gICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5zaXplID0gdGltZXMgPT09IHVuZGVmaW5lZCA/IEluZmluaXR5IDogTWF0aC5tYXgoMCwgdGltZXMpO1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBpZiAoRU1QVFlfUkVQRUFUKSB7XG4gICAgICAgICAgcmV0dXJuIEVNUFRZX1JFUEVBVDtcbiAgICAgICAgfVxuICAgICAgICBFTVBUWV9SRVBFQVQgPSB0aGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICggSW5kZXhlZFNlcSApIFJlcGVhdC5fX3Byb3RvX18gPSBJbmRleGVkU2VxO1xuICAgIFJlcGVhdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkU2VxICYmIEluZGV4ZWRTZXEucHJvdG90eXBlICk7XG4gICAgUmVwZWF0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlcGVhdDtcblxuICAgIFJlcGVhdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnUmVwZWF0IFtdJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnUmVwZWF0IFsgJyArIHRoaXMuX3ZhbHVlICsgJyAnICsgdGhpcy5zaXplICsgJyB0aW1lcyBdJztcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzKGluZGV4KSA/IHRoaXMuX3ZhbHVlIDogbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIFJlcGVhdC5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAoc2VhcmNoVmFsdWUpIHtcbiAgICAgIHJldHVybiBpcyh0aGlzLl92YWx1ZSwgc2VhcmNoVmFsdWUpO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKGJlZ2luLCBlbmQpIHtcbiAgICAgIHZhciBzaXplID0gdGhpcy5zaXplO1xuICAgICAgcmV0dXJuIHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgc2l6ZSlcbiAgICAgICAgPyB0aGlzXG4gICAgICAgIDogbmV3IFJlcGVhdChcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlLFxuICAgICAgICAgICAgcmVzb2x2ZUVuZChlbmQsIHNpemUpIC0gcmVzb2x2ZUJlZ2luKGJlZ2luLCBzaXplKVxuICAgICAgICAgICk7XG4gICAgfTtcblxuICAgIFJlcGVhdC5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UgKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFJlcGVhdC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHNlYXJjaFZhbHVlKSB7XG4gICAgICBpZiAoaXModGhpcy5fdmFsdWUsIHNlYXJjaFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mIChzZWFyY2hWYWx1ZSkge1xuICAgICAgaWYgKGlzKHRoaXMuX3ZhbHVlLCBzZWFyY2hWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChpICE9PSBzaXplKSB7XG4gICAgICAgIGlmIChmbih0aGlzLl92YWx1ZSwgcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKyssIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaTtcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHZhciBzaXplID0gdGhpcy5zaXplO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7IHJldHVybiBpID09PSBzaXplXG4gICAgICAgICAgPyBpdGVyYXRvckRvbmUoKVxuICAgICAgICAgIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCByZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrKywgdGhpcyQxLl92YWx1ZSk7IH1cbiAgICAgICk7XG4gICAgfTtcblxuICAgIFJlcGVhdC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChvdGhlcikge1xuICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgUmVwZWF0XG4gICAgICAgID8gaXModGhpcy5fdmFsdWUsIG90aGVyLl92YWx1ZSlcbiAgICAgICAgOiBkZWVwRXF1YWwob3RoZXIpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVwZWF0O1xuICB9KEluZGV4ZWRTZXEpKTtcblxuICB2YXIgRU1QVFlfUkVQRUFUO1xuXG4gIGZ1bmN0aW9uIGZyb21KUyh2YWx1ZSwgY29udmVydGVyKSB7XG4gICAgcmV0dXJuIGZyb21KU1dpdGgoXG4gICAgICBbXSxcbiAgICAgIGNvbnZlcnRlciB8fCBkZWZhdWx0Q29udmVydGVyLFxuICAgICAgdmFsdWUsXG4gICAgICAnJyxcbiAgICAgIGNvbnZlcnRlciAmJiBjb252ZXJ0ZXIubGVuZ3RoID4gMiA/IFtdIDogdW5kZWZpbmVkLFxuICAgICAgeyAnJzogdmFsdWUgfVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBmcm9tSlNXaXRoKHN0YWNrLCBjb252ZXJ0ZXIsIHZhbHVlLCBrZXksIGtleVBhdGgsIHBhcmVudFZhbHVlKSB7XG4gICAgdmFyIHRvU2VxID0gQXJyYXkuaXNBcnJheSh2YWx1ZSlcbiAgICAgID8gSW5kZXhlZFNlcVxuICAgICAgOiBpc1BsYWluT2JqKHZhbHVlKVxuICAgICAgPyBLZXllZFNlcVxuICAgICAgOiBudWxsO1xuICAgIGlmICh0b1NlcSkge1xuICAgICAgaWYgKH5zdGFjay5pbmRleE9mKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBjaXJjdWxhciBzdHJ1Y3R1cmUgdG8gSW1tdXRhYmxlJyk7XG4gICAgICB9XG4gICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgIGtleVBhdGggJiYga2V5ICE9PSAnJyAmJiBrZXlQYXRoLnB1c2goa2V5KTtcbiAgICAgIHZhciBjb252ZXJ0ZWQgPSBjb252ZXJ0ZXIuY2FsbChcbiAgICAgICAgcGFyZW50VmFsdWUsXG4gICAgICAgIGtleSxcbiAgICAgICAgdG9TZXEodmFsdWUpLm1hcChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gZnJvbUpTV2l0aChzdGFjaywgY29udmVydGVyLCB2LCBrLCBrZXlQYXRoLCB2YWx1ZSk7IH1cbiAgICAgICAgKSxcbiAgICAgICAga2V5UGF0aCAmJiBrZXlQYXRoLnNsaWNlKClcbiAgICAgICk7XG4gICAgICBzdGFjay5wb3AoKTtcbiAgICAgIGtleVBhdGggJiYga2V5UGF0aC5wb3AoKTtcbiAgICAgIHJldHVybiBjb252ZXJ0ZWQ7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHRDb252ZXJ0ZXIoaywgdikge1xuICAgIHJldHVybiBpc0tleWVkKHYpID8gdi50b01hcCgpIDogdi50b0xpc3QoKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gXCI0LjAuMC1yYy4xMlwiO1xuXG4gIHZhciBJbW11dGFibGUgPSB7XG4gICAgdmVyc2lvbjogdmVyc2lvbixcblxuICAgIENvbGxlY3Rpb246IENvbGxlY3Rpb24sXG4gICAgLy8gTm90ZTogSXRlcmFibGUgaXMgZGVwcmVjYXRlZFxuICAgIEl0ZXJhYmxlOiBDb2xsZWN0aW9uLFxuXG4gICAgU2VxOiBTZXEsXG4gICAgTWFwOiBNYXAsXG4gICAgT3JkZXJlZE1hcDogT3JkZXJlZE1hcCxcbiAgICBMaXN0OiBMaXN0LFxuICAgIFN0YWNrOiBTdGFjayxcbiAgICBTZXQ6IFNldCxcbiAgICBPcmRlcmVkU2V0OiBPcmRlcmVkU2V0LFxuXG4gICAgUmVjb3JkOiBSZWNvcmQsXG4gICAgUmFuZ2U6IFJhbmdlLFxuICAgIFJlcGVhdDogUmVwZWF0LFxuXG4gICAgaXM6IGlzLFxuICAgIGZyb21KUzogZnJvbUpTLFxuICAgIGhhc2g6IGhhc2gsXG5cbiAgICBpc0ltbXV0YWJsZTogaXNJbW11dGFibGUsXG4gICAgaXNDb2xsZWN0aW9uOiBpc0NvbGxlY3Rpb24sXG4gICAgaXNLZXllZDogaXNLZXllZCxcbiAgICBpc0luZGV4ZWQ6IGlzSW5kZXhlZCxcbiAgICBpc0Fzc29jaWF0aXZlOiBpc0Fzc29jaWF0aXZlLFxuICAgIGlzT3JkZXJlZDogaXNPcmRlcmVkLFxuICAgIGlzVmFsdWVPYmplY3Q6IGlzVmFsdWVPYmplY3QsXG4gICAgaXNTZXE6IGlzU2VxLFxuICAgIGlzTGlzdDogaXNMaXN0LFxuICAgIGlzTWFwOiBpc01hcCxcbiAgICBpc09yZGVyZWRNYXA6IGlzT3JkZXJlZE1hcCxcbiAgICBpc1N0YWNrOiBpc1N0YWNrLFxuICAgIGlzU2V0OiBpc1NldCxcbiAgICBpc09yZGVyZWRTZXQ6IGlzT3JkZXJlZFNldCxcbiAgICBpc1JlY29yZDogaXNSZWNvcmQsXG5cbiAgICBnZXQ6IGdldCxcbiAgICBnZXRJbjogZ2V0SW4sXG4gICAgaGFzOiBoYXMsXG4gICAgaGFzSW46IGhhc0luLFxuICAgIG1lcmdlOiBtZXJnZSQxLFxuICAgIG1lcmdlRGVlcDogbWVyZ2VEZWVwLFxuICAgIG1lcmdlV2l0aDogbWVyZ2VXaXRoJDEsXG4gICAgbWVyZ2VEZWVwV2l0aDogbWVyZ2VEZWVwV2l0aCxcbiAgICByZW1vdmU6IHJlbW92ZSxcbiAgICByZW1vdmVJbjogcmVtb3ZlSW4sXG4gICAgc2V0OiBzZXQsXG4gICAgc2V0SW46IHNldEluLFxuICAgIHVwZGF0ZTogdXBkYXRlLFxuICAgIHVwZGF0ZUluOiB1cGRhdGVJbixcbiAgfTtcblxuICAvLyBOb3RlOiBJdGVyYWJsZSBpcyBkZXByZWNhdGVkXG4gIHZhciBJdGVyYWJsZSA9IENvbGxlY3Rpb247XG5cbiAgZXhwb3J0cy5Db2xsZWN0aW9uID0gQ29sbGVjdGlvbjtcbiAgZXhwb3J0cy5JdGVyYWJsZSA9IEl0ZXJhYmxlO1xuICBleHBvcnRzLkxpc3QgPSBMaXN0O1xuICBleHBvcnRzLk1hcCA9IE1hcDtcbiAgZXhwb3J0cy5PcmRlcmVkTWFwID0gT3JkZXJlZE1hcDtcbiAgZXhwb3J0cy5PcmRlcmVkU2V0ID0gT3JkZXJlZFNldDtcbiAgZXhwb3J0cy5SYW5nZSA9IFJhbmdlO1xuICBleHBvcnRzLlJlY29yZCA9IFJlY29yZDtcbiAgZXhwb3J0cy5SZXBlYXQgPSBSZXBlYXQ7XG4gIGV4cG9ydHMuU2VxID0gU2VxO1xuICBleHBvcnRzLlNldCA9IFNldDtcbiAgZXhwb3J0cy5TdGFjayA9IFN0YWNrO1xuICBleHBvcnRzLmRlZmF1bHQgPSBJbW11dGFibGU7XG4gIGV4cG9ydHMuZnJvbUpTID0gZnJvbUpTO1xuICBleHBvcnRzLmdldCA9IGdldDtcbiAgZXhwb3J0cy5nZXRJbiA9IGdldEluO1xuICBleHBvcnRzLmhhcyA9IGhhcztcbiAgZXhwb3J0cy5oYXNJbiA9IGhhc0luO1xuICBleHBvcnRzLmhhc2ggPSBoYXNoO1xuICBleHBvcnRzLmlzID0gaXM7XG4gIGV4cG9ydHMuaXNBc3NvY2lhdGl2ZSA9IGlzQXNzb2NpYXRpdmU7XG4gIGV4cG9ydHMuaXNDb2xsZWN0aW9uID0gaXNDb2xsZWN0aW9uO1xuICBleHBvcnRzLmlzSW1tdXRhYmxlID0gaXNJbW11dGFibGU7XG4gIGV4cG9ydHMuaXNJbmRleGVkID0gaXNJbmRleGVkO1xuICBleHBvcnRzLmlzS2V5ZWQgPSBpc0tleWVkO1xuICBleHBvcnRzLmlzT3JkZXJlZCA9IGlzT3JkZXJlZDtcbiAgZXhwb3J0cy5pc1ZhbHVlT2JqZWN0ID0gaXNWYWx1ZU9iamVjdDtcbiAgZXhwb3J0cy5tZXJnZSA9IG1lcmdlJDE7XG4gIGV4cG9ydHMubWVyZ2VEZWVwID0gbWVyZ2VEZWVwO1xuICBleHBvcnRzLm1lcmdlRGVlcFdpdGggPSBtZXJnZURlZXBXaXRoO1xuICBleHBvcnRzLm1lcmdlV2l0aCA9IG1lcmdlV2l0aCQxO1xuICBleHBvcnRzLnJlbW92ZSA9IHJlbW92ZTtcbiAgZXhwb3J0cy5yZW1vdmVJbiA9IHJlbW92ZUluO1xuICBleHBvcnRzLnNldCA9IHNldDtcbiAgZXhwb3J0cy5zZXRJbiA9IHNldEluO1xuICBleHBvcnRzLnVwZGF0ZSA9IHVwZGF0ZTtcbiAgZXhwb3J0cy51cGRhdGVJbiA9IHVwZGF0ZUluO1xuICBleHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHsgX19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAhPSBudWxsICYmXG4gICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdmFyIGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxuICAgICAgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aFxuICAgIClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5CdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG5CdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIHZhciBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgIH1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2UgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCIvKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiLyoqXG4gKiBtYXJrZWQgLSBhIG1hcmtkb3duIHBhcnNlclxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMjAsIENocmlzdG9waGVyIEplZmZyZXkuIChNSVQgTGljZW5zZWQpXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWFya2VkanMvbWFya2VkXG4gKi9cblxuLyoqXG4gKiBETyBOT1QgRURJVCBUSElTIEZJTEVcbiAqIFRoZSBjb2RlIGluIHRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBmaWxlcyBpbiAuL3NyYy9cbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLm1hcmtlZCA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gICAgaWYgKCFvKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIH1cblxuICBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICAgIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgcmV0dXJuIGFycjI7XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG8sIGFsbG93QXJyYXlMaWtlKSB7XG4gICAgdmFyIGl0O1xuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBvW2krK11cbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gICAgfVxuXG4gICAgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICByZXR1cm4gaXQubmV4dC5iaW5kKGl0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcbiAgXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG4gIH1cblxuICB2YXIgZGVmYXVsdHMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgZnVuY3Rpb24gZ2V0RGVmYXVsdHMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYXNlVXJsOiBudWxsLFxuICAgICAgICBicmVha3M6IGZhbHNlLFxuICAgICAgICBnZm06IHRydWUsXG4gICAgICAgIGhlYWRlcklkczogdHJ1ZSxcbiAgICAgICAgaGVhZGVyUHJlZml4OiAnJyxcbiAgICAgICAgaGlnaGxpZ2h0OiBudWxsLFxuICAgICAgICBsYW5nUHJlZml4OiAnbGFuZ3VhZ2UtJyxcbiAgICAgICAgbWFuZ2xlOiB0cnVlLFxuICAgICAgICBwZWRhbnRpYzogZmFsc2UsXG4gICAgICAgIHJlbmRlcmVyOiBudWxsLFxuICAgICAgICBzYW5pdGl6ZTogZmFsc2UsXG4gICAgICAgIHNhbml0aXplcjogbnVsbCxcbiAgICAgICAgc2lsZW50OiBmYWxzZSxcbiAgICAgICAgc21hcnRMaXN0czogZmFsc2UsXG4gICAgICAgIHNtYXJ0eXBhbnRzOiBmYWxzZSxcbiAgICAgICAgdG9rZW5pemVyOiBudWxsLFxuICAgICAgICB3YWxrVG9rZW5zOiBudWxsLFxuICAgICAgICB4aHRtbDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hhbmdlRGVmYXVsdHMobmV3RGVmYXVsdHMpIHtcbiAgICAgIG1vZHVsZS5leHBvcnRzLmRlZmF1bHRzID0gbmV3RGVmYXVsdHM7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICBkZWZhdWx0czogZ2V0RGVmYXVsdHMoKSxcbiAgICAgIGdldERlZmF1bHRzOiBnZXREZWZhdWx0cyxcbiAgICAgIGNoYW5nZURlZmF1bHRzOiBjaGFuZ2VEZWZhdWx0c1xuICAgIH07XG4gIH0pO1xuICB2YXIgZGVmYXVsdHNfMSA9IGRlZmF1bHRzLmRlZmF1bHRzO1xuICB2YXIgZGVmYXVsdHNfMiA9IGRlZmF1bHRzLmdldERlZmF1bHRzO1xuICB2YXIgZGVmYXVsdHNfMyA9IGRlZmF1bHRzLmNoYW5nZURlZmF1bHRzO1xuXG4gIC8qKlxuICAgKiBIZWxwZXJzXG4gICAqL1xuICB2YXIgZXNjYXBlVGVzdCA9IC9bJjw+XCInXS87XG4gIHZhciBlc2NhcGVSZXBsYWNlID0gL1smPD5cIiddL2c7XG4gIHZhciBlc2NhcGVUZXN0Tm9FbmNvZGUgPSAvWzw+XCInXXwmKD8hIz9cXHcrOykvO1xuICB2YXIgZXNjYXBlUmVwbGFjZU5vRW5jb2RlID0gL1s8PlwiJ118Jig/ISM/XFx3KzspL2c7XG4gIHZhciBlc2NhcGVSZXBsYWNlbWVudHMgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnXG4gIH07XG5cbiAgdmFyIGdldEVzY2FwZVJlcGxhY2VtZW50ID0gZnVuY3Rpb24gZ2V0RXNjYXBlUmVwbGFjZW1lbnQoY2gpIHtcbiAgICByZXR1cm4gZXNjYXBlUmVwbGFjZW1lbnRzW2NoXTtcbiAgfTtcblxuICBmdW5jdGlvbiBlc2NhcGUoaHRtbCwgZW5jb2RlKSB7XG4gICAgaWYgKGVuY29kZSkge1xuICAgICAgaWYgKGVzY2FwZVRlc3QudGVzdChodG1sKSkge1xuICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKGVzY2FwZVJlcGxhY2UsIGdldEVzY2FwZVJlcGxhY2VtZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVzY2FwZVRlc3ROb0VuY29kZS50ZXN0KGh0bWwpKSB7XG4gICAgICAgIHJldHVybiBodG1sLnJlcGxhY2UoZXNjYXBlUmVwbGFjZU5vRW5jb2RlLCBnZXRFc2NhcGVSZXBsYWNlbWVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGh0bWw7XG4gIH1cblxuICB2YXIgdW5lc2NhcGVUZXN0ID0gLyYoIyg/OlxcZCspfCg/OiN4WzAtOUEtRmEtZl0rKXwoPzpcXHcrKSk7Py9pZztcblxuICBmdW5jdGlvbiB1bmVzY2FwZShodG1sKSB7XG4gICAgLy8gZXhwbGljaXRseSBtYXRjaCBkZWNpbWFsLCBoZXgsIGFuZCBuYW1lZCBIVE1MIGVudGl0aWVzXG4gICAgcmV0dXJuIGh0bWwucmVwbGFjZSh1bmVzY2FwZVRlc3QsIGZ1bmN0aW9uIChfLCBuKSB7XG4gICAgICBuID0gbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKG4gPT09ICdjb2xvbicpIHJldHVybiAnOic7XG5cbiAgICAgIGlmIChuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgIHJldHVybiBuLmNoYXJBdCgxKSA9PT0gJ3gnID8gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChuLnN1YnN0cmluZygyKSwgMTYpKSA6IFN0cmluZy5mcm9tQ2hhckNvZGUoK24uc3Vic3RyaW5nKDEpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcnO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGNhcmV0ID0gLyhefFteXFxbXSlcXF4vZztcblxuICBmdW5jdGlvbiBlZGl0KHJlZ2V4LCBvcHQpIHtcbiAgICByZWdleCA9IHJlZ2V4LnNvdXJjZSB8fCByZWdleDtcbiAgICBvcHQgPSBvcHQgfHwgJyc7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIHJlcGxhY2U6IGZ1bmN0aW9uIHJlcGxhY2UobmFtZSwgdmFsKSB7XG4gICAgICAgIHZhbCA9IHZhbC5zb3VyY2UgfHwgdmFsO1xuICAgICAgICB2YWwgPSB2YWwucmVwbGFjZShjYXJldCwgJyQxJyk7XG4gICAgICAgIHJlZ2V4ID0gcmVnZXgucmVwbGFjZShuYW1lLCB2YWwpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfSxcbiAgICAgIGdldFJlZ2V4OiBmdW5jdGlvbiBnZXRSZWdleCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXgsIG9wdCk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIG5vbldvcmRBbmRDb2xvblRlc3QgPSAvW15cXHc6XS9nO1xuICB2YXIgb3JpZ2luSW5kZXBlbmRlbnRVcmwgPSAvXiR8XlthLXpdW2EtejAtOSsuLV0qOnxeWz8jXS9pO1xuXG4gIGZ1bmN0aW9uIGNsZWFuVXJsKHNhbml0aXplLCBiYXNlLCBocmVmKSB7XG4gICAgaWYgKHNhbml0aXplKSB7XG4gICAgICB2YXIgcHJvdDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcHJvdCA9IGRlY29kZVVSSUNvbXBvbmVudCh1bmVzY2FwZShocmVmKSkucmVwbGFjZShub25Xb3JkQW5kQ29sb25UZXN0LCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm90LmluZGV4T2YoJ2phdmFzY3JpcHQ6JykgPT09IDAgfHwgcHJvdC5pbmRleE9mKCd2YnNjcmlwdDonKSA9PT0gMCB8fCBwcm90LmluZGV4T2YoJ2RhdGE6JykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgJiYgIW9yaWdpbkluZGVwZW5kZW50VXJsLnRlc3QoaHJlZikpIHtcbiAgICAgIGhyZWYgPSByZXNvbHZlVXJsKGJhc2UsIGhyZWYpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBocmVmID0gZW5jb2RlVVJJKGhyZWYpLnJlcGxhY2UoLyUyNS9nLCAnJScpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBocmVmO1xuICB9XG5cbiAgdmFyIGJhc2VVcmxzID0ge307XG4gIHZhciBqdXN0RG9tYWluID0gL15bXjpdKzpcXC8qW14vXSokLztcbiAgdmFyIHByb3RvY29sID0gL14oW146XSs6KVtcXHNcXFNdKiQvO1xuICB2YXIgZG9tYWluID0gL14oW146XSs6XFwvKlteL10qKVtcXHNcXFNdKiQvO1xuXG4gIGZ1bmN0aW9uIHJlc29sdmVVcmwoYmFzZSwgaHJlZikge1xuICAgIGlmICghYmFzZVVybHNbJyAnICsgYmFzZV0pIHtcbiAgICAgIC8vIHdlIGNhbiBpZ25vcmUgZXZlcnl0aGluZyBpbiBiYXNlIGFmdGVyIHRoZSBsYXN0IHNsYXNoIG9mIGl0cyBwYXRoIGNvbXBvbmVudCxcbiAgICAgIC8vIGJ1dCB3ZSBtaWdodCBuZWVkIHRvIGFkZCBfdGhhdF9cbiAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tM1xuICAgICAgaWYgKGp1c3REb21haW4udGVzdChiYXNlKSkge1xuICAgICAgICBiYXNlVXJsc1snICcgKyBiYXNlXSA9IGJhc2UgKyAnLyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlVXJsc1snICcgKyBiYXNlXSA9IHJ0cmltKGJhc2UsICcvJywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYmFzZSA9IGJhc2VVcmxzWycgJyArIGJhc2VdO1xuICAgIHZhciByZWxhdGl2ZUJhc2UgPSBiYXNlLmluZGV4T2YoJzonKSA9PT0gLTE7XG5cbiAgICBpZiAoaHJlZi5zdWJzdHJpbmcoMCwgMikgPT09ICcvLycpIHtcbiAgICAgIGlmIChyZWxhdGl2ZUJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGhyZWY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiYXNlLnJlcGxhY2UocHJvdG9jb2wsICckMScpICsgaHJlZjtcbiAgICB9IGVsc2UgaWYgKGhyZWYuY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgIGlmIChyZWxhdGl2ZUJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGhyZWY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiYXNlLnJlcGxhY2UoZG9tYWluLCAnJDEnKSArIGhyZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiYXNlICsgaHJlZjtcbiAgICB9XG4gIH1cblxuICB2YXIgbm9vcFRlc3QgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24gbm9vcFRlc3QoKSB7fVxuICB9O1xuXG4gIGZ1bmN0aW9uIG1lcmdlKG9iaikge1xuICAgIHZhciBpID0gMSxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBrZXk7XG5cbiAgICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHtcbiAgICAgICAgICBvYmpba2V5XSA9IHRhcmdldFtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNwbGl0Q2VsbHModGFibGVSb3csIGNvdW50KSB7XG4gICAgLy8gZW5zdXJlIHRoYXQgZXZlcnkgY2VsbC1kZWxpbWl0aW5nIHBpcGUgaGFzIGEgc3BhY2VcbiAgICAvLyBiZWZvcmUgaXQgdG8gZGlzdGluZ3Vpc2ggaXQgZnJvbSBhbiBlc2NhcGVkIHBpcGVcbiAgICB2YXIgcm93ID0gdGFibGVSb3cucmVwbGFjZSgvXFx8L2csIGZ1bmN0aW9uIChtYXRjaCwgb2Zmc2V0LCBzdHIpIHtcbiAgICAgIHZhciBlc2NhcGVkID0gZmFsc2UsXG4gICAgICAgICAgY3VyciA9IG9mZnNldDtcblxuICAgICAgd2hpbGUgKC0tY3VyciA+PSAwICYmIHN0cltjdXJyXSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgICAgLy8gb2RkIG51bWJlciBvZiBzbGFzaGVzIG1lYW5zIHwgaXMgZXNjYXBlZFxuICAgICAgICAvLyBzbyB3ZSBsZWF2ZSBpdCBhbG9uZVxuICAgICAgICByZXR1cm4gJ3wnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWRkIHNwYWNlIGJlZm9yZSB1bmVzY2FwZWQgfFxuICAgICAgICByZXR1cm4gJyB8JztcbiAgICAgIH1cbiAgICB9KSxcbiAgICAgICAgY2VsbHMgPSByb3cuc3BsaXQoLyBcXHwvKTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBpZiAoY2VsbHMubGVuZ3RoID4gY291bnQpIHtcbiAgICAgIGNlbGxzLnNwbGljZShjb3VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChjZWxscy5sZW5ndGggPCBjb3VudCkge1xuICAgICAgICBjZWxscy5wdXNoKCcnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBsZWFkaW5nIG9yIHRyYWlsaW5nIHdoaXRlc3BhY2UgaXMgaWdub3JlZCBwZXIgdGhlIGdmbSBzcGVjXG4gICAgICBjZWxsc1tpXSA9IGNlbGxzW2ldLnRyaW0oKS5yZXBsYWNlKC9cXFxcXFx8L2csICd8Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNlbGxzO1xuICB9IC8vIFJlbW92ZSB0cmFpbGluZyAnYydzLiBFcXVpdmFsZW50IHRvIHN0ci5yZXBsYWNlKC9jKiQvLCAnJykuXG4gIC8vIC9jKiQvIGlzIHZ1bG5lcmFibGUgdG8gUkVET1MuXG4gIC8vIGludmVydDogUmVtb3ZlIHN1ZmZpeCBvZiBub24tYyBjaGFycyBpbnN0ZWFkLiBEZWZhdWx0IGZhbHNleS5cblxuXG4gIGZ1bmN0aW9uIHJ0cmltKHN0ciwgYywgaW52ZXJ0KSB7XG4gICAgdmFyIGwgPSBzdHIubGVuZ3RoO1xuXG4gICAgaWYgKGwgPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9IC8vIExlbmd0aCBvZiBzdWZmaXggbWF0Y2hpbmcgdGhlIGludmVydCBjb25kaXRpb24uXG5cblxuICAgIHZhciBzdWZmTGVuID0gMDsgLy8gU3RlcCBsZWZ0IHVudGlsIHdlIGZhaWwgdG8gbWF0Y2ggdGhlIGludmVydCBjb25kaXRpb24uXG5cbiAgICB3aGlsZSAoc3VmZkxlbiA8IGwpIHtcbiAgICAgIHZhciBjdXJyQ2hhciA9IHN0ci5jaGFyQXQobCAtIHN1ZmZMZW4gLSAxKTtcblxuICAgICAgaWYgKGN1cnJDaGFyID09PSBjICYmICFpbnZlcnQpIHtcbiAgICAgICAgc3VmZkxlbisrO1xuICAgICAgfSBlbHNlIGlmIChjdXJyQ2hhciAhPT0gYyAmJiBpbnZlcnQpIHtcbiAgICAgICAgc3VmZkxlbisrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgbCAtIHN1ZmZMZW4pO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZENsb3NpbmdCcmFja2V0KHN0ciwgYikge1xuICAgIGlmIChzdHIuaW5kZXhPZihiWzFdKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICB2YXIgbCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIGxldmVsID0gMCxcbiAgICAgICAgaSA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHN0cltpXSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIGkrKztcbiAgICAgIH0gZWxzZSBpZiAoc3RyW2ldID09PSBiWzBdKSB7XG4gICAgICAgIGxldmVsKys7XG4gICAgICB9IGVsc2UgaWYgKHN0cltpXSA9PT0gYlsxXSkge1xuICAgICAgICBsZXZlbC0tO1xuXG4gICAgICAgIGlmIChsZXZlbCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrU2FuaXRpemVEZXByZWNhdGlvbihvcHQpIHtcbiAgICBpZiAob3B0ICYmIG9wdC5zYW5pdGl6ZSAmJiAhb3B0LnNpbGVudCkge1xuICAgICAgY29uc29sZS53YXJuKCdtYXJrZWQoKTogc2FuaXRpemUgYW5kIHNhbml0aXplciBwYXJhbWV0ZXJzIGFyZSBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMC43LjAsIHNob3VsZCBub3QgYmUgdXNlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuIFJlYWQgbW9yZSBoZXJlOiBodHRwczovL21hcmtlZC5qcy5vcmcvIy9VU0lOR19BRFZBTkNFRC5tZCNvcHRpb25zJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhlbHBlcnMgPSB7XG4gICAgZXNjYXBlOiBlc2NhcGUsXG4gICAgdW5lc2NhcGU6IHVuZXNjYXBlLFxuICAgIGVkaXQ6IGVkaXQsXG4gICAgY2xlYW5Vcmw6IGNsZWFuVXJsLFxuICAgIHJlc29sdmVVcmw6IHJlc29sdmVVcmwsXG4gICAgbm9vcFRlc3Q6IG5vb3BUZXN0LFxuICAgIG1lcmdlOiBtZXJnZSxcbiAgICBzcGxpdENlbGxzOiBzcGxpdENlbGxzLFxuICAgIHJ0cmltOiBydHJpbSxcbiAgICBmaW5kQ2xvc2luZ0JyYWNrZXQ6IGZpbmRDbG9zaW5nQnJhY2tldCxcbiAgICBjaGVja1Nhbml0aXplRGVwcmVjYXRpb246IGNoZWNrU2FuaXRpemVEZXByZWNhdGlvblxuICB9O1xuXG4gIHZhciBkZWZhdWx0cyQxID0gZGVmYXVsdHMuZGVmYXVsdHM7XG4gIHZhciBydHJpbSQxID0gaGVscGVycy5ydHJpbSxcbiAgICAgIHNwbGl0Q2VsbHMkMSA9IGhlbHBlcnMuc3BsaXRDZWxscyxcbiAgICAgIF9lc2NhcGUgPSBoZWxwZXJzLmVzY2FwZSxcbiAgICAgIGZpbmRDbG9zaW5nQnJhY2tldCQxID0gaGVscGVycy5maW5kQ2xvc2luZ0JyYWNrZXQ7XG5cbiAgZnVuY3Rpb24gb3V0cHV0TGluayhjYXAsIGxpbmssIHJhdykge1xuICAgIHZhciBocmVmID0gbGluay5ocmVmO1xuICAgIHZhciB0aXRsZSA9IGxpbmsudGl0bGUgPyBfZXNjYXBlKGxpbmsudGl0bGUpIDogbnVsbDtcbiAgICB2YXIgdGV4dCA9IGNhcFsxXS5yZXBsYWNlKC9cXFxcKFtcXFtcXF1dKS9nLCAnJDEnKTtcblxuICAgIGlmIChjYXBbMF0uY2hhckF0KDApICE9PSAnIScpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgICAgcmF3OiByYXcsXG4gICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgdGV4dDogdGV4dFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgcmF3OiByYXcsXG4gICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgdGV4dDogX2VzY2FwZSh0ZXh0KVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbmRlbnRDb2RlQ29tcGVuc2F0aW9uKHJhdywgdGV4dCkge1xuICAgIHZhciBtYXRjaEluZGVudFRvQ29kZSA9IHJhdy5tYXRjaCgvXihcXHMrKSg/OmBgYCkvKTtcblxuICAgIGlmIChtYXRjaEluZGVudFRvQ29kZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGluZGVudFRvQ29kZSA9IG1hdGNoSW5kZW50VG9Db2RlWzFdO1xuICAgIHJldHVybiB0ZXh0LnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBtYXRjaEluZGVudEluTm9kZSA9IG5vZGUubWF0Y2goL15cXHMrLyk7XG5cbiAgICAgIGlmIChtYXRjaEluZGVudEluTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGVudEluTm9kZSA9IG1hdGNoSW5kZW50SW5Ob2RlWzBdO1xuXG4gICAgICBpZiAoaW5kZW50SW5Ob2RlLmxlbmd0aCA+PSBpbmRlbnRUb0NvZGUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBub2RlLnNsaWNlKGluZGVudFRvQ29kZS5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KS5qb2luKCdcXG4nKTtcbiAgfVxuICAvKipcbiAgICogVG9rZW5pemVyXG4gICAqL1xuXG5cbiAgdmFyIFRva2VuaXplcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb2tlbml6ZXIob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQxO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBUb2tlbml6ZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLnNwYWNlID0gZnVuY3Rpb24gc3BhY2Uoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5uZXdsaW5lLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICBpZiAoY2FwWzBdLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ3NwYWNlJyxcbiAgICAgICAgICAgIHJhdzogY2FwWzBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmF3OiAnXFxuJ1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uY29kZSA9IGZ1bmN0aW9uIGNvZGUoc3JjLCB0b2tlbnMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmNvZGUuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdOyAvLyBBbiBpbmRlbnRlZCBjb2RlIGJsb2NrIGNhbm5vdCBpbnRlcnJ1cHQgYSBwYXJhZ3JhcGguXG5cbiAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICB0ZXh0OiBjYXBbMF0udHJpbVJpZ2h0KClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHQgPSBjYXBbMF0ucmVwbGFjZSgvXiB7NH0vZ20sICcnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgY29kZUJsb2NrU3R5bGU6ICdpbmRlbnRlZCcsXG4gICAgICAgICAgdGV4dDogIXRoaXMub3B0aW9ucy5wZWRhbnRpYyA/IHJ0cmltJDEodGV4dCwgJ1xcbicpIDogdGV4dFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uZmVuY2VzID0gZnVuY3Rpb24gZmVuY2VzKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2suZmVuY2VzLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgcmF3ID0gY2FwWzBdO1xuICAgICAgICB2YXIgdGV4dCA9IGluZGVudENvZGVDb21wZW5zYXRpb24ocmF3LCBjYXBbM10gfHwgJycpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgICByYXc6IHJhdyxcbiAgICAgICAgICBsYW5nOiBjYXBbMl0gPyBjYXBbMl0udHJpbSgpIDogY2FwWzJdLFxuICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmhlYWRpbmcgPSBmdW5jdGlvbiBoZWFkaW5nKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2suaGVhZGluZy5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgZGVwdGg6IGNhcFsxXS5sZW5ndGgsXG4gICAgICAgICAgdGV4dDogY2FwWzJdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5ucHRhYmxlID0gZnVuY3Rpb24gbnB0YWJsZShzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLm5wdGFibGUuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciBpdGVtID0ge1xuICAgICAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICAgICAgaGVhZGVyOiBzcGxpdENlbGxzJDEoY2FwWzFdLnJlcGxhY2UoL14gKnwgKlxcfCAqJC9nLCAnJykpLFxuICAgICAgICAgIGFsaWduOiBjYXBbMl0ucmVwbGFjZSgvXiAqfFxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgICBjZWxsczogY2FwWzNdID8gY2FwWzNdLnJlcGxhY2UoL1xcbiQvLCAnJykuc3BsaXQoJ1xcbicpIDogW10sXG4gICAgICAgICAgcmF3OiBjYXBbMF1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaXRlbS5oZWFkZXIubGVuZ3RoID09PSBpdGVtLmFsaWduLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBsID0gaXRlbS5hbGlnbi5sZW5ndGg7XG4gICAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoL14gKi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ3JpZ2h0JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL14gKjotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdjZW50ZXInO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnbGVmdCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsID0gaXRlbS5jZWxscy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtLmNlbGxzW2ldID0gc3BsaXRDZWxscyQxKGl0ZW0uY2VsbHNbaV0sIGl0ZW0uaGVhZGVyLmxlbmd0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmhyID0gZnVuY3Rpb24gaHIoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oci5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnaHInLFxuICAgICAgICAgIHJhdzogY2FwWzBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5ibG9ja3F1b3RlID0gZnVuY3Rpb24gYmxvY2txdW90ZShzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmJsb2NrcXVvdGUuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gY2FwWzBdLnJlcGxhY2UoL14gKj4gPy9nbSwgJycpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdibG9ja3F1b3RlJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5saXN0ID0gZnVuY3Rpb24gbGlzdChzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmxpc3QuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciByYXcgPSBjYXBbMF07XG4gICAgICAgIHZhciBidWxsID0gY2FwWzJdO1xuICAgICAgICB2YXIgaXNvcmRlcmVkID0gYnVsbC5sZW5ndGggPiAxO1xuICAgICAgICB2YXIgaXNwYXJlbiA9IGJ1bGxbYnVsbC5sZW5ndGggLSAxXSA9PT0gJyknO1xuICAgICAgICB2YXIgbGlzdCA9IHtcbiAgICAgICAgICB0eXBlOiAnbGlzdCcsXG4gICAgICAgICAgcmF3OiByYXcsXG4gICAgICAgICAgb3JkZXJlZDogaXNvcmRlcmVkLFxuICAgICAgICAgIHN0YXJ0OiBpc29yZGVyZWQgPyArYnVsbC5zbGljZSgwLCAtMSkgOiAnJyxcbiAgICAgICAgICBsb29zZTogZmFsc2UsXG4gICAgICAgICAgaXRlbXM6IFtdXG4gICAgICAgIH07IC8vIEdldCBlYWNoIHRvcC1sZXZlbCBpdGVtLlxuXG4gICAgICAgIHZhciBpdGVtTWF0Y2ggPSBjYXBbMF0ubWF0Y2godGhpcy5ydWxlcy5ibG9jay5pdGVtKTtcbiAgICAgICAgdmFyIG5leHQgPSBmYWxzZSxcbiAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICBzcGFjZSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBhZGRCYWNrLFxuICAgICAgICAgICAgbG9vc2UsXG4gICAgICAgICAgICBpc3Rhc2ssXG4gICAgICAgICAgICBpc2NoZWNrZWQ7XG4gICAgICAgIHZhciBsID0gaXRlbU1hdGNoLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGl0ZW0gPSBpdGVtTWF0Y2hbaV07XG4gICAgICAgICAgcmF3ID0gaXRlbTsgLy8gUmVtb3ZlIHRoZSBsaXN0IGl0ZW0ncyBidWxsZXRcbiAgICAgICAgICAvLyBzbyBpdCBpcyBzZWVuIGFzIHRoZSBuZXh0IHRva2VuLlxuXG4gICAgICAgICAgc3BhY2UgPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICBpdGVtID0gaXRlbS5yZXBsYWNlKC9eICooWyorLV18XFxkK1suKV0pICovLCAnJyk7IC8vIE91dGRlbnQgd2hhdGV2ZXIgdGhlXG4gICAgICAgICAgLy8gbGlzdCBpdGVtIGNvbnRhaW5zLiBIYWNreS5cblxuICAgICAgICAgIGlmICh+aXRlbS5pbmRleE9mKCdcXG4gJykpIHtcbiAgICAgICAgICAgIHNwYWNlIC09IGl0ZW0ubGVuZ3RoO1xuICAgICAgICAgICAgaXRlbSA9ICF0aGlzLm9wdGlvbnMucGVkYW50aWMgPyBpdGVtLnJlcGxhY2UobmV3IFJlZ0V4cCgnXiB7MSwnICsgc3BhY2UgKyAnfScsICdnbScpLCAnJykgOiBpdGVtLnJlcGxhY2UoL14gezEsNH0vZ20sICcnKTtcbiAgICAgICAgICB9IC8vIERldGVybWluZSB3aGV0aGVyIHRoZSBuZXh0IGxpc3QgaXRlbSBiZWxvbmdzIGhlcmUuXG4gICAgICAgICAgLy8gQmFja3BlZGFsIGlmIGl0IGRvZXMgbm90IGJlbG9uZyBpbiB0aGlzIGxpc3QuXG5cblxuICAgICAgICAgIGlmIChpICE9PSBsIC0gMSkge1xuICAgICAgICAgICAgYiA9IHRoaXMucnVsZXMuYmxvY2suYnVsbGV0LmV4ZWMoaXRlbU1hdGNoW2kgKyAxXSlbMF07XG5cbiAgICAgICAgICAgIGlmIChpc29yZGVyZWQgPyBiLmxlbmd0aCA9PT0gMSB8fCAhaXNwYXJlbiAmJiBiW2IubGVuZ3RoIC0gMV0gPT09ICcpJyA6IGIubGVuZ3RoID4gMSB8fCB0aGlzLm9wdGlvbnMuc21hcnRMaXN0cyAmJiBiICE9PSBidWxsKSB7XG4gICAgICAgICAgICAgIGFkZEJhY2sgPSBpdGVtTWF0Y2guc2xpY2UoaSArIDEpLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICBsaXN0LnJhdyA9IGxpc3QucmF3LnN1YnN0cmluZygwLCBsaXN0LnJhdy5sZW5ndGggLSBhZGRCYWNrLmxlbmd0aCk7XG4gICAgICAgICAgICAgIGkgPSBsIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIERldGVybWluZSB3aGV0aGVyIGl0ZW0gaXMgbG9vc2Ugb3Igbm90LlxuICAgICAgICAgIC8vIFVzZTogLyhefFxcbikoPyEgKVteXFxuXStcXG5cXG4oPyFcXHMqJCkvXG4gICAgICAgICAgLy8gZm9yIGRpc2NvdW50IGJlaGF2aW9yLlxuXG5cbiAgICAgICAgICBsb29zZSA9IG5leHQgfHwgL1xcblxcbig/IVxccyokKS8udGVzdChpdGVtKTtcblxuICAgICAgICAgIGlmIChpICE9PSBsIC0gMSkge1xuICAgICAgICAgICAgbmV4dCA9IGl0ZW0uY2hhckF0KGl0ZW0ubGVuZ3RoIC0gMSkgPT09ICdcXG4nO1xuICAgICAgICAgICAgaWYgKCFsb29zZSkgbG9vc2UgPSBuZXh0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsb29zZSkge1xuICAgICAgICAgICAgbGlzdC5sb29zZSA9IHRydWU7XG4gICAgICAgICAgfSAvLyBDaGVjayBmb3IgdGFzayBsaXN0IGl0ZW1zXG5cblxuICAgICAgICAgIGlzdGFzayA9IC9eXFxbWyB4WF1cXF0gLy50ZXN0KGl0ZW0pO1xuICAgICAgICAgIGlzY2hlY2tlZCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChpc3Rhc2spIHtcbiAgICAgICAgICAgIGlzY2hlY2tlZCA9IGl0ZW1bMV0gIT09ICcgJztcbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtLnJlcGxhY2UoL15cXFtbIHhYXVxcXSArLywgJycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3QuaXRlbXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnbGlzdF9pdGVtJyxcbiAgICAgICAgICAgIHJhdzogcmF3LFxuICAgICAgICAgICAgdGFzazogaXN0YXNrLFxuICAgICAgICAgICAgY2hlY2tlZDogaXNjaGVja2VkLFxuICAgICAgICAgICAgbG9vc2U6IGxvb3NlLFxuICAgICAgICAgICAgdGV4dDogaXRlbVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5odG1sID0gZnVuY3Rpb24gaHRtbChzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmh0bWwuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogdGhpcy5vcHRpb25zLnNhbml0aXplID8gJ3BhcmFncmFwaCcgOiAnaHRtbCcsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgcHJlOiAhdGhpcy5vcHRpb25zLnNhbml0aXplciAmJiAoY2FwWzFdID09PSAncHJlJyB8fCBjYXBbMV0gPT09ICdzY3JpcHQnIHx8IGNhcFsxXSA9PT0gJ3N0eWxlJyksXG4gICAgICAgICAgdGV4dDogdGhpcy5vcHRpb25zLnNhbml0aXplID8gdGhpcy5vcHRpb25zLnNhbml0aXplciA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIoY2FwWzBdKSA6IF9lc2NhcGUoY2FwWzBdKSA6IGNhcFswXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uZGVmID0gZnVuY3Rpb24gZGVmKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2suZGVmLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICBpZiAoY2FwWzNdKSBjYXBbM10gPSBjYXBbM10uc3Vic3RyaW5nKDEsIGNhcFszXS5sZW5ndGggLSAxKTtcbiAgICAgICAgdmFyIHRhZyA9IGNhcFsxXS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICBocmVmOiBjYXBbMl0sXG4gICAgICAgICAgdGl0bGU6IGNhcFszXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8udGFibGUgPSBmdW5jdGlvbiB0YWJsZShzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLnRhYmxlLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgaXRlbSA9IHtcbiAgICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICAgIGhlYWRlcjogc3BsaXRDZWxscyQxKGNhcFsxXS5yZXBsYWNlKC9eICp8ICpcXHwgKiQvZywgJycpKSxcbiAgICAgICAgICBhbGlnbjogY2FwWzJdLnJlcGxhY2UoL14gKnxcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgICAgY2VsbHM6IGNhcFszXSA/IGNhcFszXS5yZXBsYWNlKC9cXG4kLywgJycpLnNwbGl0KCdcXG4nKSA6IFtdXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGl0ZW0uaGVhZGVyLmxlbmd0aCA9PT0gaXRlbS5hbGlnbi5sZW5ndGgpIHtcbiAgICAgICAgICBpdGVtLnJhdyA9IGNhcFswXTtcbiAgICAgICAgICB2YXIgbCA9IGl0ZW0uYWxpZ24ubGVuZ3RoO1xuICAgICAgICAgIHZhciBpO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKC9eICotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdyaWdodCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnY2VudGVyJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL14gKjotKyAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2xlZnQnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbCA9IGl0ZW0uY2VsbHMubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaXRlbS5jZWxsc1tpXSA9IHNwbGl0Q2VsbHMkMShpdGVtLmNlbGxzW2ldLnJlcGxhY2UoL14gKlxcfCAqfCAqXFx8ICokL2csICcnKSwgaXRlbS5oZWFkZXIubGVuZ3RoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8ubGhlYWRpbmcgPSBmdW5jdGlvbiBsaGVhZGluZyhzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmxoZWFkaW5nLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICBkZXB0aDogY2FwWzJdLmNoYXJBdCgwKSA9PT0gJz0nID8gMSA6IDIsXG4gICAgICAgICAgdGV4dDogY2FwWzFdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5wYXJhZ3JhcGggPSBmdW5jdGlvbiBwYXJhZ3JhcGgoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5wYXJhZ3JhcGguZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogY2FwWzFdLmNoYXJBdChjYXBbMV0ubGVuZ3RoIC0gMSkgPT09ICdcXG4nID8gY2FwWzFdLnNsaWNlKDAsIC0xKSA6IGNhcFsxXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8udGV4dCA9IGZ1bmN0aW9uIHRleHQoc3JjLCB0b2tlbnMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLnRleHQuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChsYXN0VG9rZW4gJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgIHRleHQ6IGNhcFswXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICB0ZXh0OiBjYXBbMF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmVzY2FwZSA9IGZ1bmN0aW9uIGVzY2FwZShzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5lc2NhcGUuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2VzY2FwZScsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogX2VzY2FwZShjYXBbMV0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by50YWcgPSBmdW5jdGlvbiB0YWcoc3JjLCBpbkxpbmssIGluUmF3QmxvY2spIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS50YWcuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIGlmICghaW5MaW5rICYmIC9ePGEgL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgaW5MaW5rID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpbkxpbmsgJiYgL148XFwvYT4vaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgICBpbkxpbmsgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaW5SYXdCbG9jayAmJiAvXjwocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgaW5SYXdCbG9jayA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5SYXdCbG9jayAmJiAvXjxcXC8ocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgaW5SYXdCbG9jayA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiB0aGlzLm9wdGlvbnMuc2FuaXRpemUgPyAndGV4dCcgOiAnaHRtbCcsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgaW5MaW5rOiBpbkxpbmssXG4gICAgICAgICAgaW5SYXdCbG9jazogaW5SYXdCbG9jayxcbiAgICAgICAgICB0ZXh0OiB0aGlzLm9wdGlvbnMuc2FuaXRpemUgPyB0aGlzLm9wdGlvbnMuc2FuaXRpemVyID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pIDogX2VzY2FwZShjYXBbMF0pIDogY2FwWzBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5saW5rID0gZnVuY3Rpb24gbGluayhzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5saW5rLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgbGFzdFBhcmVuSW5kZXggPSBmaW5kQ2xvc2luZ0JyYWNrZXQkMShjYXBbMl0sICcoKScpO1xuXG4gICAgICAgIGlmIChsYXN0UGFyZW5JbmRleCA+IC0xKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gY2FwWzBdLmluZGV4T2YoJyEnKSA9PT0gMCA/IDUgOiA0O1xuICAgICAgICAgIHZhciBsaW5rTGVuID0gc3RhcnQgKyBjYXBbMV0ubGVuZ3RoICsgbGFzdFBhcmVuSW5kZXg7XG4gICAgICAgICAgY2FwWzJdID0gY2FwWzJdLnN1YnN0cmluZygwLCBsYXN0UGFyZW5JbmRleCk7XG4gICAgICAgICAgY2FwWzBdID0gY2FwWzBdLnN1YnN0cmluZygwLCBsaW5rTGVuKS50cmltKCk7XG4gICAgICAgICAgY2FwWzNdID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaHJlZiA9IGNhcFsyXTtcbiAgICAgICAgdmFyIHRpdGxlID0gJyc7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgIHZhciBsaW5rID0gL14oW14nXCJdKlteXFxzXSlcXHMrKFsnXCJdKSguKilcXDIvLmV4ZWMoaHJlZik7XG5cbiAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgaHJlZiA9IGxpbmtbMV07XG4gICAgICAgICAgICB0aXRsZSA9IGxpbmtbM107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpdGxlID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpdGxlID0gY2FwWzNdID8gY2FwWzNdLnNsaWNlKDEsIC0xKSA6ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaHJlZiA9IGhyZWYudHJpbSgpLnJlcGxhY2UoL148KFtcXHNcXFNdKik+JC8sICckMScpO1xuICAgICAgICB2YXIgdG9rZW4gPSBvdXRwdXRMaW5rKGNhcCwge1xuICAgICAgICAgIGhyZWY6IGhyZWYgPyBocmVmLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuX2VzY2FwZXMsICckMScpIDogaHJlZixcbiAgICAgICAgICB0aXRsZTogdGl0bGUgPyB0aXRsZS5yZXBsYWNlKHRoaXMucnVsZXMuaW5saW5lLl9lc2NhcGVzLCAnJDEnKSA6IHRpdGxlXG4gICAgICAgIH0sIGNhcFswXSk7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLnJlZmxpbmsgPSBmdW5jdGlvbiByZWZsaW5rKHNyYywgbGlua3MpIHtcbiAgICAgIHZhciBjYXA7XG5cbiAgICAgIGlmICgoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUucmVmbGluay5leGVjKHNyYykpIHx8IChjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5ub2xpbmsuZXhlYyhzcmMpKSkge1xuICAgICAgICB2YXIgbGluayA9IChjYXBbMl0gfHwgY2FwWzFdKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgICAgIGxpbmsgPSBsaW5rc1tsaW5rLnRvTG93ZXJDYXNlKCldO1xuXG4gICAgICAgIGlmICghbGluayB8fCAhbGluay5ocmVmKSB7XG4gICAgICAgICAgdmFyIHRleHQgPSBjYXBbMF0uY2hhckF0KDApO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICByYXc6IHRleHQsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b2tlbiA9IG91dHB1dExpbmsoY2FwLCBsaW5rLCBjYXBbMF0pO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5zdHJvbmcgPSBmdW5jdGlvbiBzdHJvbmcoc3JjLCBtYXNrZWRTcmMsIHByZXZDaGFyKSB7XG4gICAgICBpZiAocHJldkNoYXIgPT09IHZvaWQgMCkge1xuICAgICAgICBwcmV2Q2hhciA9ICcnO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF0Y2ggPSB0aGlzLnJ1bGVzLmlubGluZS5zdHJvbmcuc3RhcnQuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAobWF0Y2ggJiYgKCFtYXRjaFsxXSB8fCBtYXRjaFsxXSAmJiAocHJldkNoYXIgPT09ICcnIHx8IHRoaXMucnVsZXMuaW5saW5lLnB1bmN0dWF0aW9uLmV4ZWMocHJldkNoYXIpKSkpIHtcbiAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKC0xICogc3JjLmxlbmd0aCk7XG4gICAgICAgIHZhciBlbmRSZWcgPSBtYXRjaFswXSA9PT0gJyoqJyA/IHRoaXMucnVsZXMuaW5saW5lLnN0cm9uZy5lbmRBc3QgOiB0aGlzLnJ1bGVzLmlubGluZS5zdHJvbmcuZW5kVW5kO1xuICAgICAgICBlbmRSZWcubGFzdEluZGV4ID0gMDtcbiAgICAgICAgdmFyIGNhcDtcblxuICAgICAgICB3aGlsZSAoKG1hdGNoID0gZW5kUmVnLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnN0cm9uZy5taWRkbGUuZXhlYyhtYXNrZWRTcmMuc2xpY2UoMCwgbWF0Y2guaW5kZXggKyAzKSk7XG5cbiAgICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiAnc3Ryb25nJyxcbiAgICAgICAgICAgICAgcmF3OiBzcmMuc2xpY2UoMCwgY2FwWzBdLmxlbmd0aCksXG4gICAgICAgICAgICAgIHRleHQ6IHNyYy5zbGljZSgyLCBjYXBbMF0ubGVuZ3RoIC0gMilcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5lbSA9IGZ1bmN0aW9uIGVtKHNyYywgbWFza2VkU3JjLCBwcmV2Q2hhcikge1xuICAgICAgaWYgKHByZXZDaGFyID09PSB2b2lkIDApIHtcbiAgICAgICAgcHJldkNoYXIgPSAnJztcbiAgICAgIH1cblxuICAgICAgdmFyIG1hdGNoID0gdGhpcy5ydWxlcy5pbmxpbmUuZW0uc3RhcnQuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAobWF0Y2ggJiYgKCFtYXRjaFsxXSB8fCBtYXRjaFsxXSAmJiAocHJldkNoYXIgPT09ICcnIHx8IHRoaXMucnVsZXMuaW5saW5lLnB1bmN0dWF0aW9uLmV4ZWMocHJldkNoYXIpKSkpIHtcbiAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKC0xICogc3JjLmxlbmd0aCk7XG4gICAgICAgIHZhciBlbmRSZWcgPSBtYXRjaFswXSA9PT0gJyonID8gdGhpcy5ydWxlcy5pbmxpbmUuZW0uZW5kQXN0IDogdGhpcy5ydWxlcy5pbmxpbmUuZW0uZW5kVW5kO1xuICAgICAgICBlbmRSZWcubGFzdEluZGV4ID0gMDtcbiAgICAgICAgdmFyIGNhcDtcblxuICAgICAgICB3aGlsZSAoKG1hdGNoID0gZW5kUmVnLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmVtLm1pZGRsZS5leGVjKG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCArIDIpKTtcblxuICAgICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdlbScsXG4gICAgICAgICAgICAgIHJhdzogc3JjLnNsaWNlKDAsIGNhcFswXS5sZW5ndGgpLFxuICAgICAgICAgICAgICB0ZXh0OiBzcmMuc2xpY2UoMSwgY2FwWzBdLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uY29kZXNwYW4gPSBmdW5jdGlvbiBjb2Rlc3BhbihzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5jb2RlLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgdGV4dCA9IGNhcFsyXS5yZXBsYWNlKC9cXG4vZywgJyAnKTtcbiAgICAgICAgdmFyIGhhc05vblNwYWNlQ2hhcnMgPSAvW14gXS8udGVzdCh0ZXh0KTtcbiAgICAgICAgdmFyIGhhc1NwYWNlQ2hhcnNPbkJvdGhFbmRzID0gdGV4dC5zdGFydHNXaXRoKCcgJykgJiYgdGV4dC5lbmRzV2l0aCgnICcpO1xuXG4gICAgICAgIGlmIChoYXNOb25TcGFjZUNoYXJzICYmIGhhc1NwYWNlQ2hhcnNPbkJvdGhFbmRzKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDEsIHRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0ID0gX2VzY2FwZSh0ZXh0LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnY29kZXNwYW4nLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmJyID0gZnVuY3Rpb24gYnIoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuYnIuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2JyJyxcbiAgICAgICAgICByYXc6IGNhcFswXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uZGVsID0gZnVuY3Rpb24gZGVsKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmRlbC5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnZGVsJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICB0ZXh0OiBjYXBbMV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmF1dG9saW5rID0gZnVuY3Rpb24gYXV0b2xpbmsoc3JjLCBtYW5nbGUpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5hdXRvbGluay5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgdmFyIHRleHQsIGhyZWY7XG5cbiAgICAgICAgaWYgKGNhcFsyXSA9PT0gJ0AnKSB7XG4gICAgICAgICAgdGV4dCA9IF9lc2NhcGUodGhpcy5vcHRpb25zLm1hbmdsZSA/IG1hbmdsZShjYXBbMV0pIDogY2FwWzFdKTtcbiAgICAgICAgICBocmVmID0gJ21haWx0bzonICsgdGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0ID0gX2VzY2FwZShjYXBbMV0pO1xuICAgICAgICAgIGhyZWYgPSB0ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgIHRva2VuczogW3tcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8udXJsID0gZnVuY3Rpb24gdXJsKHNyYywgbWFuZ2xlKSB7XG4gICAgICB2YXIgY2FwO1xuXG4gICAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudXJsLmV4ZWMoc3JjKSkge1xuICAgICAgICB2YXIgdGV4dCwgaHJlZjtcblxuICAgICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgICB0ZXh0ID0gX2VzY2FwZSh0aGlzLm9wdGlvbnMubWFuZ2xlID8gbWFuZ2xlKGNhcFswXSkgOiBjYXBbMF0pO1xuICAgICAgICAgIGhyZWYgPSAnbWFpbHRvOicgKyB0ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRvIGV4dGVuZGVkIGF1dG9saW5rIHBhdGggdmFsaWRhdGlvblxuICAgICAgICAgIHZhciBwcmV2Q2FwWmVybztcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIHByZXZDYXBaZXJvID0gY2FwWzBdO1xuICAgICAgICAgICAgY2FwWzBdID0gdGhpcy5ydWxlcy5pbmxpbmUuX2JhY2twZWRhbC5leGVjKGNhcFswXSlbMF07XG4gICAgICAgICAgfSB3aGlsZSAocHJldkNhcFplcm8gIT09IGNhcFswXSk7XG5cbiAgICAgICAgICB0ZXh0ID0gX2VzY2FwZShjYXBbMF0pO1xuXG4gICAgICAgICAgaWYgKGNhcFsxXSA9PT0gJ3d3dy4nKSB7XG4gICAgICAgICAgICBocmVmID0gJ2h0dHA6Ly8nICsgdGV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgIHRva2VuczogW3tcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uaW5saW5lVGV4dCA9IGZ1bmN0aW9uIGlubGluZVRleHQoc3JjLCBpblJhd0Jsb2NrLCBzbWFydHlwYW50cykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnRleHQuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciB0ZXh0O1xuXG4gICAgICAgIGlmIChpblJhd0Jsb2NrKSB7XG4gICAgICAgICAgdGV4dCA9IHRoaXMub3B0aW9ucy5zYW5pdGl6ZSA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIgPyB0aGlzLm9wdGlvbnMuc2FuaXRpemVyKGNhcFswXSkgOiBfZXNjYXBlKGNhcFswXSkgOiBjYXBbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dCA9IF9lc2NhcGUodGhpcy5vcHRpb25zLnNtYXJ0eXBhbnRzID8gc21hcnR5cGFudHMoY2FwWzBdKSA6IGNhcFswXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBUb2tlbml6ZXI7XG4gIH0oKTtcblxuICB2YXIgbm9vcFRlc3QkMSA9IGhlbHBlcnMubm9vcFRlc3QsXG4gICAgICBlZGl0JDEgPSBoZWxwZXJzLmVkaXQsXG4gICAgICBtZXJnZSQxID0gaGVscGVycy5tZXJnZTtcbiAgLyoqXG4gICAqIEJsb2NrLUxldmVsIEdyYW1tYXJcbiAgICovXG5cbiAgdmFyIGJsb2NrID0ge1xuICAgIG5ld2xpbmU6IC9eXFxuKy8sXG4gICAgY29kZTogL14oIHs0fVteXFxuXStcXG4qKSsvLFxuICAgIGZlbmNlczogL14gezAsM30oYHszLH0oPz1bXmBcXG5dKlxcbil8fnszLH0pKFteXFxuXSopXFxuKD86fChbXFxzXFxTXSo/KVxcbikoPzogezAsM31cXDFbfmBdKiAqKD86XFxuK3wkKXwkKS8sXG4gICAgaHI6IC9eIHswLDN9KCg/Oi0gKil7Myx9fCg/Ol8gKil7Myx9fCg/OlxcKiAqKXszLH0pKD86XFxuK3wkKS8sXG4gICAgaGVhZGluZzogL14gezAsM30oI3sxLDZ9KSArKFteXFxuXSo/KSg/OiArIyspPyAqKD86XFxuK3wkKS8sXG4gICAgYmxvY2txdW90ZTogL14oIHswLDN9PiA/KHBhcmFncmFwaHxbXlxcbl0qKSg/OlxcbnwkKSkrLyxcbiAgICBsaXN0OiAvXiggezAsM30pKGJ1bGwpIFtcXHNcXFNdKz8oPzpocnxkZWZ8XFxuezIsfSg/ISApKD8hXFwxYnVsbCApXFxuKnxcXHMqJCkvLFxuICAgIGh0bWw6ICdeIHswLDN9KD86JyAvLyBvcHRpb25hbCBpbmRlbnRhdGlvblxuICAgICsgJzwoc2NyaXB0fHByZXxzdHlsZSlbXFxcXHM+XVtcXFxcc1xcXFxTXSo/KD86PC9cXFxcMT5bXlxcXFxuXSpcXFxcbit8JCknIC8vICgxKVxuICAgICsgJ3xjb21tZW50W15cXFxcbl0qKFxcXFxuK3wkKScgLy8gKDIpXG4gICAgKyAnfDxcXFxcP1tcXFxcc1xcXFxTXSo/KD86XFxcXD8+XFxcXG4qfCQpJyAvLyAoMylcbiAgICArICd8PCFbQS1aXVtcXFxcc1xcXFxTXSo/KD86PlxcXFxuKnwkKScgLy8gKDQpXG4gICAgKyAnfDwhXFxcXFtDREFUQVxcXFxbW1xcXFxzXFxcXFNdKj8oPzpcXFxcXVxcXFxdPlxcXFxuKnwkKScgLy8gKDUpXG4gICAgKyAnfDwvPyh0YWcpKD86ICt8XFxcXG58Lz8+KVtcXFxcc1xcXFxTXSo/KD86XFxcXG57Mix9fCQpJyAvLyAoNilcbiAgICArICd8PCg/IXNjcmlwdHxwcmV8c3R5bGUpKFthLXpdW1xcXFx3LV0qKSg/OmF0dHJpYnV0ZSkqPyAqLz8+KD89WyBcXFxcdF0qKD86XFxcXG58JCkpW1xcXFxzXFxcXFNdKj8oPzpcXFxcbnsyLH18JCknIC8vICg3KSBvcGVuIHRhZ1xuICAgICsgJ3w8Lyg/IXNjcmlwdHxwcmV8c3R5bGUpW2Etel1bXFxcXHctXSpcXFxccyo+KD89WyBcXFxcdF0qKD86XFxcXG58JCkpW1xcXFxzXFxcXFNdKj8oPzpcXFxcbnsyLH18JCknIC8vICg3KSBjbG9zaW5nIHRhZ1xuICAgICsgJyknLFxuICAgIGRlZjogL14gezAsM31cXFsobGFiZWwpXFxdOiAqXFxuPyAqPD8oW15cXHM+XSspPj8oPzooPzogK1xcbj8gKnwgKlxcbiAqKSh0aXRsZSkpPyAqKD86XFxuK3wkKS8sXG4gICAgbnB0YWJsZTogbm9vcFRlc3QkMSxcbiAgICB0YWJsZTogbm9vcFRlc3QkMSxcbiAgICBsaGVhZGluZzogL14oW15cXG5dKylcXG4gezAsM30oPSt8LSspICooPzpcXG4rfCQpLyxcbiAgICAvLyByZWdleCB0ZW1wbGF0ZSwgcGxhY2Vob2xkZXJzIHdpbGwgYmUgcmVwbGFjZWQgYWNjb3JkaW5nIHRvIGRpZmZlcmVudCBwYXJhZ3JhcGhcbiAgICAvLyBpbnRlcnJ1cHRpb24gcnVsZXMgb2YgY29tbW9ubWFyayBhbmQgdGhlIG9yaWdpbmFsIG1hcmtkb3duIHNwZWM6XG4gICAgX3BhcmFncmFwaDogL14oW15cXG5dKyg/Olxcbig/IWhyfGhlYWRpbmd8bGhlYWRpbmd8YmxvY2txdW90ZXxmZW5jZXN8bGlzdHxodG1sKVteXFxuXSspKikvLFxuICAgIHRleHQ6IC9eW15cXG5dKy9cbiAgfTtcbiAgYmxvY2suX2xhYmVsID0gLyg/IVxccypcXF0pKD86XFxcXFtcXFtcXF1dfFteXFxbXFxdXSkrLztcbiAgYmxvY2suX3RpdGxlID0gLyg/OlwiKD86XFxcXFwiP3xbXlwiXFxcXF0pKlwifCdbXidcXG5dKig/OlxcblteJ1xcbl0rKSpcXG4/J3xcXChbXigpXSpcXCkpLztcbiAgYmxvY2suZGVmID0gZWRpdCQxKGJsb2NrLmRlZikucmVwbGFjZSgnbGFiZWwnLCBibG9jay5fbGFiZWwpLnJlcGxhY2UoJ3RpdGxlJywgYmxvY2suX3RpdGxlKS5nZXRSZWdleCgpO1xuICBibG9jay5idWxsZXQgPSAvKD86WyorLV18XFxkezEsOX1bLildKS87XG4gIGJsb2NrLml0ZW0gPSAvXiggKikoYnVsbCkgP1teXFxuXSooPzpcXG4oPyFcXDFidWxsID8pW15cXG5dKikqLztcbiAgYmxvY2suaXRlbSA9IGVkaXQkMShibG9jay5pdGVtLCAnZ20nKS5yZXBsYWNlKC9idWxsL2csIGJsb2NrLmJ1bGxldCkuZ2V0UmVnZXgoKTtcbiAgYmxvY2subGlzdCA9IGVkaXQkMShibG9jay5saXN0KS5yZXBsYWNlKC9idWxsL2csIGJsb2NrLmJ1bGxldCkucmVwbGFjZSgnaHInLCAnXFxcXG4rKD89XFxcXDE/KD86KD86LSAqKXszLH18KD86XyAqKXszLH18KD86XFxcXCogKil7Myx9KSg/OlxcXFxuK3wkKSknKS5yZXBsYWNlKCdkZWYnLCAnXFxcXG4rKD89JyArIGJsb2NrLmRlZi5zb3VyY2UgKyAnKScpLmdldFJlZ2V4KCk7XG4gIGJsb2NrLl90YWcgPSAnYWRkcmVzc3xhcnRpY2xlfGFzaWRlfGJhc2V8YmFzZWZvbnR8YmxvY2txdW90ZXxib2R5fGNhcHRpb24nICsgJ3xjZW50ZXJ8Y29sfGNvbGdyb3VwfGRkfGRldGFpbHN8ZGlhbG9nfGRpcnxkaXZ8ZGx8ZHR8ZmllbGRzZXR8ZmlnY2FwdGlvbicgKyAnfGZpZ3VyZXxmb290ZXJ8Zm9ybXxmcmFtZXxmcmFtZXNldHxoWzEtNl18aGVhZHxoZWFkZXJ8aHJ8aHRtbHxpZnJhbWUnICsgJ3xsZWdlbmR8bGl8bGlua3xtYWlufG1lbnV8bWVudWl0ZW18bWV0YXxuYXZ8bm9mcmFtZXN8b2x8b3B0Z3JvdXB8b3B0aW9uJyArICd8cHxwYXJhbXxzZWN0aW9ufHNvdXJjZXxzdW1tYXJ5fHRhYmxlfHRib2R5fHRkfHRmb290fHRofHRoZWFkfHRpdGxlfHRyJyArICd8dHJhY2t8dWwnO1xuICBibG9jay5fY29tbWVudCA9IC88IS0tKD8hLT8+KVtcXHNcXFNdKj8oPzotLT58JCkvO1xuICBibG9jay5odG1sID0gZWRpdCQxKGJsb2NrLmh0bWwsICdpJykucmVwbGFjZSgnY29tbWVudCcsIGJsb2NrLl9jb21tZW50KS5yZXBsYWNlKCd0YWcnLCBibG9jay5fdGFnKS5yZXBsYWNlKCdhdHRyaWJ1dGUnLCAvICtbYS16QS1aOl9dW1xcdy46LV0qKD86ICo9ICpcIlteXCJcXG5dKlwifCAqPSAqJ1teJ1xcbl0qJ3wgKj0gKlteXFxzXCInPTw+YF0rKT8vKS5nZXRSZWdleCgpO1xuICBibG9jay5wYXJhZ3JhcGggPSBlZGl0JDEoYmxvY2suX3BhcmFncmFwaCkucmVwbGFjZSgnaHInLCBibG9jay5ocikucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0gJykucmVwbGFjZSgnfGxoZWFkaW5nJywgJycpIC8vIHNldGV4IGhlYWRpbmdzIGRvbid0IGludGVycnVwdCBjb21tb25tYXJrIHBhcmFncmFwaHNcbiAgLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpLnJlcGxhY2UoJ2ZlbmNlcycsICcgezAsM30oPzpgezMsfSg/PVteYFxcXFxuXSpcXFxcbil8fnszLH0pW15cXFxcbl0qXFxcXG4nKS5yZXBsYWNlKCdsaXN0JywgJyB7MCwzfSg/OlsqKy1dfDFbLildKSAnKSAvLyBvbmx5IGxpc3RzIHN0YXJ0aW5nIGZyb20gMSBjYW4gaW50ZXJydXB0XG4gIC5yZXBsYWNlKCdodG1sJywgJzwvPyg/OnRhZykoPzogK3xcXFxcbnwvPz4pfDwoPzpzY3JpcHR8cHJlfHN0eWxlfCEtLSknKS5yZXBsYWNlKCd0YWcnLCBibG9jay5fdGFnKSAvLyBwYXJzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAuZ2V0UmVnZXgoKTtcbiAgYmxvY2suYmxvY2txdW90ZSA9IGVkaXQkMShibG9jay5ibG9ja3F1b3RlKS5yZXBsYWNlKCdwYXJhZ3JhcGgnLCBibG9jay5wYXJhZ3JhcGgpLmdldFJlZ2V4KCk7XG4gIC8qKlxuICAgKiBOb3JtYWwgQmxvY2sgR3JhbW1hclxuICAgKi9cblxuICBibG9jay5ub3JtYWwgPSBtZXJnZSQxKHt9LCBibG9jayk7XG4gIC8qKlxuICAgKiBHRk0gQmxvY2sgR3JhbW1hclxuICAgKi9cblxuICBibG9jay5nZm0gPSBtZXJnZSQxKHt9LCBibG9jay5ub3JtYWwsIHtcbiAgICBucHRhYmxlOiAnXiAqKFtefFxcXFxuIF0uKlxcXFx8LiopXFxcXG4nIC8vIEhlYWRlclxuICAgICsgJyB7MCwzfShbLTpdKyAqXFxcXHxbLXwgOl0qKScgLy8gQWxpZ25cbiAgICArICcoPzpcXFxcbigoPzooPyFcXFxcbnxocnxoZWFkaW5nfGJsb2NrcXVvdGV8Y29kZXxmZW5jZXN8bGlzdHxodG1sKS4qKD86XFxcXG58JCkpKilcXFxcbip8JCknLFxuICAgIC8vIENlbGxzXG4gICAgdGFibGU6ICdeICpcXFxcfCguKylcXFxcbicgLy8gSGVhZGVyXG4gICAgKyAnIHswLDN9XFxcXHw/KCAqWy06XStbLXwgOl0qKScgLy8gQWxpZ25cbiAgICArICcoPzpcXFxcbiAqKCg/Oig/IVxcXFxufGhyfGhlYWRpbmd8YmxvY2txdW90ZXxjb2RlfGZlbmNlc3xsaXN0fGh0bWwpLiooPzpcXFxcbnwkKSkqKVxcXFxuKnwkKScgLy8gQ2VsbHNcblxuICB9KTtcbiAgYmxvY2suZ2ZtLm5wdGFibGUgPSBlZGl0JDEoYmxvY2suZ2ZtLm5wdGFibGUpLnJlcGxhY2UoJ2hyJywgYmxvY2suaHIpLnJlcGxhY2UoJ2hlYWRpbmcnLCAnIHswLDN9I3sxLDZ9ICcpLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpLnJlcGxhY2UoJ2NvZGUnLCAnIHs0fVteXFxcXG5dJykucmVwbGFjZSgnZmVuY2VzJywgJyB7MCwzfSg/OmB7Myx9KD89W15gXFxcXG5dKlxcXFxuKXx+ezMsfSlbXlxcXFxuXSpcXFxcbicpLnJlcGxhY2UoJ2xpc3QnLCAnIHswLDN9KD86WyorLV18MVsuKV0pICcpIC8vIG9ubHkgbGlzdHMgc3RhcnRpbmcgZnJvbSAxIGNhbiBpbnRlcnJ1cHRcbiAgLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8IS0tKScpLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpIC8vIHRhYmxlcyBjYW4gYmUgaW50ZXJydXB0ZWQgYnkgdHlwZSAoNikgaHRtbCBibG9ja3NcbiAgLmdldFJlZ2V4KCk7XG4gIGJsb2NrLmdmbS50YWJsZSA9IGVkaXQkMShibG9jay5nZm0udGFibGUpLnJlcGxhY2UoJ2hyJywgYmxvY2suaHIpLnJlcGxhY2UoJ2hlYWRpbmcnLCAnIHswLDN9I3sxLDZ9ICcpLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpLnJlcGxhY2UoJ2NvZGUnLCAnIHs0fVteXFxcXG5dJykucmVwbGFjZSgnZmVuY2VzJywgJyB7MCwzfSg/OmB7Myx9KD89W15gXFxcXG5dKlxcXFxuKXx+ezMsfSlbXlxcXFxuXSpcXFxcbicpLnJlcGxhY2UoJ2xpc3QnLCAnIHswLDN9KD86WyorLV18MVsuKV0pICcpIC8vIG9ubHkgbGlzdHMgc3RhcnRpbmcgZnJvbSAxIGNhbiBpbnRlcnJ1cHRcbiAgLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8IS0tKScpLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpIC8vIHRhYmxlcyBjYW4gYmUgaW50ZXJydXB0ZWQgYnkgdHlwZSAoNikgaHRtbCBibG9ja3NcbiAgLmdldFJlZ2V4KCk7XG4gIC8qKlxuICAgKiBQZWRhbnRpYyBncmFtbWFyIChvcmlnaW5hbCBKb2huIEdydWJlcidzIGxvb3NlIG1hcmtkb3duIHNwZWNpZmljYXRpb24pXG4gICAqL1xuXG4gIGJsb2NrLnBlZGFudGljID0gbWVyZ2UkMSh7fSwgYmxvY2subm9ybWFsLCB7XG4gICAgaHRtbDogZWRpdCQxKCdeICooPzpjb21tZW50ICooPzpcXFxcbnxcXFxccyokKScgKyAnfDwodGFnKVtcXFxcc1xcXFxTXSs/PC9cXFxcMT4gKig/OlxcXFxuezIsfXxcXFxccyokKScgLy8gY2xvc2VkIHRhZ1xuICAgICsgJ3w8dGFnKD86XCJbXlwiXSpcInxcXCdbXlxcJ10qXFwnfFxcXFxzW15cXCdcIi8+XFxcXHNdKikqPy8/PiAqKD86XFxcXG57Mix9fFxcXFxzKiQpKScpLnJlcGxhY2UoJ2NvbW1lbnQnLCBibG9jay5fY29tbWVudCkucmVwbGFjZSgvdGFnL2csICcoPyEoPzonICsgJ2F8ZW18c3Ryb25nfHNtYWxsfHN8Y2l0ZXxxfGRmbnxhYmJyfGRhdGF8dGltZXxjb2RlfHZhcnxzYW1wfGtiZHxzdWInICsgJ3xzdXB8aXxifHV8bWFya3xydWJ5fHJ0fHJwfGJkaXxiZG98c3Bhbnxicnx3YnJ8aW5zfGRlbHxpbWcpJyArICdcXFxcYilcXFxcdysoPyE6fFteXFxcXHdcXFxcc0BdKkApXFxcXGInKS5nZXRSZWdleCgpLFxuICAgIGRlZjogL14gKlxcWyhbXlxcXV0rKVxcXTogKjw/KFteXFxzPl0rKT4/KD86ICsoW1wiKF1bXlxcbl0rW1wiKV0pKT8gKig/Olxcbit8JCkvLFxuICAgIGhlYWRpbmc6IC9eICooI3sxLDZ9KSAqKFteXFxuXSs/KSAqKD86IysgKik/KD86XFxuK3wkKS8sXG4gICAgZmVuY2VzOiBub29wVGVzdCQxLFxuICAgIC8vIGZlbmNlcyBub3Qgc3VwcG9ydGVkXG4gICAgcGFyYWdyYXBoOiBlZGl0JDEoYmxvY2subm9ybWFsLl9wYXJhZ3JhcGgpLnJlcGxhY2UoJ2hyJywgYmxvY2suaHIpLnJlcGxhY2UoJ2hlYWRpbmcnLCAnICojezEsNn0gKlteXFxuXScpLnJlcGxhY2UoJ2xoZWFkaW5nJywgYmxvY2subGhlYWRpbmcpLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpLnJlcGxhY2UoJ3xmZW5jZXMnLCAnJykucmVwbGFjZSgnfGxpc3QnLCAnJykucmVwbGFjZSgnfGh0bWwnLCAnJykuZ2V0UmVnZXgoKVxuICB9KTtcbiAgLyoqXG4gICAqIElubGluZS1MZXZlbCBHcmFtbWFyXG4gICAqL1xuXG4gIHZhciBpbmxpbmUgPSB7XG4gICAgZXNjYXBlOiAvXlxcXFwoWyFcIiMkJSYnKCkqKyxcXC0uLzo7PD0+P0BcXFtcXF1cXFxcXl9ge3x9fl0pLyxcbiAgICBhdXRvbGluazogL148KHNjaGVtZTpbXlxcc1xceDAwLVxceDFmPD5dKnxlbWFpbCk+LyxcbiAgICB1cmw6IG5vb3BUZXN0JDEsXG4gICAgdGFnOiAnXmNvbW1lbnQnICsgJ3xePC9bYS16QS1aXVtcXFxcdzotXSpcXFxccyo+JyAvLyBzZWxmLWNsb3NpbmcgdGFnXG4gICAgKyAnfF48W2EtekEtWl1bXFxcXHctXSooPzphdHRyaWJ1dGUpKj9cXFxccyovPz4nIC8vIG9wZW4gdGFnXG4gICAgKyAnfF48XFxcXD9bXFxcXHNcXFxcU10qP1xcXFw/PicgLy8gcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiwgZS5nLiA8P3BocCA/PlxuICAgICsgJ3xePCFbYS16QS1aXStcXFxcc1tcXFxcc1xcXFxTXSo/PicgLy8gZGVjbGFyYXRpb24sIGUuZy4gPCFET0NUWVBFIGh0bWw+XG4gICAgKyAnfF48IVxcXFxbQ0RBVEFcXFxcW1tcXFxcc1xcXFxTXSo/XFxcXF1cXFxcXT4nLFxuICAgIC8vIENEQVRBIHNlY3Rpb25cbiAgICBsaW5rOiAvXiE/XFxbKGxhYmVsKVxcXVxcKFxccyooaHJlZikoPzpcXHMrKHRpdGxlKSk/XFxzKlxcKS8sXG4gICAgcmVmbGluazogL14hP1xcWyhsYWJlbClcXF1cXFsoPyFcXHMqXFxdKSgoPzpcXFxcW1xcW1xcXV0/fFteXFxbXFxdXFxcXF0pKylcXF0vLFxuICAgIG5vbGluazogL14hP1xcWyg/IVxccypcXF0pKCg/OlxcW1teXFxbXFxdXSpcXF18XFxcXFtcXFtcXF1dfFteXFxbXFxdXSkqKVxcXSg/OlxcW1xcXSk/LyxcbiAgICByZWZsaW5rU2VhcmNoOiAncmVmbGlua3xub2xpbmsoPyFcXFxcKCknLFxuICAgIHN0cm9uZzoge1xuICAgICAgc3RhcnQ6IC9eKD86KFxcKlxcKig/PVsqcHVuY3R1YXRpb25dKSl8XFwqXFwqKSg/IVtcXHNdKXxfXy8sXG4gICAgICAvLyAoMSkgcmV0dXJucyBpZiBzdGFydHMgdy8gcHVuY3R1YXRpb25cbiAgICAgIG1pZGRsZTogL15cXCpcXCooPzooPzooPyFvdmVybGFwU2tpcCkoPzpbXipdfFxcXFxcXCopfG92ZXJsYXBTa2lwKXxcXCooPzooPyFvdmVybGFwU2tpcCkoPzpbXipdfFxcXFxcXCopfG92ZXJsYXBTa2lwKSo/XFwqKSs/XFwqXFwqJHxeX18oPyFbXFxzXSkoKD86KD86KD8hb3ZlcmxhcFNraXApKD86W15fXXxcXFxcXyl8b3ZlcmxhcFNraXApfF8oPzooPyFvdmVybGFwU2tpcCkoPzpbXl9dfFxcXFxfKXxvdmVybGFwU2tpcCkqP18pKz8pX18kLyxcbiAgICAgIGVuZEFzdDogL1tecHVuY3R1YXRpb25cXHNdXFwqXFwqKD8hXFwqKXxbcHVuY3R1YXRpb25dXFwqXFwqKD8hXFwqKSg/Oig/PVtwdW5jdHVhdGlvbl9cXHNdfCQpKS8sXG4gICAgICAvLyBsYXN0IGNoYXIgY2FuJ3QgYmUgcHVuY3QsIG9yIGZpbmFsICogbXVzdCBhbHNvIGJlIGZvbGxvd2VkIGJ5IHB1bmN0IChvciBlbmRsaW5lKVxuICAgICAgZW5kVW5kOiAvW15cXHNdX18oPyFfKSg/Oig/PVtwdW5jdHVhdGlvbipcXHNdKXwkKS8gLy8gbGFzdCBjaGFyIGNhbid0IGJlIGEgc3BhY2UsIGFuZCBmaW5hbCBfIG11c3QgcHJlY2VlZCBwdW5jdCBvciBcXHMgKG9yIGVuZGxpbmUpXG5cbiAgICB9LFxuICAgIGVtOiB7XG4gICAgICBzdGFydDogL14oPzooXFwqKD89W3B1bmN0dWF0aW9uXSkpfFxcKikoPyFbKlxcc10pfF8vLFxuICAgICAgLy8gKDEpIHJldHVybnMgaWYgc3RhcnRzIHcvIHB1bmN0dWF0aW9uXG4gICAgICBtaWRkbGU6IC9eXFwqKD86KD86KD8hb3ZlcmxhcFNraXApKD86W14qXXxcXFxcXFwqKXxvdmVybGFwU2tpcCl8XFwqKD86KD8hb3ZlcmxhcFNraXApKD86W14qXXxcXFxcXFwqKXxvdmVybGFwU2tpcCkqP1xcKikrP1xcKiR8Xl8oPyFbX1xcc10pKD86KD86KD8hb3ZlcmxhcFNraXApKD86W15fXXxcXFxcXyl8b3ZlcmxhcFNraXApfF8oPzooPyFvdmVybGFwU2tpcCkoPzpbXl9dfFxcXFxfKXxvdmVybGFwU2tpcCkqP18pKz9fJC8sXG4gICAgICBlbmRBc3Q6IC9bXnB1bmN0dWF0aW9uXFxzXVxcKig/IVxcKil8W3B1bmN0dWF0aW9uXVxcKig/IVxcKikoPzooPz1bcHVuY3R1YXRpb25fXFxzXXwkKSkvLFxuICAgICAgLy8gbGFzdCBjaGFyIGNhbid0IGJlIHB1bmN0LCBvciBmaW5hbCAqIG11c3QgYWxzbyBiZSBmb2xsb3dlZCBieSBwdW5jdCAob3IgZW5kbGluZSlcbiAgICAgIGVuZFVuZDogL1teXFxzXV8oPyFfKSg/Oig/PVtwdW5jdHVhdGlvbipcXHNdKXwkKS8gLy8gbGFzdCBjaGFyIGNhbid0IGJlIGEgc3BhY2UsIGFuZCBmaW5hbCBfIG11c3QgcHJlY2VlZCBwdW5jdCBvciBcXHMgKG9yIGVuZGxpbmUpXG5cbiAgICB9LFxuICAgIGNvZGU6IC9eKGArKShbXmBdfFteYF1bXFxzXFxTXSo/W15gXSlcXDEoPyFgKS8sXG4gICAgYnI6IC9eKCB7Mix9fFxcXFwpXFxuKD8hXFxzKiQpLyxcbiAgICBkZWw6IG5vb3BUZXN0JDEsXG4gICAgdGV4dDogL14oYCt8W15gXSkoPzooPz0gezIsfVxcbil8W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKl18XFxiX3wkKXxbXiBdKD89IHsyLH1cXG4pKSkvLFxuICAgIHB1bmN0dWF0aW9uOiAvXihbXFxzKnB1bmN0dWF0aW9uXSkvXG4gIH07IC8vIGxpc3Qgb2YgcHVuY3R1YXRpb24gbWFya3MgZnJvbSBjb21tb24gbWFyayBzcGVjXG4gIC8vIHdpdGhvdXQgKiBhbmQgXyB0byB3b3JrYXJvdW5kIGNhc2VzIHdpdGggZG91YmxlIGVtcGhhc2lzXG5cbiAgaW5saW5lLl9wdW5jdHVhdGlvbiA9ICchXCIjJCUmXFwnKCkrXFxcXC0uLC86Ozw9Pj9AXFxcXFtcXFxcXWBee3x9fic7XG4gIGlubGluZS5wdW5jdHVhdGlvbiA9IGVkaXQkMShpbmxpbmUucHVuY3R1YXRpb24pLnJlcGxhY2UoL3B1bmN0dWF0aW9uL2csIGlubGluZS5fcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7IC8vIHNlcXVlbmNlcyBlbSBzaG91bGQgc2tpcCBvdmVyIFt0aXRsZV0obGluayksIGBjb2RlYCwgPGh0bWw+XG5cbiAgaW5saW5lLl9ibG9ja1NraXAgPSAnXFxcXFtbXlxcXFxdXSo/XFxcXF1cXFxcKFteXFxcXCldKj9cXFxcKXxgW15gXSo/YHw8W14+XSo/Pic7XG4gIGlubGluZS5fb3ZlcmxhcFNraXAgPSAnX19bXl9dKj9fX3xcXFxcKlxcXFwqXFxcXFteXFxcXCpcXFxcXSo/XFxcXCpcXFxcKic7XG4gIGlubGluZS5fY29tbWVudCA9IGVkaXQkMShibG9jay5fY29tbWVudCkucmVwbGFjZSgnKD86LS0+fCQpJywgJy0tPicpLmdldFJlZ2V4KCk7XG4gIGlubGluZS5lbS5zdGFydCA9IGVkaXQkMShpbmxpbmUuZW0uc3RhcnQpLnJlcGxhY2UoL3B1bmN0dWF0aW9uL2csIGlubGluZS5fcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG4gIGlubGluZS5lbS5taWRkbGUgPSBlZGl0JDEoaW5saW5lLmVtLm1pZGRsZSkucmVwbGFjZSgvcHVuY3R1YXRpb24vZywgaW5saW5lLl9wdW5jdHVhdGlvbikucmVwbGFjZSgvb3ZlcmxhcFNraXAvZywgaW5saW5lLl9vdmVybGFwU2tpcCkuZ2V0UmVnZXgoKTtcbiAgaW5saW5lLmVtLmVuZEFzdCA9IGVkaXQkMShpbmxpbmUuZW0uZW5kQXN0LCAnZycpLnJlcGxhY2UoL3B1bmN0dWF0aW9uL2csIGlubGluZS5fcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG4gIGlubGluZS5lbS5lbmRVbmQgPSBlZGl0JDEoaW5saW5lLmVtLmVuZFVuZCwgJ2cnKS5yZXBsYWNlKC9wdW5jdHVhdGlvbi9nLCBpbmxpbmUuX3B1bmN0dWF0aW9uKS5nZXRSZWdleCgpO1xuICBpbmxpbmUuc3Ryb25nLnN0YXJ0ID0gZWRpdCQxKGlubGluZS5zdHJvbmcuc3RhcnQpLnJlcGxhY2UoL3B1bmN0dWF0aW9uL2csIGlubGluZS5fcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG4gIGlubGluZS5zdHJvbmcubWlkZGxlID0gZWRpdCQxKGlubGluZS5zdHJvbmcubWlkZGxlKS5yZXBsYWNlKC9wdW5jdHVhdGlvbi9nLCBpbmxpbmUuX3B1bmN0dWF0aW9uKS5yZXBsYWNlKC9vdmVybGFwU2tpcC9nLCBpbmxpbmUuX292ZXJsYXBTa2lwKS5nZXRSZWdleCgpO1xuICBpbmxpbmUuc3Ryb25nLmVuZEFzdCA9IGVkaXQkMShpbmxpbmUuc3Ryb25nLmVuZEFzdCwgJ2cnKS5yZXBsYWNlKC9wdW5jdHVhdGlvbi9nLCBpbmxpbmUuX3B1bmN0dWF0aW9uKS5nZXRSZWdleCgpO1xuICBpbmxpbmUuc3Ryb25nLmVuZFVuZCA9IGVkaXQkMShpbmxpbmUuc3Ryb25nLmVuZFVuZCwgJ2cnKS5yZXBsYWNlKC9wdW5jdHVhdGlvbi9nLCBpbmxpbmUuX3B1bmN0dWF0aW9uKS5nZXRSZWdleCgpO1xuICBpbmxpbmUuYmxvY2tTa2lwID0gZWRpdCQxKGlubGluZS5fYmxvY2tTa2lwLCAnZycpLmdldFJlZ2V4KCk7XG4gIGlubGluZS5vdmVybGFwU2tpcCA9IGVkaXQkMShpbmxpbmUuX292ZXJsYXBTa2lwLCAnZycpLmdldFJlZ2V4KCk7XG4gIGlubGluZS5fZXNjYXBlcyA9IC9cXFxcKFshXCIjJCUmJygpKissXFwtLi86Ozw9Pj9AXFxbXFxdXFxcXF5fYHt8fX5dKS9nO1xuICBpbmxpbmUuX3NjaGVtZSA9IC9bYS16QS1aXVthLXpBLVowLTkrLi1dezEsMzF9LztcbiAgaW5saW5lLl9lbWFpbCA9IC9bYS16QS1aMC05LiEjJCUmJyorLz0/Xl9ge3x9fi1dKyhAKVthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykrKD8hWy1fXSkvO1xuICBpbmxpbmUuYXV0b2xpbmsgPSBlZGl0JDEoaW5saW5lLmF1dG9saW5rKS5yZXBsYWNlKCdzY2hlbWUnLCBpbmxpbmUuX3NjaGVtZSkucmVwbGFjZSgnZW1haWwnLCBpbmxpbmUuX2VtYWlsKS5nZXRSZWdleCgpO1xuICBpbmxpbmUuX2F0dHJpYnV0ZSA9IC9cXHMrW2EtekEtWjpfXVtcXHcuOi1dKig/Olxccyo9XFxzKlwiW15cIl0qXCJ8XFxzKj1cXHMqJ1teJ10qJ3xcXHMqPVxccypbXlxcc1wiJz08PmBdKyk/LztcbiAgaW5saW5lLnRhZyA9IGVkaXQkMShpbmxpbmUudGFnKS5yZXBsYWNlKCdjb21tZW50JywgaW5saW5lLl9jb21tZW50KS5yZXBsYWNlKCdhdHRyaWJ1dGUnLCBpbmxpbmUuX2F0dHJpYnV0ZSkuZ2V0UmVnZXgoKTtcbiAgaW5saW5lLl9sYWJlbCA9IC8oPzpcXFsoPzpcXFxcLnxbXlxcW1xcXVxcXFxdKSpcXF18XFxcXC58YFteYF0qYHxbXlxcW1xcXVxcXFxgXSkqPy87XG4gIGlubGluZS5faHJlZiA9IC88KD86XFxcXFs8Pl0/fFteXFxzPD5cXFxcXSkqPnxbXlxcc1xceDAwLVxceDFmXSovO1xuICBpbmxpbmUuX3RpdGxlID0gL1wiKD86XFxcXFwiP3xbXlwiXFxcXF0pKlwifCcoPzpcXFxcJz98W14nXFxcXF0pKid8XFwoKD86XFxcXFxcKT98W14pXFxcXF0pKlxcKS87XG4gIGlubGluZS5saW5rID0gZWRpdCQxKGlubGluZS5saW5rKS5yZXBsYWNlKCdsYWJlbCcsIGlubGluZS5fbGFiZWwpLnJlcGxhY2UoJ2hyZWYnLCBpbmxpbmUuX2hyZWYpLnJlcGxhY2UoJ3RpdGxlJywgaW5saW5lLl90aXRsZSkuZ2V0UmVnZXgoKTtcbiAgaW5saW5lLnJlZmxpbmsgPSBlZGl0JDEoaW5saW5lLnJlZmxpbmspLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lLl9sYWJlbCkuZ2V0UmVnZXgoKTtcbiAgaW5saW5lLnJlZmxpbmtTZWFyY2ggPSBlZGl0JDEoaW5saW5lLnJlZmxpbmtTZWFyY2gsICdnJykucmVwbGFjZSgncmVmbGluaycsIGlubGluZS5yZWZsaW5rKS5yZXBsYWNlKCdub2xpbmsnLCBpbmxpbmUubm9saW5rKS5nZXRSZWdleCgpO1xuICAvKipcbiAgICogTm9ybWFsIElubGluZSBHcmFtbWFyXG4gICAqL1xuXG4gIGlubGluZS5ub3JtYWwgPSBtZXJnZSQxKHt9LCBpbmxpbmUpO1xuICAvKipcbiAgICogUGVkYW50aWMgSW5saW5lIEdyYW1tYXJcbiAgICovXG5cbiAgaW5saW5lLnBlZGFudGljID0gbWVyZ2UkMSh7fSwgaW5saW5lLm5vcm1hbCwge1xuICAgIHN0cm9uZzoge1xuICAgICAgc3RhcnQ6IC9eX198XFwqXFwqLyxcbiAgICAgIG1pZGRsZTogL15fXyg/PVxcUykoW1xcc1xcU10qP1xcUylfXyg/IV8pfF5cXCpcXCooPz1cXFMpKFtcXHNcXFNdKj9cXFMpXFwqXFwqKD8hXFwqKS8sXG4gICAgICBlbmRBc3Q6IC9cXCpcXCooPyFcXCopL2csXG4gICAgICBlbmRVbmQ6IC9fXyg/IV8pL2dcbiAgICB9LFxuICAgIGVtOiB7XG4gICAgICBzdGFydDogL15ffFxcKi8sXG4gICAgICBtaWRkbGU6IC9eKClcXCooPz1cXFMpKFtcXHNcXFNdKj9cXFMpXFwqKD8hXFwqKXxeXyg/PVxcUykoW1xcc1xcU10qP1xcUylfKD8hXykvLFxuICAgICAgZW5kQXN0OiAvXFwqKD8hXFwqKS9nLFxuICAgICAgZW5kVW5kOiAvXyg/IV8pL2dcbiAgICB9LFxuICAgIGxpbms6IGVkaXQkMSgvXiE/XFxbKGxhYmVsKVxcXVxcKCguKj8pXFwpLykucmVwbGFjZSgnbGFiZWwnLCBpbmxpbmUuX2xhYmVsKS5nZXRSZWdleCgpLFxuICAgIHJlZmxpbms6IGVkaXQkMSgvXiE/XFxbKGxhYmVsKVxcXVxccypcXFsoW15cXF1dKilcXF0vKS5yZXBsYWNlKCdsYWJlbCcsIGlubGluZS5fbGFiZWwpLmdldFJlZ2V4KClcbiAgfSk7XG4gIC8qKlxuICAgKiBHRk0gSW5saW5lIEdyYW1tYXJcbiAgICovXG5cbiAgaW5saW5lLmdmbSA9IG1lcmdlJDEoe30sIGlubGluZS5ub3JtYWwsIHtcbiAgICBlc2NhcGU6IGVkaXQkMShpbmxpbmUuZXNjYXBlKS5yZXBsYWNlKCddKScsICd+fF0pJykuZ2V0UmVnZXgoKSxcbiAgICBfZXh0ZW5kZWRfZW1haWw6IC9bQS1aYS16MC05Ll8rLV0rKEApW2EtekEtWjAtOS1fXSsoPzpcXC5bYS16QS1aMC05LV9dKlthLXpBLVowLTldKSsoPyFbLV9dKS8sXG4gICAgdXJsOiAvXigoPzpmdHB8aHR0cHM/KTpcXC9cXC98d3d3XFwuKSg/OlthLXpBLVowLTlcXC1dK1xcLj8pK1teXFxzPF0qfF5lbWFpbC8sXG4gICAgX2JhY2twZWRhbDogLyg/OltePyEuLDo7Kl9+KCkmXSt8XFwoW14pXSpcXCl8Jig/IVthLXpBLVowLTldKzskKXxbPyEuLDo7Kl9+KV0rKD8hJCkpKy8sXG4gICAgZGVsOiAvXn4rKD89XFxTKShbXFxzXFxTXSo/XFxTKX4rLyxcbiAgICB0ZXh0OiAvXihgK3xbXmBdKSg/Oig/PSB7Mix9XFxuKXxbXFxzXFxTXSo/KD86KD89W1xcXFw8IVxcW2Aqfl18XFxiX3xodHRwcz86XFwvXFwvfGZ0cDpcXC9cXC98d3d3XFwufCQpfFteIF0oPz0gezIsfVxcbil8W15hLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0oPz1bYS16QS1aMC05LiEjJCUmJyorXFwvPT9fYHtcXHx9fi1dK0ApKXwoPz1bYS16QS1aMC05LiEjJCUmJyorXFwvPT9fYHtcXHx9fi1dK0ApKS9cbiAgfSk7XG4gIGlubGluZS5nZm0udXJsID0gZWRpdCQxKGlubGluZS5nZm0udXJsLCAnaScpLnJlcGxhY2UoJ2VtYWlsJywgaW5saW5lLmdmbS5fZXh0ZW5kZWRfZW1haWwpLmdldFJlZ2V4KCk7XG4gIC8qKlxuICAgKiBHRk0gKyBMaW5lIEJyZWFrcyBJbmxpbmUgR3JhbW1hclxuICAgKi9cblxuICBpbmxpbmUuYnJlYWtzID0gbWVyZ2UkMSh7fSwgaW5saW5lLmdmbSwge1xuICAgIGJyOiBlZGl0JDEoaW5saW5lLmJyKS5yZXBsYWNlKCd7Mix9JywgJyonKS5nZXRSZWdleCgpLFxuICAgIHRleHQ6IGVkaXQkMShpbmxpbmUuZ2ZtLnRleHQpLnJlcGxhY2UoJ1xcXFxiXycsICdcXFxcYl98IHsyLH1cXFxcbicpLnJlcGxhY2UoL1xcezIsXFx9L2csICcqJykuZ2V0UmVnZXgoKVxuICB9KTtcbiAgdmFyIHJ1bGVzID0ge1xuICAgIGJsb2NrOiBibG9jayxcbiAgICBpbmxpbmU6IGlubGluZVxuICB9O1xuXG4gIHZhciBkZWZhdWx0cyQyID0gZGVmYXVsdHMuZGVmYXVsdHM7XG4gIHZhciBibG9jayQxID0gcnVsZXMuYmxvY2ssXG4gICAgICBpbmxpbmUkMSA9IHJ1bGVzLmlubGluZTtcbiAgLyoqXG4gICAqIHNtYXJ0eXBhbnRzIHRleHQgcmVwbGFjZW1lbnRcbiAgICovXG5cbiAgZnVuY3Rpb24gc21hcnR5cGFudHModGV4dCkge1xuICAgIHJldHVybiB0ZXh0IC8vIGVtLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS0vZywgXCJcXHUyMDE0XCIpIC8vIGVuLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS9nLCBcIlxcdTIwMTNcIikgLy8gb3BlbmluZyBzaW5nbGVzXG4gICAgLnJlcGxhY2UoLyhefFstXFx1MjAxNC8oXFxbe1wiXFxzXSknL2csIFwiJDFcXHUyMDE4XCIpIC8vIGNsb3Npbmcgc2luZ2xlcyAmIGFwb3N0cm9waGVzXG4gICAgLnJlcGxhY2UoLycvZywgXCJcXHUyMDE5XCIpIC8vIG9wZW5pbmcgZG91Ymxlc1xuICAgIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcXHUyMDE4XFxzXSlcIi9nLCBcIiQxXFx1MjAxQ1wiKSAvLyBjbG9zaW5nIGRvdWJsZXNcbiAgICAucmVwbGFjZSgvXCIvZywgXCJcXHUyMDFEXCIpIC8vIGVsbGlwc2VzXG4gICAgLnJlcGxhY2UoL1xcLnszfS9nLCBcIlxcdTIwMjZcIik7XG4gIH1cbiAgLyoqXG4gICAqIG1hbmdsZSBlbWFpbCBhZGRyZXNzZXNcbiAgICovXG5cblxuICBmdW5jdGlvbiBtYW5nbGUodGV4dCkge1xuICAgIHZhciBvdXQgPSAnJyxcbiAgICAgICAgaSxcbiAgICAgICAgY2g7XG4gICAgdmFyIGwgPSB0ZXh0Lmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNoID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAgICBjaCA9ICd4JyArIGNoLnRvU3RyaW5nKDE2KTtcbiAgICAgIH1cblxuICAgICAgb3V0ICs9ICcmIycgKyBjaCArICc7JztcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIC8qKlxuICAgKiBCbG9jayBMZXhlclxuICAgKi9cblxuXG4gIHZhciBMZXhlcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMZXhlcihvcHRpb25zKSB7XG4gICAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgICAgdGhpcy50b2tlbnMubGlua3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQyO1xuICAgICAgdGhpcy5vcHRpb25zLnRva2VuaXplciA9IHRoaXMub3B0aW9ucy50b2tlbml6ZXIgfHwgbmV3IFRva2VuaXplcl8xKCk7XG4gICAgICB0aGlzLnRva2VuaXplciA9IHRoaXMub3B0aW9ucy50b2tlbml6ZXI7XG4gICAgICB0aGlzLnRva2VuaXplci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIHJ1bGVzID0ge1xuICAgICAgICBibG9jazogYmxvY2skMS5ub3JtYWwsXG4gICAgICAgIGlubGluZTogaW5saW5lJDEubm9ybWFsXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgIHJ1bGVzLmJsb2NrID0gYmxvY2skMS5wZWRhbnRpYztcbiAgICAgICAgcnVsZXMuaW5saW5lID0gaW5saW5lJDEucGVkYW50aWM7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICAgICAgcnVsZXMuYmxvY2sgPSBibG9jayQxLmdmbTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJyZWFrcykge1xuICAgICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZSQxLmJyZWFrcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUkMS5nZm07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy50b2tlbml6ZXIucnVsZXMgPSBydWxlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwb3NlIFJ1bGVzXG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBMZXggTWV0aG9kXG4gICAgICovXG4gICAgTGV4ZXIubGV4ID0gZnVuY3Rpb24gbGV4KHNyYywgb3B0aW9ucykge1xuICAgICAgdmFyIGxleGVyID0gbmV3IExleGVyKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGxleGVyLmxleChzcmMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgTGV4IElubGluZSBNZXRob2RcbiAgICAgKi9cbiAgICA7XG5cbiAgICBMZXhlci5sZXhJbmxpbmUgPSBmdW5jdGlvbiBsZXhJbmxpbmUoc3JjLCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGV4ZXIgPSBuZXcgTGV4ZXIob3B0aW9ucyk7XG4gICAgICByZXR1cm4gbGV4ZXIuaW5saW5lVG9rZW5zKHNyYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXByb2Nlc3NpbmdcbiAgICAgKi9cbiAgICA7XG5cbiAgICB2YXIgX3Byb3RvID0gTGV4ZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmxleCA9IGZ1bmN0aW9uIGxleChzcmMpIHtcbiAgICAgIHNyYyA9IHNyYy5yZXBsYWNlKC9cXHJcXG58XFxyL2csICdcXG4nKS5yZXBsYWNlKC9cXHQvZywgJyAgICAnKTtcbiAgICAgIHRoaXMuYmxvY2tUb2tlbnMoc3JjLCB0aGlzLnRva2VucywgdHJ1ZSk7XG4gICAgICB0aGlzLmlubGluZSh0aGlzLnRva2Vucyk7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExleGluZ1xuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5ibG9ja1Rva2VucyA9IGZ1bmN0aW9uIGJsb2NrVG9rZW5zKHNyYywgdG9rZW5zLCB0b3ApIHtcbiAgICAgIGlmICh0b2tlbnMgPT09IHZvaWQgMCkge1xuICAgICAgICB0b2tlbnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRvcCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRvcCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHNyYyA9IHNyYy5yZXBsYWNlKC9eICskL2dtLCAnJyk7XG4gICAgICB2YXIgdG9rZW4sIGksIGwsIGxhc3RUb2tlbjtcblxuICAgICAgd2hpbGUgKHNyYykge1xuICAgICAgICAvLyBuZXdsaW5lXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnNwYWNlKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuXG4gICAgICAgICAgaWYgKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBjb2RlXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5jb2RlKHNyYywgdG9rZW5zKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG5cbiAgICAgICAgICBpZiAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9ICdcXG4nICsgdG9rZW4udGV4dDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBmZW5jZXNcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmZlbmNlcyhzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gaGVhZGluZ1xuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaGVhZGluZyhzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gdGFibGUgbm8gbGVhZGluZyBwaXBlIChnZm0pXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5ucHRhYmxlKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBoclxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaHIoc3JjKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGJsb2NrcXVvdGVcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmJsb2NrcXVvdGUoc3JjKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW4udG9rZW5zID0gdGhpcy5ibG9ja1Rva2Vucyh0b2tlbi50ZXh0LCBbXSwgdG9wKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gbGlzdFxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGlzdChzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICBsID0gdG9rZW4uaXRlbXMubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdG9rZW4uaXRlbXNbaV0udG9rZW5zID0gdGhpcy5ibG9ja1Rva2Vucyh0b2tlbi5pdGVtc1tpXS50ZXh0LCBbXSwgZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBodG1sXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5odG1sKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBkZWZcblxuXG4gICAgICAgIGlmICh0b3AgJiYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZGVmKHNyYykpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcblxuICAgICAgICAgIGlmICghdGhpcy50b2tlbnMubGlua3NbdG9rZW4udGFnXSkge1xuICAgICAgICAgICAgdGhpcy50b2tlbnMubGlua3NbdG9rZW4udGFnXSA9IHtcbiAgICAgICAgICAgICAgaHJlZjogdG9rZW4uaHJlZixcbiAgICAgICAgICAgICAgdGl0bGU6IHRva2VuLnRpdGxlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIHRhYmxlIChnZm0pXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci50YWJsZShzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gbGhlYWRpbmdcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmxoZWFkaW5nKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyB0b3AtbGV2ZWwgcGFyYWdyYXBoXG5cblxuICAgICAgICBpZiAodG9wICYmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnBhcmFncmFwaChzcmMpKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIHRleHRcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRleHQoc3JjLCB0b2tlbnMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcblxuICAgICAgICAgIGlmICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgIHZhciBlcnJNc2cgPSAnSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH07XG5cbiAgICBfcHJvdG8uaW5saW5lID0gZnVuY3Rpb24gaW5saW5lKHRva2Vucykge1xuICAgICAgdmFyIGksIGosIGssIGwyLCByb3csIHRva2VuO1xuICAgICAgdmFyIGwgPSB0b2tlbnMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3BhcmFncmFwaCc6XG4gICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgY2FzZSAnaGVhZGluZyc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRva2VuLnRva2VucyA9IFtdO1xuICAgICAgICAgICAgICB0aGlzLmlubGluZVRva2Vucyh0b2tlbi50ZXh0LCB0b2tlbi50b2tlbnMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdG9rZW4udG9rZW5zID0ge1xuICAgICAgICAgICAgICAgIGhlYWRlcjogW10sXG4gICAgICAgICAgICAgICAgY2VsbHM6IFtdXG4gICAgICAgICAgICAgIH07IC8vIGhlYWRlclxuXG4gICAgICAgICAgICAgIGwyID0gdG9rZW4uaGVhZGVyLmxlbmd0aDtcblxuICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDI7IGorKykge1xuICAgICAgICAgICAgICAgIHRva2VuLnRva2Vucy5oZWFkZXJbal0gPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmlubGluZVRva2Vucyh0b2tlbi5oZWFkZXJbal0sIHRva2VuLnRva2Vucy5oZWFkZXJbal0pO1xuICAgICAgICAgICAgICB9IC8vIGNlbGxzXG5cblxuICAgICAgICAgICAgICBsMiA9IHRva2VuLmNlbGxzLmxlbmd0aDtcblxuICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDI7IGorKykge1xuICAgICAgICAgICAgICAgIHJvdyA9IHRva2VuLmNlbGxzW2pdO1xuICAgICAgICAgICAgICAgIHRva2VuLnRva2Vucy5jZWxsc1tqXSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IHJvdy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgdG9rZW4udG9rZW5zLmNlbGxzW2pdW2tdID0gW107XG4gICAgICAgICAgICAgICAgICB0aGlzLmlubGluZVRva2Vucyhyb3dba10sIHRva2VuLnRva2Vucy5jZWxsc1tqXVtrXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdibG9ja3F1b3RlJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhpcy5pbmxpbmUodG9rZW4udG9rZW5zKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdsaXN0JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbDIgPSB0b2tlbi5pdGVtcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGwyOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlubGluZSh0b2tlbi5pdGVtc1tqXS50b2tlbnMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGV4aW5nL0NvbXBpbGluZ1xuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5pbmxpbmVUb2tlbnMgPSBmdW5jdGlvbiBpbmxpbmVUb2tlbnMoc3JjLCB0b2tlbnMsIGluTGluaywgaW5SYXdCbG9jaywgcHJldkNoYXIpIHtcbiAgICAgIGlmICh0b2tlbnMgPT09IHZvaWQgMCkge1xuICAgICAgICB0b2tlbnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluTGluayA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGluTGluayA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5SYXdCbG9jayA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGluUmF3QmxvY2sgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByZXZDaGFyID09PSB2b2lkIDApIHtcbiAgICAgICAgcHJldkNoYXIgPSAnJztcbiAgICAgIH1cblxuICAgICAgdmFyIHRva2VuOyAvLyBTdHJpbmcgd2l0aCBsaW5rcyBtYXNrZWQgdG8gYXZvaWQgaW50ZXJmZXJlbmNlIHdpdGggZW0gYW5kIHN0cm9uZ1xuXG4gICAgICB2YXIgbWFza2VkU3JjID0gc3JjO1xuICAgICAgdmFyIG1hdGNoOyAvLyBNYXNrIG91dCByZWZsaW5rc1xuXG4gICAgICBpZiAodGhpcy50b2tlbnMubGlua3MpIHtcbiAgICAgICAgdmFyIGxpbmtzID0gT2JqZWN0LmtleXModGhpcy50b2tlbnMubGlua3MpO1xuXG4gICAgICAgIGlmIChsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5yZWZsaW5rU2VhcmNoLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGxpbmtzLmluY2x1ZGVzKG1hdGNoWzBdLnNsaWNlKG1hdGNoWzBdLmxhc3RJbmRleE9mKCdbJykgKyAxLCAtMSkpKSB7XG4gICAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnWycgKyAnYScucmVwZWF0KG1hdGNoWzBdLmxlbmd0aCAtIDIpICsgJ10nICsgbWFza2VkU3JjLnNsaWNlKHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5yZWZsaW5rU2VhcmNoLmxhc3RJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIE1hc2sgb3V0IG90aGVyIGJsb2Nrc1xuXG5cbiAgICAgIHdoaWxlICgobWF0Y2ggPSB0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYmxvY2tTa2lwLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgJ1snICsgJ2EnLnJlcGVhdChtYXRjaFswXS5sZW5ndGggLSAyKSArICddJyArIG1hc2tlZFNyYy5zbGljZSh0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYmxvY2tTa2lwLmxhc3RJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgLy8gZXNjYXBlXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmVzY2FwZShzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gdGFnXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci50YWcoc3JjLCBpbkxpbmssIGluUmF3QmxvY2spKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICBpbkxpbmsgPSB0b2tlbi5pbkxpbms7XG4gICAgICAgICAgaW5SYXdCbG9jayA9IHRva2VuLmluUmF3QmxvY2s7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGxpbmtcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmxpbmsoc3JjKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG5cbiAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2xpbmsnKSB7XG4gICAgICAgICAgICB0b2tlbi50b2tlbnMgPSB0aGlzLmlubGluZVRva2Vucyh0b2tlbi50ZXh0LCBbXSwgdHJ1ZSwgaW5SYXdCbG9jayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIHJlZmxpbmssIG5vbGlua1xuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIucmVmbGluayhzcmMsIHRoaXMudG9rZW5zLmxpbmtzKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG5cbiAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2xpbmsnKSB7XG4gICAgICAgICAgICB0b2tlbi50b2tlbnMgPSB0aGlzLmlubGluZVRva2Vucyh0b2tlbi50ZXh0LCBbXSwgdHJ1ZSwgaW5SYXdCbG9jayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIHN0cm9uZ1xuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuc3Ryb25nKHNyYywgbWFza2VkU3JjLCBwcmV2Q2hhcikpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2VuLnRva2VucyA9IHRoaXMuaW5saW5lVG9rZW5zKHRva2VuLnRleHQsIFtdLCBpbkxpbmssIGluUmF3QmxvY2spO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBlbVxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZW0oc3JjLCBtYXNrZWRTcmMsIHByZXZDaGFyKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW4udG9rZW5zID0gdGhpcy5pbmxpbmVUb2tlbnModG9rZW4udGV4dCwgW10sIGluTGluaywgaW5SYXdCbG9jayk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGNvZGVcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmNvZGVzcGFuKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBiclxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuYnIoc3JjKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGRlbCAoZ2ZtKVxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZGVsKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2VuLnRva2VucyA9IHRoaXMuaW5saW5lVG9rZW5zKHRva2VuLnRleHQsIFtdLCBpbkxpbmssIGluUmF3QmxvY2spO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBhdXRvbGlua1xuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuYXV0b2xpbmsoc3JjLCBtYW5nbGUpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gdXJsIChnZm0pXG5cblxuICAgICAgICBpZiAoIWluTGluayAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci51cmwoc3JjLCBtYW5nbGUpKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIHRleHRcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmlubGluZVRleHQoc3JjLCBpblJhd0Jsb2NrLCBzbWFydHlwYW50cykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHByZXZDaGFyID0gdG9rZW4ucmF3LnNsaWNlKC0xKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgdmFyIGVyck1zZyA9ICdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKTtcblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfTtcblxuICAgIF9jcmVhdGVDbGFzcyhMZXhlciwgbnVsbCwgW3tcbiAgICAgIGtleTogXCJydWxlc1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYmxvY2s6IGJsb2NrJDEsXG4gICAgICAgICAgaW5saW5lOiBpbmxpbmUkMVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBMZXhlcjtcbiAgfSgpO1xuXG4gIHZhciBkZWZhdWx0cyQzID0gZGVmYXVsdHMuZGVmYXVsdHM7XG4gIHZhciBjbGVhblVybCQxID0gaGVscGVycy5jbGVhblVybCxcbiAgICAgIGVzY2FwZSQxID0gaGVscGVycy5lc2NhcGU7XG4gIC8qKlxuICAgKiBSZW5kZXJlclxuICAgKi9cblxuICB2YXIgUmVuZGVyZXJfMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVuZGVyZXIob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQzO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBSZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uY29kZSA9IGZ1bmN0aW9uIGNvZGUoX2NvZGUsIGluZm9zdHJpbmcsIGVzY2FwZWQpIHtcbiAgICAgIHZhciBsYW5nID0gKGluZm9zdHJpbmcgfHwgJycpLm1hdGNoKC9cXFMqLylbMF07XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgICAgIHZhciBvdXQgPSB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KF9jb2RlLCBsYW5nKTtcblxuICAgICAgICBpZiAob3V0ICE9IG51bGwgJiYgb3V0ICE9PSBfY29kZSkge1xuICAgICAgICAgIGVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgIF9jb2RlID0gb3V0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghbGFuZykge1xuICAgICAgICByZXR1cm4gJzxwcmU+PGNvZGU+JyArIChlc2NhcGVkID8gX2NvZGUgOiBlc2NhcGUkMShfY29kZSwgdHJ1ZSkpICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJzxwcmU+PGNvZGUgY2xhc3M9XCInICsgdGhpcy5vcHRpb25zLmxhbmdQcmVmaXggKyBlc2NhcGUkMShsYW5nLCB0cnVlKSArICdcIj4nICsgKGVzY2FwZWQgPyBfY29kZSA6IGVzY2FwZSQxKF9jb2RlLCB0cnVlKSkgKyAnPC9jb2RlPjwvcHJlPlxcbic7XG4gICAgfTtcblxuICAgIF9wcm90by5ibG9ja3F1b3RlID0gZnVuY3Rpb24gYmxvY2txdW90ZShxdW90ZSkge1xuICAgICAgcmV0dXJuICc8YmxvY2txdW90ZT5cXG4nICsgcXVvdGUgKyAnPC9ibG9ja3F1b3RlPlxcbic7XG4gICAgfTtcblxuICAgIF9wcm90by5odG1sID0gZnVuY3Rpb24gaHRtbChfaHRtbCkge1xuICAgICAgcmV0dXJuIF9odG1sO1xuICAgIH07XG5cbiAgICBfcHJvdG8uaGVhZGluZyA9IGZ1bmN0aW9uIGhlYWRpbmcodGV4dCwgbGV2ZWwsIHJhdywgc2x1Z2dlcikge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oZWFkZXJJZHMpIHtcbiAgICAgICAgcmV0dXJuICc8aCcgKyBsZXZlbCArICcgaWQ9XCInICsgdGhpcy5vcHRpb25zLmhlYWRlclByZWZpeCArIHNsdWdnZXIuc2x1ZyhyYXcpICsgJ1wiPicgKyB0ZXh0ICsgJzwvaCcgKyBsZXZlbCArICc+XFxuJztcbiAgICAgIH0gLy8gaWdub3JlIElEc1xuXG5cbiAgICAgIHJldHVybiAnPGgnICsgbGV2ZWwgKyAnPicgKyB0ZXh0ICsgJzwvaCcgKyBsZXZlbCArICc+XFxuJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmhyID0gZnVuY3Rpb24gaHIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnhodG1sID8gJzxoci8+XFxuJyA6ICc8aHI+XFxuJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmxpc3QgPSBmdW5jdGlvbiBsaXN0KGJvZHksIG9yZGVyZWQsIHN0YXJ0KSB7XG4gICAgICB2YXIgdHlwZSA9IG9yZGVyZWQgPyAnb2wnIDogJ3VsJyxcbiAgICAgICAgICBzdGFydGF0dCA9IG9yZGVyZWQgJiYgc3RhcnQgIT09IDEgPyAnIHN0YXJ0PVwiJyArIHN0YXJ0ICsgJ1wiJyA6ICcnO1xuICAgICAgcmV0dXJuICc8JyArIHR5cGUgKyBzdGFydGF0dCArICc+XFxuJyArIGJvZHkgKyAnPC8nICsgdHlwZSArICc+XFxuJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmxpc3RpdGVtID0gZnVuY3Rpb24gbGlzdGl0ZW0odGV4dCkge1xuICAgICAgcmV0dXJuICc8bGk+JyArIHRleHQgKyAnPC9saT5cXG4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8uY2hlY2tib3ggPSBmdW5jdGlvbiBjaGVja2JveChjaGVja2VkKSB7XG4gICAgICByZXR1cm4gJzxpbnB1dCAnICsgKGNoZWNrZWQgPyAnY2hlY2tlZD1cIlwiICcgOiAnJykgKyAnZGlzYWJsZWQ9XCJcIiB0eXBlPVwiY2hlY2tib3hcIicgKyAodGhpcy5vcHRpb25zLnhodG1sID8gJyAvJyA6ICcnKSArICc+ICc7XG4gICAgfTtcblxuICAgIF9wcm90by5wYXJhZ3JhcGggPSBmdW5jdGlvbiBwYXJhZ3JhcGgodGV4dCkge1xuICAgICAgcmV0dXJuICc8cD4nICsgdGV4dCArICc8L3A+XFxuJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLnRhYmxlID0gZnVuY3Rpb24gdGFibGUoaGVhZGVyLCBib2R5KSB7XG4gICAgICBpZiAoYm9keSkgYm9keSA9ICc8dGJvZHk+JyArIGJvZHkgKyAnPC90Ym9keT4nO1xuICAgICAgcmV0dXJuICc8dGFibGU+XFxuJyArICc8dGhlYWQ+XFxuJyArIGhlYWRlciArICc8L3RoZWFkPlxcbicgKyBib2R5ICsgJzwvdGFibGU+XFxuJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLnRhYmxlcm93ID0gZnVuY3Rpb24gdGFibGVyb3coY29udGVudCkge1xuICAgICAgcmV0dXJuICc8dHI+XFxuJyArIGNvbnRlbnQgKyAnPC90cj5cXG4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8udGFibGVjZWxsID0gZnVuY3Rpb24gdGFibGVjZWxsKGNvbnRlbnQsIGZsYWdzKSB7XG4gICAgICB2YXIgdHlwZSA9IGZsYWdzLmhlYWRlciA/ICd0aCcgOiAndGQnO1xuICAgICAgdmFyIHRhZyA9IGZsYWdzLmFsaWduID8gJzwnICsgdHlwZSArICcgYWxpZ249XCInICsgZmxhZ3MuYWxpZ24gKyAnXCI+JyA6ICc8JyArIHR5cGUgKyAnPic7XG4gICAgICByZXR1cm4gdGFnICsgY29udGVudCArICc8LycgKyB0eXBlICsgJz5cXG4nO1xuICAgIH0gLy8gc3BhbiBsZXZlbCByZW5kZXJlclxuICAgIDtcblxuICAgIF9wcm90by5zdHJvbmcgPSBmdW5jdGlvbiBzdHJvbmcodGV4dCkge1xuICAgICAgcmV0dXJuICc8c3Ryb25nPicgKyB0ZXh0ICsgJzwvc3Ryb25nPic7XG4gICAgfTtcblxuICAgIF9wcm90by5lbSA9IGZ1bmN0aW9uIGVtKHRleHQpIHtcbiAgICAgIHJldHVybiAnPGVtPicgKyB0ZXh0ICsgJzwvZW0+JztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmNvZGVzcGFuID0gZnVuY3Rpb24gY29kZXNwYW4odGV4dCkge1xuICAgICAgcmV0dXJuICc8Y29kZT4nICsgdGV4dCArICc8L2NvZGU+JztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmJyID0gZnVuY3Rpb24gYnIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnhodG1sID8gJzxici8+JyA6ICc8YnI+JztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmRlbCA9IGZ1bmN0aW9uIGRlbCh0ZXh0KSB7XG4gICAgICByZXR1cm4gJzxkZWw+JyArIHRleHQgKyAnPC9kZWw+JztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmxpbmsgPSBmdW5jdGlvbiBsaW5rKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gICAgICBocmVmID0gY2xlYW5VcmwkMSh0aGlzLm9wdGlvbnMuc2FuaXRpemUsIHRoaXMub3B0aW9ucy5iYXNlVXJsLCBocmVmKTtcblxuICAgICAgaWYgKGhyZWYgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXQgPSAnPGEgaHJlZj1cIicgKyBlc2NhcGUkMShocmVmKSArICdcIic7XG5cbiAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICBvdXQgKz0gJyB0aXRsZT1cIicgKyB0aXRsZSArICdcIic7XG4gICAgICB9XG5cbiAgICAgIG91dCArPSAnPicgKyB0ZXh0ICsgJzwvYT4nO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmltYWdlID0gZnVuY3Rpb24gaW1hZ2UoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgIGhyZWYgPSBjbGVhblVybCQxKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSwgdGhpcy5vcHRpb25zLmJhc2VVcmwsIGhyZWYpO1xuXG4gICAgICBpZiAoaHJlZiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dCA9ICc8aW1nIHNyYz1cIicgKyBocmVmICsgJ1wiIGFsdD1cIicgKyB0ZXh0ICsgJ1wiJztcblxuICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgIG91dCArPSAnIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiJztcbiAgICAgIH1cblxuICAgICAgb3V0ICs9IHRoaXMub3B0aW9ucy54aHRtbCA/ICcvPicgOiAnPic7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH07XG5cbiAgICBfcHJvdG8udGV4dCA9IGZ1bmN0aW9uIHRleHQoX3RleHQpIHtcbiAgICAgIHJldHVybiBfdGV4dDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJlbmRlcmVyO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIFRleHRSZW5kZXJlclxuICAgKiByZXR1cm5zIG9ubHkgdGhlIHRleHR1YWwgcGFydCBvZiB0aGUgdG9rZW5cbiAgICovXG4gIHZhciBUZXh0UmVuZGVyZXJfMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGV4dFJlbmRlcmVyKCkge31cblxuICAgIHZhciBfcHJvdG8gPSBUZXh0UmVuZGVyZXIucHJvdG90eXBlO1xuXG4gICAgLy8gbm8gbmVlZCBmb3IgYmxvY2sgbGV2ZWwgcmVuZGVyZXJzXG4gICAgX3Byb3RvLnN0cm9uZyA9IGZ1bmN0aW9uIHN0cm9uZyh0ZXh0KSB7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmVtID0gZnVuY3Rpb24gZW0odGV4dCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by5jb2Rlc3BhbiA9IGZ1bmN0aW9uIGNvZGVzcGFuKHRleHQpIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG5cbiAgICBfcHJvdG8uZGVsID0gZnVuY3Rpb24gZGVsKHRleHQpIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG5cbiAgICBfcHJvdG8uaHRtbCA9IGZ1bmN0aW9uIGh0bWwodGV4dCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by50ZXh0ID0gZnVuY3Rpb24gdGV4dChfdGV4dCkge1xuICAgICAgcmV0dXJuIF90ZXh0O1xuICAgIH07XG5cbiAgICBfcHJvdG8ubGluayA9IGZ1bmN0aW9uIGxpbmsoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgIHJldHVybiAnJyArIHRleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by5pbWFnZSA9IGZ1bmN0aW9uIGltYWdlKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gICAgICByZXR1cm4gJycgKyB0ZXh0O1xuICAgIH07XG5cbiAgICBfcHJvdG8uYnIgPSBmdW5jdGlvbiBicigpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRleHRSZW5kZXJlcjtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBTbHVnZ2VyIGdlbmVyYXRlcyBoZWFkZXIgaWRcbiAgICovXG4gIHZhciBTbHVnZ2VyXzEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNsdWdnZXIoKSB7XG4gICAgICB0aGlzLnNlZW4gPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvID0gU2x1Z2dlci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCkgLy8gcmVtb3ZlIGh0bWwgdGFnc1xuICAgICAgLnJlcGxhY2UoLzxbIVxcL2Etel0uKj8+L2lnLCAnJykgLy8gcmVtb3ZlIHVud2FudGVkIGNoYXJzXG4gICAgICAucmVwbGFjZSgvW1xcdTIwMDAtXFx1MjA2RlxcdTJFMDAtXFx1MkU3RlxcXFwnIVwiIyQlJigpKissLi86Ozw9Pj9AW1xcXV5ge3x9fl0vZywgJycpLnJlcGxhY2UoL1xccy9nLCAnLScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbmV4dCBzYWZlICh1bmlxdWUpIHNsdWcgdG8gdXNlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmdldE5leHRTYWZlU2x1ZyA9IGZ1bmN0aW9uIGdldE5leHRTYWZlU2x1ZyhvcmlnaW5hbFNsdWcsIGlzRHJ5UnVuKSB7XG4gICAgICB2YXIgc2x1ZyA9IG9yaWdpbmFsU2x1ZztcbiAgICAgIHZhciBvY2N1cmVuY2VBY2N1bXVsYXRvciA9IDA7XG5cbiAgICAgIGlmICh0aGlzLnNlZW4uaGFzT3duUHJvcGVydHkoc2x1ZykpIHtcbiAgICAgICAgb2NjdXJlbmNlQWNjdW11bGF0b3IgPSB0aGlzLnNlZW5bb3JpZ2luYWxTbHVnXTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgb2NjdXJlbmNlQWNjdW11bGF0b3IrKztcbiAgICAgICAgICBzbHVnID0gb3JpZ2luYWxTbHVnICsgJy0nICsgb2NjdXJlbmNlQWNjdW11bGF0b3I7XG4gICAgICAgIH0gd2hpbGUgKHRoaXMuc2Vlbi5oYXNPd25Qcm9wZXJ0eShzbHVnKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNEcnlSdW4pIHtcbiAgICAgICAgdGhpcy5zZWVuW29yaWdpbmFsU2x1Z10gPSBvY2N1cmVuY2VBY2N1bXVsYXRvcjtcbiAgICAgICAgdGhpcy5zZWVuW3NsdWddID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNsdWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgc3RyaW5nIHRvIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmRyeXJ1biBHZW5lcmF0ZXMgdGhlIG5leHQgdW5pcXVlIHNsdWcgd2l0aG91dCB1cGRhdGluZyB0aGUgaW50ZXJuYWwgYWNjdW11bGF0b3IuXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnNsdWcgPSBmdW5jdGlvbiBzbHVnKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNsdWcgPSB0aGlzLnNlcmlhbGl6ZSh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcy5nZXROZXh0U2FmZVNsdWcoc2x1Zywgb3B0aW9ucy5kcnlydW4pO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2x1Z2dlcjtcbiAgfSgpO1xuXG4gIHZhciBkZWZhdWx0cyQ0ID0gZGVmYXVsdHMuZGVmYXVsdHM7XG4gIHZhciB1bmVzY2FwZSQxID0gaGVscGVycy51bmVzY2FwZTtcbiAgLyoqXG4gICAqIFBhcnNpbmcgJiBDb21waWxpbmdcbiAgICovXG5cbiAgdmFyIFBhcnNlcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJzZXIob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQ0O1xuICAgICAgdGhpcy5vcHRpb25zLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IG5ldyBSZW5kZXJlcl8xKCk7XG4gICAgICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyO1xuICAgICAgdGhpcy5yZW5kZXJlci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdGhpcy50ZXh0UmVuZGVyZXIgPSBuZXcgVGV4dFJlbmRlcmVyXzEoKTtcbiAgICAgIHRoaXMuc2x1Z2dlciA9IG5ldyBTbHVnZ2VyXzEoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIFBhcnNlIE1ldGhvZFxuICAgICAqL1xuXG5cbiAgICBQYXJzZXIucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSh0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZSh0b2tlbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgUGFyc2UgSW5saW5lIE1ldGhvZFxuICAgICAqL1xuICAgIDtcblxuICAgIFBhcnNlci5wYXJzZUlubGluZSA9IGZ1bmN0aW9uIHBhcnNlSW5saW5lKHRva2Vucywgb3B0aW9ucykge1xuICAgICAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gICAgICByZXR1cm4gcGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIExvb3BcbiAgICAgKi9cbiAgICA7XG5cbiAgICB2YXIgX3Byb3RvID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRva2VucywgdG9wKSB7XG4gICAgICBpZiAodG9wID09PSB2b2lkIDApIHtcbiAgICAgICAgdG9wID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dCA9ICcnLFxuICAgICAgICAgIGksXG4gICAgICAgICAgaixcbiAgICAgICAgICBrLFxuICAgICAgICAgIGwyLFxuICAgICAgICAgIGwzLFxuICAgICAgICAgIHJvdyxcbiAgICAgICAgICBjZWxsLFxuICAgICAgICAgIGhlYWRlcixcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIHRva2VuLFxuICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgbG9vc2UsXG4gICAgICAgICAgaXRlbUJvZHksXG4gICAgICAgICAgaXRlbSxcbiAgICAgICAgICBjaGVja2VkLFxuICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgY2hlY2tib3g7XG4gICAgICB2YXIgbCA9IHRva2Vucy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2hyJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaHIoKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdoZWFkaW5nJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaGVhZGluZyh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucyksIHRva2VuLmRlcHRoLCB1bmVzY2FwZSQxKHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zLCB0aGlzLnRleHRSZW5kZXJlcikpLCB0aGlzLnNsdWdnZXIpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2NvZGUnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5jb2RlKHRva2VuLnRleHQsIHRva2VuLmxhbmcsIHRva2VuLmVzY2FwZWQpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaGVhZGVyID0gJyc7IC8vIGhlYWRlclxuXG4gICAgICAgICAgICAgIGNlbGwgPSAnJztcbiAgICAgICAgICAgICAgbDIgPSB0b2tlbi5oZWFkZXIubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgY2VsbCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlY2VsbCh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2Vucy5oZWFkZXJbal0pLCB7XG4gICAgICAgICAgICAgICAgICBoZWFkZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgICBhbGlnbjogdG9rZW4uYWxpZ25bal1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGhlYWRlciArPSB0aGlzLnJlbmRlcmVyLnRhYmxlcm93KGNlbGwpO1xuICAgICAgICAgICAgICBib2R5ID0gJyc7XG4gICAgICAgICAgICAgIGwyID0gdG9rZW4uY2VsbHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgcm93ID0gdG9rZW4udG9rZW5zLmNlbGxzW2pdO1xuICAgICAgICAgICAgICAgIGNlbGwgPSAnJztcbiAgICAgICAgICAgICAgICBsMyA9IHJvdy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbDM7IGsrKykge1xuICAgICAgICAgICAgICAgICAgY2VsbCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlY2VsbCh0aGlzLnBhcnNlSW5saW5lKHJvd1trXSksIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYWxpZ246IHRva2VuLmFsaWduW2tdXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBib2R5ICs9IHRoaXMucmVuZGVyZXIudGFibGVyb3coY2VsbCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci50YWJsZShoZWFkZXIsIGJvZHkpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBib2R5ID0gdGhpcy5wYXJzZSh0b2tlbi50b2tlbnMpO1xuICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5ibG9ja3F1b3RlKGJvZHkpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvcmRlcmVkID0gdG9rZW4ub3JkZXJlZDtcbiAgICAgICAgICAgICAgc3RhcnQgPSB0b2tlbi5zdGFydDtcbiAgICAgICAgICAgICAgbG9vc2UgPSB0b2tlbi5sb29zZTtcbiAgICAgICAgICAgICAgbDIgPSB0b2tlbi5pdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICAgIGJvZHkgPSAnJztcblxuICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDI7IGorKykge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSB0b2tlbi5pdGVtc1tqXTtcbiAgICAgICAgICAgICAgICBjaGVja2VkID0gaXRlbS5jaGVja2VkO1xuICAgICAgICAgICAgICAgIHRhc2sgPSBpdGVtLnRhc2s7XG4gICAgICAgICAgICAgICAgaXRlbUJvZHkgPSAnJztcblxuICAgICAgICAgICAgICAgIGlmIChpdGVtLnRhc2spIHtcbiAgICAgICAgICAgICAgICAgIGNoZWNrYm94ID0gdGhpcy5yZW5kZXJlci5jaGVja2JveChjaGVja2VkKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGxvb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRva2Vucy5sZW5ndGggPiAwICYmIGl0ZW0udG9rZW5zWzBdLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zWzBdLnRleHQgPSBjaGVja2JveCArICcgJyArIGl0ZW0udG9rZW5zWzBdLnRleHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50b2tlbnNbMF0udG9rZW5zICYmIGl0ZW0udG9rZW5zWzBdLnRva2Vucy5sZW5ndGggPiAwICYmIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50ZXh0ID0gY2hlY2tib3ggKyAnICcgKyBpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgaXRlbS50b2tlbnMudW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjaGVja2JveFxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVtQm9keSArPSBjaGVja2JveDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpdGVtQm9keSArPSB0aGlzLnBhcnNlKGl0ZW0udG9rZW5zLCBsb29zZSk7XG4gICAgICAgICAgICAgICAgYm9keSArPSB0aGlzLnJlbmRlcmVyLmxpc3RpdGVtKGl0ZW1Cb2R5LCB0YXNrLCBjaGVja2VkKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmxpc3QoYm9keSwgb3JkZXJlZCwgc3RhcnQpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyBUT0RPIHBhcnNlIGlubGluZSBjb250ZW50IGlmIHBhcmFtZXRlciBtYXJrZG93bj0xXG4gICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmh0bWwodG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAncGFyYWdyYXBoJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zKSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGJvZHkgPSB0b2tlbi50b2tlbnMgPyB0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucykgOiB0b2tlbi50ZXh0O1xuXG4gICAgICAgICAgICAgIHdoaWxlIChpICsgMSA8IGwgJiYgdG9rZW5zW2kgKyAxXS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1srK2ldO1xuICAgICAgICAgICAgICAgIGJvZHkgKz0gJ1xcbicgKyAodG9rZW4udG9rZW5zID8gdGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMpIDogdG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvdXQgKz0gdG9wID8gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgoYm9keSkgOiBib2R5O1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBlcnJNc2cgPSAnVG9rZW4gd2l0aCBcIicgKyB0b2tlbi50eXBlICsgJ1wiIHR5cGUgd2FzIG5vdCBmb3VuZC4nO1xuXG4gICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIElubGluZSBUb2tlbnNcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8ucGFyc2VJbmxpbmUgPSBmdW5jdGlvbiBwYXJzZUlubGluZSh0b2tlbnMsIHJlbmRlcmVyKSB7XG4gICAgICByZW5kZXJlciA9IHJlbmRlcmVyIHx8IHRoaXMucmVuZGVyZXI7XG4gICAgICB2YXIgb3V0ID0gJycsXG4gICAgICAgICAgaSxcbiAgICAgICAgICB0b2tlbjtcbiAgICAgIHZhciBsID0gdG9rZW5zLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdlc2NhcGUnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIudGV4dCh0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmh0bWwodG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnbGluayc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5saW5rKHRva2VuLmhyZWYsIHRva2VuLnRpdGxlLCB0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5pbWFnZSh0b2tlbi5ocmVmLCB0b2tlbi50aXRsZSwgdG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnc3Ryb25nJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLnN0cm9uZyh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdlbSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5lbSh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdjb2Rlc3Bhbic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5jb2Rlc3Bhbih0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdicic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5icigpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2RlbCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5kZWwodGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMsIHJlbmRlcmVyKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci50ZXh0KHRva2VuLnRleHQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBlcnJNc2cgPSAnVG9rZW4gd2l0aCBcIicgKyB0b2tlbi50eXBlICsgJ1wiIHR5cGUgd2FzIG5vdCBmb3VuZC4nO1xuXG4gICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcblxuICAgIHJldHVybiBQYXJzZXI7XG4gIH0oKTtcblxuICB2YXIgbWVyZ2UkMiA9IGhlbHBlcnMubWVyZ2UsXG4gICAgICBjaGVja1Nhbml0aXplRGVwcmVjYXRpb24kMSA9IGhlbHBlcnMuY2hlY2tTYW5pdGl6ZURlcHJlY2F0aW9uLFxuICAgICAgZXNjYXBlJDIgPSBoZWxwZXJzLmVzY2FwZTtcbiAgdmFyIGdldERlZmF1bHRzID0gZGVmYXVsdHMuZ2V0RGVmYXVsdHMsXG4gICAgICBjaGFuZ2VEZWZhdWx0cyA9IGRlZmF1bHRzLmNoYW5nZURlZmF1bHRzLFxuICAgICAgZGVmYXVsdHMkNSA9IGRlZmF1bHRzLmRlZmF1bHRzO1xuICAvKipcbiAgICogTWFya2VkXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG1hcmtlZChzcmMsIG9wdCwgY2FsbGJhY2spIHtcbiAgICAvLyB0aHJvdyBlcnJvciBpbiBjYXNlIG9mIG5vbiBzdHJpbmcgaW5wdXRcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3VuZGVmaW5lZCcgfHwgc3JjID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcmtlZCgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkIG9yIG51bGwnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFya2VkKCk6IGlucHV0IHBhcmFtZXRlciBpcyBvZiB0eXBlICcgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3JjKSArICcsIHN0cmluZyBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdDtcbiAgICAgIG9wdCA9IG51bGw7XG4gICAgfVxuXG4gICAgb3B0ID0gbWVyZ2UkMih7fSwgbWFya2VkLmRlZmF1bHRzLCBvcHQgfHwge30pO1xuICAgIGNoZWNrU2FuaXRpemVEZXByZWNhdGlvbiQxKG9wdCk7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBoaWdobGlnaHQgPSBvcHQuaGlnaGxpZ2h0O1xuICAgICAgdmFyIHRva2VucztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdG9rZW5zID0gTGV4ZXJfMS5sZXgoc3JjLCBvcHQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkb25lID0gZnVuY3Rpb24gZG9uZShlcnIpIHtcbiAgICAgICAgdmFyIG91dDtcblxuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvdXQgPSBQYXJzZXJfMS5wYXJzZSh0b2tlbnMsIG9wdCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyID0gZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvcHQuaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0O1xuICAgICAgICByZXR1cm4gZXJyID8gY2FsbGJhY2soZXJyKSA6IGNhbGxiYWNrKG51bGwsIG91dCk7XG4gICAgICB9O1xuXG4gICAgICBpZiAoIWhpZ2hsaWdodCB8fCBoaWdobGlnaHQubGVuZ3RoIDwgMykge1xuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgb3B0LmhpZ2hsaWdodDtcbiAgICAgIGlmICghdG9rZW5zLmxlbmd0aCkgcmV0dXJuIGRvbmUoKTtcbiAgICAgIHZhciBwZW5kaW5nID0gMDtcbiAgICAgIG1hcmtlZC53YWxrVG9rZW5zKHRva2VucywgZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnY29kZScpIHtcbiAgICAgICAgICBwZW5kaW5nKys7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBoaWdobGlnaHQodG9rZW4udGV4dCwgdG9rZW4ubGFuZywgZnVuY3Rpb24gKGVyciwgY29kZSkge1xuICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChjb2RlICE9IG51bGwgJiYgY29kZSAhPT0gdG9rZW4udGV4dCkge1xuICAgICAgICAgICAgICAgIHRva2VuLnRleHQgPSBjb2RlO1xuICAgICAgICAgICAgICAgIHRva2VuLmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcGVuZGluZy0tO1xuXG4gICAgICAgICAgICAgIGlmIChwZW5kaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChwZW5kaW5nID09PSAwKSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB2YXIgX3Rva2VucyA9IExleGVyXzEubGV4KHNyYywgb3B0KTtcblxuICAgICAgaWYgKG9wdC53YWxrVG9rZW5zKSB7XG4gICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKF90b2tlbnMsIG9wdC53YWxrVG9rZW5zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFBhcnNlcl8xLnBhcnNlKF90b2tlbnMsIG9wdCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5tZXNzYWdlICs9ICdcXG5QbGVhc2UgcmVwb3J0IHRoaXMgdG8gaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZC4nO1xuXG4gICAgICBpZiAob3B0LnNpbGVudCkge1xuICAgICAgICByZXR1cm4gJzxwPkFuIGVycm9yIG9jY3VycmVkOjwvcD48cHJlPicgKyBlc2NhcGUkMihlLm1lc3NhZ2UgKyAnJywgdHJ1ZSkgKyAnPC9wcmU+JztcbiAgICAgIH1cblxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE9wdGlvbnNcbiAgICovXG5cblxuICBtYXJrZWQub3B0aW9ucyA9IG1hcmtlZC5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdCkge1xuICAgIG1lcmdlJDIobWFya2VkLmRlZmF1bHRzLCBvcHQpO1xuICAgIGNoYW5nZURlZmF1bHRzKG1hcmtlZC5kZWZhdWx0cyk7XG4gICAgcmV0dXJuIG1hcmtlZDtcbiAgfTtcblxuICBtYXJrZWQuZ2V0RGVmYXVsdHMgPSBnZXREZWZhdWx0cztcbiAgbWFya2VkLmRlZmF1bHRzID0gZGVmYXVsdHMkNTtcbiAgLyoqXG4gICAqIFVzZSBFeHRlbnNpb25cbiAgICovXG5cbiAgbWFya2VkLnVzZSA9IGZ1bmN0aW9uIChleHRlbnNpb24pIHtcbiAgICB2YXIgb3B0cyA9IG1lcmdlJDIoe30sIGV4dGVuc2lvbik7XG5cbiAgICBpZiAoZXh0ZW5zaW9uLnJlbmRlcmVyKSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSBtYXJrZWQuZGVmYXVsdHMucmVuZGVyZXIgfHwgbmV3IFJlbmRlcmVyXzEoKTtcblxuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChwcm9wKSB7XG4gICAgICAgICAgdmFyIHByZXZSZW5kZXJlciA9IHJlbmRlcmVyW3Byb3BdO1xuXG4gICAgICAgICAgcmVuZGVyZXJbcHJvcF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJldCA9IGV4dGVuc2lvbi5yZW5kZXJlcltwcm9wXS5hcHBseShyZW5kZXJlciwgYXJncyk7XG5cbiAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHJldCA9IHByZXZSZW5kZXJlci5hcHBseShyZW5kZXJlciwgYXJncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGV4dGVuc2lvbi5yZW5kZXJlcikge1xuICAgICAgICAgIF9sb29wKHByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0cy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgfSkoKTtcbiAgICB9XG5cbiAgICBpZiAoZXh0ZW5zaW9uLnRva2VuaXplcikge1xuICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRva2VuaXplciA9IG1hcmtlZC5kZWZhdWx0cy50b2tlbml6ZXIgfHwgbmV3IFRva2VuaXplcl8xKCk7XG5cbiAgICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihwcm9wKSB7XG4gICAgICAgICAgdmFyIHByZXZUb2tlbml6ZXIgPSB0b2tlbml6ZXJbcHJvcF07XG5cbiAgICAgICAgICB0b2tlbml6ZXJbcHJvcF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmV0ID0gZXh0ZW5zaW9uLnRva2VuaXplcltwcm9wXS5hcHBseSh0b2tlbml6ZXIsIGFyZ3MpO1xuXG4gICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXQgPSBwcmV2VG9rZW5pemVyLmFwcGx5KHRva2VuaXplciwgYXJncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGV4dGVuc2lvbi50b2tlbml6ZXIpIHtcbiAgICAgICAgICBfbG9vcDIocHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRzLnRva2VuaXplciA9IHRva2VuaXplcjtcbiAgICAgIH0pKCk7XG4gICAgfVxuXG4gICAgaWYgKGV4dGVuc2lvbi53YWxrVG9rZW5zKSB7XG4gICAgICB2YXIgd2Fsa1Rva2VucyA9IG1hcmtlZC5kZWZhdWx0cy53YWxrVG9rZW5zO1xuXG4gICAgICBvcHRzLndhbGtUb2tlbnMgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgZXh0ZW5zaW9uLndhbGtUb2tlbnModG9rZW4pO1xuXG4gICAgICAgIGlmICh3YWxrVG9rZW5zKSB7XG4gICAgICAgICAgd2Fsa1Rva2Vucyh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgbWFya2VkLnNldE9wdGlvbnMob3B0cyk7XG4gIH07XG4gIC8qKlxuICAgKiBSdW4gY2FsbGJhY2sgZm9yIGV2ZXJ5IHRva2VuXG4gICAqL1xuXG5cbiAgbWFya2VkLndhbGtUb2tlbnMgPSBmdW5jdGlvbiAodG9rZW5zLCBjYWxsYmFjaykge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodG9rZW5zKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICAgIHZhciB0b2tlbiA9IF9zdGVwLnZhbHVlO1xuICAgICAgY2FsbGJhY2sodG9rZW4pO1xuXG4gICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHRva2VuLnRva2Vucy5oZWFkZXIpLCBfc3RlcDI7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgY2VsbCA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICAgICAgbWFya2VkLndhbGtUb2tlbnMoY2VsbCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSh0b2tlbi50b2tlbnMuY2VsbHMpLCBfc3RlcDM7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMygpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgcm93ID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHJvdyksIF9zdGVwNDsgIShfc3RlcDQgPSBfaXRlcmF0b3I0KCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jZWxsID0gX3N0ZXA0LnZhbHVlO1xuICAgICAgICAgICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKF9jZWxsLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKHRva2VuLml0ZW1zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAodG9rZW4udG9rZW5zKSB7XG4gICAgICAgICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKHRva2VuLnRva2VucywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBQYXJzZSBJbmxpbmVcbiAgICovXG5cblxuICBtYXJrZWQucGFyc2VJbmxpbmUgPSBmdW5jdGlvbiAoc3JjLCBvcHQpIHtcbiAgICAvLyB0aHJvdyBlcnJvciBpbiBjYXNlIG9mIG5vbiBzdHJpbmcgaW5wdXRcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3VuZGVmaW5lZCcgfHwgc3JjID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcmtlZC5wYXJzZUlubGluZSgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkIG9yIG51bGwnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFya2VkLnBhcnNlSW5saW5lKCk6IGlucHV0IHBhcmFtZXRlciBpcyBvZiB0eXBlICcgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3JjKSArICcsIHN0cmluZyBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIG9wdCA9IG1lcmdlJDIoe30sIG1hcmtlZC5kZWZhdWx0cywgb3B0IHx8IHt9KTtcbiAgICBjaGVja1Nhbml0aXplRGVwcmVjYXRpb24kMShvcHQpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciB0b2tlbnMgPSBMZXhlcl8xLmxleElubGluZShzcmMsIG9wdCk7XG5cbiAgICAgIGlmIChvcHQud2Fsa1Rva2Vucykge1xuICAgICAgICBtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbnMsIG9wdC53YWxrVG9rZW5zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFBhcnNlcl8xLnBhcnNlSW5saW5lKHRva2Vucywgb3B0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlLm1lc3NhZ2UgKz0gJ1xcblBsZWFzZSByZXBvcnQgdGhpcyB0byBodHRwczovL2dpdGh1Yi5jb20vbWFya2VkanMvbWFya2VkLic7XG5cbiAgICAgIGlmIChvcHQuc2lsZW50KSB7XG4gICAgICAgIHJldHVybiAnPHA+QW4gZXJyb3Igb2NjdXJyZWQ6PC9wPjxwcmU+JyArIGVzY2FwZSQyKGUubWVzc2FnZSArICcnLCB0cnVlKSArICc8L3ByZT4nO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEV4cG9zZVxuICAgKi9cblxuXG4gIG1hcmtlZC5QYXJzZXIgPSBQYXJzZXJfMTtcbiAgbWFya2VkLnBhcnNlciA9IFBhcnNlcl8xLnBhcnNlO1xuICBtYXJrZWQuUmVuZGVyZXIgPSBSZW5kZXJlcl8xO1xuICBtYXJrZWQuVGV4dFJlbmRlcmVyID0gVGV4dFJlbmRlcmVyXzE7XG4gIG1hcmtlZC5MZXhlciA9IExleGVyXzE7XG4gIG1hcmtlZC5sZXhlciA9IExleGVyXzEubGV4O1xuICBtYXJrZWQuVG9rZW5pemVyID0gVG9rZW5pemVyXzE7XG4gIG1hcmtlZC5TbHVnZ2VyID0gU2x1Z2dlcl8xO1xuICBtYXJrZWQucGFyc2UgPSBtYXJrZWQ7XG4gIHZhciBtYXJrZWRfMSA9IG1hcmtlZDtcblxuICByZXR1cm4gbWFya2VkXzE7XG5cbn0pKSk7XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyoqXG4gKiBBY3Rpb25zIHRoYXQgbW9kaWZ5IHRoZSBVUkwuXG4gKi9cbnZhciBMb2NhdGlvbkFjdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBhIG5ldyBsb2NhdGlvbiBpcyBiZWluZyBwdXNoZWQgdG8gdGhlIGhpc3Rvcnkgc3RhY2suXG4gICAqL1xuICBQVVNIOiAncHVzaCcsXG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGUgY3VycmVudCBsb2NhdGlvbiBzaG91bGQgYmUgcmVwbGFjZWQuXG4gICAqL1xuICBSRVBMQUNFOiAncmVwbGFjZScsXG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGUgbW9zdCByZWNlbnQgZW50cnkgc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSB0aGUgaGlzdG9yeSBzdGFjay5cbiAgICovXG4gIFBPUDogJ3BvcCdcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMb2NhdGlvbkFjdGlvbnM7XG4iLCJ2YXIgTG9jYXRpb25BY3Rpb25zID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9Mb2NhdGlvbkFjdGlvbnMnKTtcblxuLyoqXG4gKiBBIHNjcm9sbCBiZWhhdmlvciB0aGF0IGF0dGVtcHRzIHRvIGltaXRhdGUgdGhlIGRlZmF1bHQgYmVoYXZpb3JcbiAqIG9mIG1vZGVybiBicm93c2Vycy5cbiAqL1xudmFyIEltaXRhdGVCcm93c2VyQmVoYXZpb3IgPSB7XG5cbiAgdXBkYXRlU2Nyb2xsUG9zaXRpb246IGZ1bmN0aW9uIChwb3NpdGlvbiwgYWN0aW9uVHlwZSkge1xuICAgIHN3aXRjaCAoYWN0aW9uVHlwZSkge1xuICAgICAgY2FzZSBMb2NhdGlvbkFjdGlvbnMuUFVTSDpcbiAgICAgIGNhc2UgTG9jYXRpb25BY3Rpb25zLlJFUExBQ0U6XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExvY2F0aW9uQWN0aW9ucy5QT1A6XG4gICAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW1pdGF0ZUJyb3dzZXJCZWhhdmlvcjtcbiIsIi8qKlxuICogQSBzY3JvbGwgYmVoYXZpb3IgdGhhdCBhbHdheXMgc2Nyb2xscyB0byB0aGUgdG9wIG9mIHRoZSBwYWdlXG4gKiBhZnRlciBhIHRyYW5zaXRpb24uXG4gKi9cbnZhciBTY3JvbGxUb1RvcEJlaGF2aW9yID0ge1xuXG4gIHVwZGF0ZVNjcm9sbFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2Nyb2xsVG9Ub3BCZWhhdmlvcjtcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgRmFrZU5vZGUgPSByZXF1aXJlKCcuLi9taXhpbnMvRmFrZU5vZGUnKTtcbnZhciBQcm9wVHlwZXMgPSByZXF1aXJlKCcuLi91dGlscy9Qcm9wVHlwZXMnKTtcblxuLyoqXG4gKiBBIDxEZWZhdWx0Um91dGU+IGNvbXBvbmVudCBpcyBhIHNwZWNpYWwga2luZCBvZiA8Um91dGU+IHRoYXRcbiAqIHJlbmRlcnMgd2hlbiBpdHMgcGFyZW50IG1hdGNoZXMgYnV0IG5vbmUgb2YgaXRzIHNpYmxpbmdzIGRvLlxuICogT25seSBvbmUgc3VjaCByb3V0ZSBtYXkgYmUgdXNlZCBhdCBhbnkgZ2l2ZW4gbGV2ZWwgaW4gdGhlXG4gKiByb3V0ZSBoaWVyYXJjaHkuXG4gKi9cbnZhciBEZWZhdWx0Um91dGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgZGlzcGxheU5hbWU6ICdEZWZhdWx0Um91dGUnLFxuXG4gIG1peGluczogWyBGYWtlTm9kZSBdLFxuXG4gIHByb3BUeXBlczoge1xuICAgIG5hbWU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgcGF0aDogUHJvcFR5cGVzLmZhbHN5LFxuICAgIGhhbmRsZXI6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWZhdWx0Um91dGU7XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGNsYXNzU2V0ID0gcmVxdWlyZSgncmVhY3QvbGliL2N4Jyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgncmVhY3QvbGliL09iamVjdC5hc3NpZ24nKTtcbnZhciBOYXZpZ2F0aW9uID0gcmVxdWlyZSgnLi4vbWl4aW5zL05hdmlnYXRpb24nKTtcbnZhciBTdGF0ZSA9IHJlcXVpcmUoJy4uL21peGlucy9TdGF0ZScpO1xuXG5mdW5jdGlvbiBpc0xlZnRDbGlja0V2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5idXR0b24gPT09IDA7XG59XG5cbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudCkge1xuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG59XG5cbi8qKlxuICogPExpbms+IGNvbXBvbmVudHMgYXJlIHVzZWQgdG8gY3JlYXRlIGFuIDxhPiBlbGVtZW50IHRoYXQgbGlua3MgdG8gYSByb3V0ZS5cbiAqIFdoZW4gdGhhdCByb3V0ZSBpcyBhY3RpdmUsIHRoZSBsaW5rIGdldHMgYW4gXCJhY3RpdmVcIiBjbGFzcyBuYW1lIChvciB0aGVcbiAqIHZhbHVlIG9mIGl0cyBgYWN0aXZlQ2xhc3NOYW1lYCBwcm9wKS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgYXNzdW1pbmcgeW91IGhhdmUgdGhlIGZvbGxvd2luZyByb3V0ZTpcbiAqXG4gKiAgIDxSb3V0ZSBuYW1lPVwic2hvd1Bvc3RcIiBwYXRoPVwiL3Bvc3RzLzpwb3N0SURcIiBoYW5kbGVyPXtQb3N0fS8+XG4gKlxuICogWW91IGNvdWxkIHVzZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudCB0byBsaW5rIHRvIHRoYXQgcm91dGU6XG4gKlxuICogICA8TGluayB0bz1cInNob3dQb3N0XCIgcGFyYW1zPXt7IHBvc3RJRDogXCIxMjNcIiB9fSAvPlxuICpcbiAqIEluIGFkZGl0aW9uIHRvIHBhcmFtcywgbGlua3MgbWF5IHBhc3MgYWxvbmcgcXVlcnkgc3RyaW5nIHBhcmFtZXRlcnNcbiAqIHVzaW5nIHRoZSBgcXVlcnlgIHByb3AuXG4gKlxuICogICA8TGluayB0bz1cInNob3dQb3N0XCIgcGFyYW1zPXt7IHBvc3RJRDogXCIxMjNcIiB9fSBxdWVyeT17eyBzaG93OnRydWUgfX0vPlxuICovXG52YXIgTGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICBkaXNwbGF5TmFtZTogJ0xpbmsnLFxuXG4gIG1peGluczogWyBOYXZpZ2F0aW9uLCBTdGF0ZSBdLFxuXG4gIHByb3BUeXBlczoge1xuICAgIGFjdGl2ZUNsYXNzTmFtZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIHRvOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgcGFyYW1zOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHF1ZXJ5OiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIG9uQ2xpY2s6IFJlYWN0LlByb3BUeXBlcy5mdW5jXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGl2ZUNsYXNzTmFtZTogJ2FjdGl2ZSdcbiAgICB9O1xuICB9LFxuXG4gIGhhbmRsZUNsaWNrOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgYWxsb3dUcmFuc2l0aW9uID0gdHJ1ZTtcbiAgICB2YXIgY2xpY2tSZXN1bHQ7XG5cbiAgICBpZiAodGhpcy5wcm9wcy5vbkNsaWNrKVxuICAgICAgY2xpY2tSZXN1bHQgPSB0aGlzLnByb3BzLm9uQ2xpY2soZXZlbnQpO1xuXG4gICAgaWYgKGlzTW9kaWZpZWRFdmVudChldmVudCkgfHwgIWlzTGVmdENsaWNrRXZlbnQoZXZlbnQpKVxuICAgICAgcmV0dXJuO1xuXG4gICAgaWYgKGNsaWNrUmVzdWx0ID09PSBmYWxzZSB8fCBldmVudC5kZWZhdWx0UHJldmVudGVkID09PSB0cnVlKVxuICAgICAgYWxsb3dUcmFuc2l0aW9uID0gZmFsc2U7XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgaWYgKGFsbG93VHJhbnNpdGlvbilcbiAgICAgIHRoaXMudHJhbnNpdGlvblRvKHRoaXMucHJvcHMudG8sIHRoaXMucHJvcHMucGFyYW1zLCB0aGlzLnByb3BzLnF1ZXJ5KTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIFwiaHJlZlwiIGF0dHJpYnV0ZSB0byB1c2Ugb24gdGhlIERPTSBlbGVtZW50LlxuICAgKi9cbiAgZ2V0SHJlZjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1ha2VIcmVmKHRoaXMucHJvcHMudG8sIHRoaXMucHJvcHMucGFyYW1zLCB0aGlzLnByb3BzLnF1ZXJ5KTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIFwiY2xhc3NcIiBhdHRyaWJ1dGUgdG8gdXNlIG9uIHRoZSBET00gZWxlbWVudCwgd2hpY2ggY29udGFpbnNcbiAgICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmVDbGFzc05hbWUgcHJvcGVydHkgd2hlbiB0aGlzIDxMaW5rPiBpcyBhY3RpdmUuXG4gICAqL1xuICBnZXRDbGFzc05hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2xhc3NOYW1lcyA9IHt9O1xuXG4gICAgaWYgKHRoaXMucHJvcHMuY2xhc3NOYW1lKVxuICAgICAgY2xhc3NOYW1lc1t0aGlzLnByb3BzLmNsYXNzTmFtZV0gPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMuaXNBY3RpdmUodGhpcy5wcm9wcy50bywgdGhpcy5wcm9wcy5wYXJhbXMsIHRoaXMucHJvcHMucXVlcnkpKVxuICAgICAgY2xhc3NOYW1lc1t0aGlzLnByb3BzLmFjdGl2ZUNsYXNzTmFtZV0gPSB0cnVlO1xuXG4gICAgcmV0dXJuIGNsYXNzU2V0KGNsYXNzTmFtZXMpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9wcyA9IGFzc2lnbih7fSwgdGhpcy5wcm9wcywge1xuICAgICAgaHJlZjogdGhpcy5nZXRIcmVmKCksXG4gICAgICBjbGFzc05hbWU6IHRoaXMuZ2V0Q2xhc3NOYW1lKCksXG4gICAgICBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrXG4gICAgfSk7XG5cbiAgICByZXR1cm4gUmVhY3QuRE9NLmEocHJvcHMsIHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbms7XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIEZha2VOb2RlID0gcmVxdWlyZSgnLi4vbWl4aW5zL0Zha2VOb2RlJyk7XG52YXIgUHJvcFR5cGVzID0gcmVxdWlyZSgnLi4vdXRpbHMvUHJvcFR5cGVzJyk7XG5cbi8qKlxuICogQSA8Tm90Rm91bmRSb3V0ZT4gaXMgYSBzcGVjaWFsIGtpbmQgb2YgPFJvdXRlPiB0aGF0XG4gKiByZW5kZXJzIHdoZW4gdGhlIGJlZ2lubmluZyBvZiBpdHMgcGFyZW50J3MgcGF0aCBtYXRjaGVzXG4gKiBidXQgbm9uZSBvZiBpdHMgc2libGluZ3MgZG8sIGluY2x1ZGluZyBhbnkgPERlZmF1bHRSb3V0ZT4uXG4gKiBPbmx5IG9uZSBzdWNoIHJvdXRlIG1heSBiZSB1c2VkIGF0IGFueSBnaXZlbiBsZXZlbCBpbiB0aGVcbiAqIHJvdXRlIGhpZXJhcmNoeS5cbiAqL1xudmFyIE5vdEZvdW5kUm91dGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgZGlzcGxheU5hbWU6ICdOb3RGb3VuZFJvdXRlJyxcblxuICBtaXhpbnM6IFsgRmFrZU5vZGUgXSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBuYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHBhdGg6IFByb3BUeXBlcy5mYWxzeSxcbiAgICBoYW5kbGVyOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTm90Rm91bmRSb3V0ZTtcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgRmFrZU5vZGUgPSByZXF1aXJlKCcuLi9taXhpbnMvRmFrZU5vZGUnKTtcbnZhciBQcm9wVHlwZXMgPSByZXF1aXJlKCcuLi91dGlscy9Qcm9wVHlwZXMnKTtcblxuLyoqXG4gKiBBIDxSZWRpcmVjdD4gY29tcG9uZW50IGlzIGEgc3BlY2lhbCBraW5kIG9mIDxSb3V0ZT4gdGhhdCBhbHdheXNcbiAqIHJlZGlyZWN0cyB0byBhbm90aGVyIHJvdXRlIHdoZW4gaXQgbWF0Y2hlcy5cbiAqL1xudmFyIFJlZGlyZWN0ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gIGRpc3BsYXlOYW1lOiAnUmVkaXJlY3QnLFxuXG4gIG1peGluczogWyBGYWtlTm9kZSBdLFxuXG4gIHByb3BUeXBlczoge1xuICAgIHBhdGg6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgZnJvbTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZywgLy8gQWxpYXMgZm9yIHBhdGguXG4gICAgdG86IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgaGFuZGxlcjogUHJvcFR5cGVzLmZhbHN5XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVkaXJlY3Q7XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIEZha2VOb2RlID0gcmVxdWlyZSgnLi4vbWl4aW5zL0Zha2VOb2RlJyk7XG5cbi8qKlxuICogPFJvdXRlPiBjb21wb25lbnRzIHNwZWNpZnkgY29tcG9uZW50cyB0aGF0IGFyZSByZW5kZXJlZCB0byB0aGUgcGFnZSB3aGVuIHRoZVxuICogVVJMIG1hdGNoZXMgYSBnaXZlbiBwYXR0ZXJuLlxuICpcbiAqIFJvdXRlcyBhcmUgYXJyYW5nZWQgaW4gYSBuZXN0ZWQgdHJlZSBzdHJ1Y3R1cmUuIFdoZW4gYSBuZXcgVVJMIGlzIHJlcXVlc3RlZCxcbiAqIHRoZSB0cmVlIGlzIHNlYXJjaGVkIGRlcHRoLWZpcnN0IHRvIGZpbmQgYSByb3V0ZSB3aG9zZSBwYXRoIG1hdGNoZXMgdGhlIFVSTC5cbiAqIFdoZW4gb25lIGlzIGZvdW5kLCBhbGwgcm91dGVzIGluIHRoZSB0cmVlIHRoYXQgbGVhZCB0byBpdCBhcmUgY29uc2lkZXJlZFxuICogXCJhY3RpdmVcIiBhbmQgdGhlaXIgY29tcG9uZW50cyBhcmUgcmVuZGVyZWQgaW50byB0aGUgRE9NLCBuZXN0ZWQgaW4gdGhlIHNhbWVcbiAqIG9yZGVyIGFzIHRoZXkgYXJlIGluIHRoZSB0cmVlLlxuICpcbiAqIFRoZSBwcmVmZXJyZWQgd2F5IHRvIGNvbmZpZ3VyZSBhIHJvdXRlciBpcyB1c2luZyBKU1guIFRoZSBYTUwtbGlrZSBzeW50YXggaXNcbiAqIGEgZ3JlYXQgd2F5IHRvIHZpc3VhbGl6ZSBob3cgcm91dGVzIGFyZSBsYWlkIG91dCBpbiBhbiBhcHBsaWNhdGlvbi5cbiAqXG4gKiAgIHZhciByb3V0ZXMgPSBbXG4gKiAgICAgPFJvdXRlIGhhbmRsZXI9e0FwcH0+XG4gKiAgICAgICA8Um91dGUgbmFtZT1cImxvZ2luXCIgaGFuZGxlcj17TG9naW59Lz5cbiAqICAgICAgIDxSb3V0ZSBuYW1lPVwibG9nb3V0XCIgaGFuZGxlcj17TG9nb3V0fS8+XG4gKiAgICAgICA8Um91dGUgbmFtZT1cImFib3V0XCIgaGFuZGxlcj17QWJvdXR9Lz5cbiAqICAgICA8L1JvdXRlPlxuICogICBdO1xuICogICBcbiAqICAgUm91dGVyLnJ1bihyb3V0ZXMsIGZ1bmN0aW9uIChIYW5kbGVyKSB7XG4gKiAgICAgUmVhY3QucmVuZGVyKDxIYW5kbGVyLz4sIGRvY3VtZW50LmJvZHkpO1xuICogICB9KTtcbiAqXG4gKiBIYW5kbGVycyBmb3IgUm91dGUgY29tcG9uZW50cyB0aGF0IGNvbnRhaW4gY2hpbGRyZW4gY2FuIHJlbmRlciB0aGVpciBhY3RpdmVcbiAqIGNoaWxkIHJvdXRlIHVzaW5nIGEgPFJvdXRlSGFuZGxlcj4gZWxlbWVudC5cbiAqXG4gKiAgIHZhciBBcHAgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICByZXR1cm4gKFxuICogICAgICAgICA8ZGl2IGNsYXNzPVwiYXBwbGljYXRpb25cIj5cbiAqICAgICAgICAgICA8Um91dGVIYW5kbGVyLz5cbiAqICAgICAgICAgPC9kaXY+XG4gKiAgICAgICApO1xuICogICAgIH1cbiAqICAgfSk7XG4gKi9cbnZhciBSb3V0ZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICBkaXNwbGF5TmFtZTogJ1JvdXRlJyxcblxuICBtaXhpbnM6IFsgRmFrZU5vZGUgXSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBuYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHBhdGg6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgaGFuZGxlcjogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBpZ25vcmVTY3JvbGxCZWhhdmlvcjogUmVhY3QuUHJvcFR5cGVzLmJvb2xcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3V0ZTtcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUm91dGVIYW5kbGVyTWl4aW4gPSByZXF1aXJlKCcuLi9taXhpbnMvUm91dGVIYW5kbGVyJyk7XG5cbi8qKlxuICogQSA8Um91dGVIYW5kbGVyPiBjb21wb25lbnQgcmVuZGVycyB0aGUgYWN0aXZlIGNoaWxkIHJvdXRlIGhhbmRsZXJcbiAqIHdoZW4gcm91dGVzIGFyZSBuZXN0ZWQuXG4gKi9cbnZhciBSb3V0ZUhhbmRsZXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgZGlzcGxheU5hbWU6ICdSb3V0ZUhhbmRsZXInLFxuXG4gIG1peGluczogW1JvdXRlSGFuZGxlck1peGluXSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVmOiAnX19yb3V0ZUhhbmRsZXJfXydcbiAgICB9O1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldFJvdXRlSGFuZGxlcigpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdXRlSGFuZGxlcjtcbiIsImV4cG9ydHMuRGVmYXVsdFJvdXRlID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL0RlZmF1bHRSb3V0ZScpO1xuZXhwb3J0cy5MaW5rID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL0xpbmsnKTtcbmV4cG9ydHMuTm90Rm91bmRSb3V0ZSA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9Ob3RGb3VuZFJvdXRlJyk7XG5leHBvcnRzLlJlZGlyZWN0ID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL1JlZGlyZWN0Jyk7XG5leHBvcnRzLlJvdXRlID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL1JvdXRlJyk7XG5leHBvcnRzLlJvdXRlSGFuZGxlciA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9Sb3V0ZUhhbmRsZXInKTtcblxuZXhwb3J0cy5IYXNoTG9jYXRpb24gPSByZXF1aXJlKCcuL2xvY2F0aW9ucy9IYXNoTG9jYXRpb24nKTtcbmV4cG9ydHMuSGlzdG9yeUxvY2F0aW9uID0gcmVxdWlyZSgnLi9sb2NhdGlvbnMvSGlzdG9yeUxvY2F0aW9uJyk7XG5leHBvcnRzLlJlZnJlc2hMb2NhdGlvbiA9IHJlcXVpcmUoJy4vbG9jYXRpb25zL1JlZnJlc2hMb2NhdGlvbicpO1xuXG5leHBvcnRzLkltaXRhdGVCcm93c2VyQmVoYXZpb3IgPSByZXF1aXJlKCcuL2JlaGF2aW9ycy9JbWl0YXRlQnJvd3NlckJlaGF2aW9yJyk7XG5leHBvcnRzLlNjcm9sbFRvVG9wQmVoYXZpb3IgPSByZXF1aXJlKCcuL2JlaGF2aW9ycy9TY3JvbGxUb1RvcEJlaGF2aW9yJyk7XG5cbmV4cG9ydHMuTmF2aWdhdGlvbiA9IHJlcXVpcmUoJy4vbWl4aW5zL05hdmlnYXRpb24nKTtcbmV4cG9ydHMuU3RhdGUgPSByZXF1aXJlKCcuL21peGlucy9TdGF0ZScpO1xuXG5leHBvcnRzLmNyZWF0ZSA9IHJlcXVpcmUoJy4vdXRpbHMvY3JlYXRlUm91dGVyJyk7XG5leHBvcnRzLnJ1biA9IHJlcXVpcmUoJy4vdXRpbHMvcnVuUm91dGVyJyk7XG5cbmV4cG9ydHMuSGlzdG9yeSA9IHJlcXVpcmUoJy4vdXRpbHMvSGlzdG9yeScpO1xuIiwidmFyIExvY2F0aW9uQWN0aW9ucyA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvTG9jYXRpb25BY3Rpb25zJyk7XG52YXIgSGlzdG9yeSA9IHJlcXVpcmUoJy4uL3V0aWxzL0hpc3RvcnknKTtcbnZhciBQYXRoID0gcmVxdWlyZSgnLi4vdXRpbHMvUGF0aCcpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgVVJMIHBhdGggZnJvbSB0aGUgYGhhc2hgIHBvcnRpb24gb2YgdGhlIFVSTCwgaW5jbHVkaW5nXG4gKiBxdWVyeSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGdldEhhc2hQYXRoKCkge1xuICByZXR1cm4gUGF0aC5kZWNvZGUoXG4gICAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAgIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gICAgd2luZG93LmxvY2F0aW9uLmhyZWYuc3BsaXQoJyMnKVsxXSB8fCAnJ1xuICApO1xufVxuXG52YXIgX2FjdGlvblR5cGU7XG5cbmZ1bmN0aW9uIGVuc3VyZVNsYXNoKCkge1xuICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XG5cbiAgaWYgKHBhdGguY2hhckF0KDApID09PSAnLycpXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgSGFzaExvY2F0aW9uLnJlcGxhY2UoJy8nICsgcGF0aCk7XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgX2NoYW5nZUxpc3RlbmVycyA9IFtdO1xuXG5mdW5jdGlvbiBub3RpZnlDaGFuZ2UodHlwZSkge1xuICBpZiAodHlwZSA9PT0gTG9jYXRpb25BY3Rpb25zLlBVU0gpXG4gICAgSGlzdG9yeS5sZW5ndGggKz0gMTtcblxuICB2YXIgY2hhbmdlID0ge1xuICAgIHBhdGg6IGdldEhhc2hQYXRoKCksXG4gICAgdHlwZTogdHlwZVxuICB9O1xuXG4gIF9jaGFuZ2VMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICBsaXN0ZW5lcihjaGFuZ2UpO1xuICB9KTtcbn1cblxudmFyIF9pc0xpc3RlbmluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBvbkhhc2hDaGFuZ2UoKSB7XG4gIGlmIChlbnN1cmVTbGFzaCgpKSB7XG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbiBfYWN0aW9uVHlwZSB0aGVuIGFsbCB3ZSBrbm93IGlzIHRoZSBoYXNoXG4gICAgLy8gY2hhbmdlZC4gSXQgd2FzIHByb2JhYmx5IGNhdXNlZCBieSB0aGUgdXNlciBjbGlja2luZyB0aGUgQmFja1xuICAgIC8vIGJ1dHRvbiwgYnV0IG1heSBoYXZlIGFsc28gYmVlbiB0aGUgRm9yd2FyZCBidXR0b24gb3IgbWFudWFsXG4gICAgLy8gbWFuaXB1bGF0aW9uLiBTbyBqdXN0IGd1ZXNzICdwb3AnLlxuICAgIG5vdGlmeUNoYW5nZShfYWN0aW9uVHlwZSB8fCBMb2NhdGlvbkFjdGlvbnMuUE9QKTtcbiAgICBfYWN0aW9uVHlwZSA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBBIExvY2F0aW9uIHRoYXQgdXNlcyBgd2luZG93LmxvY2F0aW9uLmhhc2hgLlxuICovXG52YXIgSGFzaExvY2F0aW9uID0ge1xuXG4gIGFkZENoYW5nZUxpc3RlbmVyOiBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICBfY2hhbmdlTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgLy8gRG8gdGhpcyBCRUZPUkUgbGlzdGVuaW5nIGZvciBoYXNoY2hhbmdlLlxuICAgIGVuc3VyZVNsYXNoKCk7XG5cbiAgICBpZiAoX2lzTGlzdGVuaW5nKVxuICAgICAgcmV0dXJuO1xuXG4gICAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIG9uSGFzaENoYW5nZSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuYXR0YWNoRXZlbnQoJ29uaGFzaGNoYW5nZScsIG9uSGFzaENoYW5nZSk7XG4gICAgfVxuXG4gICAgX2lzTGlzdGVuaW5nID0gdHJ1ZTtcbiAgfSxcblxuICByZW1vdmVDaGFuZ2VMaXN0ZW5lcjogZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IF9jaGFuZ2VMaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbDsgaSArKykge1xuICAgICAgaWYgKF9jaGFuZ2VMaXN0ZW5lcnNbaV0gPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIF9jaGFuZ2VMaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgb25IYXNoQ2hhbmdlLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudCgnb25oYXNoY2hhbmdlJywgb25IYXNoQ2hhbmdlKTtcbiAgICB9XG5cbiAgICBpZiAoX2NoYW5nZUxpc3RlbmVycy5sZW5ndGggPT09IDApXG4gICAgICBfaXNMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgfSxcblxuXG5cbiAgcHVzaDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBfYWN0aW9uVHlwZSA9IExvY2F0aW9uQWN0aW9ucy5QVVNIO1xuICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gUGF0aC5lbmNvZGUocGF0aCk7XG4gIH0sXG5cbiAgcmVwbGFjZTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBfYWN0aW9uVHlwZSA9IExvY2F0aW9uQWN0aW9ucy5SRVBMQUNFO1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArICcjJyArIFBhdGguZW5jb2RlKHBhdGgpKTtcbiAgfSxcblxuICBwb3A6IGZ1bmN0aW9uICgpIHtcbiAgICBfYWN0aW9uVHlwZSA9IExvY2F0aW9uQWN0aW9ucy5QT1A7XG4gICAgSGlzdG9yeS5iYWNrKCk7XG4gIH0sXG5cbiAgZ2V0Q3VycmVudFBhdGg6IGdldEhhc2hQYXRoLFxuXG4gIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICc8SGFzaExvY2F0aW9uPic7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoTG9jYXRpb247XG4iLCJ2YXIgTG9jYXRpb25BY3Rpb25zID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9Mb2NhdGlvbkFjdGlvbnMnKTtcbnZhciBIaXN0b3J5ID0gcmVxdWlyZSgnLi4vdXRpbHMvSGlzdG9yeScpO1xudmFyIFBhdGggPSByZXF1aXJlKCcuLi91dGlscy9QYXRoJyk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBVUkwgcGF0aCBmcm9tIGB3aW5kb3cubG9jYXRpb25gLCBpbmNsdWRpbmcgcXVlcnkgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3dQYXRoKCkge1xuICByZXR1cm4gUGF0aC5kZWNvZGUoXG4gICAgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaFxuICApO1xufVxuXG52YXIgX2NoYW5nZUxpc3RlbmVycyA9IFtdO1xuXG5mdW5jdGlvbiBub3RpZnlDaGFuZ2UodHlwZSkge1xuICB2YXIgY2hhbmdlID0ge1xuICAgIHBhdGg6IGdldFdpbmRvd1BhdGgoKSxcbiAgICB0eXBlOiB0eXBlXG4gIH07XG5cbiAgX2NoYW5nZUxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgIGxpc3RlbmVyKGNoYW5nZSk7XG4gIH0pO1xufVxuXG52YXIgX2lzTGlzdGVuaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIG9uUG9wU3RhdGUoKSB7XG4gIG5vdGlmeUNoYW5nZShMb2NhdGlvbkFjdGlvbnMuUE9QKTtcbn1cblxuLyoqXG4gKiBBIExvY2F0aW9uIHRoYXQgdXNlcyBIVE1MNSBoaXN0b3J5LlxuICovXG52YXIgSGlzdG9yeUxvY2F0aW9uID0ge1xuXG4gIGFkZENoYW5nZUxpc3RlbmVyOiBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICBfY2hhbmdlTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgaWYgKF9pc0xpc3RlbmluZylcbiAgICAgIHJldHVybjtcblxuICAgIGlmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgb25Qb3BTdGF0ZSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuYXR0YWNoRXZlbnQoJ3BvcHN0YXRlJywgb25Qb3BTdGF0ZSk7XG4gICAgfVxuXG4gICAgX2lzTGlzdGVuaW5nID0gdHJ1ZTtcbiAgfSxcblxuICByZW1vdmVDaGFuZ2VMaXN0ZW5lcjogZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IF9jaGFuZ2VMaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbDsgaSArKykge1xuICAgICAgaWYgKF9jaGFuZ2VMaXN0ZW5lcnNbaV0gPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIF9jaGFuZ2VMaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIG9uUG9wU3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnQoJ3BvcHN0YXRlJywgb25Qb3BTdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKF9jaGFuZ2VMaXN0ZW5lcnMubGVuZ3RoID09PSAwKVxuICAgICAgX2lzTGlzdGVuaW5nID0gZmFsc2U7XG4gIH0sXG5cblxuXG4gIHB1c2g6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHsgcGF0aDogcGF0aCB9LCAnJywgUGF0aC5lbmNvZGUocGF0aCkpO1xuICAgIEhpc3RvcnkubGVuZ3RoICs9IDE7XG4gICAgbm90aWZ5Q2hhbmdlKExvY2F0aW9uQWN0aW9ucy5QVVNIKTtcbiAgfSxcblxuICByZXBsYWNlOiBmdW5jdGlvbiAocGF0aCkge1xuICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IHBhdGg6IHBhdGggfSwgJycsIFBhdGguZW5jb2RlKHBhdGgpKTtcbiAgICBub3RpZnlDaGFuZ2UoTG9jYXRpb25BY3Rpb25zLlJFUExBQ0UpO1xuICB9LFxuXG4gIHBvcDogSGlzdG9yeS5iYWNrLFxuXG4gIGdldEN1cnJlbnRQYXRoOiBnZXRXaW5kb3dQYXRoLFxuXG4gIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICc8SGlzdG9yeUxvY2F0aW9uPic7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIaXN0b3J5TG9jYXRpb247XG4iLCJ2YXIgSGlzdG9yeUxvY2F0aW9uID0gcmVxdWlyZSgnLi9IaXN0b3J5TG9jYXRpb24nKTtcbnZhciBIaXN0b3J5ID0gcmVxdWlyZSgnLi4vdXRpbHMvSGlzdG9yeScpO1xudmFyIFBhdGggPSByZXF1aXJlKCcuLi91dGlscy9QYXRoJyk7XG5cbi8qKlxuICogQSBMb2NhdGlvbiB0aGF0IHVzZXMgZnVsbCBwYWdlIHJlZnJlc2hlcy4gVGhpcyBpcyB1c2VkIGFzXG4gKiB0aGUgZmFsbGJhY2sgZm9yIEhpc3RvcnlMb2NhdGlvbiBpbiBicm93c2VycyB0aGF0IGRvIG5vdFxuICogc3VwcG9ydCB0aGUgSFRNTDUgaGlzdG9yeSBBUEkuXG4gKi9cbnZhciBSZWZyZXNoTG9jYXRpb24gPSB7XG5cbiAgcHVzaDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICB3aW5kb3cubG9jYXRpb24gPSBQYXRoLmVuY29kZShwYXRoKTtcbiAgfSxcblxuICByZXBsYWNlOiBmdW5jdGlvbiAocGF0aCkge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKFBhdGguZW5jb2RlKHBhdGgpKTtcbiAgfSxcblxuICBwb3A6IEhpc3RvcnkuYmFjayxcblxuICBnZXRDdXJyZW50UGF0aDogSGlzdG9yeUxvY2F0aW9uLmdldEN1cnJlbnRQYXRoLFxuXG4gIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICc8UmVmcmVzaExvY2F0aW9uPic7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWZyZXNoTG9jYXRpb247XG4iLCJ2YXIgaW52YXJpYW50ID0gcmVxdWlyZSgncmVhY3QvbGliL2ludmFyaWFudCcpO1xuXG52YXIgRmFrZU5vZGUgPSB7XG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgZmFsc2UsXG4gICAgICAnJXMgZWxlbWVudHMgc2hvdWxkIG5vdCBiZSByZW5kZXJlZCcsXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lXG4gICAgKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZha2VOb2RlO1xuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLyoqXG4gKiBBIG1peGluIGZvciBjb21wb25lbnRzIHRoYXQgbW9kaWZ5IHRoZSBVUkwuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgbWl4aW5zOiBbIFJvdXRlci5OYXZpZ2F0aW9uIF0sXG4gKiAgICAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uIChldmVudCkge1xuICogICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAqICAgICAgIHRoaXMudHJhbnNpdGlvblRvKCdhUm91dGUnLCB7IHRoZTogJ3BhcmFtcycgfSwgeyB0aGU6ICdxdWVyeScgfSk7XG4gKiAgICAgfSxcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAqICAgICAgIHJldHVybiAoXG4gKiAgICAgICAgIDxhIG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xpY2t9PkNsaWNrIG1lITwvYT5cbiAqICAgICAgICk7XG4gKiAgICAgfVxuICogICB9KTtcbiAqL1xudmFyIE5hdmlnYXRpb24gPSB7XG5cbiAgY29udGV4dFR5cGVzOiB7XG4gICAgbWFrZVBhdGg6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgbWFrZUhyZWY6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgdHJhbnNpdGlvblRvOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIHJlcGxhY2VXaXRoOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIGdvQmFjazogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFic29sdXRlIFVSTCBwYXRoIGNyZWF0ZWQgZnJvbSB0aGUgZ2l2ZW4gcm91dGVcbiAgICogbmFtZSwgVVJMIHBhcmFtZXRlcnMsIGFuZCBxdWVyeSB2YWx1ZXMuXG4gICAqL1xuICBtYWtlUGF0aDogZnVuY3Rpb24gKHRvLCBwYXJhbXMsIHF1ZXJ5KSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5tYWtlUGF0aCh0bywgcGFyYW1zLCBxdWVyeSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgdGhhdCBtYXkgc2FmZWx5IGJlIHVzZWQgYXMgdGhlIGhyZWYgb2YgYVxuICAgKiBsaW5rIHRvIHRoZSByb3V0ZSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICAgKi9cbiAgbWFrZUhyZWY6IGZ1bmN0aW9uICh0bywgcGFyYW1zLCBxdWVyeSkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQubWFrZUhyZWYodG8sIHBhcmFtcywgcXVlcnkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFuc2l0aW9ucyB0byB0aGUgVVJMIHNwZWNpZmllZCBpbiB0aGUgYXJndW1lbnRzIGJ5IHB1c2hpbmdcbiAgICogYSBuZXcgVVJMIG9udG8gdGhlIGhpc3Rvcnkgc3RhY2suXG4gICAqL1xuICB0cmFuc2l0aW9uVG86IGZ1bmN0aW9uICh0bywgcGFyYW1zLCBxdWVyeSkge1xuICAgIHRoaXMuY29udGV4dC50cmFuc2l0aW9uVG8odG8sIHBhcmFtcywgcXVlcnkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFuc2l0aW9ucyB0byB0aGUgVVJMIHNwZWNpZmllZCBpbiB0aGUgYXJndW1lbnRzIGJ5IHJlcGxhY2luZ1xuICAgKiB0aGUgY3VycmVudCBVUkwgaW4gdGhlIGhpc3Rvcnkgc3RhY2suXG4gICAqL1xuICByZXBsYWNlV2l0aDogZnVuY3Rpb24gKHRvLCBwYXJhbXMsIHF1ZXJ5KSB7XG4gICAgdGhpcy5jb250ZXh0LnJlcGxhY2VXaXRoKHRvLCBwYXJhbXMsIHF1ZXJ5KTtcbiAgfSxcblxuICAvKipcbiAgICogVHJhbnNpdGlvbnMgdG8gdGhlIHByZXZpb3VzIFVSTC5cbiAgICovXG4gIGdvQmFjazogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29udGV4dC5nb0JhY2soKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5hdmlnYXRpb247XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vKipcbiAqIFByb3ZpZGVzIHRoZSByb3V0ZXIgd2l0aCBjb250ZXh0IGZvciBSb3V0ZXIuTmF2aWdhdGlvbi5cbiAqL1xudmFyIE5hdmlnYXRpb25Db250ZXh0ID0ge1xuXG4gIGNoaWxkQ29udGV4dFR5cGVzOiB7XG4gICAgbWFrZVBhdGg6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgbWFrZUhyZWY6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgdHJhbnNpdGlvblRvOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIHJlcGxhY2VXaXRoOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIGdvQmFjazogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICB9LFxuXG4gIGdldENoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYWtlUGF0aDogdGhpcy5jb25zdHJ1Y3Rvci5tYWtlUGF0aCxcbiAgICAgIG1ha2VIcmVmOiB0aGlzLmNvbnN0cnVjdG9yLm1ha2VIcmVmLFxuICAgICAgdHJhbnNpdGlvblRvOiB0aGlzLmNvbnN0cnVjdG9yLnRyYW5zaXRpb25UbyxcbiAgICAgIHJlcGxhY2VXaXRoOiB0aGlzLmNvbnN0cnVjdG9yLnJlcGxhY2VXaXRoLFxuICAgICAgZ29CYWNrOiB0aGlzLmNvbnN0cnVjdG9yLmdvQmFja1xuICAgIH07XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOYXZpZ2F0aW9uQ29udGV4dDtcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb250ZXh0VHlwZXM6IHtcbiAgICBnZXRSb3V0ZUF0RGVwdGg6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgZ2V0Um91dGVDb21wb25lbnRzOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIHJvdXRlSGFuZGxlcnM6IFJlYWN0LlByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgY2hpbGRDb250ZXh0VHlwZXM6IHtcbiAgICByb3V0ZUhhbmRsZXJzOiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZFxuICB9LFxuXG4gIGdldENoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICByb3V0ZUhhbmRsZXJzOiB0aGlzLmNvbnRleHQucm91dGVIYW5kbGVycy5jb25jYXQoWyB0aGlzIF0pXG4gICAgfTtcbiAgfSxcblxuICBnZXRSb3V0ZURlcHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5yb3V0ZUhhbmRsZXJzLmxlbmd0aCAtIDE7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl91cGRhdGVSb3V0ZUNvbXBvbmVudCgpO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3VwZGF0ZVJvdXRlQ29tcG9uZW50KCk7XG4gIH0sXG5cbiAgX3VwZGF0ZVJvdXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlcHRoID0gdGhpcy5nZXRSb3V0ZURlcHRoKCk7XG4gICAgdmFyIGNvbXBvbmVudHMgPSB0aGlzLmNvbnRleHQuZ2V0Um91dGVDb21wb25lbnRzKCk7XG4gICAgY29tcG9uZW50c1tkZXB0aF0gPSB0aGlzLnJlZnNbdGhpcy5wcm9wcy5yZWYgfHwgJ19fcm91dGVIYW5kbGVyX18nXTtcbiAgfSxcblxuICBnZXRSb3V0ZUhhbmRsZXI6IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciByb3V0ZSA9IHRoaXMuY29udGV4dC5nZXRSb3V0ZUF0RGVwdGgodGhpcy5nZXRSb3V0ZURlcHRoKCkpO1xuICAgIHJldHVybiByb3V0ZSA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQocm91dGUuaGFuZGxlciwgcHJvcHMgfHwgdGhpcy5wcm9wcykgOiBudWxsO1xuICB9XG59OyIsInZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdyZWFjdC9saWIvaW52YXJpYW50Jyk7XG52YXIgY2FuVXNlRE9NID0gcmVxdWlyZSgncmVhY3QvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50JykuY2FuVXNlRE9NO1xudmFyIGdldFdpbmRvd1Njcm9sbFBvc2l0aW9uID0gcmVxdWlyZSgnLi4vdXRpbHMvZ2V0V2luZG93U2Nyb2xsUG9zaXRpb24nKTtcblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlU2Nyb2xsKHN0YXRlLCBwcmV2U3RhdGUpIHtcbiAgaWYgKCFwcmV2U3RhdGUpXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgLy8gRG9uJ3QgdXBkYXRlIHNjcm9sbCBwb3NpdGlvbiB3aGVuIG9ubHkgdGhlIHF1ZXJ5IGhhcyBjaGFuZ2VkLlxuICBpZiAoc3RhdGUucGF0aG5hbWUgPT09IHByZXZTdGF0ZS5wYXRobmFtZSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIHJvdXRlcyA9IHN0YXRlLnJvdXRlcztcbiAgdmFyIHByZXZSb3V0ZXMgPSBwcmV2U3RhdGUucm91dGVzO1xuXG4gIHZhciBzaGFyZWRBbmNlc3RvclJvdXRlcyA9IHJvdXRlcy5maWx0ZXIoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgcmV0dXJuIHByZXZSb3V0ZXMuaW5kZXhPZihyb3V0ZSkgIT09IC0xO1xuICB9KTtcblxuICByZXR1cm4gIXNoYXJlZEFuY2VzdG9yUm91dGVzLnNvbWUoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgcmV0dXJuIHJvdXRlLmlnbm9yZVNjcm9sbEJlaGF2aW9yO1xuICB9KTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyB0aGUgcm91dGVyIHdpdGggdGhlIGFiaWxpdHkgdG8gbWFuYWdlIHdpbmRvdyBzY3JvbGwgcG9zaXRpb25cbiAqIGFjY29yZGluZyB0byBpdHMgc2Nyb2xsIGJlaGF2aW9yLlxuICovXG52YXIgU2Nyb2xsaW5nID0ge1xuXG4gIHN0YXRpY3M6IHtcbiAgICAvKipcbiAgICAgKiBSZWNvcmRzIGN1cmVudCBzY3JvbGwgcG9zaXRpb24gYXMgdGhlIGxhc3Qga25vd24gcG9zaXRpb24gZm9yIHRoZSBnaXZlbiBVUkwgcGF0aC5cbiAgICAgKi9cbiAgICByZWNvcmRTY3JvbGxQb3NpdGlvbjogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIGlmICghdGhpcy5zY3JvbGxIaXN0b3J5KVxuICAgICAgICB0aGlzLnNjcm9sbEhpc3RvcnkgPSB7fTtcblxuICAgICAgdGhpcy5zY3JvbGxIaXN0b3J5W3BhdGhdID0gZ2V0V2luZG93U2Nyb2xsUG9zaXRpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGFzdCBrbm93biBzY3JvbGwgcG9zaXRpb24gZm9yIHRoZSBnaXZlbiBVUkwgcGF0aC5cbiAgICAgKi9cbiAgICBnZXRTY3JvbGxQb3NpdGlvbjogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIGlmICghdGhpcy5zY3JvbGxIaXN0b3J5KVxuICAgICAgICB0aGlzLnNjcm9sbEhpc3RvcnkgPSB7fTtcblxuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsSGlzdG9yeVtwYXRoXSB8fCBudWxsO1xuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICB0aGlzLmdldFNjcm9sbEJlaGF2aW9yKCkgPT0gbnVsbCB8fCBjYW5Vc2VET00sXG4gICAgICAnQ2Fubm90IHVzZSBzY3JvbGwgYmVoYXZpb3Igd2l0aG91dCBhIERPTSdcbiAgICApO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdXBkYXRlU2Nyb2xsKCk7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbiAocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICB0aGlzLl91cGRhdGVTY3JvbGwocHJldlN0YXRlKTtcbiAgfSxcblxuICBfdXBkYXRlU2Nyb2xsOiBmdW5jdGlvbiAocHJldlN0YXRlKSB7XG4gICAgaWYgKCFzaG91bGRVcGRhdGVTY3JvbGwodGhpcy5zdGF0ZSwgcHJldlN0YXRlKSlcbiAgICAgIHJldHVybjtcblxuICAgIHZhciBzY3JvbGxCZWhhdmlvciA9IHRoaXMuZ2V0U2Nyb2xsQmVoYXZpb3IoKTtcblxuICAgIGlmIChzY3JvbGxCZWhhdmlvcilcbiAgICAgIHNjcm9sbEJlaGF2aW9yLnVwZGF0ZVNjcm9sbFBvc2l0aW9uKFxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmdldFNjcm9sbFBvc2l0aW9uKHRoaXMuc3RhdGUucGF0aCksXG4gICAgICAgIHRoaXMuc3RhdGUuYWN0aW9uXG4gICAgICApO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2Nyb2xsaW5nO1xuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLyoqXG4gKiBBIG1peGluIGZvciBjb21wb25lbnRzIHRoYXQgbmVlZCB0byBrbm93IHRoZSBwYXRoLCByb3V0ZXMsIFVSTFxuICogcGFyYW1zIGFuZCBxdWVyeSB0aGF0IGFyZSBjdXJyZW50bHkgYWN0aXZlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICB2YXIgQWJvdXRMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIG1peGluczogWyBSb3V0ZXIuU3RhdGUgXSxcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAqICAgICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLnByb3BzLmNsYXNzTmFtZTtcbiAqICAgXG4gKiAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSgnYWJvdXQnKSlcbiAqICAgICAgICAgY2xhc3NOYW1lICs9ICcgaXMtYWN0aXZlJztcbiAqICAgXG4gKiAgICAgICByZXR1cm4gUmVhY3QuRE9NLmEoeyBjbGFzc05hbWU6IGNsYXNzTmFtZSB9LCB0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICovXG52YXIgU3RhdGUgPSB7XG5cbiAgY29udGV4dFR5cGVzOiB7XG4gICAgZ2V0Q3VycmVudFBhdGg6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgZ2V0Q3VycmVudFJvdXRlczogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBnZXRDdXJyZW50UGF0aG5hbWU6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgZ2V0Q3VycmVudFBhcmFtczogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBnZXRDdXJyZW50UXVlcnk6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgaXNBY3RpdmU6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBVUkwgcGF0aC5cbiAgICovXG4gIGdldFBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LmdldEN1cnJlbnRQYXRoKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJvdXRlcyB0aGF0IGFyZSBjdXJyZW50bHkgYWN0aXZlLlxuICAgKi9cbiAgZ2V0Um91dGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5nZXRDdXJyZW50Um91dGVzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgVVJMIHBhdGggd2l0aG91dCB0aGUgcXVlcnkgc3RyaW5nLlxuICAgKi9cbiAgZ2V0UGF0aG5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LmdldEN1cnJlbnRQYXRobmFtZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCBvZiB0aGUgVVJMIHBhcmFtcyB0aGF0IGFyZSBjdXJyZW50bHkgYWN0aXZlLlxuICAgKi9cbiAgZ2V0UGFyYW1zOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5nZXRDdXJyZW50UGFyYW1zKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IG9mIHRoZSBxdWVyeSBwYXJhbXMgdGhhdCBhcmUgY3VycmVudGx5IGFjdGl2ZS5cbiAgICovXG4gIGdldFF1ZXJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5nZXRDdXJyZW50UXVlcnkoKTtcbiAgfSxcblxuICAvKipcbiAgICogQSBoZWxwZXIgbWV0aG9kIHRvIGRldGVybWluZSBpZiBhIGdpdmVuIHJvdXRlLCBwYXJhbXMsIGFuZCBxdWVyeVxuICAgKiBhcmUgYWN0aXZlLlxuICAgKi9cbiAgaXNBY3RpdmU6IGZ1bmN0aW9uICh0bywgcGFyYW1zLCBxdWVyeSkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuaXNBY3RpdmUodG8sIHBhcmFtcywgcXVlcnkpO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGU7XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9PYmplY3QuYXNzaWduJyk7XG52YXIgUGF0aCA9IHJlcXVpcmUoJy4uL3V0aWxzL1BhdGgnKTtcblxuZnVuY3Rpb24gcm91dGVJc0FjdGl2ZShhY3RpdmVSb3V0ZXMsIHJvdXRlTmFtZSkge1xuICByZXR1cm4gYWN0aXZlUm91dGVzLnNvbWUoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgcmV0dXJuIHJvdXRlLm5hbWUgPT09IHJvdXRlTmFtZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBhcmFtc0FyZUFjdGl2ZShhY3RpdmVQYXJhbXMsIHBhcmFtcykge1xuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBwYXJhbXMpXG4gICAgaWYgKFN0cmluZyhhY3RpdmVQYXJhbXNbcHJvcGVydHldKSAhPT0gU3RyaW5nKHBhcmFtc1twcm9wZXJ0eV0pKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBxdWVyeUlzQWN0aXZlKGFjdGl2ZVF1ZXJ5LCBxdWVyeSkge1xuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBxdWVyeSlcbiAgICBpZiAoU3RyaW5nKGFjdGl2ZVF1ZXJ5W3Byb3BlcnR5XSkgIT09IFN0cmluZyhxdWVyeVtwcm9wZXJ0eV0pKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIHRoZSByb3V0ZXIgd2l0aCBjb250ZXh0IGZvciBSb3V0ZXIuU3RhdGUuXG4gKi9cbnZhciBTdGF0ZUNvbnRleHQgPSB7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgVVJMIHBhdGggKyBxdWVyeSBzdHJpbmcuXG4gICAqL1xuICBnZXRDdXJyZW50UGF0aDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnBhdGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSByZWFkLW9ubHkgYXJyYXkgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgcm91dGVzLlxuICAgKi9cbiAgZ2V0Q3VycmVudFJvdXRlczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnJvdXRlcy5zbGljZSgwKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBVUkwgcGF0aCB3aXRob3V0IHRoZSBxdWVyeSBzdHJpbmcuXG4gICAqL1xuICBnZXRDdXJyZW50UGF0aG5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5wYXRobmFtZTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHJlYWQtb25seSBvYmplY3Qgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgVVJMIHBhcmFtZXRlcnMuXG4gICAqL1xuICBnZXRDdXJyZW50UGFyYW1zOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFzc2lnbih7fSwgdGhpcy5zdGF0ZS5wYXJhbXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcmVhZC1vbmx5IG9iamVjdCBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBxdWVyeSBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgZ2V0Q3VycmVudFF1ZXJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFzc2lnbih7fSwgdGhpcy5zdGF0ZS5xdWVyeSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcm91dGUsIHBhcmFtcywgYW5kIHF1ZXJ5IGFyZSBhY3RpdmUuXG4gICAqL1xuICBpc0FjdGl2ZTogZnVuY3Rpb24gKHRvLCBwYXJhbXMsIHF1ZXJ5KSB7XG4gICAgaWYgKFBhdGguaXNBYnNvbHV0ZSh0bykpXG4gICAgICByZXR1cm4gdG8gPT09IHRoaXMuc3RhdGUucGF0aDtcblxuICAgIHJldHVybiByb3V0ZUlzQWN0aXZlKHRoaXMuc3RhdGUucm91dGVzLCB0bykgJiZcbiAgICAgIHBhcmFtc0FyZUFjdGl2ZSh0aGlzLnN0YXRlLnBhcmFtcywgcGFyYW1zKSAmJlxuICAgICAgKHF1ZXJ5ID09IG51bGwgfHwgcXVlcnlJc0FjdGl2ZSh0aGlzLnN0YXRlLnF1ZXJ5LCBxdWVyeSkpO1xuICB9LFxuXG4gIGNoaWxkQ29udGV4dFR5cGVzOiB7XG4gICAgZ2V0Q3VycmVudFBhdGg6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgZ2V0Q3VycmVudFJvdXRlczogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBnZXRDdXJyZW50UGF0aG5hbWU6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgZ2V0Q3VycmVudFBhcmFtczogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBnZXRDdXJyZW50UXVlcnk6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgaXNBY3RpdmU6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgfSxcblxuICBnZXRDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0Q3VycmVudFBhdGg6IHRoaXMuZ2V0Q3VycmVudFBhdGgsXG4gICAgICBnZXRDdXJyZW50Um91dGVzOiB0aGlzLmdldEN1cnJlbnRSb3V0ZXMsXG4gICAgICBnZXRDdXJyZW50UGF0aG5hbWU6IHRoaXMuZ2V0Q3VycmVudFBhdGhuYW1lLFxuICAgICAgZ2V0Q3VycmVudFBhcmFtczogdGhpcy5nZXRDdXJyZW50UGFyYW1zLFxuICAgICAgZ2V0Q3VycmVudFF1ZXJ5OiB0aGlzLmdldEN1cnJlbnRRdWVyeSxcbiAgICAgIGlzQWN0aXZlOiB0aGlzLmlzQWN0aXZlXG4gICAgfTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlQ29udGV4dDtcbiIsIi8qKlxuICogUmVwcmVzZW50cyBhIGNhbmNlbGxhdGlvbiBjYXVzZWQgYnkgbmF2aWdhdGluZyBhd2F5XG4gKiBiZWZvcmUgdGhlIHByZXZpb3VzIHRyYW5zaXRpb24gaGFzIGZ1bGx5IHJlc29sdmVkLlxuICovXG5mdW5jdGlvbiBDYW5jZWxsYXRpb24oKSB7IH1cblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxsYXRpb247XG4iLCJ2YXIgaW52YXJpYW50ID0gcmVxdWlyZSgncmVhY3QvbGliL2ludmFyaWFudCcpO1xudmFyIGNhblVzZURPTSA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpLmNhblVzZURPTTtcblxudmFyIEhpc3RvcnkgPSB7XG5cbiAgLyoqXG4gICAqIFNlbmRzIHRoZSBicm93c2VyIGJhY2sgb25lIGVudHJ5IGluIHRoZSBoaXN0b3J5LlxuICAgKi9cbiAgYmFjazogZnVuY3Rpb24gKCkge1xuICAgIGludmFyaWFudChcbiAgICAgIGNhblVzZURPTSxcbiAgICAgICdDYW5ub3QgdXNlIEhpc3RvcnkuYmFjayB3aXRob3V0IGEgRE9NJ1xuICAgICk7XG5cbiAgICAvLyBEbyB0aGlzIGZpcnN0IHNvIHRoYXQgSGlzdG9yeS5sZW5ndGggd2lsbFxuICAgIC8vIGJlIGFjY3VyYXRlIGluIGxvY2F0aW9uIGNoYW5nZSBsaXN0ZW5lcnMuXG4gICAgSGlzdG9yeS5sZW5ndGggLT0gMTtcblxuICAgIHdpbmRvdy5oaXN0b3J5LmJhY2soKTtcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIGhpc3RvcnkuXG4gICAqL1xuICBsZW5ndGg6IDFcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIaXN0b3J5O1xuIiwidmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9pbnZhcmlhbnQnKTtcbnZhciBtZXJnZSA9IHJlcXVpcmUoJ3FzL2xpYi91dGlscycpLm1lcmdlO1xudmFyIHFzID0gcmVxdWlyZSgncXMnKTtcblxudmFyIHBhcmFtQ29tcGlsZU1hdGNoZXIgPSAvOihbYS16QS1aXyRdW2EtekEtWjAtOV8kXSopfFsqLigpXFxbXFxdXFxcXCt8e31eJF0vZztcbnZhciBwYXJhbUluamVjdE1hdGNoZXIgPSAvOihbYS16QS1aXyRdW2EtekEtWjAtOV8kP10qWz9dPyl8WypdL2c7XG52YXIgcGFyYW1JbmplY3RUcmFpbGluZ1NsYXNoTWF0Y2hlciA9IC9cXC9cXC9cXD98XFwvXFw/L2c7XG52YXIgcXVlcnlNYXRjaGVyID0gL1xcPyguKykvO1xuXG52YXIgX2NvbXBpbGVkUGF0dGVybnMgPSB7fTtcblxuZnVuY3Rpb24gY29tcGlsZVBhdHRlcm4ocGF0dGVybikge1xuICBpZiAoIShwYXR0ZXJuIGluIF9jb21waWxlZFBhdHRlcm5zKSkge1xuICAgIHZhciBwYXJhbU5hbWVzID0gW107XG4gICAgdmFyIHNvdXJjZSA9IHBhdHRlcm4ucmVwbGFjZShwYXJhbUNvbXBpbGVNYXRjaGVyLCBmdW5jdGlvbiAobWF0Y2gsIHBhcmFtTmFtZSkge1xuICAgICAgaWYgKHBhcmFtTmFtZSkge1xuICAgICAgICBwYXJhbU5hbWVzLnB1c2gocGFyYW1OYW1lKTtcbiAgICAgICAgcmV0dXJuICcoW14vPyNdKyknO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaCA9PT0gJyonKSB7XG4gICAgICAgIHBhcmFtTmFtZXMucHVzaCgnc3BsYXQnKTtcbiAgICAgICAgcmV0dXJuICcoLio/KSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ1xcXFwnICsgbWF0Y2g7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBfY29tcGlsZWRQYXR0ZXJuc1twYXR0ZXJuXSA9IHtcbiAgICAgIG1hdGNoZXI6IG5ldyBSZWdFeHAoJ14nICsgc291cmNlICsgJyQnLCAnaScpLFxuICAgICAgcGFyYW1OYW1lczogcGFyYW1OYW1lc1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2NvbXBpbGVkUGF0dGVybnNbcGF0dGVybl07XG59XG5cbnZhciBQYXRoID0ge1xuXG4gIC8qKlxuICAgKiBTYWZlbHkgZGVjb2RlcyBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIFVSTCBwYXRoLlxuICAgKi9cbiAgZGVjb2RlOiBmdW5jdGlvbiAocGF0aCkge1xuICAgIHJldHVybiBkZWNvZGVVUkkocGF0aC5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhZmVseSBlbmNvZGVzIHNwZWNpYWwgY2hhcmFjdGVycyBpbiB0aGUgZ2l2ZW4gVVJMIHBhdGguXG4gICAqL1xuICBlbmNvZGU6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSShwYXRoKS5yZXBsYWNlKC8lMjAvZywgJysnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgbmFtZXMgb2YgYWxsIHBhcmFtZXRlcnMgaW4gdGhlIGdpdmVuIHBhdHRlcm4uXG4gICAqL1xuICBleHRyYWN0UGFyYW1OYW1lczogZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgICByZXR1cm4gY29tcGlsZVBhdHRlcm4ocGF0dGVybikucGFyYW1OYW1lcztcbiAgfSxcblxuICAvKipcbiAgICogRXh0cmFjdHMgdGhlIHBvcnRpb25zIG9mIHRoZSBnaXZlbiBVUkwgcGF0aCB0aGF0IG1hdGNoIHRoZSBnaXZlbiBwYXR0ZXJuXG4gICAqIGFuZCByZXR1cm5zIGFuIG9iamVjdCBvZiBwYXJhbSBuYW1lID0+IHZhbHVlIHBhaXJzLiBSZXR1cm5zIG51bGwgaWYgdGhlXG4gICAqIHBhdHRlcm4gZG9lcyBub3QgbWF0Y2ggdGhlIGdpdmVuIHBhdGguXG4gICAqL1xuICBleHRyYWN0UGFyYW1zOiBmdW5jdGlvbiAocGF0dGVybiwgcGF0aCkge1xuICAgIHZhciBvYmplY3QgPSBjb21waWxlUGF0dGVybihwYXR0ZXJuKTtcbiAgICB2YXIgbWF0Y2ggPSBwYXRoLm1hdGNoKG9iamVjdC5tYXRjaGVyKTtcblxuICAgIGlmICghbWF0Y2gpXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIHZhciBwYXJhbXMgPSB7fTtcblxuICAgIG9iamVjdC5wYXJhbU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtTmFtZSwgaW5kZXgpIHtcbiAgICAgIHBhcmFtc1twYXJhbU5hbWVdID0gbWF0Y2hbaW5kZXggKyAxXTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2ZXJzaW9uIG9mIHRoZSBnaXZlbiByb3V0ZSBwYXRoIHdpdGggcGFyYW1zIGludGVycG9sYXRlZC4gVGhyb3dzXG4gICAqIGlmIHRoZXJlIGlzIGEgZHluYW1pYyBzZWdtZW50IG9mIHRoZSByb3V0ZSBwYXRoIGZvciB3aGljaCB0aGVyZSBpcyBubyBwYXJhbS5cbiAgICovXG4gIGluamVjdFBhcmFtczogZnVuY3Rpb24gKHBhdHRlcm4sIHBhcmFtcykge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICAgIHZhciBzcGxhdEluZGV4ID0gMDtcblxuICAgIHJldHVybiBwYXR0ZXJuLnJlcGxhY2UocGFyYW1JbmplY3RNYXRjaGVyLCBmdW5jdGlvbiAobWF0Y2gsIHBhcmFtTmFtZSkge1xuICAgICAgcGFyYW1OYW1lID0gcGFyYW1OYW1lIHx8ICdzcGxhdCc7XG5cbiAgICAgIC8vIElmIHBhcmFtIGlzIG9wdGlvbmFsIGRvbid0IGNoZWNrIGZvciBleGlzdGVuY2VcbiAgICAgIGlmIChwYXJhbU5hbWUuc2xpY2UoLTEpICE9PSAnPycpIHtcbiAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgIHBhcmFtc1twYXJhbU5hbWVdICE9IG51bGwsXG4gICAgICAgICAgJ01pc3NpbmcgXCInICsgcGFyYW1OYW1lICsgJ1wiIHBhcmFtZXRlciBmb3IgcGF0aCBcIicgKyBwYXR0ZXJuICsgJ1wiJ1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1OYW1lID0gcGFyYW1OYW1lLnNsaWNlKDAsIC0xKTtcblxuICAgICAgICBpZiAocGFyYW1zW3BhcmFtTmFtZV0gPT0gbnVsbClcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWdtZW50O1xuICAgICAgaWYgKHBhcmFtTmFtZSA9PT0gJ3NwbGF0JyAmJiBBcnJheS5pc0FycmF5KHBhcmFtc1twYXJhbU5hbWVdKSkge1xuICAgICAgICBzZWdtZW50ID0gcGFyYW1zW3BhcmFtTmFtZV1bc3BsYXRJbmRleCsrXTtcblxuICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgc2VnbWVudCAhPSBudWxsLFxuICAgICAgICAgICdNaXNzaW5nIHNwbGF0ICMgJyArIHNwbGF0SW5kZXggKyAnIGZvciBwYXRoIFwiJyArIHBhdHRlcm4gKyAnXCInXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWdtZW50ID0gcGFyYW1zW3BhcmFtTmFtZV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWdtZW50O1xuICAgIH0pLnJlcGxhY2UocGFyYW1JbmplY3RUcmFpbGluZ1NsYXNoTWF0Y2hlciwgJy8nKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBpcyB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgYW55IHF1ZXJ5IHN0cmluZyBjb250YWluZWRcbiAgICogaW4gdGhlIGdpdmVuIHBhdGgsIG51bGwgaWYgdGhlIHBhdGggY29udGFpbnMgbm8gcXVlcnkgc3RyaW5nLlxuICAgKi9cbiAgZXh0cmFjdFF1ZXJ5OiBmdW5jdGlvbiAocGF0aCkge1xuICAgIHZhciBtYXRjaCA9IHBhdGgubWF0Y2gocXVlcnlNYXRjaGVyKTtcbiAgICByZXR1cm4gbWF0Y2ggJiYgcXMucGFyc2UobWF0Y2hbMV0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gcGF0aCB3aXRob3V0IHRoZSBxdWVyeSBzdHJpbmcuXG4gICAqL1xuICB3aXRob3V0UXVlcnk6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZShxdWVyeU1hdGNoZXIsICcnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZlcnNpb24gb2YgdGhlIGdpdmVuIHBhdGggd2l0aCB0aGUgcGFyYW1ldGVycyBpbiB0aGUgZ2l2ZW5cbiAgICogcXVlcnkgbWVyZ2VkIGludG8gdGhlIHF1ZXJ5IHN0cmluZy5cbiAgICovXG4gIHdpdGhRdWVyeTogZnVuY3Rpb24gKHBhdGgsIHF1ZXJ5KSB7XG4gICAgdmFyIGV4aXN0aW5nUXVlcnkgPSBQYXRoLmV4dHJhY3RRdWVyeShwYXRoKTtcblxuICAgIGlmIChleGlzdGluZ1F1ZXJ5KVxuICAgICAgcXVlcnkgPSBxdWVyeSA/IG1lcmdlKGV4aXN0aW5nUXVlcnksIHF1ZXJ5KSA6IGV4aXN0aW5nUXVlcnk7XG5cbiAgICB2YXIgcXVlcnlTdHJpbmcgPSBxdWVyeSAmJiBxcy5zdHJpbmdpZnkocXVlcnkpO1xuXG4gICAgaWYgKHF1ZXJ5U3RyaW5nKVxuICAgICAgcmV0dXJuIFBhdGgud2l0aG91dFF1ZXJ5KHBhdGgpICsgJz8nICsgcXVlcnlTdHJpbmc7XG5cbiAgICByZXR1cm4gcGF0aDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwYXRoIGlzIGFic29sdXRlLlxuICAgKi9cbiAgaXNBYnNvbHV0ZTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gcGF0aC5cbiAgICovXG4gIG5vcm1hbGl6ZTogZnVuY3Rpb24gKHBhdGgsIHBhcmVudFJvdXRlKSB7XG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXlxcLyovLCAnLycpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBKb2lucyB0d28gVVJMIHBhdGhzIHRvZ2V0aGVyLlxuICAgKi9cbiAgam9pbjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS5yZXBsYWNlKC9cXC8qJC8sICcvJykgKyBiO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGF0aDtcbiIsInZhciBQcm9taXNlID0gcmVxdWlyZSgnd2hlbi9saWIvUHJvbWlzZScpO1xuXG4vLyBUT0RPOiBVc2UgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgY2hlY2sgKyBlbnZpZnkgdG8gZW5hYmxlXG4vLyB3aGVuJ3MgcHJvbWlzZSBtb25pdG9yIGhlcmUgd2hlbiBpbiBkZXYuXG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcbiIsInZhciBQcm9wVHlwZXMgPSB7XG5cbiAgLyoqXG4gICAqIFJlcXVpcmVzIHRoYXQgdGhlIHZhbHVlIG9mIGEgcHJvcCBiZSBmYWxzeS5cbiAgICovXG4gIGZhbHN5OiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSlcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJzwnICsgY29tcG9uZW50TmFtZSArICc+IG1heSBub3QgaGF2ZSBhIFwiJyArIHByb3BOYW1lICsgJ1wiIHByb3AnKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb3BUeXBlcztcbiIsIi8qKlxuICogRW5jYXBzdWxhdGVzIGEgcmVkaXJlY3QgdG8gdGhlIGdpdmVuIHJvdXRlLlxuICovXG5mdW5jdGlvbiBSZWRpcmVjdCh0bywgcGFyYW1zLCBxdWVyeSkge1xuICB0aGlzLnRvID0gdG87XG4gIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVkaXJlY3Q7XG4iLCJ2YXIgYXNzaWduID0gcmVxdWlyZSgncmVhY3QvbGliL09iamVjdC5hc3NpZ24nKTtcbnZhciByZXZlcnNlZEFycmF5ID0gcmVxdWlyZSgnLi9yZXZlcnNlZEFycmF5Jyk7XG52YXIgUmVkaXJlY3QgPSByZXF1aXJlKCcuL1JlZGlyZWN0Jyk7XG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vUHJvbWlzZScpO1xuXG4vKipcbiAqIFJ1bnMgYWxsIGhvb2sgZnVuY3Rpb25zIHNlcmlhbGx5IGFuZCBjYWxscyBjYWxsYmFjayhlcnJvcikgd2hlbiBmaW5pc2hlZC5cbiAqIEEgaG9vayBtYXkgcmV0dXJuIGEgcHJvbWlzZSBpZiBpdCBuZWVkcyB0byBleGVjdXRlIGFzeW5jaHJvbm91c2x5LlxuICovXG5mdW5jdGlvbiBydW5Ib29rcyhob29rcywgY2FsbGJhY2spIHtcbiAgdmFyIHByb21pc2U7XG4gIHRyeSB7XG4gICAgcHJvbWlzZSA9IGhvb2tzLnJlZHVjZShmdW5jdGlvbiAocHJvbWlzZSwgaG9vaykge1xuICAgICAgLy8gVGhlIGZpcnN0IGhvb2sgdG8gdXNlIHRyYW5zaXRpb24ud2FpdCBtYWtlcyB0aGUgcmVzdFxuICAgICAgLy8gb2YgdGhlIHRyYW5zaXRpb24gYXN5bmMgZnJvbSB0aGF0IHBvaW50IGZvcndhcmQuXG4gICAgICByZXR1cm4gcHJvbWlzZSA/IHByb21pc2UudGhlbihob29rKSA6IGhvb2soKTtcbiAgICB9LCBudWxsKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IpOyAvLyBTeW5jIGVycm9yLlxuICB9XG5cbiAgaWYgKHByb21pc2UpIHtcbiAgICAvLyBVc2Ugc2V0VGltZW91dCB0byBicmVhayB0aGUgcHJvbWlzZSBjaGFpbi5cbiAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChjYWxsYmFjayk7XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuXG4vKipcbiAqIENhbGxzIHRoZSB3aWxsVHJhbnNpdGlvbkZyb20gaG9vayBvZiBhbGwgaGFuZGxlcnMgaW4gdGhlIGdpdmVuIG1hdGNoZXNcbiAqIHNlcmlhbGx5IGluIHJldmVyc2Ugd2l0aCB0aGUgdHJhbnNpdGlvbiBvYmplY3QgYW5kIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mXG4gKiB0aGUgcm91dGUncyBoYW5kbGVyLCBzbyB0aGF0IHRoZSBkZWVwZXN0IG5lc3RlZCBoYW5kbGVycyBhcmUgY2FsbGVkIGZpcnN0LlxuICogQ2FsbHMgY2FsbGJhY2soZXJyb3IpIHdoZW4gZmluaXNoZWQuXG4gKi9cbmZ1bmN0aW9uIHJ1blRyYW5zaXRpb25Gcm9tSG9va3ModHJhbnNpdGlvbiwgcm91dGVzLCBjb21wb25lbnRzLCBjYWxsYmFjaykge1xuICBjb21wb25lbnRzID0gcmV2ZXJzZWRBcnJheShjb21wb25lbnRzKTtcblxuICB2YXIgaG9va3MgPSByZXZlcnNlZEFycmF5KHJvdXRlcykubWFwKGZ1bmN0aW9uIChyb3V0ZSwgaW5kZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGhhbmRsZXIgPSByb3V0ZS5oYW5kbGVyO1xuXG4gICAgICBpZiAoIXRyYW5zaXRpb24uaXNBYm9ydGVkICYmIGhhbmRsZXIud2lsbFRyYW5zaXRpb25Gcm9tKVxuICAgICAgICByZXR1cm4gaGFuZGxlci53aWxsVHJhbnNpdGlvbkZyb20odHJhbnNpdGlvbiwgY29tcG9uZW50c1tpbmRleF0pO1xuXG4gICAgICB2YXIgcHJvbWlzZSA9IHRyYW5zaXRpb24uX3Byb21pc2U7XG4gICAgICB0cmFuc2l0aW9uLl9wcm9taXNlID0gbnVsbDtcblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcbiAgfSk7XG5cbiAgcnVuSG9va3MoaG9va3MsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBDYWxscyB0aGUgd2lsbFRyYW5zaXRpb25UbyBob29rIG9mIGFsbCBoYW5kbGVycyBpbiB0aGUgZ2l2ZW4gbWF0Y2hlc1xuICogc2VyaWFsbHkgd2l0aCB0aGUgdHJhbnNpdGlvbiBvYmplY3QgYW5kIGFueSBwYXJhbXMgdGhhdCBhcHBseSB0byB0aGF0XG4gKiBoYW5kbGVyLiBDYWxscyBjYWxsYmFjayhlcnJvcikgd2hlbiBmaW5pc2hlZC5cbiAqL1xuZnVuY3Rpb24gcnVuVHJhbnNpdGlvblRvSG9va3ModHJhbnNpdGlvbiwgcm91dGVzLCBwYXJhbXMsIHF1ZXJ5LCBjYWxsYmFjaykge1xuICB2YXIgaG9va3MgPSByb3V0ZXMubWFwKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IHJvdXRlLmhhbmRsZXI7XG5cbiAgICAgIGlmICghdHJhbnNpdGlvbi5pc0Fib3J0ZWQgJiYgaGFuZGxlci53aWxsVHJhbnNpdGlvblRvKVxuICAgICAgICBoYW5kbGVyLndpbGxUcmFuc2l0aW9uVG8odHJhbnNpdGlvbiwgcGFyYW1zLCBxdWVyeSk7XG5cbiAgICAgIHZhciBwcm9taXNlID0gdHJhbnNpdGlvbi5fcHJvbWlzZTtcbiAgICAgIHRyYW5zaXRpb24uX3Byb21pc2UgPSBudWxsO1xuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuICB9KTtcblxuICBydW5Ib29rcyhob29rcywgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIEVuY2Fwc3VsYXRlcyBhIHRyYW5zaXRpb24gdG8gYSBnaXZlbiBwYXRoLlxuICpcbiAqIFRoZSB3aWxsVHJhbnNpdGlvblRvIGFuZCB3aWxsVHJhbnNpdGlvbkZyb20gaGFuZGxlcnMgcmVjZWl2ZVxuICogYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBhcyB0aGVpciBmaXJzdCBhcmd1bWVudC5cbiAqL1xuZnVuY3Rpb24gVHJhbnNpdGlvbihwYXRoLCByZXRyeSkge1xuICB0aGlzLnBhdGggPSBwYXRoO1xuICB0aGlzLmFib3J0UmVhc29uID0gbnVsbDtcbiAgdGhpcy5pc0Fib3J0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZXRyeSA9IHJldHJ5LmJpbmQodGhpcyk7XG4gIHRoaXMuX3Byb21pc2UgPSBudWxsO1xufVxuXG5hc3NpZ24oVHJhbnNpdGlvbi5wcm90b3R5cGUsIHtcblxuICBhYm9ydDogZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIGlmICh0aGlzLmlzQWJvcnRlZCkge1xuICAgICAgLy8gRmlyc3QgYWJvcnQgd2lucy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmFib3J0UmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMuaXNBYm9ydGVkID0gdHJ1ZTtcbiAgfSxcblxuICByZWRpcmVjdDogZnVuY3Rpb24gKHRvLCBwYXJhbXMsIHF1ZXJ5KSB7XG4gICAgdGhpcy5hYm9ydChuZXcgUmVkaXJlY3QodG8sIHBhcmFtcywgcXVlcnkpKTtcbiAgfSxcblxuICB3YWl0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLl9wcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcbiAgfSxcblxuICBmcm9tOiBmdW5jdGlvbiAocm91dGVzLCBjb21wb25lbnRzLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBydW5UcmFuc2l0aW9uRnJvbUhvb2tzKHRoaXMsIHJvdXRlcywgY29tcG9uZW50cywgY2FsbGJhY2spO1xuICB9LFxuXG4gIHRvOiBmdW5jdGlvbiAocm91dGVzLCBwYXJhbXMsIHF1ZXJ5LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBydW5UcmFuc2l0aW9uVG9Ib29rcyh0aGlzLCByb3V0ZXMsIHBhcmFtcywgcXVlcnksIGNhbGxiYWNrKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2l0aW9uO1xuIiwiLyoganNoaW50IC1XMDU4ICovXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdyZWFjdC9saWIvd2FybmluZycpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9pbnZhcmlhbnQnKTtcbnZhciBjYW5Vc2VET00gPSByZXF1aXJlKCdyZWFjdC9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKS5jYW5Vc2VET007XG52YXIgSW1pdGF0ZUJyb3dzZXJCZWhhdmlvciA9IHJlcXVpcmUoJy4uL2JlaGF2aW9ycy9JbWl0YXRlQnJvd3NlckJlaGF2aW9yJyk7XG52YXIgUm91dGVIYW5kbGVyID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9Sb3V0ZUhhbmRsZXInKTtcbnZhciBMb2NhdGlvbkFjdGlvbnMgPSByZXF1aXJlKCcuLi9hY3Rpb25zL0xvY2F0aW9uQWN0aW9ucycpO1xudmFyIEhhc2hMb2NhdGlvbiA9IHJlcXVpcmUoJy4uL2xvY2F0aW9ucy9IYXNoTG9jYXRpb24nKTtcbnZhciBIaXN0b3J5TG9jYXRpb24gPSByZXF1aXJlKCcuLi9sb2NhdGlvbnMvSGlzdG9yeUxvY2F0aW9uJyk7XG52YXIgUmVmcmVzaExvY2F0aW9uID0gcmVxdWlyZSgnLi4vbG9jYXRpb25zL1JlZnJlc2hMb2NhdGlvbicpO1xudmFyIE5hdmlnYXRpb25Db250ZXh0ID0gcmVxdWlyZSgnLi4vbWl4aW5zL05hdmlnYXRpb25Db250ZXh0Jyk7XG52YXIgU3RhdGVDb250ZXh0ID0gcmVxdWlyZSgnLi4vbWl4aW5zL1N0YXRlQ29udGV4dCcpO1xudmFyIFNjcm9sbGluZyA9IHJlcXVpcmUoJy4uL21peGlucy9TY3JvbGxpbmcnKTtcbnZhciBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4gPSByZXF1aXJlKCcuL2NyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbicpO1xudmFyIHN1cHBvcnRzSGlzdG9yeSA9IHJlcXVpcmUoJy4vc3VwcG9ydHNIaXN0b3J5Jyk7XG52YXIgVHJhbnNpdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNpdGlvbicpO1xudmFyIFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vUHJvcFR5cGVzJyk7XG52YXIgUmVkaXJlY3QgPSByZXF1aXJlKCcuL1JlZGlyZWN0Jyk7XG52YXIgSGlzdG9yeSA9IHJlcXVpcmUoJy4vSGlzdG9yeScpO1xudmFyIENhbmNlbGxhdGlvbiA9IHJlcXVpcmUoJy4vQ2FuY2VsbGF0aW9uJyk7XG52YXIgUGF0aCA9IHJlcXVpcmUoJy4vUGF0aCcpO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGxvY2F0aW9uIGZvciBuZXcgcm91dGVycy5cbiAqL1xudmFyIERFRkFVTFRfTE9DQVRJT04gPSBjYW5Vc2VET00gPyBIYXNoTG9jYXRpb24gOiAnLyc7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgc2Nyb2xsIGJlaGF2aW9yIGZvciBuZXcgcm91dGVycy5cbiAqL1xudmFyIERFRkFVTFRfU0NST0xMX0JFSEFWSU9SID0gY2FuVXNlRE9NID8gSW1pdGF0ZUJyb3dzZXJCZWhhdmlvciA6IG51bGw7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgZXJyb3IgaGFuZGxlciBmb3IgbmV3IHJvdXRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRFcnJvckhhbmRsZXIoZXJyb3IpIHtcbiAgLy8gVGhyb3cgc28gd2UgZG9uJ3Qgc2lsZW50bHkgc3dhbGxvdyBhc3luYyBlcnJvcnMuXG4gIHRocm93IGVycm9yOyAvLyBUaGlzIGVycm9yIHByb2JhYmx5IG9yaWdpbmF0ZWQgaW4gYSB0cmFuc2l0aW9uIGhvb2suXG59XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgYWJvcnRlZCB0cmFuc2l0aW9uIGhhbmRsZXIgZm9yIG5ldyByb3V0ZXJzLlxuICovXG5mdW5jdGlvbiBkZWZhdWx0QWJvcnRIYW5kbGVyKGFib3J0UmVhc29uLCBsb2NhdGlvbikge1xuICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBhYm9ydGVkIHRyYW5zaXRpb24hIFJlYXNvbjogJyArIGFib3J0UmVhc29uKTtcblxuICBpZiAoYWJvcnRSZWFzb24gaW5zdGFuY2VvZiBDYW5jZWxsYXRpb24pIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoYWJvcnRSZWFzb24gaW5zdGFuY2VvZiBSZWRpcmVjdCkge1xuICAgIGxvY2F0aW9uLnJlcGxhY2UodGhpcy5tYWtlUGF0aChhYm9ydFJlYXNvbi50bywgYWJvcnRSZWFzb24ucGFyYW1zLCBhYm9ydFJlYXNvbi5xdWVyeSkpO1xuICB9IGVsc2Uge1xuICAgIGxvY2F0aW9uLnBvcCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRNYXRjaChwYXRobmFtZSwgcm91dGVzLCBkZWZhdWx0Um91dGUsIG5vdEZvdW5kUm91dGUpIHtcbiAgdmFyIG1hdGNoLCByb3V0ZSwgcGFyYW1zO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSByb3V0ZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICByb3V0ZSA9IHJvdXRlc1tpXTtcblxuICAgIC8vIENoZWNrIHRoZSBzdWJ0cmVlIGZpcnN0IHRvIGZpbmQgdGhlIG1vc3QgZGVlcGx5LW5lc3RlZCBtYXRjaC5cbiAgICBtYXRjaCA9IGZpbmRNYXRjaChwYXRobmFtZSwgcm91dGUuY2hpbGRSb3V0ZXMsIHJvdXRlLmRlZmF1bHRSb3V0ZSwgcm91dGUubm90Rm91bmRSb3V0ZSk7XG5cbiAgICBpZiAobWF0Y2ggIT0gbnVsbCkge1xuICAgICAgbWF0Y2gucm91dGVzLnVuc2hpZnQocm91dGUpO1xuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cblxuICAgIC8vIE5vIHJvdXRlcyBpbiB0aGUgc3VidHJlZSBtYXRjaGVkLCBzbyBjaGVjayB0aGlzIHJvdXRlLlxuICAgIHBhcmFtcyA9IFBhdGguZXh0cmFjdFBhcmFtcyhyb3V0ZS5wYXRoLCBwYXRobmFtZSk7XG5cbiAgICBpZiAocGFyYW1zKVxuICAgICAgcmV0dXJuIGNyZWF0ZU1hdGNoKHJvdXRlLCBwYXJhbXMpO1xuICB9XG5cbiAgLy8gTm8gcm91dGVzIG1hdGNoZWQsIHNvIHRyeSB0aGUgZGVmYXVsdCByb3V0ZSBpZiB0aGVyZSBpcyBvbmUuXG4gIGlmIChkZWZhdWx0Um91dGUgJiYgKHBhcmFtcyA9IFBhdGguZXh0cmFjdFBhcmFtcyhkZWZhdWx0Um91dGUucGF0aCwgcGF0aG5hbWUpKSlcbiAgICByZXR1cm4gY3JlYXRlTWF0Y2goZGVmYXVsdFJvdXRlLCBwYXJhbXMpO1xuXG4gIC8vIExhc3QgYXR0ZW1wdDogZG9lcyB0aGUgXCJub3QgZm91bmRcIiByb3V0ZSBtYXRjaD9cbiAgaWYgKG5vdEZvdW5kUm91dGUgJiYgKHBhcmFtcyA9IFBhdGguZXh0cmFjdFBhcmFtcyhub3RGb3VuZFJvdXRlLnBhdGgsIHBhdGhuYW1lKSkpXG4gICAgcmV0dXJuIGNyZWF0ZU1hdGNoKG5vdEZvdW5kUm91dGUsIHBhcmFtcyk7XG5cbiAgcmV0dXJuIG1hdGNoO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNYXRjaChyb3V0ZSwgcGFyYW1zKSB7XG4gIHJldHVybiB7IHJvdXRlczogWyByb3V0ZSBdLCBwYXJhbXM6IHBhcmFtcyB9O1xufVxuXG5mdW5jdGlvbiBoYXNQcm9wZXJ0aWVzKG9iamVjdCwgcHJvcGVydGllcykge1xuICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gcHJvcGVydGllcylcbiAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpICYmIG9iamVjdFtwcm9wZXJ0eU5hbWVdICE9PSBwcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGhhc01hdGNoKHJvdXRlcywgcm91dGUsIHByZXZQYXJhbXMsIG5leHRQYXJhbXMsIHByZXZRdWVyeSwgbmV4dFF1ZXJ5KSB7XG4gIHJldHVybiByb3V0ZXMuc29tZShmdW5jdGlvbiAocikge1xuICAgIGlmIChyICE9PSByb3V0ZSlcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBwYXJhbU5hbWVzID0gcm91dGUucGFyYW1OYW1lcztcbiAgICB2YXIgcGFyYW1OYW1lO1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgYWxsIHBhcmFtcyB0aGUgcm91dGUgY2FyZXMgYWJvdXQgZGlkIG5vdCBjaGFuZ2UuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcmFtTmFtZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHBhcmFtTmFtZSA9IHBhcmFtTmFtZXNbaV07XG5cbiAgICAgIGlmIChuZXh0UGFyYW1zW3BhcmFtTmFtZV0gIT09IHByZXZQYXJhbXNbcGFyYW1OYW1lXSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSB0aGUgcXVlcnkgaGFzbid0IGNoYW5nZWQuXG4gICAgcmV0dXJuIGhhc1Byb3BlcnRpZXMocHJldlF1ZXJ5LCBuZXh0UXVlcnkpICYmIGhhc1Byb3BlcnRpZXMobmV4dFF1ZXJ5LCBwcmV2UXVlcnkpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3IHJvdXRlciB1c2luZyB0aGUgZ2l2ZW4gb3B0aW9ucy4gQSByb3V0ZXJcbiAqIGlzIGEgUmVhY3RDb21wb25lbnQgY2xhc3MgdGhhdCBrbm93cyBob3cgdG8gcmVhY3QgdG8gY2hhbmdlcyBpbiB0aGVcbiAqIFVSTCBhbmQga2VlcCB0aGUgY29udGVudHMgb2YgdGhlIHBhZ2UgaW4gc3luYy5cbiAqXG4gKiBPcHRpb25zIG1heSBiZSBhbnkgb2YgdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAtIHJvdXRlcyAgICAgICAgICAgKHJlcXVpcmVkKSBUaGUgcm91dGUgY29uZmlnXG4gKiAtIGxvY2F0aW9uICAgICAgICAgVGhlIGxvY2F0aW9uIHRvIHVzZS4gRGVmYXVsdHMgdG8gSGFzaExvY2F0aW9uIHdoZW5cbiAqICAgICAgICAgICAgICAgICAgICB0aGUgRE9NIGlzIGF2YWlsYWJsZSwgXCIvXCIgb3RoZXJ3aXNlXG4gKiAtIHNjcm9sbEJlaGF2aW9yICAgVGhlIHNjcm9sbCBiZWhhdmlvciB0byB1c2UuIERlZmF1bHRzIHRvIEltaXRhdGVCcm93c2VyQmVoYXZpb3JcbiAqICAgICAgICAgICAgICAgICAgICB3aGVuIHRoZSBET00gaXMgYXZhaWxhYmxlLCBudWxsIG90aGVyd2lzZVxuICogLSBvbkVycm9yICAgICAgICAgIEEgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGhhbmRsZSBlcnJvcnNcbiAqIC0gb25BYm9ydCAgICAgICAgICBBIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBoYW5kbGUgYWJvcnRlZCB0cmFuc2l0aW9uc1xuICpcbiAqIFdoZW4gcmVuZGVyaW5nIGluIGEgc2VydmVyLXNpZGUgZW52aXJvbm1lbnQsIHRoZSBsb2NhdGlvbiBzaG91bGQgc2ltcGx5XG4gKiBiZSB0aGUgVVJMIHBhdGggdGhhdCB3YXMgdXNlZCBpbiB0aGUgcmVxdWVzdCwgaW5jbHVkaW5nIHRoZSBxdWVyeSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlcihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMgPSB7IHJvdXRlczogb3B0aW9ucyB9OyAvLyBSb3V0ZXIuY3JlYXRlKDxSb3V0ZT4pXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgIG9wdGlvbnMgPSB7IHJvdXRlczogb3B0aW9ucyB9OyAvLyBSb3V0ZXIuY3JlYXRlKFsgPFJvdXRlPiwgPFJvdXRlPiBdKVxuICB9XG5cbiAgdmFyIHJvdXRlcyA9IFtdO1xuICB2YXIgbmFtZWRSb3V0ZXMgPSB7fTtcbiAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgdmFyIGxvY2F0aW9uID0gb3B0aW9ucy5sb2NhdGlvbiB8fCBERUZBVUxUX0xPQ0FUSU9OO1xuICB2YXIgc2Nyb2xsQmVoYXZpb3IgPSBvcHRpb25zLnNjcm9sbEJlaGF2aW9yIHx8IERFRkFVTFRfU0NST0xMX0JFSEFWSU9SO1xuICB2YXIgb25FcnJvciA9IG9wdGlvbnMub25FcnJvciB8fCBkZWZhdWx0RXJyb3JIYW5kbGVyO1xuICB2YXIgb25BYm9ydCA9IG9wdGlvbnMub25BYm9ydCB8fCBkZWZhdWx0QWJvcnRIYW5kbGVyO1xuICB2YXIgc3RhdGUgPSB7fTtcbiAgdmFyIG5leHRTdGF0ZSA9IHt9O1xuICB2YXIgcGVuZGluZ1RyYW5zaXRpb24gPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKCkge1xuICAgIHN0YXRlID0gbmV4dFN0YXRlO1xuICAgIG5leHRTdGF0ZSA9IHt9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgIWNhblVzZURPTSB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnLFxuICAgICAgJ1lvdSBzaG91bGQgbm90IHVzZSBhIHN0YXRpYyBsb2NhdGlvbiBpbiBhIERPTSBlbnZpcm9ubWVudCBiZWNhdXNlICcgK1xuICAgICAgJ3RoZSByb3V0ZXIgd2lsbCBub3QgYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIGN1cnJlbnQgVVJMJ1xuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgY2FuVXNlRE9NLFxuICAgICAgJ1lvdSBjYW5ub3QgdXNlICVzIHdpdGhvdXQgYSBET00nLFxuICAgICAgbG9jYXRpb25cbiAgICApO1xuICB9XG5cbiAgLy8gQXV0b21hdGljYWxseSBmYWxsIGJhY2sgdG8gZnVsbCBwYWdlIHJlZnJlc2hlcyBpblxuICAvLyBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdGhlIEhUTUwgaGlzdG9yeSBBUEkuXG4gIGlmIChsb2NhdGlvbiA9PT0gSGlzdG9yeUxvY2F0aW9uICYmICFzdXBwb3J0c0hpc3RvcnkoKSlcbiAgICBsb2NhdGlvbiA9IFJlZnJlc2hMb2NhdGlvbjtcblxuICB2YXIgcm91dGVyID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gICAgZGlzcGxheU5hbWU6ICdSb3V0ZXInLFxuXG4gICAgbWl4aW5zOiBbIE5hdmlnYXRpb25Db250ZXh0LCBTdGF0ZUNvbnRleHQsIFNjcm9sbGluZyBdLFxuXG4gICAgc3RhdGljczoge1xuXG4gICAgICBkZWZhdWx0Um91dGU6IG51bGwsXG4gICAgICBub3RGb3VuZFJvdXRlOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgcm91dGVzIHRvIHRoaXMgcm91dGVyIGZyb20gdGhlIGdpdmVuIGNoaWxkcmVuIG9iamVjdCAoc2VlIFJlYWN0Q2hpbGRyZW4pLlxuICAgICAgICovXG4gICAgICBhZGRSb3V0ZXM6IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgICAgICByb3V0ZXMucHVzaC5hcHBseShyb3V0ZXMsIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihjaGlsZHJlbiwgdGhpcywgbmFtZWRSb3V0ZXMpKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhbiBhYnNvbHV0ZSBVUkwgcGF0aCBjcmVhdGVkIGZyb20gdGhlIGdpdmVuIHJvdXRlXG4gICAgICAgKiBuYW1lLCBVUkwgcGFyYW1ldGVycywgYW5kIHF1ZXJ5LlxuICAgICAgICovXG4gICAgICBtYWtlUGF0aDogZnVuY3Rpb24gKHRvLCBwYXJhbXMsIHF1ZXJ5KSB7XG4gICAgICAgIHZhciBwYXRoO1xuICAgICAgICBpZiAoUGF0aC5pc0Fic29sdXRlKHRvKSkge1xuICAgICAgICAgIHBhdGggPSBQYXRoLm5vcm1hbGl6ZSh0byk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJvdXRlID0gbmFtZWRSb3V0ZXNbdG9dO1xuXG4gICAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICAnVW5hYmxlIHRvIGZpbmQgPFJvdXRlIG5hbWU9XCIlc1wiPicsXG4gICAgICAgICAgICB0b1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBwYXRoID0gcm91dGUucGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQYXRoLndpdGhRdWVyeShQYXRoLmluamVjdFBhcmFtcyhwYXRoLCBwYXJhbXMpLCBxdWVyeSk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgdGhhdCBtYXkgc2FmZWx5IGJlIHVzZWQgYXMgdGhlIGhyZWYgb2YgYSBsaW5rXG4gICAgICAgKiB0byB0aGUgcm91dGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZSwgVVJMIHBhcmFtZXRlcnMsIGFuZCBxdWVyeS5cbiAgICAgICAqL1xuICAgICAgbWFrZUhyZWY6IGZ1bmN0aW9uICh0bywgcGFyYW1zLCBxdWVyeSkge1xuICAgICAgICB2YXIgcGF0aCA9IHRoaXMubWFrZVBhdGgodG8sIHBhcmFtcywgcXVlcnkpO1xuICAgICAgICByZXR1cm4gKGxvY2F0aW9uID09PSBIYXNoTG9jYXRpb24pID8gJyMnICsgcGF0aCA6IHBhdGg7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zaXRpb25zIHRvIHRoZSBVUkwgc3BlY2lmaWVkIGluIHRoZSBhcmd1bWVudHMgYnkgcHVzaGluZ1xuICAgICAgICogYSBuZXcgVVJMIG9udG8gdGhlIGhpc3Rvcnkgc3RhY2suXG4gICAgICAgKi9cbiAgICAgIHRyYW5zaXRpb25UbzogZnVuY3Rpb24gKHRvLCBwYXJhbXMsIHF1ZXJ5KSB7XG4gICAgICAgIGludmFyaWFudChcbiAgICAgICAgICB0eXBlb2YgbG9jYXRpb24gIT09ICdzdHJpbmcnLFxuICAgICAgICAgICdZb3UgY2Fubm90IHVzZSB0cmFuc2l0aW9uVG8gd2l0aCBhIHN0YXRpYyBsb2NhdGlvbidcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMubWFrZVBhdGgodG8sIHBhcmFtcywgcXVlcnkpO1xuXG4gICAgICAgIGlmIChwZW5kaW5nVHJhbnNpdGlvbikge1xuICAgICAgICAgIC8vIFJlcGxhY2Ugc28gcGVuZGluZyBsb2NhdGlvbiBkb2VzIG5vdCBzdGF5IGluIGhpc3RvcnkuXG4gICAgICAgICAgbG9jYXRpb24ucmVwbGFjZShwYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2NhdGlvbi5wdXNoKHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zaXRpb25zIHRvIHRoZSBVUkwgc3BlY2lmaWVkIGluIHRoZSBhcmd1bWVudHMgYnkgcmVwbGFjaW5nXG4gICAgICAgKiB0aGUgY3VycmVudCBVUkwgaW4gdGhlIGhpc3Rvcnkgc3RhY2suXG4gICAgICAgKi9cbiAgICAgIHJlcGxhY2VXaXRoOiBmdW5jdGlvbiAodG8sIHBhcmFtcywgcXVlcnkpIHtcbiAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgIHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3N0cmluZycsXG4gICAgICAgICAgJ1lvdSBjYW5ub3QgdXNlIHJlcGxhY2VXaXRoIHdpdGggYSBzdGF0aWMgbG9jYXRpb24nXG4gICAgICAgICk7XG5cbiAgICAgICAgbG9jYXRpb24ucmVwbGFjZSh0aGlzLm1ha2VQYXRoKHRvLCBwYXJhbXMsIHF1ZXJ5KSk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zaXRpb25zIHRvIHRoZSBwcmV2aW91cyBVUkwgaWYgb25lIGlzIGF2YWlsYWJsZS4gUmV0dXJucyB0cnVlIGlmIHRoZVxuICAgICAgICogcm91dGVyIHdhcyBhYmxlIHRvIGdvIGJhY2ssIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlOiBUaGUgcm91dGVyIG9ubHkgdHJhY2tzIGhpc3RvcnkgZW50cmllcyBpbiB5b3VyIGFwcGxpY2F0aW9uLCBub3QgdGhlXG4gICAgICAgKiBjdXJyZW50IGJyb3dzZXIgc2Vzc2lvbiwgc28geW91IGNhbiBzYWZlbHkgY2FsbCB0aGlzIGZ1bmN0aW9uIHdpdGhvdXQgZ3VhcmRpbmdcbiAgICAgICAqIGFnYWluc3Qgc2VuZGluZyB0aGUgdXNlciBiYWNrIHRvIHNvbWUgb3RoZXIgc2l0ZS4gSG93ZXZlciwgd2hlbiB1c2luZ1xuICAgICAgICogUmVmcmVzaExvY2F0aW9uICh3aGljaCBpcyB0aGUgZmFsbGJhY2sgZm9yIEhpc3RvcnlMb2NhdGlvbiBpbiBicm93c2VycyB0aGF0XG4gICAgICAgKiBkb24ndCBzdXBwb3J0IEhUTUw1IGhpc3RvcnkpIHRoaXMgbWV0aG9kIHdpbGwgKmFsd2F5cyogc2VuZCB0aGUgY2xpZW50IGJhY2tcbiAgICAgICAqIGJlY2F1c2Ugd2UgY2Fubm90IHJlbGlhYmx5IHRyYWNrIGhpc3RvcnkgbGVuZ3RoLlxuICAgICAgICovXG4gICAgICBnb0JhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgIHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3N0cmluZycsXG4gICAgICAgICAgJ1lvdSBjYW5ub3QgdXNlIGdvQmFjayB3aXRoIGEgc3RhdGljIGxvY2F0aW9uJ1xuICAgICAgICApO1xuXG4gICAgICAgIGlmIChIaXN0b3J5Lmxlbmd0aCA+IDEgfHwgbG9jYXRpb24gPT09IFJlZnJlc2hMb2NhdGlvbikge1xuICAgICAgICAgIGxvY2F0aW9uLnBvcCgpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ2dvQmFjaygpIHdhcyBpZ25vcmVkIGJlY2F1c2UgdGhlcmUgaXMgbm8gcm91dGVyIGhpc3RvcnknKTtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFBlcmZvcm1zIGEgbWF0Y2ggb2YgdGhlIGdpdmVuIHBhdGhuYW1lIGFnYWluc3QgdGhpcyByb3V0ZXIgYW5kIHJldHVybnMgYW4gb2JqZWN0XG4gICAgICAgKiB3aXRoIHRoZSB7IHJvdXRlcywgcGFyYW1zIH0gdGhhdCBtYXRjaC4gUmV0dXJucyBudWxsIGlmIG5vIG1hdGNoIGNhbiBiZSBtYWRlLlxuICAgICAgICovXG4gICAgICBtYXRjaDogZnVuY3Rpb24gKHBhdGhuYW1lKSB7XG4gICAgICAgIHJldHVybiBmaW5kTWF0Y2gocGF0aG5hbWUsIHJvdXRlcywgdGhpcy5kZWZhdWx0Um91dGUsIHRoaXMubm90Rm91bmRSb3V0ZSkgfHwgbnVsbDtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUGVyZm9ybXMgYSB0cmFuc2l0aW9uIHRvIHRoZSBnaXZlbiBwYXRoIGFuZCBjYWxscyBjYWxsYmFjayhlcnJvciwgYWJvcnRSZWFzb24pXG4gICAgICAgKiB3aGVuIHRoZSB0cmFuc2l0aW9uIGlzIGZpbmlzaGVkLiBJZiBib3RoIGFyZ3VtZW50cyBhcmUgbnVsbCB0aGUgcm91dGVyJ3Mgc3RhdGVcbiAgICAgICAqIHdhcyB1cGRhdGVkLiBPdGhlcndpc2UgdGhlIHRyYW5zaXRpb24gZGlkIG5vdCBjb21wbGV0ZS5cbiAgICAgICAqXG4gICAgICAgKiBJbiBhIHRyYW5zaXRpb24sIGEgcm91dGVyIGZpcnN0IGRldGVybWluZXMgd2hpY2ggcm91dGVzIGFyZSBpbnZvbHZlZCBieSBiZWdpbm5pbmdcbiAgICAgICAqIHdpdGggdGhlIGN1cnJlbnQgcm91dGUsIHVwIHRoZSByb3V0ZSB0cmVlIHRvIHRoZSBmaXJzdCBwYXJlbnQgcm91dGUgdGhhdCBpcyBzaGFyZWRcbiAgICAgICAqIHdpdGggdGhlIGRlc3RpbmF0aW9uIHJvdXRlLCBhbmQgYmFjayBkb3duIHRoZSB0cmVlIHRvIHRoZSBkZXN0aW5hdGlvbiByb3V0ZS4gVGhlXG4gICAgICAgKiB3aWxsVHJhbnNpdGlvbkZyb20gaG9vayBpcyBpbnZva2VkIG9uIGFsbCByb3V0ZSBoYW5kbGVycyB3ZSdyZSB0cmFuc2l0aW9uaW5nIGF3YXlcbiAgICAgICAqIGZyb20sIGluIHJldmVyc2UgbmVzdGluZyBvcmRlci4gTGlrZXdpc2UsIHRoZSB3aWxsVHJhbnNpdGlvblRvIGhvb2sgaXMgaW52b2tlZCBvblxuICAgICAgICogYWxsIHJvdXRlIGhhbmRsZXJzIHdlJ3JlIHRyYW5zaXRpb25pbmcgdG8uXG4gICAgICAgKlxuICAgICAgICogQm90aCB3aWxsVHJhbnNpdGlvbkZyb20gYW5kIHdpbGxUcmFuc2l0aW9uVG8gaG9va3MgbWF5IGVpdGhlciBhYm9ydCBvciByZWRpcmVjdCB0aGVcbiAgICAgICAqIHRyYW5zaXRpb24uIFRvIHJlc29sdmUgYXN5bmNocm9ub3VzbHksIHRoZXkgbWF5IHVzZSB0cmFuc2l0aW9uLndhaXQocHJvbWlzZSkuIElmIG5vXG4gICAgICAgKiBob29rcyB3YWl0LCB0aGUgdHJhbnNpdGlvbiBpcyBmdWxseSBzeW5jaHJvbm91cy5cbiAgICAgICAqL1xuICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIChwYXRoLCBhY3Rpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChwZW5kaW5nVHJhbnNpdGlvbikge1xuICAgICAgICAgIHBlbmRpbmdUcmFuc2l0aW9uLmFib3J0KG5ldyBDYW5jZWxsYXRpb24pO1xuICAgICAgICAgIHBlbmRpbmdUcmFuc2l0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmV2UGF0aCA9IHN0YXRlLnBhdGg7XG4gICAgICAgIGlmIChwcmV2UGF0aCA9PT0gcGF0aClcbiAgICAgICAgICByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG8hXG5cbiAgICAgICAgLy8gUmVjb3JkIHRoZSBzY3JvbGwgcG9zaXRpb24gYXMgZWFybHkgYXMgcG9zc2libGUgdG9cbiAgICAgICAgLy8gZ2V0IGl0IGJlZm9yZSBicm93c2VycyB0cnkgdXBkYXRlIGl0IGF1dG9tYXRpY2FsbHkuXG4gICAgICAgIGlmIChwcmV2UGF0aCAmJiBhY3Rpb24gIT09IExvY2F0aW9uQWN0aW9ucy5SRVBMQUNFKVxuICAgICAgICAgIHRoaXMucmVjb3JkU2Nyb2xsUG9zaXRpb24ocHJldlBhdGgpO1xuXG4gICAgICAgIHZhciBwYXRobmFtZSA9IFBhdGgud2l0aG91dFF1ZXJ5KHBhdGgpO1xuICAgICAgICB2YXIgbWF0Y2ggPSB0aGlzLm1hdGNoKHBhdGhuYW1lKTtcblxuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIG1hdGNoICE9IG51bGwsXG4gICAgICAgICAgJ05vIHJvdXRlIG1hdGNoZXMgcGF0aCBcIiVzXCIuIE1ha2Ugc3VyZSB5b3UgaGF2ZSA8Um91dGUgcGF0aD1cIiVzXCI+IHNvbWV3aGVyZSBpbiB5b3VyIHJvdXRlcycsXG4gICAgICAgICAgcGF0aCwgcGF0aFxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChtYXRjaCA9PSBudWxsKVxuICAgICAgICAgIG1hdGNoID0ge307XG5cbiAgICAgICAgdmFyIHByZXZSb3V0ZXMgPSBzdGF0ZS5yb3V0ZXMgfHwgW107XG4gICAgICAgIHZhciBwcmV2UGFyYW1zID0gc3RhdGUucGFyYW1zIHx8IHt9O1xuICAgICAgICB2YXIgcHJldlF1ZXJ5ID0gc3RhdGUucXVlcnkgfHwge307XG5cbiAgICAgICAgdmFyIG5leHRSb3V0ZXMgPSBtYXRjaC5yb3V0ZXMgfHwgW107XG4gICAgICAgIHZhciBuZXh0UGFyYW1zID0gbWF0Y2gucGFyYW1zIHx8IHt9O1xuICAgICAgICB2YXIgbmV4dFF1ZXJ5ID0gUGF0aC5leHRyYWN0UXVlcnkocGF0aCkgfHwge307XG5cbiAgICAgICAgdmFyIGZyb21Sb3V0ZXMsIHRvUm91dGVzO1xuICAgICAgICBpZiAocHJldlJvdXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICBmcm9tUm91dGVzID0gcHJldlJvdXRlcy5maWx0ZXIoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gIWhhc01hdGNoKG5leHRSb3V0ZXMsIHJvdXRlLCBwcmV2UGFyYW1zLCBuZXh0UGFyYW1zLCBwcmV2UXVlcnksIG5leHRRdWVyeSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0b1JvdXRlcyA9IG5leHRSb3V0ZXMuZmlsdGVyKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICAgICAgcmV0dXJuICFoYXNNYXRjaChwcmV2Um91dGVzLCByb3V0ZSwgcHJldlBhcmFtcywgbmV4dFBhcmFtcywgcHJldlF1ZXJ5LCBuZXh0UXVlcnkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyb21Sb3V0ZXMgPSBbXTtcbiAgICAgICAgICB0b1JvdXRlcyA9IG5leHRSb3V0ZXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IG5ldyBUcmFuc2l0aW9uKHBhdGgsIHRoaXMucmVwbGFjZVdpdGguYmluZCh0aGlzLCBwYXRoKSk7XG4gICAgICAgIHBlbmRpbmdUcmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcblxuICAgICAgICB0cmFuc2l0aW9uLmZyb20oZnJvbVJvdXRlcywgY29tcG9uZW50cywgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgaWYgKGVycm9yIHx8IHRyYW5zaXRpb24uaXNBYm9ydGVkKVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwocm91dGVyLCBlcnJvciwgdHJhbnNpdGlvbik7XG5cbiAgICAgICAgICB0cmFuc2l0aW9uLnRvKHRvUm91dGVzLCBuZXh0UGFyYW1zLCBuZXh0UXVlcnksIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yIHx8IHRyYW5zaXRpb24uaXNBYm9ydGVkKVxuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChyb3V0ZXIsIGVycm9yLCB0cmFuc2l0aW9uKTtcblxuICAgICAgICAgICAgbmV4dFN0YXRlLnBhdGggPSBwYXRoO1xuICAgICAgICAgICAgbmV4dFN0YXRlLmFjdGlvbiA9IGFjdGlvbjtcbiAgICAgICAgICAgIG5leHRTdGF0ZS5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgbmV4dFN0YXRlLnJvdXRlcyA9IG5leHRSb3V0ZXM7XG4gICAgICAgICAgICBuZXh0U3RhdGUucGFyYW1zID0gbmV4dFBhcmFtcztcbiAgICAgICAgICAgIG5leHRTdGF0ZS5xdWVyeSA9IG5leHRRdWVyeTtcblxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbChyb3V0ZXIsIG51bGwsIHRyYW5zaXRpb24pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogU3RhcnRzIHRoaXMgcm91dGVyIGFuZCBjYWxscyBjYWxsYmFjayhyb3V0ZXIsIHN0YXRlKSB3aGVuIHRoZSByb3V0ZSBjaGFuZ2VzLlxuICAgICAgICpcbiAgICAgICAqIElmIHRoZSByb3V0ZXIncyBsb2NhdGlvbiBpcyBzdGF0aWMgKGkuZS4gYSBVUkwgcGF0aCBpbiBhIHNlcnZlciBlbnZpcm9ubWVudClcbiAgICAgICAqIHRoZSBjYWxsYmFjayBpcyBjYWxsZWQgb25seSBvbmNlLiBPdGhlcndpc2UsIHRoZSBsb2NhdGlvbiBzaG91bGQgYmUgb25lIG9mIHRoZVxuICAgICAgICogUm91dGVyLipMb2NhdGlvbiBvYmplY3RzIChlLmcuIFJvdXRlci5IYXNoTG9jYXRpb24gb3IgUm91dGVyLkhpc3RvcnlMb2NhdGlvbikuXG4gICAgICAgKi9cbiAgICAgIHJ1bjogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBkaXNwYXRjaEhhbmRsZXIgPSBmdW5jdGlvbiAoZXJyb3IsIHRyYW5zaXRpb24pIHtcbiAgICAgICAgICBwZW5kaW5nVHJhbnNpdGlvbiA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIG9uRXJyb3IuY2FsbChyb3V0ZXIsIGVycm9yKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRyYW5zaXRpb24uaXNBYm9ydGVkKSB7XG4gICAgICAgICAgICBvbkFib3J0LmNhbGwocm91dGVyLCB0cmFuc2l0aW9uLmFib3J0UmVhc29uLCBsb2NhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwocm91dGVyLCByb3V0ZXIsIG5leHRTdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcm91dGVyLmRpc3BhdGNoKGxvY2F0aW9uLCBudWxsLCBkaXNwYXRjaEhhbmRsZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIExpc3RlbiBmb3IgY2hhbmdlcyB0byB0aGUgbG9jYXRpb24uXG4gICAgICAgICAgdmFyIGNoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgcm91dGVyLmRpc3BhdGNoKGNoYW5nZS5wYXRoLCBjaGFuZ2UudHlwZSwgZGlzcGF0Y2hIYW5kbGVyKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKGxvY2F0aW9uLmFkZENoYW5nZUxpc3RlbmVyKVxuICAgICAgICAgICAgbG9jYXRpb24uYWRkQ2hhbmdlTGlzdGVuZXIoY2hhbmdlTGlzdGVuZXIpO1xuXG4gICAgICAgICAgLy8gQm9vdHN0cmFwIHVzaW5nIHRoZSBjdXJyZW50IHBhdGguXG4gICAgICAgICAgcm91dGVyLmRpc3BhdGNoKGxvY2F0aW9uLmdldEN1cnJlbnRQYXRoKCksIG51bGwsIGRpc3BhdGNoSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHRlYXJkb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbG9jYXRpb24ucmVtb3ZlQ2hhbmdlTGlzdGVuZXIodGhpcy5jaGFuZ2VMaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgcHJvcFR5cGVzOiB7XG4gICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLmZhbHN5XG4gICAgfSxcblxuICAgIGdldExvY2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgfSxcblxuICAgIGdldFNjcm9sbEJlaGF2aW9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc2Nyb2xsQmVoYXZpb3I7XG4gICAgfSxcblxuICAgIGdldFJvdXRlQXREZXB0aDogZnVuY3Rpb24gKGRlcHRoKSB7XG4gICAgICB2YXIgcm91dGVzID0gdGhpcy5zdGF0ZS5yb3V0ZXM7XG4gICAgICByZXR1cm4gcm91dGVzICYmIHJvdXRlc1tkZXB0aF07XG4gICAgfSxcblxuICAgIGdldFJvdXRlQ29tcG9uZW50czogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgfSxcblxuICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdXBkYXRlU3RhdGUoKTtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gKCkge1xuICAgICAgdXBkYXRlU3RhdGUoKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoc3RhdGUpO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICByb3V0ZXIudGVhcmRvd24oKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSb3V0ZUF0RGVwdGgoMCkgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlSGFuZGxlciwgdGhpcy5wcm9wcykgOiBudWxsO1xuICAgIH0sXG5cbiAgICBjaGlsZENvbnRleHRUeXBlczoge1xuICAgICAgZ2V0Um91dGVBdERlcHRoOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgZ2V0Um91dGVDb21wb25lbnRzOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgcm91dGVIYW5kbGVyczogUmVhY3QuUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWRcbiAgICB9LFxuXG4gICAgZ2V0Q2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXRSb3V0ZUNvbXBvbmVudHM6IHRoaXMuZ2V0Um91dGVDb21wb25lbnRzLFxuICAgICAgICBnZXRSb3V0ZUF0RGVwdGg6IHRoaXMuZ2V0Um91dGVBdERlcHRoLFxuICAgICAgICByb3V0ZUhhbmRsZXJzOiBbIHRoaXMgXVxuICAgICAgfTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgaWYgKG9wdGlvbnMucm91dGVzKVxuICAgIHJvdXRlci5hZGRSb3V0ZXMob3B0aW9ucy5yb3V0ZXMpO1xuXG4gIHJldHVybiByb3V0ZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUm91dGVyO1xuIiwiLyoganNoaW50IC1XMDg0ICovXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdyZWFjdC9saWIvd2FybmluZycpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9pbnZhcmlhbnQnKTtcbnZhciBEZWZhdWx0Um91dGUgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0RlZmF1bHRSb3V0ZScpO1xudmFyIE5vdEZvdW5kUm91dGUgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL05vdEZvdW5kUm91dGUnKTtcbnZhciBSZWRpcmVjdCA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvUmVkaXJlY3QnKTtcbnZhciBSb3V0ZSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvUm91dGUnKTtcbnZhciBQYXRoID0gcmVxdWlyZSgnLi9QYXRoJyk7XG5cbnZhciBDT05GSUdfRUxFTUVOVF9UWVBFUyA9IFtcbiAgRGVmYXVsdFJvdXRlLnR5cGUsXG4gIE5vdEZvdW5kUm91dGUudHlwZSxcbiAgUmVkaXJlY3QudHlwZSxcbiAgUm91dGUudHlwZVxuXTtcblxuZnVuY3Rpb24gY3JlYXRlUmVkaXJlY3RIYW5kbGVyKHRvLCBfcGFyYW1zLCBfcXVlcnkpIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICBzdGF0aWNzOiB7XG4gICAgICB3aWxsVHJhbnNpdGlvblRvOiBmdW5jdGlvbiAodHJhbnNpdGlvbiwgcGFyYW1zLCBxdWVyeSkge1xuICAgICAgICB0cmFuc2l0aW9uLnJlZGlyZWN0KHRvLCBfcGFyYW1zIHx8IHBhcmFtcywgX3F1ZXJ5IHx8IHF1ZXJ5KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyhjb21wb25lbnROYW1lLCBwcm9wVHlwZXMsIHByb3BzKSB7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xuICAgIGlmIChwcm9wVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICB2YXIgZXJyb3IgPSBwcm9wVHlwZXNbcHJvcE5hbWVdKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKVxuICAgICAgICB3YXJuaW5nKGZhbHNlLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUm91dGUoZWxlbWVudCwgcGFyZW50Um91dGUsIG5hbWVkUm91dGVzKSB7XG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICB2YXIgcHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICB2YXIgY29tcG9uZW50TmFtZSA9ICh0eXBlICYmIHR5cGUuZGlzcGxheU5hbWUpIHx8ICdVbmtub3duQ29tcG9uZW50JztcblxuICBpbnZhcmlhbnQoXG4gICAgQ09ORklHX0VMRU1FTlRfVFlQRVMuaW5kZXhPZih0eXBlKSAhPT0gLTEsXG4gICAgJ1VucmVjb2duaXplZCByb3V0ZSBjb25maWd1cmF0aW9uIGVsZW1lbnQgXCI8JXM+XCInLFxuICAgIGNvbXBvbmVudE5hbWVcbiAgKTtcblxuICBpZiAodHlwZS5wcm9wVHlwZXMpXG4gICAgY2hlY2tQcm9wVHlwZXMoY29tcG9uZW50TmFtZSwgdHlwZS5wcm9wVHlwZXMsIHByb3BzKTtcblxuICB2YXIgcm91dGUgPSB7IG5hbWU6IHByb3BzLm5hbWUgfTtcblxuICBpZiAocHJvcHMuaWdub3JlU2Nyb2xsQmVoYXZpb3IpIHtcbiAgICByb3V0ZS5pZ25vcmVTY3JvbGxCZWhhdmlvciA9IHRydWU7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gUmVkaXJlY3QudHlwZSkge1xuICAgIHJvdXRlLmhhbmRsZXIgPSBjcmVhdGVSZWRpcmVjdEhhbmRsZXIocHJvcHMudG8sIHByb3BzLnBhcmFtcywgcHJvcHMucXVlcnkpO1xuICAgIHByb3BzLnBhdGggPSBwcm9wcy5wYXRoIHx8IHByb3BzLmZyb20gfHwgJyonO1xuICB9IGVsc2Uge1xuICAgIHJvdXRlLmhhbmRsZXIgPSBwcm9wcy5oYW5kbGVyO1xuICB9XG5cbiAgdmFyIHBhcmVudFBhdGggPSAocGFyZW50Um91dGUgJiYgcGFyZW50Um91dGUucGF0aCkgfHwgJy8nO1xuXG4gIGlmICgocHJvcHMucGF0aCB8fCBwcm9wcy5uYW1lKSAmJiB0eXBlICE9PSBEZWZhdWx0Um91dGUudHlwZSAmJiB0eXBlICE9PSBOb3RGb3VuZFJvdXRlLnR5cGUpIHtcbiAgICB2YXIgcGF0aCA9IHByb3BzLnBhdGggfHwgcHJvcHMubmFtZTtcblxuICAgIC8vIFJlbGF0aXZlIHBhdGhzIGV4dGVuZCB0aGVpciBwYXJlbnQuXG4gICAgaWYgKCFQYXRoLmlzQWJzb2x1dGUocGF0aCkpXG4gICAgICBwYXRoID0gUGF0aC5qb2luKHBhcmVudFBhdGgsIHBhdGgpO1xuXG4gICAgcm91dGUucGF0aCA9IFBhdGgubm9ybWFsaXplKHBhdGgpO1xuICB9IGVsc2Uge1xuICAgIHJvdXRlLnBhdGggPSBwYXJlbnRQYXRoO1xuXG4gICAgaWYgKHR5cGUgPT09IE5vdEZvdW5kUm91dGUudHlwZSlcbiAgICAgIHJvdXRlLnBhdGggKz0gJyonO1xuICB9XG5cbiAgcm91dGUucGFyYW1OYW1lcyA9IFBhdGguZXh0cmFjdFBhcmFtTmFtZXMocm91dGUucGF0aCk7XG5cbiAgLy8gTWFrZSBzdXJlIHRoZSByb3V0ZSdzIHBhdGggaGFzIGFsbCBwYXJhbXMgaXRzIHBhcmVudCBuZWVkcy5cbiAgaWYgKHBhcmVudFJvdXRlICYmIEFycmF5LmlzQXJyYXkocGFyZW50Um91dGUucGFyYW1OYW1lcykpIHtcbiAgICBwYXJlbnRSb3V0ZS5wYXJhbU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtTmFtZSkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICByb3V0ZS5wYXJhbU5hbWVzLmluZGV4T2YocGFyYW1OYW1lKSAhPT0gLTEsXG4gICAgICAgICdUaGUgbmVzdGVkIHJvdXRlIHBhdGggXCIlc1wiIGlzIG1pc3NpbmcgdGhlIFwiJXNcIiBwYXJhbWV0ZXIgb2YgaXRzIHBhcmVudCBwYXRoIFwiJXNcIicsXG4gICAgICAgIHJvdXRlLnBhdGgsIHBhcmFtTmFtZSwgcGFyZW50Um91dGUucGF0aFxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSB0aGUgcm91dGUgY2FuIGJlIGxvb2tlZCB1cCBieSA8TGluaz5zLlxuICBpZiAocHJvcHMubmFtZSkge1xuICAgIGludmFyaWFudChcbiAgICAgIG5hbWVkUm91dGVzW3Byb3BzLm5hbWVdID09IG51bGwsXG4gICAgICAnWW91IGNhbm5vdCB1c2UgdGhlIG5hbWUgXCIlc1wiIGZvciBtb3JlIHRoYW4gb25lIHJvdXRlJyxcbiAgICAgIHByb3BzLm5hbWVcbiAgICApO1xuXG4gICAgbmFtZWRSb3V0ZXNbcHJvcHMubmFtZV0gPSByb3V0ZTtcbiAgfVxuXG4gIC8vIEhhbmRsZSA8Tm90Rm91bmRSb3V0ZT4uXG4gIGlmICh0eXBlID09PSBOb3RGb3VuZFJvdXRlLnR5cGUpIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBwYXJlbnRSb3V0ZSxcbiAgICAgICc8Tm90Rm91bmRSb3V0ZT4gbXVzdCBoYXZlIGEgcGFyZW50IDxSb3V0ZT4nXG4gICAgKTtcblxuICAgIGludmFyaWFudChcbiAgICAgIHBhcmVudFJvdXRlLm5vdEZvdW5kUm91dGUgPT0gbnVsbCxcbiAgICAgICdZb3UgbWF5IG5vdCBoYXZlIG1vcmUgdGhhbiBvbmUgPE5vdEZvdW5kUm91dGU+IHBlciA8Um91dGU+J1xuICAgICk7XG5cbiAgICBwYXJlbnRSb3V0ZS5ub3RGb3VuZFJvdXRlID0gcm91dGU7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEhhbmRsZSA8RGVmYXVsdFJvdXRlPi5cbiAgaWYgKHR5cGUgPT09IERlZmF1bHRSb3V0ZS50eXBlKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgcGFyZW50Um91dGUsXG4gICAgICAnPERlZmF1bHRSb3V0ZT4gbXVzdCBoYXZlIGEgcGFyZW50IDxSb3V0ZT4nXG4gICAgKTtcblxuICAgIGludmFyaWFudChcbiAgICAgIHBhcmVudFJvdXRlLmRlZmF1bHRSb3V0ZSA9PSBudWxsLFxuICAgICAgJ1lvdSBtYXkgbm90IGhhdmUgbW9yZSB0aGFuIG9uZSA8RGVmYXVsdFJvdXRlPiBwZXIgPFJvdXRlPidcbiAgICApO1xuXG4gICAgcGFyZW50Um91dGUuZGVmYXVsdFJvdXRlID0gcm91dGU7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJvdXRlLmNoaWxkUm91dGVzID0gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKHByb3BzLmNoaWxkcmVuLCByb3V0ZSwgbmFtZWRSb3V0ZXMpO1xuXG4gIHJldHVybiByb3V0ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHJvdXRlIG9iamVjdHMgZnJvbSB0aGUgZ2l2ZW4gUmVhY3RDaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGNoaWxkcmVuLCBwYXJlbnRSb3V0ZSwgbmFtZWRSb3V0ZXMpIHtcbiAgdmFyIHJvdXRlcyA9IFtdO1xuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIC8vIEV4Y2x1ZGUgPERlZmF1bHRSb3V0ZT5zIGFuZCA8Tm90Rm91bmRSb3V0ZT5zLlxuICAgIGlmIChjaGlsZCA9IGNyZWF0ZVJvdXRlKGNoaWxkLCBwYXJlbnRSb3V0ZSwgbmFtZWRSb3V0ZXMpKVxuICAgICAgcm91dGVzLnB1c2goY2hpbGQpO1xuICB9KTtcblxuICByZXR1cm4gcm91dGVzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbjtcbiIsInZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdyZWFjdC9saWIvaW52YXJpYW50Jyk7XG52YXIgY2FuVXNlRE9NID0gcmVxdWlyZSgncmVhY3QvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50JykuY2FuVXNlRE9NO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSB3aW5kb3cgYXMgeyB4LCB5IH0uXG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbFBvc2l0aW9uKCkge1xuICBpbnZhcmlhbnQoXG4gICAgY2FuVXNlRE9NLFxuICAgICdDYW5ub3QgZ2V0IGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIHdpdGhvdXQgYSBET00nXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG4gICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRXaW5kb3dTY3JvbGxQb3NpdGlvbjtcbiIsImZ1bmN0aW9uIHJldmVyc2VkQXJyYXkoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5LnNsaWNlKDApLnJldmVyc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXZlcnNlZEFycmF5O1xuIiwidmFyIGNyZWF0ZVJvdXRlciA9IHJlcXVpcmUoJy4vY3JlYXRlUm91dGVyJyk7XG5cbi8qKlxuICogQSBoaWdoLWxldmVsIGNvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGNyZWF0ZXMsIGNvbmZpZ3VyZXMsIGFuZFxuICogcnVucyBhIHJvdXRlciBpbiBvbmUgc2hvdC4gVGhlIG1ldGhvZCBzaWduYXR1cmUgaXM6XG4gKlxuICogICBSb3V0ZXIucnVuKHJvdXRlc1ssIGxvY2F0aW9uIF0sIGNhbGxiYWNrKTtcbiAqXG4gKiBVc2luZyBgd2luZG93LmxvY2F0aW9uLmhhc2hgIHRvIG1hbmFnZSB0aGUgVVJMLCB5b3UgY291bGQgZG86XG4gKlxuICogICBSb3V0ZXIucnVuKHJvdXRlcywgZnVuY3Rpb24gKEhhbmRsZXIpIHtcbiAqICAgICBSZWFjdC5yZW5kZXIoPEhhbmRsZXIvPiwgZG9jdW1lbnQuYm9keSk7XG4gKiAgIH0pO1xuICogXG4gKiBVc2luZyBIVE1MNSBoaXN0b3J5IGFuZCBhIGN1c3RvbSBcImN1cnNvclwiIHByb3A6XG4gKiBcbiAqICAgUm91dGVyLnJ1bihyb3V0ZXMsIFJvdXRlci5IaXN0b3J5TG9jYXRpb24sIGZ1bmN0aW9uIChIYW5kbGVyKSB7XG4gKiAgICAgUmVhY3QucmVuZGVyKDxIYW5kbGVyIGN1cnNvcj17Y3Vyc29yfS8+LCBkb2N1bWVudC5ib2R5KTtcbiAqICAgfSk7XG4gKlxuICogUmV0dXJucyB0aGUgbmV3bHkgY3JlYXRlZCByb3V0ZXIuXG4gKlxuICogTm90ZTogSWYgeW91IG5lZWQgdG8gc3BlY2lmeSBmdXJ0aGVyIG9wdGlvbnMgZm9yIHlvdXIgcm91dGVyIHN1Y2hcbiAqIGFzIGVycm9yL2Fib3J0IGhhbmRsaW5nIG9yIGN1c3RvbSBzY3JvbGwgYmVoYXZpb3IsIHVzZSBSb3V0ZXIuY3JlYXRlXG4gKiBpbnN0ZWFkLlxuICpcbiAqICAgdmFyIHJvdXRlciA9IFJvdXRlci5jcmVhdGUob3B0aW9ucyk7XG4gKiAgIHJvdXRlci5ydW4oZnVuY3Rpb24gKEhhbmRsZXIpIHtcbiAqICAgICAvLyAuLi5cbiAqICAgfSk7XG4gKi9cbmZ1bmN0aW9uIHJ1blJvdXRlcihyb3V0ZXMsIGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBsb2NhdGlvbjtcbiAgICBsb2NhdGlvbiA9IG51bGw7XG4gIH1cblxuICB2YXIgcm91dGVyID0gY3JlYXRlUm91dGVyKHtcbiAgICByb3V0ZXM6IHJvdXRlcyxcbiAgICBsb2NhdGlvbjogbG9jYXRpb25cbiAgfSk7XG5cbiAgcm91dGVyLnJ1bihjYWxsYmFjayk7XG5cbiAgcmV0dXJuIHJvdXRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBydW5Sb3V0ZXI7XG4iLCJmdW5jdGlvbiBzdXBwb3J0c0hpc3RvcnkoKSB7XG4gIC8qISB0YWtlbiBmcm9tIG1vZGVybml6clxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9MSUNFTlNFXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL2ZlYXR1cmUtZGV0ZWN0cy9oaXN0b3J5LmpzXG4gICAqIGNoYW5nZWQgdG8gYXZvaWQgZmFsc2UgbmVnYXRpdmVzIGZvciBXaW5kb3dzIFBob25lczogaHR0cHM6Ly9naXRodWIuY29tL3JhY2t0L3JlYWN0LXJvdXRlci9pc3N1ZXMvNTg2XG4gICAqL1xuICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICBpZiAoKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHxcbiAgICAgICh1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkpICYmXG4gICAgICB1YS5pbmRleE9mKCdNb2JpbGUgU2FmYXJpJykgIT09IC0xICYmXG4gICAgICB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiZcbiAgICAgIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuICh3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNIaXN0b3J5O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYicpO1xuIiwiLy8gTG9hZCBtb2R1bGVzXG5cbnZhciBTdHJpbmdpZnkgPSByZXF1aXJlKCcuL3N0cmluZ2lmeScpO1xudmFyIFBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpO1xuXG5cbi8vIERlY2xhcmUgaW50ZXJuYWxzXG5cbnZhciBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzdHJpbmdpZnk6IFN0cmluZ2lmeSxcbiAgICBwYXJzZTogUGFyc2Vcbn07XG4iLCIvLyBMb2FkIG1vZHVsZXNcblxudmFyIFV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5cbi8vIERlY2xhcmUgaW50ZXJuYWxzXG5cbnZhciBpbnRlcm5hbHMgPSB7XG4gICAgZGVsaW1pdGVyOiAnJicsXG4gICAgZGVwdGg6IDUsXG4gICAgYXJyYXlMaW1pdDogMjAsXG4gICAgcGFyYW1ldGVyTGltaXQ6IDEwMDBcbn07XG5cblxuaW50ZXJuYWxzLnBhcnNlVmFsdWVzID0gZnVuY3Rpb24gKHN0ciwgb3B0aW9ucykge1xuXG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdChvcHRpb25zLmRlbGltaXRlciwgb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdCA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBvcHRpb25zLnBhcmFtZXRlckxpbWl0KTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHBhcnRzLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgdmFyIHBvcyA9IHBhcnQuaW5kZXhPZignXT0nKSA9PT0gLTEgPyBwYXJ0LmluZGV4T2YoJz0nKSA6IHBhcnQuaW5kZXhPZignXT0nKSArIDE7XG5cbiAgICAgICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgICAgICAgIG9ialtVdGlscy5kZWNvZGUocGFydCldID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gVXRpbHMuZGVjb2RlKHBhcnQuc2xpY2UoMCwgcG9zKSk7XG4gICAgICAgICAgICB2YXIgdmFsID0gVXRpbHMuZGVjb2RlKHBhcnQuc2xpY2UocG9zICsgMSkpO1xuXG4gICAgICAgICAgICBpZiAoIW9ialtrZXldKSB7XG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IFtdLmNvbmNhdChvYmpba2V5XSkuY29uY2F0KHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxuXG5pbnRlcm5hbHMucGFyc2VPYmplY3QgPSBmdW5jdGlvbiAoY2hhaW4sIHZhbCwgb3B0aW9ucykge1xuXG4gICAgaWYgKCFjaGFpbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICB2YXIgcm9vdCA9IGNoYWluLnNoaWZ0KCk7XG5cbiAgICB2YXIgb2JqID0ge307XG4gICAgaWYgKHJvb3QgPT09ICdbXScpIHtcbiAgICAgICAgb2JqID0gW107XG4gICAgICAgIG9iaiA9IG9iai5jb25jYXQoaW50ZXJuYWxzLnBhcnNlT2JqZWN0KGNoYWluLCB2YWwsIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBjbGVhblJvb3QgPSByb290WzBdID09PSAnWycgJiYgcm9vdFtyb290Lmxlbmd0aCAtIDFdID09PSAnXScgPyByb290LnNsaWNlKDEsIHJvb3QubGVuZ3RoIC0gMSkgOiByb290O1xuICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludChjbGVhblJvb3QsIDEwKTtcbiAgICAgICAgaWYgKCFpc05hTihpbmRleCkgJiZcbiAgICAgICAgICAgIHJvb3QgIT09IGNsZWFuUm9vdCAmJlxuICAgICAgICAgICAgaW5kZXggPD0gb3B0aW9ucy5hcnJheUxpbWl0KSB7XG5cbiAgICAgICAgICAgIG9iaiA9IFtdO1xuICAgICAgICAgICAgb2JqW2luZGV4XSA9IGludGVybmFscy5wYXJzZU9iamVjdChjaGFpbiwgdmFsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9ialtjbGVhblJvb3RdID0gaW50ZXJuYWxzLnBhcnNlT2JqZWN0KGNoYWluLCB2YWwsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cblxuaW50ZXJuYWxzLnBhcnNlS2V5cyA9IGZ1bmN0aW9uIChrZXksIHZhbCwgb3B0aW9ucykge1xuXG4gICAgaWYgKCFrZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRoZSByZWdleCBjaHVua3NcblxuICAgIHZhciBwYXJlbnQgPSAvXihbXlxcW1xcXV0qKS87XG4gICAgdmFyIGNoaWxkID0gLyhcXFtbXlxcW1xcXV0qXFxdKS9nO1xuXG4gICAgLy8gR2V0IHRoZSBwYXJlbnRcblxuICAgIHZhciBzZWdtZW50ID0gcGFyZW50LmV4ZWMoa2V5KTtcblxuICAgIC8vIERvbid0IGFsbG93IHRoZW0gdG8gb3ZlcndyaXRlIG9iamVjdCBwcm90b3R5cGUgcHJvcGVydGllc1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoc2VnbWVudFsxXSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFN0YXNoIHRoZSBwYXJlbnQgaWYgaXQgZXhpc3RzXG5cbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGlmIChzZWdtZW50WzFdKSB7XG4gICAgICAgIGtleXMucHVzaChzZWdtZW50WzFdKTtcbiAgICB9XG5cbiAgICAvLyBMb29wIHRocm91Z2ggY2hpbGRyZW4gYXBwZW5kaW5nIHRvIHRoZSBhcnJheSB1bnRpbCB3ZSBoaXQgZGVwdGhcblxuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoKHNlZ21lbnQgPSBjaGlsZC5leGVjKGtleSkpICE9PSBudWxsICYmIGkgPCBvcHRpb25zLmRlcHRoKSB7XG5cbiAgICAgICAgKytpO1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoc2VnbWVudFsxXS5yZXBsYWNlKC9cXFt8XFxdL2csICcnKSkpIHtcbiAgICAgICAgICAgIGtleXMucHVzaChzZWdtZW50WzFdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZXJlJ3MgYSByZW1haW5kZXIsIGp1c3QgYWRkIHdoYXRldmVyIGlzIGxlZnRcblxuICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIGtleXMucHVzaCgnWycgKyBrZXkuc2xpY2Uoc2VnbWVudC5pbmRleCkgKyAnXScpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcm5hbHMucGFyc2VPYmplY3Qoa2V5cywgdmFsLCBvcHRpb25zKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyLCBvcHRpb25zKSB7XG5cbiAgICBpZiAoc3RyID09PSAnJyB8fFxuICAgICAgICBzdHIgPT09IG51bGwgfHxcbiAgICAgICAgdHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcblxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5kZWxpbWl0ZXIgPSB0eXBlb2Ygb3B0aW9ucy5kZWxpbWl0ZXIgPT09ICdzdHJpbmcnIHx8IFV0aWxzLmlzUmVnRXhwKG9wdGlvbnMuZGVsaW1pdGVyKSA/IG9wdGlvbnMuZGVsaW1pdGVyIDogaW50ZXJuYWxzLmRlbGltaXRlcjtcbiAgICBvcHRpb25zLmRlcHRoID0gdHlwZW9mIG9wdGlvbnMuZGVwdGggPT09ICdudW1iZXInID8gb3B0aW9ucy5kZXB0aCA6IGludGVybmFscy5kZXB0aDtcbiAgICBvcHRpb25zLmFycmF5TGltaXQgPSB0eXBlb2Ygb3B0aW9ucy5hcnJheUxpbWl0ID09PSAnbnVtYmVyJyA/IG9wdGlvbnMuYXJyYXlMaW1pdCA6IGludGVybmFscy5hcnJheUxpbWl0O1xuICAgIG9wdGlvbnMucGFyYW1ldGVyTGltaXQgPSB0eXBlb2Ygb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdCA9PT0gJ251bWJlcicgPyBvcHRpb25zLnBhcmFtZXRlckxpbWl0IDogaW50ZXJuYWxzLnBhcmFtZXRlckxpbWl0O1xuXG4gICAgdmFyIHRlbXBPYmogPSB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IGludGVybmFscy5wYXJzZVZhbHVlcyhzdHIsIG9wdGlvbnMpIDogc3RyO1xuICAgIHZhciBvYmogPSB7fTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUga2V5cyBhbmQgc2V0dXAgdGhlIG5ldyBvYmplY3RcblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGVtcE9iaik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0ga2V5cy5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgbmV3T2JqID0gaW50ZXJuYWxzLnBhcnNlS2V5cyhrZXksIHRlbXBPYmpba2V5XSwgb3B0aW9ucyk7XG4gICAgICAgIG9iaiA9IFV0aWxzLm1lcmdlKG9iaiwgbmV3T2JqKTtcbiAgICB9XG5cbiAgICByZXR1cm4gVXRpbHMuY29tcGFjdChvYmopO1xufTtcbiIsIi8vIExvYWQgbW9kdWxlc1xuXG52YXIgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cblxuLy8gRGVjbGFyZSBpbnRlcm5hbHNcblxudmFyIGludGVybmFscyA9IHtcbiAgICBkZWxpbWl0ZXI6ICcmJ1xufTtcblxuXG5pbnRlcm5hbHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKG9iaiwgcHJlZml4KSB7XG5cbiAgICBpZiAoVXRpbHMuaXNCdWZmZXIob2JqKSkge1xuICAgICAgICBvYmogPSBvYmoudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBvYmogPSBvYmoudG9JU09TdHJpbmcoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIG9iaiA9ICcnO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJyB8fFxuICAgICAgICB0eXBlb2Ygb2JqID09PSAnbnVtYmVyJyB8fFxuICAgICAgICB0eXBlb2Ygb2JqID09PSAnYm9vbGVhbicpIHtcblxuICAgICAgICByZXR1cm4gW2VuY29kZVVSSUNvbXBvbmVudChwcmVmaXgpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9iaildO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KGludGVybmFscy5zdHJpbmdpZnkob2JqW2tleV0sIHByZWZpeCArICdbJyArIGtleSArICddJykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlcztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBvcHRpb25zKSB7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgZGVsaW1pdGVyID0gdHlwZW9mIG9wdGlvbnMuZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/IGludGVybmFscy5kZWxpbWl0ZXIgOiBvcHRpb25zLmRlbGltaXRlcjtcblxuICAgIHZhciBrZXlzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAga2V5cyA9IGtleXMuY29uY2F0KGludGVybmFscy5zdHJpbmdpZnkob2JqW2tleV0sIGtleSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleXMuam9pbihkZWxpbWl0ZXIpO1xufTtcbiIsIi8vIExvYWQgbW9kdWxlc1xuXG5cbi8vIERlY2xhcmUgaW50ZXJuYWxzXG5cbnZhciBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLmFycmF5VG9PYmplY3QgPSBmdW5jdGlvbiAoc291cmNlKSB7XG5cbiAgICB2YXIgb2JqID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gc291cmNlLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VbaV0gIT09ICd1bmRlZmluZWQnKSB7XG5cbiAgICAgICAgICAgIG9ialtpXSA9IHNvdXJjZVtpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuXG5cbmV4cG9ydHMubWVyZ2UgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblxuICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBzb3VyY2UubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtpXSA9IGV4cG9ydHMubWVyZ2UodGFyZ2V0W2ldLCBzb3VyY2VbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2ldID0gc291cmNlW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKHNvdXJjZSk7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0ID0gZXhwb3J0cy5hcnJheVRvT2JqZWN0KHRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgZm9yICh2YXIgayA9IDAsIGtsID0ga2V5cy5sZW5ndGg7IGsgPCBrbDsgKytrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2tdO1xuICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgaWYgKCF0YXJnZXRba2V5XSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IGV4cG9ydHMubWVyZ2UodGFyZ2V0W2tleV0sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLmNvbXBhY3QgPSBmdW5jdGlvbiAob2JqLCByZWZzKSB7XG5cbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgb2JqID09PSBudWxsKSB7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICByZWZzID0gcmVmcyB8fCBbXTtcbiAgICB2YXIgbG9va3VwID0gcmVmcy5pbmRleE9mKG9iaik7XG4gICAgaWYgKGxvb2t1cCAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHJlZnNbbG9va3VwXTtcbiAgICB9XG5cbiAgICByZWZzLnB1c2gob2JqKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgdmFyIGNvbXBhY3RlZCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmpbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29tcGFjdGVkLnB1c2gob2JqW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wYWN0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGtleXMubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgb2JqW2tleV0gPSBleHBvcnRzLmNvbXBhY3Qob2JqW2tleV0sIHJlZnMpO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuXG5cbmV4cG9ydHMuaXNSZWdFeHAgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBSZWdFeHBdJztcbn07XG5cblxuZXhwb3J0cy5pc0J1ZmZlciA9IGZ1bmN0aW9uIChvYmopIHtcblxuICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbiIsIi8qKiBAbGljZW5zZSBNSVQgTGljZW5zZSAoYykgY29weXJpZ2h0IDIwMTAtMjAxNCBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9ycyAqL1xuLyoqIEBhdXRob3IgQnJpYW4gQ2F2YWxpZXIgKi9cbi8qKiBAYXV0aG9yIEpvaG4gSGFubiAqL1xuXG4oZnVuY3Rpb24oZGVmaW5lKSB7ICd1c2Ugc3RyaWN0JztcbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG5cdHZhciBtYWtlUHJvbWlzZSA9IHJlcXVpcmUoJy4vbWFrZVByb21pc2UnKTtcblx0dmFyIFNjaGVkdWxlciA9IHJlcXVpcmUoJy4vU2NoZWR1bGVyJyk7XG5cdHZhciBhc3luYyA9IHJlcXVpcmUoJy4vYXN5bmMnKTtcblxuXHRyZXR1cm4gbWFrZVByb21pc2Uoe1xuXHRcdHNjaGVkdWxlcjogbmV3IFNjaGVkdWxlcihhc3luYylcblx0fSk7XG5cbn0pO1xufSkodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9KTtcbiIsIi8qKiBAbGljZW5zZSBNSVQgTGljZW5zZSAoYykgY29weXJpZ2h0IDIwMTAtMjAxNCBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9ycyAqL1xuLyoqIEBhdXRob3IgQnJpYW4gQ2F2YWxpZXIgKi9cbi8qKiBAYXV0aG9yIEpvaG4gSGFubiAqL1xuXG4oZnVuY3Rpb24oZGVmaW5lKSB7ICd1c2Ugc3RyaWN0JztcbmRlZmluZShmdW5jdGlvbigpIHtcblx0LyoqXG5cdCAqIENpcmN1bGFyIHF1ZXVlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjYXBhY2l0eVBvdzIgcG93ZXIgb2YgMiB0byB3aGljaCB0aGlzIHF1ZXVlJ3MgY2FwYWNpdHlcblx0ICogIHdpbGwgYmUgc2V0IGluaXRpYWxseS4gZWcgd2hlbiBjYXBhY2l0eVBvdzIgPT0gMywgcXVldWUgY2FwYWNpdHlcblx0ICogIHdpbGwgYmUgOC5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBRdWV1ZShjYXBhY2l0eVBvdzIpIHtcblx0XHR0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSB0aGlzLmxlbmd0aCA9IDA7XG5cdFx0dGhpcy5idWZmZXIgPSBuZXcgQXJyYXkoMSA8PCBjYXBhY2l0eVBvdzIpO1xuXHR9XG5cblx0UXVldWUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbih4KSB7XG5cdFx0aWYodGhpcy5sZW5ndGggPT09IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5fZW5zdXJlQ2FwYWNpdHkodGhpcy5sZW5ndGggKiAyKTtcblx0XHR9XG5cblx0XHR0aGlzLmJ1ZmZlclt0aGlzLnRhaWxdID0geDtcblx0XHR0aGlzLnRhaWwgPSAodGhpcy50YWlsICsgMSkgJiAodGhpcy5idWZmZXIubGVuZ3RoIC0gMSk7XG5cdFx0Kyt0aGlzLmxlbmd0aDtcblx0XHRyZXR1cm4gdGhpcy5sZW5ndGg7XG5cdH07XG5cblx0UXVldWUucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHggPSB0aGlzLmJ1ZmZlclt0aGlzLmhlYWRdO1xuXHRcdHRoaXMuYnVmZmVyW3RoaXMuaGVhZF0gPSB2b2lkIDA7XG5cdFx0dGhpcy5oZWFkID0gKHRoaXMuaGVhZCArIDEpICYgKHRoaXMuYnVmZmVyLmxlbmd0aCAtIDEpO1xuXHRcdC0tdGhpcy5sZW5ndGg7XG5cdFx0cmV0dXJuIHg7XG5cdH07XG5cblx0UXVldWUucHJvdG90eXBlLl9lbnN1cmVDYXBhY2l0eSA9IGZ1bmN0aW9uKGNhcGFjaXR5KSB7XG5cdFx0dmFyIGhlYWQgPSB0aGlzLmhlYWQ7XG5cdFx0dmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuXHRcdHZhciBuZXdCdWZmZXIgPSBuZXcgQXJyYXkoY2FwYWNpdHkpO1xuXHRcdHZhciBpID0gMDtcblx0XHR2YXIgbGVuO1xuXG5cdFx0aWYoaGVhZCA9PT0gMCkge1xuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGg7XG5cdFx0XHRmb3IoOyBpPGxlbjsgKytpKSB7XG5cdFx0XHRcdG5ld0J1ZmZlcltpXSA9IGJ1ZmZlcltpXTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FwYWNpdHkgPSBidWZmZXIubGVuZ3RoO1xuXHRcdFx0bGVuID0gdGhpcy50YWlsO1xuXHRcdFx0Zm9yKDsgaGVhZDxjYXBhY2l0eTsgKytpLCArK2hlYWQpIHtcblx0XHRcdFx0bmV3QnVmZmVyW2ldID0gYnVmZmVyW2hlYWRdO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoaGVhZD0wOyBoZWFkPGxlbjsgKytpLCArK2hlYWQpIHtcblx0XHRcdFx0bmV3QnVmZmVyW2ldID0gYnVmZmVyW2hlYWRdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuYnVmZmVyID0gbmV3QnVmZmVyO1xuXHRcdHRoaXMuaGVhZCA9IDA7XG5cdFx0dGhpcy50YWlsID0gdGhpcy5sZW5ndGg7XG5cdH07XG5cblx0cmV0dXJuIFF1ZXVlO1xuXG59KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24oZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTsgfSkpO1xuIiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG4vKiogQGF1dGhvciBCcmlhbiBDYXZhbGllciAqL1xuLyoqIEBhdXRob3IgSm9obiBIYW5uICovXG5cbihmdW5jdGlvbihkZWZpbmUpIHsgJ3VzZSBzdHJpY3QnO1xuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUpIHtcblxuXHR2YXIgUXVldWUgPSByZXF1aXJlKCcuL1F1ZXVlJyk7XG5cblx0Ly8gQ3JlZGl0IHRvIFR3aXNvbCAoaHR0cHM6Ly9naXRodWIuY29tL1R3aXNvbCkgZm9yIHN1Z2dlc3Rpbmdcblx0Ly8gdGhpcyB0eXBlIG9mIGV4dGVuc2libGUgcXVldWUgKyB0cmFtcG9saW5lIGFwcHJvYWNoIGZvciBuZXh0LXRpY2sgY29uZmxhdGlvbi5cblxuXHQvKipcblx0ICogQXN5bmMgdGFzayBzY2hlZHVsZXJcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gYXN5bmMgZnVuY3Rpb24gdG8gc2NoZWR1bGUgYSBzaW5nbGUgYXN5bmMgZnVuY3Rpb25cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBTY2hlZHVsZXIoYXN5bmMpIHtcblx0XHR0aGlzLl9hc3luYyA9IGFzeW5jO1xuXHRcdHRoaXMuX3F1ZXVlID0gbmV3IFF1ZXVlKDE1KTtcblx0XHR0aGlzLl9hZnRlclF1ZXVlID0gbmV3IFF1ZXVlKDUpO1xuXHRcdHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcblxuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR0aGlzLmRyYWluID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRzZWxmLl9kcmFpbigpO1xuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogRW5xdWV1ZSBhIHRhc2tcblx0ICogQHBhcmFtIHt7IHJ1bjpmdW5jdGlvbiB9fSB0YXNrXG5cdCAqL1xuXHRTY2hlZHVsZXIucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbih0YXNrKSB7XG5cdFx0dGhpcy5fYWRkKHRoaXMuX3F1ZXVlLCB0YXNrKTtcblx0fTtcblxuXHQvKipcblx0ICogRW5xdWV1ZSBhIHRhc2sgdG8gcnVuIGFmdGVyIHRoZSBtYWluIHRhc2sgcXVldWVcblx0ICogQHBhcmFtIHt7IHJ1bjpmdW5jdGlvbiB9fSB0YXNrXG5cdCAqL1xuXHRTY2hlZHVsZXIucHJvdG90eXBlLmFmdGVyUXVldWUgPSBmdW5jdGlvbih0YXNrKSB7XG5cdFx0dGhpcy5fYWRkKHRoaXMuX2FmdGVyUXVldWUsIHRhc2spO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmFpbiB0aGUgaGFuZGxlciBxdWV1ZSBlbnRpcmVseSwgYW5kIHRoZW4gdGhlIGFmdGVyIHF1ZXVlXG5cdCAqL1xuXHRTY2hlZHVsZXIucHJvdG90eXBlLl9kcmFpbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHJ1blF1ZXVlKHRoaXMuX3F1ZXVlKTtcblx0XHR0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG5cdFx0cnVuUXVldWUodGhpcy5fYWZ0ZXJRdWV1ZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZCBhIHRhc2sgdG8gdGhlIHEsIGFuZCBzY2hlZHVsZSBkcmFpbiBpZiBub3QgYWxyZWFkeSBzY2hlZHVsZWRcblx0ICogQHBhcmFtIHtRdWV1ZX0gcXVldWVcblx0ICogQHBhcmFtIHt7cnVuOmZ1bmN0aW9ufX0gdGFza1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0U2NoZWR1bGVyLnByb3RvdHlwZS5fYWRkID0gZnVuY3Rpb24ocXVldWUsIHRhc2spIHtcblx0XHRxdWV1ZS5wdXNoKHRhc2spO1xuXHRcdGlmKCF0aGlzLl9ydW5uaW5nKSB7XG5cdFx0XHR0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcblx0XHRcdHRoaXMuX2FzeW5jKHRoaXMuZHJhaW4pO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUnVuIGFsbCB0aGUgdGFza3MgaW4gdGhlIHFcblx0ICogQHBhcmFtIHF1ZXVlXG5cdCAqL1xuXHRmdW5jdGlvbiBydW5RdWV1ZShxdWV1ZSkge1xuXHRcdHdoaWxlKHF1ZXVlLmxlbmd0aCA+IDApIHtcblx0XHRcdHF1ZXVlLnNoaWZ0KCkucnVuKCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIFNjaGVkdWxlcjtcblxufSk7XG59KHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9KSk7XG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cblxuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSkge1xuXG5cdC8vIFNuaWZmIFwiYmVzdFwiIGFzeW5jIHNjaGVkdWxpbmcgb3B0aW9uXG5cdC8vIFByZWZlciBwcm9jZXNzLm5leHRUaWNrIG9yIE11dGF0aW9uT2JzZXJ2ZXIsIHRoZW4gY2hlY2sgZm9yXG5cdC8vIHZlcnR4IGFuZCBmaW5hbGx5IGZhbGwgYmFjayB0byBzZXRUaW1lb3V0XG5cblx0Lypqc2hpbnQgbWF4Y29tcGxleGl0eTo2Ki9cblx0LypnbG9iYWwgcHJvY2Vzcyxkb2N1bWVudCxzZXRUaW1lb3V0LE11dGF0aW9uT2JzZXJ2ZXIsV2ViS2l0TXV0YXRpb25PYnNlcnZlciovXG5cdHZhciBuZXh0VGljaywgTXV0YXRpb25PYnM7XG5cblx0aWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzICE9PSBudWxsICYmXG5cdFx0dHlwZW9mIHByb2Nlc3MubmV4dFRpY2sgPT09ICdmdW5jdGlvbicpIHtcblx0XHRuZXh0VGljayA9IGZ1bmN0aW9uKGYpIHtcblx0XHRcdHByb2Nlc3MubmV4dFRpY2soZik7XG5cdFx0fTtcblxuXHR9IGVsc2UgaWYgKE11dGF0aW9uT2JzID1cblx0XHQodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicgJiYgTXV0YXRpb25PYnNlcnZlcikgfHxcblx0XHQodHlwZW9mIFdlYktpdE11dGF0aW9uT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicgJiYgV2ViS2l0TXV0YXRpb25PYnNlcnZlcikpIHtcblx0XHRuZXh0VGljayA9IChmdW5jdGlvbiAoZG9jdW1lbnQsIE11dGF0aW9uT2JzZXJ2ZXIpIHtcblx0XHRcdHZhciBzY2hlZHVsZWQ7XG5cdFx0XHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRcdHZhciBvID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIocnVuKTtcblx0XHRcdG8ub2JzZXJ2ZShlbCwgeyBhdHRyaWJ1dGVzOiB0cnVlIH0pO1xuXG5cdFx0XHRmdW5jdGlvbiBydW4oKSB7XG5cdFx0XHRcdHZhciBmID0gc2NoZWR1bGVkO1xuXHRcdFx0XHRzY2hlZHVsZWQgPSB2b2lkIDA7XG5cdFx0XHRcdGYoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChmKSB7XG5cdFx0XHRcdHNjaGVkdWxlZCA9IGY7XG5cdFx0XHRcdGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAneCcpO1xuXHRcdFx0fTtcblx0XHR9KGRvY3VtZW50LCBNdXRhdGlvbk9icykpO1xuXG5cdH0gZWxzZSB7XG5cdFx0bmV4dFRpY2sgPSAoZnVuY3Rpb24oY2pzUmVxdWlyZSkge1xuXHRcdFx0dmFyIHZlcnR4O1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gdmVydC54IDEueCB8fCAyLnhcblx0XHRcdFx0dmVydHggPSBjanNSZXF1aXJlKCd2ZXJ0eCcpO1xuXHRcdFx0fSBjYXRjaCAoaWdub3JlKSB7fVxuXG5cdFx0XHRpZiAodmVydHgpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiB2ZXJ0eC5ydW5Pbkxvb3AgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRyZXR1cm4gdmVydHgucnVuT25Mb29wO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0eXBlb2YgdmVydHgucnVuT25Db250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZlcnR4LnJ1bk9uQ29udGV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjYXB0dXJlIHNldFRpbWVvdXQgdG8gYXZvaWQgYmVpbmcgY2F1Z2h0IGJ5IGZha2UgdGltZXJzXG5cdFx0XHQvLyB1c2VkIGluIHRpbWUgYmFzZWQgdGVzdHNcblx0XHRcdHZhciBjYXB0dXJlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICh0KSB7XG5cdFx0XHRcdGNhcHR1cmVkU2V0VGltZW91dCh0LCAwKTtcblx0XHRcdH07XG5cdFx0fShyZXF1aXJlKSk7XG5cdH1cblxuXHRyZXR1cm4gbmV4dFRpY2s7XG59KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24oZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH0pKTtcbiIsIi8qKiBAbGljZW5zZSBNSVQgTGljZW5zZSAoYykgY29weXJpZ2h0IDIwMTAtMjAxNCBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9ycyAqL1xuLyoqIEBhdXRob3IgQnJpYW4gQ2F2YWxpZXIgKi9cbi8qKiBAYXV0aG9yIEpvaG4gSGFubiAqL1xuXG4oZnVuY3Rpb24oZGVmaW5lKSB7ICd1c2Ugc3RyaWN0JztcbmRlZmluZShmdW5jdGlvbigpIHtcblxuXHRyZXR1cm4gZnVuY3Rpb24gbWFrZVByb21pc2UoZW52aXJvbm1lbnQpIHtcblxuXHRcdHZhciB0YXNrcyA9IGVudmlyb25tZW50LnNjaGVkdWxlcjtcblxuXHRcdHZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8XG5cdFx0XHRmdW5jdGlvbihwcm90bykge1xuXHRcdFx0XHRmdW5jdGlvbiBDaGlsZCgpIHt9XG5cdFx0XHRcdENoaWxkLnByb3RvdHlwZSA9IHByb3RvO1xuXHRcdFx0XHRyZXR1cm4gbmV3IENoaWxkKCk7XG5cdFx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIGEgcHJvbWlzZSB3aG9zZSBmYXRlIGlzIGRldGVybWluZWQgYnkgcmVzb2x2ZXJcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZVxuXHRcdCAqIEBuYW1lIFByb21pc2Vcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyLCBoYW5kbGVyKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVyID0gcmVzb2x2ZXIgPT09IEhhbmRsZXIgPyBoYW5kbGVyIDogaW5pdChyZXNvbHZlcik7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUnVuIHRoZSBzdXBwbGllZCByZXNvbHZlclxuXHRcdCAqIEBwYXJhbSByZXNvbHZlclxuXHRcdCAqIEByZXR1cm5zIHtQZW5kaW5nfVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGluaXQocmVzb2x2ZXIpIHtcblx0XHRcdHZhciBoYW5kbGVyID0gbmV3IFBlbmRpbmcoKTtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmVzb2x2ZXIocHJvbWlzZVJlc29sdmUsIHByb21pc2VSZWplY3QsIHByb21pc2VOb3RpZnkpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRwcm9taXNlUmVqZWN0KGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaGFuZGxlcjtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUcmFuc2l0aW9uIGZyb20gcHJlLXJlc29sdXRpb24gc3RhdGUgdG8gcG9zdC1yZXNvbHV0aW9uIHN0YXRlLCBub3RpZnlpbmdcblx0XHRcdCAqIGFsbCBsaXN0ZW5lcnMgb2YgdGhlIHVsdGltYXRlIGZ1bGZpbGxtZW50IG9yIHJlamVjdGlvblxuXHRcdFx0ICogQHBhcmFtIHsqfSB4IHJlc29sdXRpb24gdmFsdWVcblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gcHJvbWlzZVJlc29sdmUgKHgpIHtcblx0XHRcdFx0aGFuZGxlci5yZXNvbHZlKHgpO1xuXHRcdFx0fVxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZWplY3QgdGhpcyBwcm9taXNlIHdpdGggcmVhc29uLCB3aGljaCB3aWxsIGJlIHVzZWQgdmVyYmF0aW1cblx0XHRcdCAqIEBwYXJhbSB7RXJyb3J8Kn0gcmVhc29uIHJlamVjdGlvbiByZWFzb24sIHN0cm9uZ2x5IHN1Z2dlc3RlZFxuXHRcdFx0ICogICB0byBiZSBhbiBFcnJvciB0eXBlXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIHByb21pc2VSZWplY3QgKHJlYXNvbikge1xuXHRcdFx0XHRoYW5kbGVyLnJlamVjdChyZWFzb24pO1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIElzc3VlIGEgcHJvZ3Jlc3MgZXZlbnQsIG5vdGlmeWluZyBhbGwgcHJvZ3Jlc3MgbGlzdGVuZXJzXG5cdFx0XHQgKiBAcGFyYW0geyp9IHggcHJvZ3Jlc3MgZXZlbnQgcGF5bG9hZCB0byBwYXNzIHRvIGFsbCBsaXN0ZW5lcnNcblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gcHJvbWlzZU5vdGlmeSAoeCkge1xuXHRcdFx0XHRoYW5kbGVyLm5vdGlmeSh4KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDcmVhdGlvblxuXG5cdFx0UHJvbWlzZS5yZXNvbHZlID0gcmVzb2x2ZTtcblx0XHRQcm9taXNlLnJlamVjdCA9IHJlamVjdDtcblx0XHRQcm9taXNlLm5ldmVyID0gbmV2ZXI7XG5cblx0XHRQcm9taXNlLl9kZWZlciA9IGRlZmVyO1xuXHRcdFByb21pc2UuX2hhbmRsZXIgPSBnZXRIYW5kbGVyO1xuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhIHRydXN0ZWQgcHJvbWlzZS4gSWYgeCBpcyBhbHJlYWR5IGEgdHJ1c3RlZCBwcm9taXNlLCBpdCBpc1xuXHRcdCAqIHJldHVybmVkLCBvdGhlcndpc2UgcmV0dXJucyBhIG5ldyB0cnVzdGVkIFByb21pc2Ugd2hpY2ggZm9sbG93cyB4LlxuXHRcdCAqIEBwYXJhbSAgeyp9IHhcblx0XHQgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG5cdFx0XHRyZXR1cm4gaXNQcm9taXNlKHgpID8geFxuXHRcdFx0XHQ6IG5ldyBQcm9taXNlKEhhbmRsZXIsIG5ldyBBc3luYyhnZXRIYW5kbGVyKHgpKSk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIGEgcmVqZWN0IHByb21pc2Ugd2l0aCB4IGFzIGl0cyByZWFzb24gKHggaXMgdXNlZCB2ZXJiYXRpbSlcblx0XHQgKiBAcGFyYW0geyp9IHhcblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gcmVqZWN0ZWQgcHJvbWlzZVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHJlamVjdCh4KSB7XG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoSGFuZGxlciwgbmV3IEFzeW5jKG5ldyBSZWplY3RlZCh4KSkpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiBhIHByb21pc2UgdGhhdCByZW1haW5zIHBlbmRpbmcgZm9yZXZlclxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBmb3JldmVyLXBlbmRpbmcgcHJvbWlzZS5cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBuZXZlcigpIHtcblx0XHRcdHJldHVybiBmb3JldmVyUGVuZGluZ1Byb21pc2U7IC8vIFNob3VsZCBiZSBmcm96ZW5cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGVzIGFuIGludGVybmFsIHtwcm9taXNlLCByZXNvbHZlcn0gcGFpclxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gZGVmZXIoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoSGFuZGxlciwgbmV3IFBlbmRpbmcoKSk7XG5cdFx0fVxuXG5cdFx0Ly8gVHJhbnNmb3JtYXRpb24gYW5kIGZsb3cgY29udHJvbFxuXG5cdFx0LyoqXG5cdFx0ICogVHJhbnNmb3JtIHRoaXMgcHJvbWlzZSdzIGZ1bGZpbGxtZW50IHZhbHVlLCByZXR1cm5pbmcgYSBuZXcgUHJvbWlzZVxuXHRcdCAqIGZvciB0aGUgdHJhbnNmb3JtZWQgcmVzdWx0LiAgSWYgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZCwgb25SZWplY3RlZFxuXHRcdCAqIGlzIGNhbGxlZCB3aXRoIHRoZSByZWFzb24uICBvblByb2dyZXNzICptYXkqIGJlIGNhbGxlZCB3aXRoIHVwZGF0ZXMgdG93YXJkXG5cdFx0ICogdGhpcyBwcm9taXNlJ3MgZnVsZmlsbG1lbnQuXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbj19IG9uRnVsZmlsbGVkIGZ1bGZpbGxtZW50IGhhbmRsZXJcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gb25SZWplY3RlZCByZWplY3Rpb24gaGFuZGxlclxuXHRcdCAqIEBkZXByZWNhdGVkIEBwYXJhbSB7ZnVuY3Rpb249fSBvblByb2dyZXNzIHByb2dyZXNzIGhhbmRsZXJcblx0XHQgKiBAcmV0dXJuIHtQcm9taXNlfSBuZXcgcHJvbWlzZVxuXHRcdCAqL1xuXHRcdFByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMuX2hhbmRsZXI7XG5cdFx0XHR2YXIgc3RhdGUgPSBwYXJlbnQuam9pbigpLnN0YXRlKCk7XG5cblx0XHRcdGlmICgodHlwZW9mIG9uRnVsZmlsbGVkICE9PSAnZnVuY3Rpb24nICYmIHN0YXRlID4gMCkgfHxcblx0XHRcdFx0KHR5cGVvZiBvblJlamVjdGVkICE9PSAnZnVuY3Rpb24nICYmIHN0YXRlIDwgMCkpIHtcblx0XHRcdFx0Ly8gU2hvcnQgY2lyY3VpdDogdmFsdWUgd2lsbCBub3QgY2hhbmdlLCBzaW1wbHkgc2hhcmUgaGFuZGxlclxuXHRcdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoSGFuZGxlciwgcGFyZW50KTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHAgPSB0aGlzLl9iZWdldCgpO1xuXHRcdFx0dmFyIGNoaWxkID0gcC5faGFuZGxlcjtcblxuXHRcdFx0cGFyZW50LmNoYWluKGNoaWxkLCBwYXJlbnQucmVjZWl2ZXIsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLFxuXHRcdFx0XHRcdGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdm9pZCAwKTtcblxuXHRcdFx0cmV0dXJuIHA7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIElmIHRoaXMgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkIGR1ZSB0byBhbiBlcnJvciwgY2FsbCBvblJlamVjdGVkIHRvXG5cdFx0ICogaGFuZGxlIHRoZSBlcnJvci4gU2hvcnRjdXQgZm9yIC50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZClcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uP30gb25SZWplY3RlZFxuXHRcdCAqIEByZXR1cm4ge1Byb21pc2V9XG5cdFx0ICovXG5cdFx0UHJvbWlzZS5wcm90b3R5cGVbJ2NhdGNoJ10gPSBmdW5jdGlvbihvblJlamVjdGVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50aGVuKHZvaWQgMCwgb25SZWplY3RlZCk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgYSBuZXcsIHBlbmRpbmcgcHJvbWlzZSBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoaXMgcHJvbWlzZVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdFx0ICovXG5cdFx0UHJvbWlzZS5wcm90b3R5cGUuX2JlZ2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5faGFuZGxlcjtcblx0XHRcdHZhciBjaGlsZCA9IG5ldyBQZW5kaW5nKHBhcmVudC5yZWNlaXZlciwgcGFyZW50LmpvaW4oKS5jb250ZXh0KTtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihIYW5kbGVyLCBjaGlsZCk7XG5cdFx0fTtcblxuXHRcdC8vIEFycmF5IGNvbWJpbmF0b3JzXG5cblx0XHRQcm9taXNlLmFsbCA9IGFsbDtcblx0XHRQcm9taXNlLnJhY2UgPSByYWNlO1xuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIGEgcHJvbWlzZSB0aGF0IHdpbGwgZnVsZmlsbCB3aGVuIGFsbCBwcm9taXNlcyBpbiB0aGVcblx0XHQgKiBpbnB1dCBhcnJheSBoYXZlIGZ1bGZpbGxlZCwgb3Igd2lsbCByZWplY3Qgd2hlbiBvbmUgb2YgdGhlXG5cdFx0ICogcHJvbWlzZXMgcmVqZWN0cy5cblx0XHQgKiBAcGFyYW0ge2FycmF5fSBwcm9taXNlcyBhcnJheSBvZiBwcm9taXNlc1xuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIGZvciBhcnJheSBvZiBmdWxmaWxsbWVudCB2YWx1ZXNcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcblx0XHRcdC8qanNoaW50IG1heGNvbXBsZXhpdHk6OCovXG5cdFx0XHR2YXIgcmVzb2x2ZXIgPSBuZXcgUGVuZGluZygpO1xuXHRcdFx0dmFyIHBlbmRpbmcgPSBwcm9taXNlcy5sZW5ndGggPj4+IDA7XG5cdFx0XHR2YXIgcmVzdWx0cyA9IG5ldyBBcnJheShwZW5kaW5nKTtcblxuXHRcdFx0dmFyIGksIGgsIHgsIHM7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcHJvbWlzZXMubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0eCA9IHByb21pc2VzW2ldO1xuXG5cdFx0XHRcdGlmICh4ID09PSB2b2lkIDAgJiYgIShpIGluIHByb21pc2VzKSkge1xuXHRcdFx0XHRcdC0tcGVuZGluZztcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChtYXliZVRoZW5hYmxlKHgpKSB7XG5cdFx0XHRcdFx0aCA9IGdldEhhbmRsZXJNYXliZVRoZW5hYmxlKHgpO1xuXG5cdFx0XHRcdFx0cyA9IGguc3RhdGUoKTtcblx0XHRcdFx0XHRpZiAocyA9PT0gMCkge1xuXHRcdFx0XHRcdFx0aC5mb2xkKHNldHRsZUF0LCBpLCByZXN1bHRzLCByZXNvbHZlcik7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChzID4gMCkge1xuXHRcdFx0XHRcdFx0cmVzdWx0c1tpXSA9IGgudmFsdWU7XG5cdFx0XHRcdFx0XHQtLXBlbmRpbmc7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHVucmVwb3J0UmVtYWluaW5nKHByb21pc2VzLCBpKzEsIGgpO1xuXHRcdFx0XHRcdFx0cmVzb2x2ZXIuYmVjb21lKGgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzdWx0c1tpXSA9IHg7XG5cdFx0XHRcdFx0LS1wZW5kaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmKHBlbmRpbmcgPT09IDApIHtcblx0XHRcdFx0cmVzb2x2ZXIuYmVjb21lKG5ldyBGdWxmaWxsZWQocmVzdWx0cykpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoSGFuZGxlciwgcmVzb2x2ZXIpO1xuXG5cdFx0XHRmdW5jdGlvbiBzZXR0bGVBdChpLCB4LCByZXNvbHZlcikge1xuXHRcdFx0XHQvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSovXG5cdFx0XHRcdHRoaXNbaV0gPSB4O1xuXHRcdFx0XHRpZigtLXBlbmRpbmcgPT09IDApIHtcblx0XHRcdFx0XHRyZXNvbHZlci5iZWNvbWUobmV3IEZ1bGZpbGxlZCh0aGlzKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1bnJlcG9ydFJlbWFpbmluZyhwcm9taXNlcywgc3RhcnQsIHJlamVjdGVkSGFuZGxlcikge1xuXHRcdFx0dmFyIGksIGgsIHg7XG5cdFx0XHRmb3IoaT1zdGFydDsgaTxwcm9taXNlcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR4ID0gcHJvbWlzZXNbaV07XG5cdFx0XHRcdGlmKG1heWJlVGhlbmFibGUoeCkpIHtcblx0XHRcdFx0XHRoID0gZ2V0SGFuZGxlck1heWJlVGhlbmFibGUoeCk7XG5cblx0XHRcdFx0XHRpZihoICE9PSByZWplY3RlZEhhbmRsZXIpIHtcblx0XHRcdFx0XHRcdGgudmlzaXQoaCwgdm9pZCAwLCBoLl91bnJlcG9ydCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogRnVsZmlsbC1yZWplY3QgY29tcGV0aXRpdmUgcmFjZS4gUmV0dXJuIGEgcHJvbWlzZSB0aGF0IHdpbGwgc2V0dGxlXG5cdFx0ICogdG8gdGhlIHNhbWUgc3RhdGUgYXMgdGhlIGVhcmxpZXN0IGlucHV0IHByb21pc2UgdG8gc2V0dGxlLlxuXHRcdCAqXG5cdFx0ICogV0FSTklORzogVGhlIEVTNiBQcm9taXNlIHNwZWMgcmVxdWlyZXMgdGhhdCByYWNlKClpbmcgYW4gZW1wdHkgYXJyYXlcblx0XHQgKiBtdXN0IHJldHVybiBhIHByb21pc2UgdGhhdCBpcyBwZW5kaW5nIGZvcmV2ZXIuICBUaGlzIGltcGxlbWVudGF0aW9uXG5cdFx0ICogcmV0dXJucyBhIHNpbmdsZXRvbiBmb3JldmVyLXBlbmRpbmcgcHJvbWlzZSwgdGhlIHNhbWUgc2luZ2xldG9uIHRoYXQgaXNcblx0XHQgKiByZXR1cm5lZCBieSBQcm9taXNlLm5ldmVyKCksIHRodXMgY2FuIGJlIGNoZWNrZWQgd2l0aCA9PT1cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7YXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzIHRvIHJhY2Vcblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gaWYgaW5wdXQgaXMgbm9uLWVtcHR5LCBhIHByb21pc2UgdGhhdCB3aWxsIHNldHRsZVxuXHRcdCAqIHRvIHRoZSBzYW1lIG91dGNvbWUgYXMgdGhlIGVhcmxpZXN0IGlucHV0IHByb21pc2UgdG8gc2V0dGxlLiBpZiBlbXB0eVxuXHRcdCAqIGlzIGVtcHR5LCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgbmV2ZXIgc2V0dGxlLlxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHJhY2UocHJvbWlzZXMpIHtcblx0XHRcdC8vIFNpZ2gsIHJhY2UoW10pIGlzIHVudGVzdGFibGUgdW5sZXNzIHdlIHJldHVybiAqc29tZXRoaW5nKlxuXHRcdFx0Ly8gdGhhdCBpcyByZWNvZ25pemFibGUgd2l0aG91dCBjYWxsaW5nIC50aGVuKCkgb24gaXQuXG5cdFx0XHRpZihPYmplY3QocHJvbWlzZXMpID09PSBwcm9taXNlcyAmJiBwcm9taXNlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIG5ldmVyKCk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBoID0gbmV3IFBlbmRpbmcoKTtcblx0XHRcdHZhciBpLCB4O1xuXHRcdFx0Zm9yKGk9MDsgaTxwcm9taXNlcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR4ID0gcHJvbWlzZXNbaV07XG5cdFx0XHRcdGlmICh4ICE9PSB2b2lkIDAgJiYgaSBpbiBwcm9taXNlcykge1xuXHRcdFx0XHRcdGdldEhhbmRsZXIoeCkudmlzaXQoaCwgaC5yZXNvbHZlLCBoLnJlamVjdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShIYW5kbGVyLCBoKTtcblx0XHR9XG5cblx0XHQvLyBQcm9taXNlIGludGVybmFsc1xuXHRcdC8vIEJlbG93IHRoaXMsIGV2ZXJ5dGhpbmcgaXMgQHByaXZhdGVcblxuXHRcdC8qKlxuXHRcdCAqIEdldCBhbiBhcHByb3ByaWF0ZSBoYW5kbGVyIGZvciB4LCB3aXRob3V0IGNoZWNraW5nIGZvciBjeWNsZXNcblx0XHQgKiBAcGFyYW0geyp9IHhcblx0XHQgKiBAcmV0dXJucyB7b2JqZWN0fSBoYW5kbGVyXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gZ2V0SGFuZGxlcih4KSB7XG5cdFx0XHRpZihpc1Byb21pc2UoeCkpIHtcblx0XHRcdFx0cmV0dXJuIHguX2hhbmRsZXIuam9pbigpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1heWJlVGhlbmFibGUoeCkgPyBnZXRIYW5kbGVyVW50cnVzdGVkKHgpIDogbmV3IEZ1bGZpbGxlZCh4KTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBHZXQgYSBoYW5kbGVyIGZvciB0aGVuYWJsZSB4LlxuXHRcdCAqIE5PVEU6IFlvdSBtdXN0IG9ubHkgY2FsbCB0aGlzIGlmIG1heWJlVGhlbmFibGUoeCkgPT0gdHJ1ZVxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufFByb21pc2V9IHhcblx0XHQgKiBAcmV0dXJucyB7b2JqZWN0fSBoYW5kbGVyXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gZ2V0SGFuZGxlck1heWJlVGhlbmFibGUoeCkge1xuXHRcdFx0cmV0dXJuIGlzUHJvbWlzZSh4KSA/IHguX2hhbmRsZXIuam9pbigpIDogZ2V0SGFuZGxlclVudHJ1c3RlZCh4KTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBHZXQgYSBoYW5kbGVyIGZvciBwb3RlbnRpYWxseSB1bnRydXN0ZWQgdGhlbmFibGUgeFxuXHRcdCAqIEBwYXJhbSB7Kn0geFxuXHRcdCAqIEByZXR1cm5zIHtvYmplY3R9IGhhbmRsZXJcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBnZXRIYW5kbGVyVW50cnVzdGVkKHgpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciB1bnRydXN0ZWRUaGVuID0geC50aGVuO1xuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIHVudHJ1c3RlZFRoZW4gPT09ICdmdW5jdGlvbidcblx0XHRcdFx0XHQ/IG5ldyBUaGVuYWJsZSh1bnRydXN0ZWRUaGVuLCB4KVxuXHRcdFx0XHRcdDogbmV3IEZ1bGZpbGxlZCh4KTtcblx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IFJlamVjdGVkKGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXIgZm9yIGEgcHJvbWlzZSB0aGF0IGlzIHBlbmRpbmcgZm9yZXZlclxuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIEhhbmRsZXIoKSB7fVxuXG5cdFx0SGFuZGxlci5wcm90b3R5cGUud2hlblxuXHRcdFx0PSBIYW5kbGVyLnByb3RvdHlwZS5iZWNvbWVcblx0XHRcdD0gSGFuZGxlci5wcm90b3R5cGUubm90aWZ5XG5cdFx0XHQ9IEhhbmRsZXIucHJvdG90eXBlLmZhaWxcblx0XHRcdD0gSGFuZGxlci5wcm90b3R5cGUuX3VucmVwb3J0XG5cdFx0XHQ9IEhhbmRsZXIucHJvdG90eXBlLl9yZXBvcnRcblx0XHRcdD0gbm9vcDtcblxuXHRcdEhhbmRsZXIucHJvdG90eXBlLl9zdGF0ZSA9IDA7XG5cblx0XHRIYW5kbGVyLnByb3RvdHlwZS5zdGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3N0YXRlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSZWN1cnNpdmVseSBjb2xsYXBzZSBoYW5kbGVyIGNoYWluIHRvIGZpbmQgdGhlIGhhbmRsZXJcblx0XHQgKiBuZWFyZXN0IHRvIHRoZSBmdWxseSByZXNvbHZlZCB2YWx1ZS5cblx0XHQgKiBAcmV0dXJucyB7b2JqZWN0fSBoYW5kbGVyIG5lYXJlc3QgdGhlIGZ1bGx5IHJlc29sdmVkIHZhbHVlXG5cdFx0ICovXG5cdFx0SGFuZGxlci5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGggPSB0aGlzO1xuXHRcdFx0d2hpbGUoaC5oYW5kbGVyICE9PSB2b2lkIDApIHtcblx0XHRcdFx0aCA9IGguaGFuZGxlcjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBoO1xuXHRcdH07XG5cblx0XHRIYW5kbGVyLnByb3RvdHlwZS5jaGFpbiA9IGZ1bmN0aW9uKHRvLCByZWNlaXZlciwgZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIHtcblx0XHRcdHRoaXMud2hlbih7XG5cdFx0XHRcdHJlc29sdmVyOiB0byxcblx0XHRcdFx0cmVjZWl2ZXI6IHJlY2VpdmVyLFxuXHRcdFx0XHRmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcblx0XHRcdFx0cmVqZWN0ZWQ6IHJlamVjdGVkLFxuXHRcdFx0XHRwcm9ncmVzczogcHJvZ3Jlc3Ncblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHRIYW5kbGVyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uKHJlY2VpdmVyLCBmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcykge1xuXHRcdFx0dGhpcy5jaGFpbihmYWlsSWZSZWplY3RlZCwgcmVjZWl2ZXIsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKTtcblx0XHR9O1xuXG5cdFx0SGFuZGxlci5wcm90b3R5cGUuZm9sZCA9IGZ1bmN0aW9uKGYsIHosIGMsIHRvKSB7XG5cdFx0XHR0aGlzLnZpc2l0KHRvLCBmdW5jdGlvbih4KSB7XG5cdFx0XHRcdGYuY2FsbChjLCB6LCB4LCB0aGlzKTtcblx0XHRcdH0sIHRvLnJlamVjdCwgdG8ubm90aWZ5KTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlciB0aGF0IGludm9rZXMgZmFpbCgpIG9uIGFueSBoYW5kbGVyIGl0IGJlY29tZXNcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBGYWlsSWZSZWplY3RlZCgpIHt9XG5cblx0XHRpbmhlcml0KEhhbmRsZXIsIEZhaWxJZlJlamVjdGVkKTtcblxuXHRcdEZhaWxJZlJlamVjdGVkLnByb3RvdHlwZS5iZWNvbWUgPSBmdW5jdGlvbihoKSB7XG5cdFx0XHRoLmZhaWwoKTtcblx0XHR9O1xuXG5cdFx0dmFyIGZhaWxJZlJlamVjdGVkID0gbmV3IEZhaWxJZlJlamVjdGVkKCk7XG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGVyIHRoYXQgbWFuYWdlcyBhIHF1ZXVlIG9mIGNvbnN1bWVycyB3YWl0aW5nIG9uIGEgcGVuZGluZyBwcm9taXNlXG5cdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gUGVuZGluZyhyZWNlaXZlciwgaW5oZXJpdGVkQ29udGV4dCkge1xuXHRcdFx0UHJvbWlzZS5jcmVhdGVDb250ZXh0KHRoaXMsIGluaGVyaXRlZENvbnRleHQpO1xuXG5cdFx0XHR0aGlzLmNvbnN1bWVycyA9IHZvaWQgMDtcblx0XHRcdHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcblx0XHRcdHRoaXMuaGFuZGxlciA9IHZvaWQgMDtcblx0XHRcdHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRpbmhlcml0KEhhbmRsZXIsIFBlbmRpbmcpO1xuXG5cdFx0UGVuZGluZy5wcm90b3R5cGUuX3N0YXRlID0gMDtcblxuXHRcdFBlbmRpbmcucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbih4KSB7XG5cdFx0XHR0aGlzLmJlY29tZShnZXRIYW5kbGVyKHgpKTtcblx0XHR9O1xuXG5cdFx0UGVuZGluZy5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0aWYodGhpcy5yZXNvbHZlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuYmVjb21lKG5ldyBSZWplY3RlZCh4KSk7XG5cdFx0fTtcblxuXHRcdFBlbmRpbmcucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICghdGhpcy5yZXNvbHZlZCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblxuXHRcdFx0dmFyIGggPSB0aGlzO1xuXG5cdFx0XHR3aGlsZSAoaC5oYW5kbGVyICE9PSB2b2lkIDApIHtcblx0XHRcdFx0aCA9IGguaGFuZGxlcjtcblx0XHRcdFx0aWYgKGggPT09IHRoaXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5oYW5kbGVyID0gY3ljbGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaDtcblx0XHR9O1xuXG5cdFx0UGVuZGluZy5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcSA9IHRoaXMuY29uc3VtZXJzO1xuXHRcdFx0dmFyIGhhbmRsZXIgPSB0aGlzLmpvaW4oKTtcblx0XHRcdHRoaXMuY29uc3VtZXJzID0gdm9pZCAwO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHEubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0aGFuZGxlci53aGVuKHFbaV0pO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRQZW5kaW5nLnByb3RvdHlwZS5iZWNvbWUgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG5cdFx0XHRpZih0aGlzLnJlc29sdmVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5yZXNvbHZlZCA9IHRydWU7XG5cdFx0XHR0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuXHRcdFx0aWYodGhpcy5jb25zdW1lcnMgIT09IHZvaWQgMCkge1xuXHRcdFx0XHR0YXNrcy5lbnF1ZXVlKHRoaXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZih0aGlzLmNvbnRleHQgIT09IHZvaWQgMCkge1xuXHRcdFx0XHRoYW5kbGVyLl9yZXBvcnQodGhpcy5jb250ZXh0KTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0UGVuZGluZy5wcm90b3R5cGUud2hlbiA9IGZ1bmN0aW9uKGNvbnRpbnVhdGlvbikge1xuXHRcdFx0aWYodGhpcy5yZXNvbHZlZCkge1xuXHRcdFx0XHR0YXNrcy5lbnF1ZXVlKG5ldyBDb250aW51YXRpb25UYXNrKGNvbnRpbnVhdGlvbiwgdGhpcy5oYW5kbGVyKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZih0aGlzLmNvbnN1bWVycyA9PT0gdm9pZCAwKSB7XG5cdFx0XHRcdFx0dGhpcy5jb25zdW1lcnMgPSBbY29udGludWF0aW9uXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLmNvbnN1bWVycy5wdXNoKGNvbnRpbnVhdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0UGVuZGluZy5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0aWYoIXRoaXMucmVzb2x2ZWQpIHtcblx0XHRcdFx0dGFza3MuZW5xdWV1ZShuZXcgUHJvZ3Jlc3NUYXNrKHgsIHRoaXMpKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0UGVuZGluZy5wcm90b3R5cGUuZmFpbCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0XHRcdHZhciBjID0gdHlwZW9mIGNvbnRleHQgPT09ICd1bmRlZmluZWQnID8gdGhpcy5jb250ZXh0IDogY29udGV4dDtcblx0XHRcdHRoaXMucmVzb2x2ZWQgJiYgdGhpcy5oYW5kbGVyLmpvaW4oKS5mYWlsKGMpO1xuXHRcdH07XG5cblx0XHRQZW5kaW5nLnByb3RvdHlwZS5fcmVwb3J0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdFx0dGhpcy5yZXNvbHZlZCAmJiB0aGlzLmhhbmRsZXIuam9pbigpLl9yZXBvcnQoY29udGV4dCk7XG5cdFx0fTtcblxuXHRcdFBlbmRpbmcucHJvdG90eXBlLl91bnJlcG9ydCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5yZXNvbHZlZCAmJiB0aGlzLmhhbmRsZXIuam9pbigpLl91bnJlcG9ydCgpO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBXcmFwIGFub3RoZXIgaGFuZGxlciBhbmQgZm9yY2UgaXQgaW50byBhIGZ1dHVyZSBzdGFja1xuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBoYW5kbGVyXG5cdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gQXN5bmMoaGFuZGxlcikge1xuXHRcdFx0dGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcblx0XHR9XG5cblx0XHRpbmhlcml0KEhhbmRsZXIsIEFzeW5jKTtcblxuXHRcdEFzeW5jLnByb3RvdHlwZS53aGVuID0gZnVuY3Rpb24oY29udGludWF0aW9uKSB7XG5cdFx0XHR0YXNrcy5lbnF1ZXVlKG5ldyBDb250aW51YXRpb25UYXNrKGNvbnRpbnVhdGlvbiwgdGhpcykpO1xuXHRcdH07XG5cblx0XHRBc3luYy5wcm90b3R5cGUuX3JlcG9ydCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0XHRcdHRoaXMuam9pbigpLl9yZXBvcnQoY29udGV4dCk7XG5cdFx0fTtcblxuXHRcdEFzeW5jLnByb3RvdHlwZS5fdW5yZXBvcnQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuam9pbigpLl91bnJlcG9ydCgpO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGVyIHRoYXQgd3JhcHMgYW4gdW50cnVzdGVkIHRoZW5hYmxlIGFuZCBhc3NpbWlsYXRlcyBpdCBpbiBhIGZ1dHVyZSBzdGFja1xuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IHRoZW5cblx0XHQgKiBAcGFyYW0ge3t0aGVuOiBmdW5jdGlvbn19IHRoZW5hYmxlXG5cdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gVGhlbmFibGUodGhlbiwgdGhlbmFibGUpIHtcblx0XHRcdFBlbmRpbmcuY2FsbCh0aGlzKTtcblx0XHRcdHRhc2tzLmVucXVldWUobmV3IEFzc2ltaWxhdGVUYXNrKHRoZW4sIHRoZW5hYmxlLCB0aGlzKSk7XG5cdFx0fVxuXG5cdFx0aW5oZXJpdChQZW5kaW5nLCBUaGVuYWJsZSk7XG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGVyIGZvciBhIGZ1bGZpbGxlZCBwcm9taXNlXG5cdFx0ICogQHBhcmFtIHsqfSB4IGZ1bGZpbGxtZW50IHZhbHVlXG5cdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gRnVsZmlsbGVkKHgpIHtcblx0XHRcdFByb21pc2UuY3JlYXRlQ29udGV4dCh0aGlzKTtcblx0XHRcdHRoaXMudmFsdWUgPSB4O1xuXHRcdH1cblxuXHRcdGluaGVyaXQoSGFuZGxlciwgRnVsZmlsbGVkKTtcblxuXHRcdEZ1bGZpbGxlZC5wcm90b3R5cGUuX3N0YXRlID0gMTtcblxuXHRcdEZ1bGZpbGxlZC5wcm90b3R5cGUuZm9sZCA9IGZ1bmN0aW9uKGYsIHosIGMsIHRvKSB7XG5cdFx0XHRydW5Db250aW51YXRpb24zKGYsIHosIHRoaXMsIGMsIHRvKTtcblx0XHR9O1xuXG5cdFx0RnVsZmlsbGVkLnByb3RvdHlwZS53aGVuID0gZnVuY3Rpb24oY29udCkge1xuXHRcdFx0cnVuQ29udGludWF0aW9uMShjb250LmZ1bGZpbGxlZCwgdGhpcywgY29udC5yZWNlaXZlciwgY29udC5yZXNvbHZlcik7XG5cdFx0fTtcblxuXHRcdHZhciBlcnJvcklkID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXIgZm9yIGEgcmVqZWN0ZWQgcHJvbWlzZVxuXHRcdCAqIEBwYXJhbSB7Kn0geCByZWplY3Rpb24gcmVhc29uXG5cdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gUmVqZWN0ZWQoeCkge1xuXHRcdFx0UHJvbWlzZS5jcmVhdGVDb250ZXh0KHRoaXMpO1xuXG5cdFx0XHR0aGlzLmlkID0gKytlcnJvcklkO1xuXHRcdFx0dGhpcy52YWx1ZSA9IHg7XG5cdFx0XHR0aGlzLmhhbmRsZWQgPSBmYWxzZTtcblx0XHRcdHRoaXMucmVwb3J0ZWQgPSBmYWxzZTtcblxuXHRcdFx0dGhpcy5fcmVwb3J0KCk7XG5cdFx0fVxuXG5cdFx0aW5oZXJpdChIYW5kbGVyLCBSZWplY3RlZCk7XG5cblx0XHRSZWplY3RlZC5wcm90b3R5cGUuX3N0YXRlID0gLTE7XG5cblx0XHRSZWplY3RlZC5wcm90b3R5cGUuZm9sZCA9IGZ1bmN0aW9uKGYsIHosIGMsIHRvKSB7XG5cdFx0XHR0by5iZWNvbWUodGhpcyk7XG5cdFx0fTtcblxuXHRcdFJlamVjdGVkLnByb3RvdHlwZS53aGVuID0gZnVuY3Rpb24oY29udCkge1xuXHRcdFx0aWYodHlwZW9mIGNvbnQucmVqZWN0ZWQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0dGhpcy5fdW5yZXBvcnQoKTtcblx0XHRcdH1cblx0XHRcdHJ1bkNvbnRpbnVhdGlvbjEoY29udC5yZWplY3RlZCwgdGhpcywgY29udC5yZWNlaXZlciwgY29udC5yZXNvbHZlcik7XG5cdFx0fTtcblxuXHRcdFJlamVjdGVkLnByb3RvdHlwZS5fcmVwb3J0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdFx0dGFza3MuYWZ0ZXJRdWV1ZShuZXcgUmVwb3J0VGFzayh0aGlzLCBjb250ZXh0KSk7XG5cdFx0fTtcblxuXHRcdFJlamVjdGVkLnByb3RvdHlwZS5fdW5yZXBvcnQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuaGFuZGxlZCA9IHRydWU7XG5cdFx0XHR0YXNrcy5hZnRlclF1ZXVlKG5ldyBVbnJlcG9ydFRhc2sodGhpcykpO1xuXHRcdH07XG5cblx0XHRSZWplY3RlZC5wcm90b3R5cGUuZmFpbCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0XHRcdFByb21pc2Uub25GYXRhbFJlamVjdGlvbih0aGlzLCBjb250ZXh0ID09PSB2b2lkIDAgPyB0aGlzLmNvbnRleHQgOiBjb250ZXh0KTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gUmVwb3J0VGFzayhyZWplY3Rpb24sIGNvbnRleHQpIHtcblx0XHRcdHRoaXMucmVqZWN0aW9uID0gcmVqZWN0aW9uO1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gY29udGV4dDtcblx0XHR9XG5cblx0XHRSZXBvcnRUYXNrLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmKCF0aGlzLnJlamVjdGlvbi5oYW5kbGVkKSB7XG5cdFx0XHRcdHRoaXMucmVqZWN0aW9uLnJlcG9ydGVkID0gdHJ1ZTtcblx0XHRcdFx0UHJvbWlzZS5vblBvdGVudGlhbGx5VW5oYW5kbGVkUmVqZWN0aW9uKHRoaXMucmVqZWN0aW9uLCB0aGlzLmNvbnRleHQpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBVbnJlcG9ydFRhc2socmVqZWN0aW9uKSB7XG5cdFx0XHR0aGlzLnJlamVjdGlvbiA9IHJlamVjdGlvbjtcblx0XHR9XG5cblx0XHRVbnJlcG9ydFRhc2sucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYodGhpcy5yZWplY3Rpb24ucmVwb3J0ZWQpIHtcblx0XHRcdFx0UHJvbWlzZS5vblBvdGVudGlhbGx5VW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlZCh0aGlzLnJlamVjdGlvbik7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIFVuaGFuZGxlZCByZWplY3Rpb24gaG9va3Ncblx0XHQvLyBCeSBkZWZhdWx0LCBldmVyeXRoaW5nIGlzIGEgbm9vcFxuXG5cdFx0Ly8gVE9ETzogQmV0dGVyIG5hbWVzOiBcImFubm90YXRlXCI/XG5cdFx0UHJvbWlzZS5jcmVhdGVDb250ZXh0XG5cdFx0XHQ9IFByb21pc2UuZW50ZXJDb250ZXh0XG5cdFx0XHQ9IFByb21pc2UuZXhpdENvbnRleHRcblx0XHRcdD0gUHJvbWlzZS5vblBvdGVudGlhbGx5VW5oYW5kbGVkUmVqZWN0aW9uXG5cdFx0XHQ9IFByb21pc2Uub25Qb3RlbnRpYWxseVVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWRcblx0XHRcdD0gUHJvbWlzZS5vbkZhdGFsUmVqZWN0aW9uXG5cdFx0XHQ9IG5vb3A7XG5cblx0XHQvLyBFcnJvcnMgYW5kIHNpbmdsZXRvbnNcblxuXHRcdHZhciBmb3JldmVyUGVuZGluZ0hhbmRsZXIgPSBuZXcgSGFuZGxlcigpO1xuXHRcdHZhciBmb3JldmVyUGVuZGluZ1Byb21pc2UgPSBuZXcgUHJvbWlzZShIYW5kbGVyLCBmb3JldmVyUGVuZGluZ0hhbmRsZXIpO1xuXG5cdFx0ZnVuY3Rpb24gY3ljbGUoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFJlamVjdGVkKG5ldyBUeXBlRXJyb3IoJ1Byb21pc2UgY3ljbGUnKSk7XG5cdFx0fVxuXG5cdFx0Ly8gVGFzayBydW5uZXJzXG5cblx0XHQvKipcblx0XHQgKiBSdW4gYSBzaW5nbGUgY29uc3VtZXJcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBDb250aW51YXRpb25UYXNrKGNvbnRpbnVhdGlvbiwgaGFuZGxlcikge1xuXHRcdFx0dGhpcy5jb250aW51YXRpb24gPSBjb250aW51YXRpb247XG5cdFx0XHR0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuXHRcdH1cblxuXHRcdENvbnRpbnVhdGlvblRhc2sucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5oYW5kbGVyLmpvaW4oKS53aGVuKHRoaXMuY29udGludWF0aW9uKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUnVuIGEgcXVldWUgb2YgcHJvZ3Jlc3MgaGFuZGxlcnNcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBQcm9ncmVzc1Rhc2sodmFsdWUsIGhhbmRsZXIpIHtcblx0XHRcdHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG5cdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0UHJvZ3Jlc3NUYXNrLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBxID0gdGhpcy5oYW5kbGVyLmNvbnN1bWVycztcblx0XHRcdGlmKHEgPT09IHZvaWQgMCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGZvciAodmFyIGMsIGkgPSAwOyBpIDwgcS5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRjID0gcVtpXTtcblx0XHRcdFx0cnVuTm90aWZ5KGMucHJvZ3Jlc3MsIHRoaXMudmFsdWUsIHRoaXMuaGFuZGxlciwgYy5yZWNlaXZlciwgYy5yZXNvbHZlcik7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEFzc2ltaWxhdGUgYSB0aGVuYWJsZSwgc2VuZGluZyBpdCdzIHZhbHVlIHRvIHJlc29sdmVyXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gdGhlblxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSB0aGVuYWJsZVxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSByZXNvbHZlclxuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIEFzc2ltaWxhdGVUYXNrKHRoZW4sIHRoZW5hYmxlLCByZXNvbHZlcikge1xuXHRcdFx0dGhpcy5fdGhlbiA9IHRoZW47XG5cdFx0XHR0aGlzLnRoZW5hYmxlID0gdGhlbmFibGU7XG5cdFx0XHR0aGlzLnJlc29sdmVyID0gcmVzb2x2ZXI7XG5cdFx0fVxuXG5cdFx0QXNzaW1pbGF0ZVRhc2sucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGggPSB0aGlzLnJlc29sdmVyO1xuXHRcdFx0dHJ5QXNzaW1pbGF0ZSh0aGlzLl90aGVuLCB0aGlzLnRoZW5hYmxlLCBfcmVzb2x2ZSwgX3JlamVjdCwgX25vdGlmeSk7XG5cblx0XHRcdGZ1bmN0aW9uIF9yZXNvbHZlKHgpIHsgaC5yZXNvbHZlKHgpOyB9XG5cdFx0XHRmdW5jdGlvbiBfcmVqZWN0KHgpICB7IGgucmVqZWN0KHgpOyB9XG5cdFx0XHRmdW5jdGlvbiBfbm90aWZ5KHgpICB7IGgubm90aWZ5KHgpOyB9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHRyeUFzc2ltaWxhdGUodGhlbiwgdGhlbmFibGUsIHJlc29sdmUsIHJlamVjdCwgbm90aWZ5KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR0aGVuLmNhbGwodGhlbmFibGUsIHJlc29sdmUsIHJlamVjdCwgbm90aWZ5KTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmVqZWN0KGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE90aGVyIGhlbHBlcnNcblxuXHRcdC8qKlxuXHRcdCAqIEBwYXJhbSB7Kn0geFxuXHRcdCAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmZiB4IGlzIGEgdHJ1c3RlZCBQcm9taXNlXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gaXNQcm9taXNlKHgpIHtcblx0XHRcdHJldHVybiB4IGluc3RhbmNlb2YgUHJvbWlzZTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBUZXN0IGp1c3QgZW5vdWdoIHRvIHJ1bGUgb3V0IHByaW1pdGl2ZXMsIGluIG9yZGVyIHRvIHRha2UgZmFzdGVyXG5cdFx0ICogcGF0aHMgaW4gc29tZSBjb2RlXG5cdFx0ICogQHBhcmFtIHsqfSB4XG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlIGlmZiB4IGlzIGd1YXJhbnRlZWQgKm5vdCogdG8gYmUgYSB0aGVuYWJsZVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIG1heWJlVGhlbmFibGUoeCkge1xuXHRcdFx0cmV0dXJuICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHggPT09ICdmdW5jdGlvbicpICYmIHggIT09IG51bGw7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcnVuQ29udGludWF0aW9uMShmLCBoLCByZWNlaXZlciwgbmV4dCkge1xuXHRcdFx0aWYodHlwZW9mIGYgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0cmV0dXJuIG5leHQuYmVjb21lKGgpO1xuXHRcdFx0fVxuXG5cdFx0XHRQcm9taXNlLmVudGVyQ29udGV4dChoKTtcblx0XHRcdHRyeUNhdGNoUmVqZWN0KGYsIGgudmFsdWUsIHJlY2VpdmVyLCBuZXh0KTtcblx0XHRcdFByb21pc2UuZXhpdENvbnRleHQoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBydW5Db250aW51YXRpb24zKGYsIHgsIGgsIHJlY2VpdmVyLCBuZXh0KSB7XG5cdFx0XHRpZih0eXBlb2YgZiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRyZXR1cm4gbmV4dC5iZWNvbWUoaCk7XG5cdFx0XHR9XG5cblx0XHRcdFByb21pc2UuZW50ZXJDb250ZXh0KGgpO1xuXHRcdFx0dHJ5Q2F0Y2hSZWplY3QzKGYsIHgsIGgudmFsdWUsIHJlY2VpdmVyLCBuZXh0KTtcblx0XHRcdFByb21pc2UuZXhpdENvbnRleHQoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBydW5Ob3RpZnkoZiwgeCwgaCwgcmVjZWl2ZXIsIG5leHQpIHtcblx0XHRcdGlmKHR5cGVvZiBmICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHJldHVybiBuZXh0Lm5vdGlmeSh4KTtcblx0XHRcdH1cblxuXHRcdFx0UHJvbWlzZS5lbnRlckNvbnRleHQoaCk7XG5cdFx0XHR0cnlDYXRjaFJldHVybihmLCB4LCByZWNlaXZlciwgbmV4dCk7XG5cdFx0XHRQcm9taXNlLmV4aXRDb250ZXh0KCk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIGYuY2FsbCh0aGlzQXJnLCB4KSwgb3IgaWYgaXQgdGhyb3dzIHJldHVybiBhIHJlamVjdGVkIHByb21pc2UgZm9yXG5cdFx0ICogdGhlIHRocm93biBleGNlcHRpb25cblx0XHQgKi9cblx0XHRmdW5jdGlvbiB0cnlDYXRjaFJlamVjdChmLCB4LCB0aGlzQXJnLCBuZXh0KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRuZXh0LmJlY29tZShnZXRIYW5kbGVyKGYuY2FsbCh0aGlzQXJnLCB4KSkpO1xuXHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdG5leHQuYmVjb21lKG5ldyBSZWplY3RlZChlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogU2FtZSBhcyBhYm92ZSwgYnV0IGluY2x1ZGVzIHRoZSBleHRyYSBhcmd1bWVudCBwYXJhbWV0ZXIuXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gdHJ5Q2F0Y2hSZWplY3QzKGYsIHgsIHksIHRoaXNBcmcsIG5leHQpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGYuY2FsbCh0aGlzQXJnLCB4LCB5LCBuZXh0KTtcblx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRuZXh0LmJlY29tZShuZXcgUmVqZWN0ZWQoZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiBmLmNhbGwodGhpc0FyZywgeCksIG9yIGlmIGl0IHRocm93cywgKnJldHVybiogdGhlIGV4Y2VwdGlvblxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHRyeUNhdGNoUmV0dXJuKGYsIHgsIHRoaXNBcmcsIG5leHQpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdG5leHQubm90aWZ5KGYuY2FsbCh0aGlzQXJnLCB4KSk7XG5cdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0bmV4dC5ub3RpZnkoZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW5oZXJpdChQYXJlbnQsIENoaWxkKSB7XG5cdFx0XHRDaGlsZC5wcm90b3R5cGUgPSBvYmplY3RDcmVhdGUoUGFyZW50LnByb3RvdHlwZSk7XG5cdFx0XHRDaGlsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDaGlsZDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBub29wKCkge31cblxuXHRcdHJldHVybiBQcm9taXNlO1xuXHR9O1xufSk7XG59KHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7IH0pKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDU1NDb3JlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogVGhlIENTU0NvcmUgbW9kdWxlIHNwZWNpZmllcyB0aGUgQVBJIChhbmQgaW1wbGVtZW50cyBtb3N0IG9mIHRoZSBtZXRob2RzKVxuICogdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVuIGRlYWxpbmcgd2l0aCB0aGUgZGlzcGxheSBvZiBlbGVtZW50cyAodmlhIHRoZWlyXG4gKiBDU1MgY2xhc3NlcyBhbmQgdmlzaWJpbGl0eSBvbiBzY3JlZW4uIEl0IGlzIGFuIEFQSSBmb2N1c2VkIG9uIG11dGF0aW5nIHRoZVxuICogZGlzcGxheSBhbmQgbm90IHJlYWRpbmcgaXQgYXMgbm8gbG9naWNhbCBzdGF0ZSBzaG91bGQgYmUgZW5jb2RlZCBpbiB0aGVcbiAqIGRpc3BsYXkgb2YgZWxlbWVudHMuXG4gKi9cblxudmFyIENTU0NvcmUgPSB7XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGNsYXNzIHBhc3NlZCBpbiB0byB0aGUgZWxlbWVudCBpZiBpdCBkb2Vzbid0IGFscmVhZHkgaGF2ZSBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIHNldCB0aGUgY2xhc3Mgb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSB0aGUgQ1NTIGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fSB0aGUgZWxlbWVudCBwYXNzZWQgaW5cbiAgICovXG4gIGFkZENsYXNzOiBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgIS9cXHMvLnRlc3QoY2xhc3NOYW1lKSxcbiAgICAgICdDU1NDb3JlLmFkZENsYXNzIHRha2VzIG9ubHkgYSBzaW5nbGUgY2xhc3MgbmFtZS4gXCIlc1wiIGNvbnRhaW5zICcgK1xuICAgICAgJ211bHRpcGxlIGNsYXNzZXMuJywgY2xhc3NOYW1lXG4gICAgKSA6IGludmFyaWFudCghL1xccy8udGVzdChjbGFzc05hbWUpKSk7XG5cbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKCFDU1NDb3JlLmhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZSArICcgJyArIGNsYXNzTmFtZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGNsYXNzIHBhc3NlZCBpbiBmcm9tIHRoZSBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgdGhlIENTUyBjbGFzc05hbWVcbiAgICogQHJldHVybiB7RE9NRWxlbWVudH0gdGhlIGVsZW1lbnQgcGFzc2VkIGluXG4gICAqL1xuICByZW1vdmVDbGFzczogZnVuY3Rpb24oZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICEvXFxzLy50ZXN0KGNsYXNzTmFtZSksXG4gICAgICAnQ1NTQ29yZS5yZW1vdmVDbGFzcyB0YWtlcyBvbmx5IGEgc2luZ2xlIGNsYXNzIG5hbWUuIFwiJXNcIiBjb250YWlucyAnICtcbiAgICAgICdtdWx0aXBsZSBjbGFzc2VzLicsIGNsYXNzTmFtZVxuICAgICkgOiBpbnZhcmlhbnQoIS9cXHMvLnRlc3QoY2xhc3NOYW1lKSkpO1xuXG4gICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgfSBlbHNlIGlmIChDU1NDb3JlLmhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZVxuICAgICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBjbGFzc05hbWUgKyAnKD86XFxcXHN8JCknLCAnZycpLCAnJDEnKVxuICAgICAgICAgIC5yZXBsYWNlKC9cXHMrL2csICcgJykgLy8gbXVsdGlwbGUgc3BhY2VzIHRvIG9uZVxuICAgICAgICAgIC5yZXBsYWNlKC9eXFxzKnxcXHMqJC9nLCAnJyk7IC8vIHRyaW0gdGhlIGVuZHNcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhlbHBlciB0byBhZGQgb3IgcmVtb3ZlIGEgY2xhc3MgZnJvbSBhbiBlbGVtZW50IGJhc2VkIG9uIGEgY29uZGl0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIHRoZSBDU1MgY2xhc3NOYW1lXG4gICAqIEBwYXJhbSB7Kn0gYm9vbCBjb25kaXRpb24gdG8gd2hldGhlciB0byBhZGQgb3IgcmVtb3ZlIHRoZSBjbGFzc1xuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fSB0aGUgZWxlbWVudCBwYXNzZWQgaW5cbiAgICovXG4gIGNvbmRpdGlvbkNsYXNzOiBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUsIGJvb2wpIHtcbiAgICByZXR1cm4gKGJvb2wgPyBDU1NDb3JlLmFkZENsYXNzIDogQ1NTQ29yZS5yZW1vdmVDbGFzcykoZWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgfSxcblxuICAvKipcbiAgICogVGVzdHMgd2hldGhlciB0aGUgZWxlbWVudCBoYXMgdGhlIGNsYXNzIHNwZWNpZmllZC5cbiAgICpcbiAgICogQHBhcmFtIHtET01Ob2RlfERPTVdpbmRvd30gZWxlbWVudCB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgdGhlIENTUyBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZWxlbWVudCBoYXMgdGhlIGNsYXNzLCBmYWxzZSBpZiBub3RcbiAgICovXG4gIGhhc0NsYXNzOiBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgIS9cXHMvLnRlc3QoY2xhc3NOYW1lKSxcbiAgICAgICdDU1MuaGFzQ2xhc3MgdGFrZXMgb25seSBhIHNpbmdsZSBjbGFzcyBuYW1lLidcbiAgICApIDogaW52YXJpYW50KCEvXFxzLy50ZXN0KGNsYXNzTmFtZSkpKTtcbiAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICAgIHJldHVybiAhIWNsYXNzTmFtZSAmJiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gKCcgJyArIGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnKS5pbmRleE9mKCcgJyArIGNsYXNzTmFtZSArICcgJykgPiAtMTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU0NvcmU7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXhlY3V0aW9uRW52aXJvbm1lbnRcbiAqL1xuXG4vKmpzbGludCBldmlsOiB0cnVlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY2FuVXNlRE9NID0gISEoXG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gIHdpbmRvdy5kb2N1bWVudCAmJlxuICB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudFxuKTtcblxuLyoqXG4gKiBTaW1wbGUsIGxpZ2h0d2VpZ2h0IG1vZHVsZSBhc3Npc3Rpbmcgd2l0aCB0aGUgZGV0ZWN0aW9uIGFuZCBjb250ZXh0IG9mXG4gKiBXb3JrZXIuIEhlbHBzIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBhbmQgYWxsb3dzIGNvZGUgdG8gcmVhc29uIGFib3V0XG4gKiB3aGV0aGVyIG9yIG5vdCB0aGV5IGFyZSBpbiBhIFdvcmtlciwgZXZlbiBpZiB0aGV5IG5ldmVyIGluY2x1ZGUgdGhlIG1haW5cbiAqIGBSZWFjdFdvcmtlcmAgZGVwZW5kZW5jeS5cbiAqL1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0ge1xuXG4gIGNhblVzZURPTTogY2FuVXNlRE9NLFxuXG4gIGNhblVzZVdvcmtlcnM6IHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnLFxuXG4gIGNhblVzZUV2ZW50TGlzdGVuZXJzOlxuICAgIGNhblVzZURPTSAmJiAhISh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCB3aW5kb3cuYXR0YWNoRXZlbnQpLFxuXG4gIGNhblVzZVZpZXdwb3J0OiBjYW5Vc2VET00gJiYgISF3aW5kb3cuc2NyZWVuLFxuXG4gIGlzSW5Xb3JrZXI6ICFjYW5Vc2VET00gLy8gRm9yIG5vdywgdGhpcyBpcyB0cnVlIC0gbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQ7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIE9iamVjdC5hc3NpZ25cbiAqL1xuXG4vLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LmFzc2lnblxuXG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2VzKSB7XG4gIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gdGFyZ2V0IGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICB9XG5cbiAgdmFyIHRvID0gT2JqZWN0KHRhcmdldCk7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgZm9yICh2YXIgbmV4dEluZGV4ID0gMTsgbmV4dEluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgbmV4dEluZGV4KyspIHtcbiAgICB2YXIgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tuZXh0SW5kZXhdO1xuICAgIGlmIChuZXh0U291cmNlID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBmcm9tID0gT2JqZWN0KG5leHRTb3VyY2UpO1xuXG4gICAgLy8gV2UgZG9uJ3QgY3VycmVudGx5IHN1cHBvcnQgYWNjZXNzb3JzIG5vciBwcm94aWVzLiBUaGVyZWZvcmUgdGhpc1xuICAgIC8vIGNvcHkgY2Fubm90IHRocm93LiBJZiB3ZSBldmVyIHN1cHBvcnRlZCB0aGlzIHRoZW4gd2UgbXVzdCBoYW5kbGVcbiAgICAvLyBleGNlcHRpb25zIGFuZCBzaWRlLWVmZmVjdHMuIFdlIGRvbid0IHN1cHBvcnQgc3ltYm9scyBzbyB0aGV5IHdvbid0XG4gICAgLy8gYmUgdHJhbnNmZXJyZWQuXG5cbiAgICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuICAgICAgICB0b1trZXldID0gZnJvbVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0bztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0VHJhbnNpdGlvbkV2ZW50c1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcblxuLyoqXG4gKiBFVkVOVF9OQU1FX01BUCBpcyB1c2VkIHRvIGRldGVybWluZSB3aGljaCBldmVudCBmaXJlZCB3aGVuIGFcbiAqIHRyYW5zaXRpb24vYW5pbWF0aW9uIGVuZHMsIGJhc2VkIG9uIHRoZSBzdHlsZSBwcm9wZXJ0eSB1c2VkIHRvXG4gKiBkZWZpbmUgdGhhdCBldmVudC5cbiAqL1xudmFyIEVWRU5UX05BTUVfTUFQID0ge1xuICB0cmFuc2l0aW9uZW5kOiB7XG4gICAgJ3RyYW5zaXRpb24nOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgJ1dlYmtpdFRyYW5zaXRpb24nOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgJ01velRyYW5zaXRpb24nOiAnbW96VHJhbnNpdGlvbkVuZCcsXG4gICAgJ09UcmFuc2l0aW9uJzogJ29UcmFuc2l0aW9uRW5kJyxcbiAgICAnbXNUcmFuc2l0aW9uJzogJ01TVHJhbnNpdGlvbkVuZCdcbiAgfSxcblxuICBhbmltYXRpb25lbmQ6IHtcbiAgICAnYW5pbWF0aW9uJzogJ2FuaW1hdGlvbmVuZCcsXG4gICAgJ1dlYmtpdEFuaW1hdGlvbic6ICd3ZWJraXRBbmltYXRpb25FbmQnLFxuICAgICdNb3pBbmltYXRpb24nOiAnbW96QW5pbWF0aW9uRW5kJyxcbiAgICAnT0FuaW1hdGlvbic6ICdvQW5pbWF0aW9uRW5kJyxcbiAgICAnbXNBbmltYXRpb24nOiAnTVNBbmltYXRpb25FbmQnXG4gIH1cbn07XG5cbnZhciBlbmRFdmVudHMgPSBbXTtcblxuZnVuY3Rpb24gZGV0ZWN0RXZlbnRzKCkge1xuICB2YXIgdGVzdEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZhciBzdHlsZSA9IHRlc3RFbC5zdHlsZTtcblxuICAvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxuICAvLyB0aGUgdW4tcHJlZml4ZWQgXCJhbmltYXRpb25cIiBhbmQgXCJ0cmFuc2l0aW9uXCIgcHJvcGVydGllcyBhcmUgZGVmaW5lZCBvbiB0aGVcbiAgLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXG4gIC8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzZWFibGUsIGFuZCBpZiBub3QgcmVtb3ZlIHRoZW1cbiAgLy8gZnJvbSB0aGUgbWFwXG4gIGlmICghKCdBbmltYXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSBFVkVOVF9OQU1FX01BUC5hbmltYXRpb25lbmQuYW5pbWF0aW9uO1xuICB9XG5cbiAgaWYgKCEoJ1RyYW5zaXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSBFVkVOVF9OQU1FX01BUC50cmFuc2l0aW9uZW5kLnRyYW5zaXRpb247XG4gIH1cblxuICBmb3IgKHZhciBiYXNlRXZlbnROYW1lIGluIEVWRU5UX05BTUVfTUFQKSB7XG4gICAgdmFyIGJhc2VFdmVudHMgPSBFVkVOVF9OQU1FX01BUFtiYXNlRXZlbnROYW1lXTtcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gYmFzZUV2ZW50cykge1xuICAgICAgaWYgKHN0eWxlTmFtZSBpbiBzdHlsZSkge1xuICAgICAgICBlbmRFdmVudHMucHVzaChiYXNlRXZlbnRzW3N0eWxlTmFtZV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBkZXRlY3RFdmVudHMoKTtcbn1cblxuLy8gV2UgdXNlIHRoZSByYXcge2FkZHxyZW1vdmV9RXZlbnRMaXN0ZW5lcigpIGNhbGwgYmVjYXVzZSBFdmVudExpc3RlbmVyXG4vLyBkb2VzIG5vdCBrbm93IGhvdyB0byByZW1vdmUgZXZlbnQgbGlzdGVuZXJzIGFuZCB3ZSByZWFsbHkgc2hvdWxkXG4vLyBjbGVhbiB1cC4gQWxzbywgdGhlc2UgZXZlbnRzIGFyZSBub3QgdHJpZ2dlcmVkIGluIG9sZGVyIGJyb3dzZXJzXG4vLyBzbyB3ZSBzaG91bGQgYmUgQS1PSyBoZXJlLlxuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50TmFtZSwgZXZlbnRMaXN0ZW5lcikge1xuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudExpc3RlbmVyLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnROYW1lLCBldmVudExpc3RlbmVyKSB7XG4gIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbn1cblxudmFyIFJlYWN0VHJhbnNpdGlvbkV2ZW50cyA9IHtcbiAgYWRkRW5kRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24obm9kZSwgZXZlbnRMaXN0ZW5lcikge1xuICAgIGlmIChlbmRFdmVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBJZiBDU1MgdHJhbnNpdGlvbnMgYXJlIG5vdCBzdXBwb3J0ZWQsIHRyaWdnZXIgYW4gXCJlbmQgYW5pbWF0aW9uXCJcbiAgICAgIC8vIGV2ZW50IGltbWVkaWF0ZWx5LlxuICAgICAgd2luZG93LnNldFRpbWVvdXQoZXZlbnRMaXN0ZW5lciwgMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVuZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVuZEV2ZW50KSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGVuZEV2ZW50LCBldmVudExpc3RlbmVyKTtcbiAgICB9KTtcbiAgfSxcblxuICByZW1vdmVFbmRFdmVudExpc3RlbmVyOiBmdW5jdGlvbihub2RlLCBldmVudExpc3RlbmVyKSB7XG4gICAgaWYgKGVuZEV2ZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZW5kRXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZW5kRXZlbnQpIHtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgZW5kRXZlbnQsIGV2ZW50TGlzdGVuZXIpO1xuICAgIH0pO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VHJhbnNpdGlvbkV2ZW50cztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjeFxuICovXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIG1hcmsgc3RyaW5nIGxpdGVyYWxzIHJlcHJlc2VudGluZyBDU1MgY2xhc3MgbmFtZXNcbiAqIHNvIHRoYXQgdGhleSBjYW4gYmUgdHJhbnNmb3JtZWQgc3RhdGljYWxseS4gVGhpcyBhbGxvd3MgZm9yIG1vZHVsYXJpemF0aW9uXG4gKiBhbmQgbWluaWZpY2F0aW9uIG9mIENTUyBjbGFzcyBuYW1lcy5cbiAqXG4gKiBJbiBzdGF0aWNfdXBzdHJlYW0sIHRoaXMgZnVuY3Rpb24gaXMgYWN0dWFsbHkgaW1wbGVtZW50ZWQsIGJ1dCBpdCBzaG91bGRcbiAqIGV2ZW50dWFsbHkgYmUgcmVwbGFjZWQgd2l0aCBzb21ldGhpbmcgbW9yZSBkZXNjcmlwdGl2ZSwgYW5kIHRoZSB0cmFuc2Zvcm1cbiAqIHRoYXQgaXMgdXNlZCBpbiB0aGUgbWFpbiBzdGFjayBzaG91bGQgYmUgcG9ydGVkIGZvciB1c2UgZWxzZXdoZXJlLlxuICpcbiAqIEBwYXJhbSBzdHJpbmd8b2JqZWN0IGNsYXNzTmFtZSB0byBtb2R1bGFyaXplLCBvciBhbiBvYmplY3Qgb2Yga2V5L3ZhbHVlcy5cbiAqICAgICAgICAgICAgICAgICAgICAgIEluIHRoZSBvYmplY3QgY2FzZSwgdGhlIHZhbHVlcyBhcmUgY29uZGl0aW9ucyB0aGF0XG4gKiAgICAgICAgICAgICAgICAgICAgICBkZXRlcm1pbmUgaWYgdGhlIGNsYXNzTmFtZSBrZXlzIHNob3VsZCBiZSBpbmNsdWRlZC5cbiAqIEBwYXJhbSBbc3RyaW5nIC4uLl0gIFZhcmlhYmxlIGxpc3Qgb2YgY2xhc3NOYW1lcyBpbiB0aGUgc3RyaW5nIGNhc2UuXG4gKiBAcmV0dXJuIHN0cmluZyAgICAgICBSZW5kZXJhYmxlIHNwYWNlLXNlcGFyYXRlZCBDU1MgY2xhc3NOYW1lLlxuICovXG5mdW5jdGlvbiBjeChjbGFzc05hbWVzKSB7XG4gIGlmICh0eXBlb2YgY2xhc3NOYW1lcyA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhjbGFzc05hbWVzKS5maWx0ZXIoZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgICByZXR1cm4gY2xhc3NOYW1lc1tjbGFzc05hbWVdO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbChhcmd1bWVudHMsICcgJyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjeDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlbXB0eUZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xuZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbihhcmcpIHsgcmV0dXJuIGFyZzsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGludmFyaWFudFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICtcbiAgICAgICAgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJ1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICdJbnZhcmlhbnQgVmlvbGF0aW9uOiAnICtcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJnc1thcmdJbmRleCsrXTsgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgd2FybmluZ1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2VtcHR5RnVuY3Rpb25cIik7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICB3YXJuaW5nID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQgKSB7Zm9yICh2YXIgYXJncz1bXSwkX18wPTIsJF9fMT1hcmd1bWVudHMubGVuZ3RoOyRfXzA8JF9fMTskX18wKyspIGFyZ3MucHVzaChhcmd1bWVudHNbJF9fMF0pO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArXG4gICAgICAgICdtZXNzYWdlIGFyZ3VtZW50J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGNvbnNvbGUud2FybignV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpICB7cmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107fSkpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJpbW11dGFibGVcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiNC4wLjAtcmMuMTJcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkltbXV0YWJsZSBEYXRhIENvbGxlY3Rpb25zXCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9pbW11dGFibGUtanMuY29tXCIsXG4gIFwiYXV0aG9yXCI6IHtcbiAgICBcIm5hbWVcIjogXCJMZWUgQnlyb25cIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9sZWVieXJvblwiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQ6Ly9naXRodWIuY29tL2ltbXV0YWJsZS1qcy9pbW11dGFibGUtanMuZ2l0XCJcbiAgfSxcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9pbW11dGFibGUtanMvaW1tdXRhYmxlLWpzL2lzc3Vlc1wiXG4gIH0sXG4gIFwibWFpblwiOiBcImRpc3QvaW1tdXRhYmxlLmpzXCIsXG4gIFwibW9kdWxlXCI6IFwiZGlzdC9pbW11dGFibGUuZXMuanNcIixcbiAgXCJ0eXBpbmdzXCI6IFwiZGlzdC9pbW11dGFibGUtbm9uYW1iaWVudC5kLnRzXCIsXG4gIFwidHlwZXNjcmlwdFwiOiB7XG4gICAgXCJkZWZpbml0aW9uXCI6IFwiZGlzdC9pbW11dGFibGUuZC50c1wiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJidWlsZFwiOiBcInJ1bi1zIGJ1aWxkOipcIixcbiAgICBcImJ1aWxkOmRpc3RcIjogXCJydW4tcyBjbGVhbjpkaXN0IGJ1bmRsZTpkaXN0IGJ1bmRsZTplcyBjb3B5OmRpc3Qgc3RhdHM6ZGlzdCBwcmVwYXJlOmRpc3RcIixcbiAgICBcImJ1aWxkOnBhZ2VzXCI6IFwiZ3VscCAtLWd1bHBmaWxlIC4vcmVzb3VyY2VzL2d1bHBmaWxlLmpzIGRlZmF1bHRcIixcbiAgICBcInN0YXRzOmRpc3RcIjogXCJub2RlIC4vcmVzb3VyY2VzL2Rpc3Qtc3RhdHMuanNcIixcbiAgICBcImNsZWFuOmRpc3RcIjogXCJyaW1yYWYgZGlzdFwiLFxuICAgIFwiYnVuZGxlOmRpc3RcIjogXCJyb2xsdXAgLWMgLi9yZXNvdXJjZXMvcm9sbHVwLWNvbmZpZy5qc1wiLFxuICAgIFwiYnVuZGxlOmVzXCI6IFwicm9sbHVwIC1jIC4vcmVzb3VyY2VzL3JvbGx1cC1jb25maWctZXMuanNcIixcbiAgICBcImNvcHk6ZGlzdFwiOiBcIm5vZGUgLi9yZXNvdXJjZXMvY29weS1kaXN0LXR5cGVkZWZzLmpzXCIsXG4gICAgXCJwcmVwYXJlOmRpc3RcIjogXCIuL3Jlc291cmNlcy9wcmVwYXJlLWRpc3Quc2hcIixcbiAgICBcImZvcm1hdFwiOiBcIm5wbSBydW4gbGludDpmb3JtYXQgLS0gLS13cml0ZVwiLFxuICAgIFwibGludFwiOiBcInJ1bi1zIGxpbnQ6KlwiLFxuICAgIFwibGludDp0c1wiOiBcInRzbGludCBcXFwiX190ZXN0c19fLyoqLyoudHNcXFwiXCIsXG4gICAgXCJsaW50OmpzXCI6IFwiZXNsaW50IFxcXCJ7X190ZXN0c19fLHNyYyxwYWdlcy9zcmMscGFnZXMvbGlifS8qKi8qLmpzXFxcIlwiLFxuICAgIFwibGludDpmb3JtYXRcIjogXCJwcmV0dGllciAtLWNoZWNrIFxcXCJ7X190ZXN0c19fLHNyYyxwYWdlcy9zcmMscGFnZXMvbGliLHBlcmYscmVzb3VyY2VzfS8qKi8qe1xcXFwuanMsXFxcXC50c31cXFwiXCIsXG4gICAgXCJ0ZXN0b25seVwiOiBcIi4vcmVzb3VyY2VzL2plc3RcIixcbiAgICBcInRlc3RcIjogXCJydW4tcyBmb3JtYXQgYnVpbGQgbGludCB0ZXN0b25seSB0ZXN0OnR5cGVzXCIsXG4gICAgXCJjaGVjazpnaXQtY2xlYW5cIjogXCIuL3Jlc291cmNlcy9jaGVjay1jaGFuZ2VzXCIsXG4gICAgXCJ0ZXN0OnR5cGVzXCI6IFwicnVuLXMgdGVzdDp0eXBlczoqXCIsXG4gICAgXCJ0ZXN0OnR5cGVzOnRzXCI6IFwidHNjIC4vdHlwZS1kZWZpbml0aW9ucy9JbW11dGFibGUuZC50cyAtLWxpYiBlczIwMTUgJiYgZHRzbGludCB0eXBlLWRlZmluaXRpb25zL3RzLXRlc3RzXCIsXG4gICAgXCJ0ZXN0OnR5cGVzOmZsb3dcIjogXCJmbG93IGNoZWNrIHR5cGUtZGVmaW5pdGlvbnMvZmxvdy10ZXN0cyAtLWluY2x1ZGUtd2FybmluZ3NcIixcbiAgICBcInBlcmZcIjogXCJub2RlIC4vcmVzb3VyY2VzL2JlbmNoLmpzXCIsXG4gICAgXCJzdGFydFwiOiBcImd1bHAgLS1ndWxwZmlsZSAuL3Jlc291cmNlcy9ndWxwZmlsZS5qcyBkZXZcIlxuICB9LFxuICBcInByZXR0aWVyXCI6IHtcbiAgICBcInNpbmdsZVF1b3RlXCI6IHRydWUsXG4gICAgXCJ0cmFpbGluZ0NvbW1hXCI6IFwiZXM1XCIsXG4gICAgXCJzZW1pXCI6IHRydWUsXG4gICAgXCJhcnJvd1BhcmVuc1wiOiBcImF2b2lkXCJcbiAgfSxcbiAgXCJqZXN0XCI6IHtcbiAgICBcIm1vZHVsZUZpbGVFeHRlbnNpb25zXCI6IFtcbiAgICAgIFwianNcIixcbiAgICAgIFwidHNcIlxuICAgIF0sXG4gICAgXCJ0cmFuc2Zvcm1cIjoge1xuICAgICAgXCJeLitcXFxcLnRzJFwiOiBcIjxyb290RGlyPi9yZXNvdXJjZXMvamVzdFByZXByb2Nlc3Nvci5qc1wiXG4gICAgfSxcbiAgICBcInRlc3RSZWdleFwiOiBcIi9fX3Rlc3RzX18vLipcXFxcLih0c3xqcykkXCIsXG4gICAgXCJ1bm1vY2tlZE1vZHVsZVBhdGhQYXR0ZXJuc1wiOiBbXG4gICAgICBcIi4vbm9kZV9tb2R1bGVzL3JlYWN0XCJcbiAgICBdXG4gIH0sXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImJlbmNobWFya1wiOiBcIjIuMS40XCIsXG4gICAgXCJicm93c2VyLXN5bmNcIjogXCJeMi4yNi4xMlwiLFxuICAgIFwiYnJvd3NlcmlmeVwiOiBcIjE2LjUuMlwiLFxuICAgIFwiY29sb3JzXCI6IFwiMS40LjBcIixcbiAgICBcImRlbFwiOiBcIjYuMC4wXCIsXG4gICAgXCJkdHNsaW50XCI6IFwiNC4xLjBcIixcbiAgICBcImVzbGludFwiOiBcIjcuMjkuMFwiLFxuICAgIFwiZXNsaW50LWNvbmZpZy1haXJibmJcIjogXCIxOC4yLjFcIixcbiAgICBcImVzbGludC1jb25maWctcHJldHRpZXJcIjogXCI4LjMuMFwiLFxuICAgIFwiZXNsaW50LXBsdWdpbi1pbXBvcnRcIjogXCIyLjIzLjRcIixcbiAgICBcImVzbGludC1wbHVnaW4tanN4LWExMXlcIjogXCI2LjQuMVwiLFxuICAgIFwiZXNsaW50LXBsdWdpbi1wcmV0dGllclwiOiBcIjMuNC4wXCIsXG4gICAgXCJlc2xpbnQtcGx1Z2luLXJlYWN0XCI6IFwiNy4yNC4wXCIsXG4gICAgXCJmbG93LWJpblwiOiBcIjAuODkuMFwiLFxuICAgIFwiZ3VscFwiOiBcIjQuMC4yXCIsXG4gICAgXCJndWxwLWNvbmNhdFwiOiBcIjIuNi4xXCIsXG4gICAgXCJndWxwLWZpbHRlclwiOiBcIjYuMC4wXCIsXG4gICAgXCJndWxwLWhlYWRlclwiOiBcIjIuMC45XCIsXG4gICAgXCJndWxwLWxlc3NcIjogXCI0LjAuMVwiLFxuICAgIFwiZ3VscC1zaXplXCI6IFwiMy4wLjBcIixcbiAgICBcImd1bHAtc291cmNlbWFwc1wiOiBcIjIuNi41XCIsXG4gICAgXCJndWxwLXVnbGlmeVwiOiBcIjMuMC4yXCIsXG4gICAgXCJndWxwLXV0aWxcIjogXCIzLjAuOFwiLFxuICAgIFwiamFzbWluZS1jaGVja1wiOiBcIjAuMS41XCIsXG4gICAgXCJqZXN0XCI6IFwiMjYuNS4yXCIsXG4gICAgXCJtYXJrZWRcIjogXCIxLjIuMFwiLFxuICAgIFwibWljcm90aW1lXCI6IFwiMy4wLjBcIixcbiAgICBcIm1rZGlycFwiOiBcIjEuMC40XCIsXG4gICAgXCJucG0tcnVuLWFsbFwiOiBcIjQuMS41XCIsXG4gICAgXCJwcmV0dGllclwiOiBcIl4yLjMuMVwiLFxuICAgIFwicmVhY3RcIjogXCJeMC4xMi4yXCIsXG4gICAgXCJyZWFjdC1yb3V0ZXJcIjogXCJeMC4xMS42XCIsXG4gICAgXCJyZWFjdC10b29sc1wiOiBcIjAuMTMuM1wiLFxuICAgIFwicmltcmFmXCI6IFwiMy4wLjJcIixcbiAgICBcInJvbGx1cFwiOiBcIjIuMjkuMFwiLFxuICAgIFwicm9sbHVwLXBsdWdpbi1idWJsZVwiOiBcIjAuMTkuMlwiLFxuICAgIFwicm9sbHVwLXBsdWdpbi1jb21tb25qc1wiOiBcIjkuMS4zXCIsXG4gICAgXCJyb2xsdXAtcGx1Z2luLWpzb25cIjogXCIzLjAuMFwiLFxuICAgIFwicm9sbHVwLXBsdWdpbi1zdHJpcC1iYW5uZXJcIjogXCIyLjAuMFwiLFxuICAgIFwidGhyb3VnaDJcIjogXCI0LjAuMlwiLFxuICAgIFwidHJhbnNkdWNlcnMtanNcIjogXCJeMC40LjE3NFwiLFxuICAgIFwidHNsaW50XCI6IFwiNi4xLjNcIixcbiAgICBcInR5cGVzY3JpcHRcIjogXCI0LjMuNFwiLFxuICAgIFwidWdsaWZ5LWpzXCI6IFwiMy4xMS4xXCIsXG4gICAgXCJ1Z2xpZnktc2F2ZS1saWNlbnNlXCI6IFwiMC40LjFcIixcbiAgICBcInZpbnlsLWJ1ZmZlclwiOiBcIjEuMC4xXCIsXG4gICAgXCJ2aW55bC1zb3VyY2Utc3RyZWFtXCI6IFwiMi4wLjBcIlxuICB9LFxuICBcImZpbGVzXCI6IFtcbiAgICBcImRpc3RcIixcbiAgICBcImNvbnRyaWJcIixcbiAgICBcIlJFQURNRS5tZFwiLFxuICAgIFwiTElDRU5TRVwiXG4gIF0sXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiaW1tdXRhYmxlXCIsXG4gICAgXCJwZXJzaXN0ZW50XCIsXG4gICAgXCJsYXp5XCIsXG4gICAgXCJkYXRhXCIsXG4gICAgXCJkYXRhc3RydWN0dXJlXCIsXG4gICAgXCJmdW5jdGlvbmFsXCIsXG4gICAgXCJjb2xsZWN0aW9uXCIsXG4gICAgXCJzdGF0ZWxlc3NcIixcbiAgICBcInNlcXVlbmNlXCIsXG4gICAgXCJpdGVyYXRpb25cIlxuICBdXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XCJJbW11dGFibGVcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiSW1tdXRhYmxlIGRhdGEgZW5jb3VyYWdlcyBwdXJlIGZ1bmN0aW9ucyAoZGF0YS1pbiwgZGF0YS1vdXQpIGFuZCBsZW5kcyBpdHNlbGZcXG50byBtdWNoIHNpbXBsZXIgYXBwbGljYXRpb24gZGV2ZWxvcG1lbnQgYW5kIGVuYWJsaW5nIHRlY2huaXF1ZXMgZnJvbVxcbmZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgc3VjaCBhcyBsYXp5IGV2YWx1YXRpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiV2hpbGUgZGVzaWduZWQgdG8gYnJpbmcgdGhlc2UgcG93ZXJmdWwgZnVuY3Rpb25hbCBjb25jZXB0cyB0byBKYXZhU2NyaXB0LCBpdFxcbnByZXNlbnRzIGFuIE9iamVjdC1PcmllbnRlZCBBUEkgZmFtaWxpYXIgdG8gSmF2YXNjcmlwdCBlbmdpbmVlcnMgYW5kIGNsb3NlbHlcXG5taXJyb3JpbmcgdGhhdCBvZiBBcnJheSwgTWFwLCBhbmQgU2V0LiBJdCBpcyBlYXN5IGFuZCBlZmZpY2llbnQgdG8gY29udmVydCB0b1xcbmFuZCBmcm9tIHBsYWluIEphdmFzY3JpcHQgdHlwZXMuXFxuXFxuIyMgSG93IHRvIHJlYWQgdGhlc2UgZG9jc1xcblxcbkluIG9yZGVyIHRvIGJldHRlciBleHBsYWluIHdoYXQga2luZHMgb2YgdmFsdWVzIHRoZSBJbW11dGFibGUuanMgQVBJIGV4cGVjdHNcXG5hbmQgcHJvZHVjZXMsIHRoaXMgZG9jdW1lbnRhdGlvbiBpcyBwcmVzZW50ZWQgaW4gYSBzdGF0aWNhbGx5IHR5cGVkIGRpYWxlY3Qgb2ZcXG5KYXZhU2NyaXB0IChsaWtlIFtGbG93XVtdIG9yIFtUeXBlU2NyaXB0XVtdKS4gWW91ICpkb24ndCBuZWVkKiB0byB1c2UgdGhlc2VcXG50eXBlIGNoZWNraW5nIHRvb2xzIGluIG9yZGVyIHRvIHVzZSBJbW11dGFibGUuanMsIGhvd2V2ZXIgYmVjb21pbmcgZmFtaWxpYXJcXG53aXRoIHRoZWlyIHN5bnRheCB3aWxsIGhlbHAgeW91IGdldCBhIGRlZXBlciB1bmRlcnN0YW5kaW5nIG9mIHRoaXMgQVBJLlxcblxcbioqQSBmZXcgZXhhbXBsZXMgYW5kIGhvdyB0byByZWFkIHRoZW0uKipcXG5cXG5BbGwgbWV0aG9kcyBkZXNjcmliZSB0aGUga2luZHMgb2YgZGF0YSB0aGV5IGFjY2VwdCBhbmQgdGhlIGtpbmRzIG9mIGRhdGFcXG50aGV5IHJldHVybi4gRm9yIGV4YW1wbGUgYSBmdW5jdGlvbiB3aGljaCBhY2NlcHRzIHR3byBudW1iZXJzIGFuZCByZXR1cm5zXFxuYSBudW1iZXIgd291bGQgbG9vayBsaWtlIHRoaXM6XFxuXFxuYGBganNcXG5zdW0oZmlyc3Q6IG51bWJlciwgc2Vjb25kOiBudW1iZXIpOiBudW1iZXJcXG5gYGBcXG5cXG5Tb21ldGltZXMsIG1ldGhvZHMgY2FuIGFjY2VwdCBkaWZmZXJlbnQga2luZHMgb2YgZGF0YSBvciByZXR1cm4gZGlmZmVyZW50XFxua2luZHMgb2YgZGF0YSwgYW5kIHRoaXMgaXMgZGVzY3JpYmVkIHdpdGggYSAqdHlwZSB2YXJpYWJsZSosIHdoaWNoIGlzXFxudHlwaWNhbGx5IGluIGFsbC1jYXBzLiBGb3IgZXhhbXBsZSwgYSBmdW5jdGlvbiB3aGljaCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZVxcbmtpbmQgb2YgZGF0YSBpdCB3YXMgcHJvdmlkZWQgd291bGQgbG9vayBsaWtlIHRoaXM6XFxuXFxuYGBganNcXG5pZGVudGl0eTxUPih2YWx1ZTogVCk6IFRcXG5gYGBcXG5cXG5UeXBlIHZhcmlhYmxlcyBhcmUgZGVmaW5lZCB3aXRoIGNsYXNzZXMgYW5kIHJlZmVycmVkIHRvIGluIG1ldGhvZHMuIEZvclxcbmV4YW1wbGUsIGEgY2xhc3MgdGhhdCBob2xkcyBvbnRvIGEgdmFsdWUgZm9yIHlvdSBtaWdodCBsb29rIGxpa2UgdGhpczpcXG5cXG5gYGBqc1xcbmNsYXNzIEJveDxUPiB7XFxuICBjb25zdHJ1Y3Rvcih2YWx1ZTogVClcXG4gIGdldFZhbHVlKCk6IFRcXG59XFxuYGBgXFxuXFxuSW4gb3JkZXIgdG8gbWFuaXB1bGF0ZSBJbW11dGFibGUgZGF0YSwgbWV0aG9kcyB0aGF0IHdlJ3JlIHVzZWQgdG8gYWZmZWN0aW5nXFxuYSBDb2xsZWN0aW9uIGluc3RlYWQgcmV0dXJuIGEgbmV3IENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZS4gVGhlIHR5cGVcXG5gdGhpc2AgcmVmZXJzIHRvIHRoZSBzYW1lIGtpbmQgb2YgY2xhc3MuIEZvciBleGFtcGxlLCBhIExpc3Qgd2hpY2ggcmV0dXJuc1xcbm5ldyBMaXN0cyB3aGVuIHlvdSBgcHVzaGAgYSB2YWx1ZSBvbnRvIGl0IG1pZ2h0IGxvb2sgbGlrZTpcXG5cXG5gYGBqc1xcbmNsYXNzIExpc3Q8VD4ge1xcbiAgcHVzaCh2YWx1ZTogVCk6IHRoaXNcXG59XFxuYGBgXFxuXFxuTWFueSBtZXRob2RzIGluIEltbXV0YWJsZS5qcyBhY2NlcHQgdmFsdWVzIHdoaWNoIGltcGxlbWVudCB0aGUgSmF2YVNjcmlwdFxcbltJdGVyYWJsZV1bXSBwcm90b2NvbCwgYW5kIG1pZ2h0IGFwcGVhciBsaWtlIGBJdGVyYWJsZTxzdHJpbmc+YCBmb3Igc29tZXRoaW5nXFxud2hpY2ggcmVwcmVzZW50cyBzZXF1ZW5jZSBvZiBzdHJpbmdzLiBUeXBpY2FsbHkgaW4gSmF2YVNjcmlwdCB3ZSB1c2UgcGxhaW5cXG5BcnJheXMgKGBbXWApIHdoZW4gYW4gSXRlcmFibGUgaXMgZXhwZWN0ZWQsIGJ1dCBhbHNvIGFsbCBvZiB0aGUgSW1tdXRhYmxlLmpzXFxuY29sbGVjdGlvbnMgYXJlIGl0ZXJhYmxlIHRoZW1zZWx2ZXMhXFxuXFxuRm9yIGV4YW1wbGUsIHRvIGdldCBhIHZhbHVlIGRlZXAgd2l0aGluIGEgc3RydWN0dXJlIG9mIGRhdGEsIHdlIG1pZ2h0IHVzZVxcbmBnZXRJbmAgd2hpY2ggZXhwZWN0cyBhbiBgSXRlcmFibGVgIHBhdGg6XFxuXFxuYGBgXFxuZ2V0SW4ocGF0aDogSXRlcmFibGU8c3RyaW5nIHwgbnVtYmVyPik6IHVua25vd25cXG5gYGBcXG5cXG5UbyB1c2UgdGhpcyBtZXRob2QsIHdlIGNvdWxkIHBhc3MgYW4gYXJyYXk6IGBkYXRhLmdldEluKFsgXFxcImtleVxcXCIsIDIgXSlgLlxcblxcblxcbk5vdGU6IEFsbCBleGFtcGxlcyBhcmUgcHJlc2VudGVkIGluIHRoZSBtb2Rlcm4gW0VTMjAxNV1bXSB2ZXJzaW9uIG9mXFxuSmF2YVNjcmlwdC4gVXNlIHRvb2xzIGxpa2UgQmFiZWwgdG8gc3VwcG9ydCBvbGRlciBicm93c2Vycy5cXG5cXG5Gb3IgZXhhbXBsZTpcXG5cXG5gYGBqc1xcbi8vIEVTMjAxNVxcbmNvbnN0IG1hcHBlZEZvbyA9IGZvby5tYXAoeCA9PiB4ICogeCk7XFxuLy8gRVM1XFxudmFyIG1hcHBlZEZvbyA9IGZvby5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggKiB4OyB9KTtcXG5gYGBcXG5cXG5bRVMyMDE1XTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9OZXdfaW5fSmF2YVNjcmlwdC9FQ01BU2NyaXB0XzZfc3VwcG9ydF9pbl9Nb3ppbGxhXFxuW1R5cGVTY3JpcHRdOiBodHRwczovL3d3dy50eXBlc2NyaXB0bGFuZy5vcmcvXFxuW0Zsb3ddOiBodHRwczovL2Zsb3d0eXBlLm9yZy9cXG5bSXRlcmFibGVdOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9JdGVyYXRpb25fcHJvdG9jb2xzXCIsXCJub3Rlc1wiOltdfSxcIm1vZHVsZVwiOntcIkxpc3RcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiTGlzdHMgYXJlIG9yZGVyZWQgaW5kZXhlZCBkZW5zZSBjb2xsZWN0aW9ucywgbXVjaCBsaWtlIGEgSmF2YVNjcmlwdFxcbkFycmF5LlwiLFwiZGVzY3JpcHRpb25cIjpcIkxpc3RzIGFyZSBpbW11dGFibGUgYW5kIGZ1bGx5IHBlcnNpc3RlbnQgd2l0aCBPKGxvZzMyIE4pIGdldHMgYW5kIHNldHMsXFxuYW5kIE8oMSkgcHVzaCBhbmQgcG9wLlxcblxcbkxpc3RzIGltcGxlbWVudCBEZXF1ZSwgd2l0aCBlZmZpY2llbnQgYWRkaXRpb24gYW5kIHJlbW92YWwgZnJvbSBib3RoIHRoZVxcbmVuZCAoYHB1c2hgLCBgcG9wYCkgYW5kIGJlZ2lubmluZyAoYHVuc2hpZnRgLCBgc2hpZnRgKS5cXG5cXG5Vbmxpa2UgYSBKYXZhU2NyaXB0IEFycmF5LCB0aGVyZSBpcyBubyBkaXN0aW5jdGlvbiBiZXR3ZWVuIGFuXFxuXFxcInVuc2V0XFxcIiBpbmRleCBhbmQgYW4gaW5kZXggc2V0IHRvIGB1bmRlZmluZWRgLiBgTGlzdCNmb3JFYWNoYCB2aXNpdHMgYWxsXFxuaW5kaWNlcyBmcm9tIDAgdG8gc2l6ZSwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZXkgd2VyZSBleHBsaWNpdGx5IGRlZmluZWQuXCIsXCJub3Rlc1wiOltdfSxcIm1vZHVsZVwiOntcImlzTGlzdFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYSBMaXN0XCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcbkxpc3QuaXNMaXN0KFtdKTsgLy8gZmFsc2VcXG5MaXN0LmlzTGlzdChMaXN0KCkpOyAvLyB0cnVlXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlTGlzdFwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6MTIwfV19fSxcIm9mXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDcmVhdGVzIGEgbmV3IExpc3QgY29udGFpbmluZyBgdmFsdWVzYC5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxuTGlzdC5vZigxLCAyLCAzLCA0KVxcbi8vIExpc3QgWyAxLCAyLCAzLCA0IF1cXG5gYGBcXG5cXG5Ob3RlOiBWYWx1ZXMgYXJlIG5vdCBhbHRlcmVkIG9yIGNvbnZlcnRlZCBpbiBhbnkgd2F5LlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXG5MaXN0Lm9mKHt4OjF9LCAyLCBbM10sIDQpXFxuLy8gTGlzdCBbIHsgeDogMSB9LCAyLCBbIDMgXSwgNCBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVzXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTQxfV19fX0sXCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkNyZWF0ZSBhIG5ldyBpbW11dGFibGUgTGlzdCBjb250YWluaW5nIHRoZSB2YWx1ZXMgb2YgdGhlIHByb3ZpZGVkXFxuY29sbGVjdGlvbi1saWtlLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBMaXN0YCBpcyBhIGZhY3RvcnkgZnVuY3Rpb24gYW5kIG5vdCBhIGNsYXNzLCBhbmQgZG9lcyBub3QgdXNlIHRoZVxcbmBuZXdgIGtleXdvcmQgZHVyaW5nIGNvbnN0cnVjdGlvbi5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTGlzdCwgU2V0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcblxcbmNvbnN0IGVtcHR5TGlzdCA9IExpc3QoKVxcbi8vIExpc3QgW11cXG5cXG5jb25zdCBwbGFpbkFycmF5ID0gWyAxLCAyLCAzLCA0IF1cXG5jb25zdCBsaXN0RnJvbVBsYWluQXJyYXkgPSBMaXN0KHBsYWluQXJyYXkpXFxuLy8gTGlzdCBbIDEsIDIsIDMsIDQgXVxcblxcbmNvbnN0IHBsYWluU2V0ID0gU2V0KFsgMSwgMiwgMywgNCBdKVxcbmNvbnN0IGxpc3RGcm9tUGxhaW5TZXQgPSBMaXN0KHBsYWluU2V0KVxcbi8vIExpc3QgWyAxLCAyLCAzLCA0IF1cXG5cXG5jb25zdCBhcnJheUl0ZXJhdG9yID0gcGxhaW5BcnJheVtTeW1ib2wuaXRlcmF0b3JdKClcXG5jb25zdCBsaXN0RnJvbUNvbGxlY3Rpb25BcnJheSA9IExpc3QoYXJyYXlJdGVyYXRvcilcXG4vLyBMaXN0IFsgMSwgMiwgMywgNCBdXFxuXFxubGlzdEZyb21QbGFpbkFycmF5LmVxdWFscyhsaXN0RnJvbUNvbGxlY3Rpb25BcnJheSkgLy8gdHJ1ZVxcbmxpc3RGcm9tUGxhaW5TZXQuZXF1YWxzKGxpc3RGcm9tQ29sbGVjdGlvbkFycmF5KSAvLyB0cnVlXFxubGlzdEZyb21QbGFpblNldC5lcXVhbHMobGlzdEZyb21QbGFpbkFycmF5KSAvLyB0cnVlXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoxNzV9LHtcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTc2fSx7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcImxpbmVcIjoxNzd9XX0sXCJpbnRlcmZhY2VcIjp7XCJsaW5lXCI6MTc5LFwidHlwZVBhcmFtc1wiOltcIlRcIl0sXCJleHRlbmRzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfV0sXCJncm91cHNcIjpbe1wibWVtYmVyc1wiOntcIiNzaXplXCI6e1wibGluZVwiOjE4NH19fSx7XCJ0aXRsZVwiOlwiUGVyc2lzdGVudCBjaGFuZ2VzXCIsXCJtZW1iZXJzXCI6e1wiI3NldFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IExpc3Qgd2hpY2ggaW5jbHVkZXMgYHZhbHVlYCBhdCBgaW5kZXhgLiBJZiBgaW5kZXhgIGFscmVhZHlcXG5leGlzdHMgaW4gdGhpcyBMaXN0LCBpdCB3aWxsIGJlIHJlcGxhY2VkLlwiLFwiZGVzY3JpcHRpb25cIjpcImBpbmRleGAgbWF5IGJlIGEgbmVnYXRpdmUgbnVtYmVyLCB3aGljaCBpbmRleGVzIGJhY2sgZnJvbSB0aGUgZW5kIG9mIHRoZVxcbkxpc3QuIGB2LnNldCgtMSwgXFxcInZhbHVlXFxcIilgIHNldHMgdGhlIGxhc3QgaXRlbSBpbiB0aGUgTGlzdC5cXG5cXG5JZiBgaW5kZXhgIGxhcmdlciB0aGFuIGBzaXplYCwgdGhlIHJldHVybmVkIExpc3QncyBgc2l6ZWAgd2lsbCBiZSBsYXJnZVxcbmVub3VnaCB0byBpbmNsdWRlIHRoZSBgaW5kZXhgLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuY29uc3Qgb3JpZ2luYWxMaXN0ID0gTGlzdChbIDAgXSk7XFxuLy8gTGlzdCBbIDAgXVxcbm9yaWdpbmFsTGlzdC5zZXQoMSwgMSk7XFxuLy8gTGlzdCBbIDAsIDEgXVxcbm9yaWdpbmFsTGlzdC5zZXQoMCwgJ292ZXJ3cml0dGVuJyk7XFxuLy8gTGlzdCBbIFxcXCJvdmVyd3JpdHRlblxcXCIgXVxcbm9yaWdpbmFsTGlzdC5zZXQoMiwgMik7XFxuLy8gTGlzdCBbIDAsIHVuZGVmaW5lZCwgMiBdXFxuXFxuTGlzdCgpLnNldCg1MDAwMCwgJ3ZhbHVlJykuc2l6ZTtcXG4vLyA1MDAwMVxcbmBgYFxcblxcbk5vdGU6IGBzZXRgIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MjE3fV19LFwiI2RlbGV0ZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IExpc3Qgd2hpY2ggZXhjbHVkZXMgdGhpcyBgaW5kZXhgIGFuZCB3aXRoIGEgc2l6ZSAxIGxlc3NcXG50aGFuIHRoaXMgTGlzdC4gVmFsdWVzIGF0IGluZGljZXMgYWJvdmUgYGluZGV4YCBhcmUgc2hpZnRlZCBkb3duIGJ5IDEgdG9cXG5maWxsIHRoZSBwb3NpdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJUaGlzIGlzIHN5bm9ueW1vdXMgd2l0aCBgbGlzdC5zcGxpY2UoaW5kZXgsIDEpYC5cXG5cXG5gaW5kZXhgIG1heSBiZSBhIG5lZ2F0aXZlIG51bWJlciwgd2hpY2ggaW5kZXhlcyBiYWNrIGZyb20gdGhlIGVuZCBvZiB0aGVcXG5MaXN0LiBgdi5kZWxldGUoLTEpYCBkZWxldGVzIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIExpc3QuXFxuXFxuTm90ZTogYGRlbGV0ZWAgY2Fubm90IGJlIHNhZmVseSB1c2VkIGluIElFOFxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuTGlzdChbIDAsIDEsIDIsIDMsIDQgXSkuZGVsZXRlKDApO1xcbi8vIExpc3QgWyAxLCAyLCAzLCA0IF1cXG5gYGBcXG5cXG5TaW5jZSBgZGVsZXRlKClgIHJlLWluZGV4ZXMgdmFsdWVzLCBpdCBwcm9kdWNlcyBhIGNvbXBsZXRlIGNvcHksIHdoaWNoXFxuaGFzIGBPKE4pYCBjb21wbGV4aXR5Llxcblxcbk5vdGU6IGBkZWxldGVgICpjYW5ub3QqIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwiYWxpYXNcIixcImJvZHlcIjpcInJlbW92ZVwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6Mn19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjI0Nn1dfSxcIiNpbnNlcnRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBMaXN0IHdpdGggYHZhbHVlYCBhdCBgaW5kZXhgIHdpdGggYSBzaXplIDEgbW9yZSB0aGFuIHRoaXNcXG5MaXN0LiBWYWx1ZXMgYXQgaW5kaWNlcyBhYm92ZSBgaW5kZXhgIGFyZSBzaGlmdGVkIG92ZXIgYnkgMS5cIixcImRlc2NyaXB0aW9uXCI6XCJUaGlzIGlzIHN5bm9ueW1vdXMgd2l0aCBgbGlzdC5zcGxpY2UoaW5kZXgsIDAsIHZhbHVlKWAuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5MaXN0KFsgMCwgMSwgMiwgMywgNCBdKS5pbnNlcnQoNiwgNSlcXG4vLyBMaXN0IFsgMCwgMSwgMiwgMywgNCwgNSBdXFxuYGBgXFxuXFxuU2luY2UgYGluc2VydCgpYCByZS1pbmRleGVzIHZhbHVlcywgaXQgcHJvZHVjZXMgYSBjb21wbGV0ZSBjb3B5LCB3aGljaFxcbmhhcyBgTyhOKWAgY29tcGxleGl0eS5cXG5cXG5Ob3RlOiBgaW5zZXJ0YCAqY2Fubm90KiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MjY4fV19LFwiI2NsZWFyXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTGlzdCB3aXRoIDAgc2l6ZSBhbmQgbm8gdmFsdWVzIGluIGNvbnN0YW50IHRpbWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5MaXN0KFsgMSwgMiwgMywgNCBdKS5jbGVhcigpXFxuLy8gTGlzdCBbXVxcbmBgYFxcblxcbk5vdGU6IGBjbGVhcmAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjI4M31dfSxcIiNwdXNoXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTGlzdCB3aXRoIHRoZSBwcm92aWRlZCBgdmFsdWVzYCBhcHBlbmRlZCwgc3RhcnRpbmcgYXQgdGhpc1xcbkxpc3QncyBgc2l6ZWAuXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5MaXN0KFsgMSwgMiwgMywgNCBdKS5wdXNoKDUpXFxuLy8gTGlzdCBbIDEsIDIsIDMsIDQsIDUgXVxcbmBgYFxcblxcbk5vdGU6IGBwdXNoYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjI5OX1dfSxcIiNwb3BcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBMaXN0IHdpdGggYSBzaXplIG9uZXMgbGVzcyB0aGFuIHRoaXMgTGlzdCwgZXhjbHVkaW5nXFxudGhlIGxhc3QgaW5kZXggaW4gdGhpcyBMaXN0LlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IHRoaXMgZGlmZmVycyBmcm9tIGBBcnJheSNwb3BgIGJlY2F1c2UgaXQgcmV0dXJucyBhIG5ld1xcbkxpc3QgcmF0aGVyIHRoYW4gdGhlIHJlbW92ZWQgdmFsdWUuIFVzZSBgbGFzdCgpYCB0byBnZXQgdGhlIGxhc3QgdmFsdWVcXG5pbiB0aGlzIExpc3QuXFxuXFxuYGBganNcXG5MaXN0KFsgMSwgMiwgMywgNCBdKS5wb3AoKVxcbi8vIExpc3RbIDEsIDIsIDMgXVxcbmBgYFxcblxcbk5vdGU6IGBwb3BgIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjozMTZ9XX0sXCIjdW5zaGlmdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IExpc3Qgd2l0aCB0aGUgcHJvdmlkZWQgYHZhbHVlc2AgcHJlcGVuZGVkLCBzaGlmdGluZyBvdGhlclxcbnZhbHVlcyBhaGVhZCB0byBoaWdoZXIgaW5kaWNlcy5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbkxpc3QoWyAyLCAzLCA0XSkudW5zaGlmdCgxKTtcXG4vLyBMaXN0IFsgMSwgMiwgMywgNCBdXFxuYGBgXFxuXFxuTm90ZTogYHVuc2hpZnRgIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVzXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MzMyfV19LFwiI3NoaWZ0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTGlzdCB3aXRoIGEgc2l6ZSBvbmVzIGxlc3MgdGhhbiB0aGlzIExpc3QsIGV4Y2x1ZGluZ1xcbnRoZSBmaXJzdCBpbmRleCBpbiB0aGlzIExpc3QsIHNoaWZ0aW5nIGFsbCBvdGhlciB2YWx1ZXMgdG8gYSBsb3dlciBpbmRleC5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiB0aGlzIGRpZmZlcnMgZnJvbSBgQXJyYXkjc2hpZnRgIGJlY2F1c2UgaXQgcmV0dXJucyBhIG5ld1xcbkxpc3QgcmF0aGVyIHRoYW4gdGhlIHJlbW92ZWQgdmFsdWUuIFVzZSBgZmlyc3QoKWAgdG8gZ2V0IHRoZSBmaXJzdFxcbnZhbHVlIGluIHRoaXMgTGlzdC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbkxpc3QoWyAwLCAxLCAyLCAzLCA0IF0pLnNoaWZ0KCk7XFxuLy8gTGlzdCBbIDEsIDIsIDMsIDQgXVxcbmBgYFxcblxcbk5vdGU6IGBzaGlmdGAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjM1Mn1dfSxcIiN1cGRhdGVcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBMaXN0IHdpdGggYW4gdXBkYXRlZCB2YWx1ZSBhdCBgaW5kZXhgIHdpdGggdGhlIHJldHVyblxcbnZhbHVlIG9mIGNhbGxpbmcgYHVwZGF0ZXJgIHdpdGggdGhlIGV4aXN0aW5nIHZhbHVlLCBvciBgbm90U2V0VmFsdWVgIGlmXFxuYGluZGV4YCB3YXMgbm90IHNldC4gSWYgY2FsbGVkIHdpdGggYSBzaW5nbGUgYXJndW1lbnQsIGB1cGRhdGVyYCBpc1xcbmNhbGxlZCB3aXRoIHRoZSBMaXN0IGl0c2VsZi5cIixcImRlc2NyaXB0aW9uXCI6XCJgaW5kZXhgIG1heSBiZSBhIG5lZ2F0aXZlIG51bWJlciwgd2hpY2ggaW5kZXhlcyBiYWNrIGZyb20gdGhlIGVuZCBvZiB0aGVcXG5MaXN0LiBgdi51cGRhdGUoLTEpYCB1cGRhdGVzIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIExpc3QuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5jb25zdCBsaXN0ID0gTGlzdChbICdhJywgJ2InLCAnYycgXSlcXG5jb25zdCByZXN1bHQgPSBsaXN0LnVwZGF0ZSgyLCB2YWwgPT4gdmFsLnRvVXBwZXJDYXNlKCkpXFxuLy8gTGlzdCBbIFxcXCJhXFxcIiwgXFxcImJcXFwiLCBcXFwiQ1xcXCIgXVxcbmBgYFxcblxcblRoaXMgY2FuIGJlIHZlcnkgdXNlZnVsIGFzIGEgd2F5IHRvIFxcXCJjaGFpblxcXCIgYSBub3JtYWwgZnVuY3Rpb24gaW50byBhXFxuc2VxdWVuY2Ugb2YgbWV0aG9kcy4gUnhKUyBjYWxscyB0aGlzIFxcXCJsZXRcXFwiIGFuZCBsb2Rhc2ggY2FsbHMgaXQgXFxcInRocnVcXFwiLlxcblxcbkZvciBleGFtcGxlLCB0byBzdW0gYSBMaXN0IGFmdGVyIG1hcHBpbmcgYW5kIGZpbHRlcmluZzpcXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmZ1bmN0aW9uIHN1bShjb2xsZWN0aW9uKSB7XFxuICByZXR1cm4gY29sbGVjdGlvbi5yZWR1Y2UoKHN1bSwgeCkgPT4gc3VtICsgeCwgMClcXG59XFxuXFxuTGlzdChbIDEsIDIsIDMgXSlcXG4gIC5tYXAoeCA9PiB4ICsgMSlcXG4gIC5maWx0ZXIoeCA9PiB4ICUgMiA9PT0gMClcXG4gIC51cGRhdGUoc3VtKVxcbi8vIDZcXG5gYGBcXG5cXG5Ob3RlOiBgdXBkYXRlKGluZGV4KWAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI3VwZGF0ZWBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6Mzk2fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6Mzk3fSx7XCJ0eXBlUGFyYW1zXCI6W1wiUlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ1cGRhdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiUlwifX19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJSXCJ9LFwibGluZVwiOjM5OH1dfSxcIiNzZXRTaXplXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTGlzdCB3aXRoIHNpemUgYHNpemVgLiBJZiBgc2l6ZWAgaXMgbGVzcyB0aGFuIHRoaXNcXG5MaXN0J3Mgc2l6ZSwgdGhlIG5ldyBMaXN0IHdpbGwgZXhjbHVkZSB2YWx1ZXMgYXQgdGhlIGhpZ2hlciBpbmRpY2VzLlxcbklmIGBzaXplYCBpcyBncmVhdGVyIHRoYW4gdGhpcyBMaXN0J3Mgc2l6ZSwgdGhlIG5ldyBMaXN0IHdpbGwgaGF2ZVxcbnVuZGVmaW5lZCB2YWx1ZXMgZm9yIHRoZSBuZXdseSBhdmFpbGFibGUgaW5kaWNlcy5cIixcImRlc2NyaXB0aW9uXCI6XCJXaGVuIGJ1aWxkaW5nIGEgbmV3IExpc3QgYW5kIHRoZSBmaW5hbCBzaXplIGlzIGtub3duIHVwIGZyb250LCBgc2V0U2l6ZWBcXG51c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYHdpdGhNdXRhdGlvbnNgIG1heSByZXN1bHQgaW4gdGhlIG1vcmVcXG5wZXJmb3JtYW50IGNvbnN0cnVjdGlvbi5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwic2l6ZVwiLFwidHlwZVwiOntcImtcIjoyfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6NDEwfV19fX0se1widGl0bGVcIjpcIkRlZXAgcGVyc2lzdGVudCBjaGFuZ2VzXCIsXCJtZW1iZXJzXCI6e1wiI3NldEluXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTGlzdCBoYXZpbmcgc2V0IGB2YWx1ZWAgYXQgdGhpcyBga2V5UGF0aGAuIElmIGFueSBrZXlzIGluXFxuYGtleVBhdGhgIGRvIG5vdCBleGlzdCwgYSBuZXcgaW1tdXRhYmxlIE1hcCB3aWxsIGJlIGNyZWF0ZWQgYXQgdGhhdCBrZXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiSW5kZXggbnVtYmVycyBhcmUgdXNlZCBhcyBrZXlzIHRvIGRldGVybWluZSB0aGUgcGF0aCB0byBmb2xsb3cgaW5cXG50aGUgTGlzdC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBsaXN0ID0gTGlzdChbIDAsIDEsIDIsIExpc3QoWyAzLCA0IF0pXSlcXG5saXN0LnNldEluKFszLCAwXSwgOTk5KTtcXG4vLyBMaXN0IFsgMCwgMSwgMiwgTGlzdCBbIDk5OSwgNCBdIF1cXG5gYGBcXG5cXG5QbGFpbiBKYXZhU2NyaXB0IE9iamVjdCBvciBBcnJheXMgbWF5IGJlIG5lc3RlZCB3aXRoaW4gYW4gSW1tdXRhYmxlLmpzXFxuQ29sbGVjdGlvbiwgYW5kIHNldEluKCkgY2FuIHVwZGF0ZSB0aG9zZSB2YWx1ZXMgYXMgd2VsbCwgdHJlYXRpbmcgdGhlbVxcbmltbXV0YWJseSBieSBjcmVhdGluZyBuZXcgY29waWVzIG9mIHRob3NlIHZhbHVlcyB3aXRoIHRoZSBjaGFuZ2VzIGFwcGxpZWQuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3QgbGlzdCA9IExpc3QoWyAwLCAxLCAyLCB7IHBsYWluOiAnb2JqZWN0JyB9XSlcXG5saXN0LnNldEluKFszLCAncGxhaW4nXSwgJ3ZhbHVlJyk7XFxuLy8gTGlzdChbIDAsIDEsIDIsIHsgcGxhaW46ICd2YWx1ZScgfV0pXFxuYGBgXFxuXFxuTm90ZTogYHNldEluYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX0se1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo0NDR9XX0sXCIjZGVsZXRlSW5cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBMaXN0IGhhdmluZyByZW1vdmVkIHRoZSB2YWx1ZSBhdCB0aGlzIGBrZXlQYXRoYC4gSWYgYW55XFxua2V5cyBpbiBga2V5UGF0aGAgZG8gbm90IGV4aXN0LCBubyBjaGFuZ2Ugd2lsbCBvY2N1ci5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBsaXN0ID0gTGlzdChbIDAsIDEsIDIsIExpc3QoWyAzLCA0IF0pXSlcXG5saXN0LmRlbGV0ZUluKFszLCAwXSk7XFxuLy8gTGlzdCBbIDAsIDEsIDIsIExpc3QgWyA0IF0gXVxcbmBgYFxcblxcblBsYWluIEphdmFTY3JpcHQgT2JqZWN0IG9yIEFycmF5cyBtYXkgYmUgbmVzdGVkIHdpdGhpbiBhbiBJbW11dGFibGUuanNcXG5Db2xsZWN0aW9uLCBhbmQgcmVtb3ZlSW4oKSBjYW4gdXBkYXRlIHRob3NlIHZhbHVlcyBhcyB3ZWxsLCB0cmVhdGluZyB0aGVtXFxuaW1tdXRhYmx5IGJ5IGNyZWF0aW5nIG5ldyBjb3BpZXMgb2YgdGhvc2UgdmFsdWVzIHdpdGggdGhlIGNoYW5nZXMgYXBwbGllZC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBsaXN0ID0gTGlzdChbIDAsIDEsIDIsIHsgcGxhaW46ICdvYmplY3QnIH1dKVxcbmxpc3QucmVtb3ZlSW4oWzMsICdwbGFpbiddKTtcXG4vLyBMaXN0KFsgMCwgMSwgMiwge31dKVxcbmBgYFxcblxcbk5vdGU6IGBkZWxldGVJbmAgKmNhbm5vdCogYmUgc2FmZWx5IHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwiYWxpYXNcIixcImJvZHlcIjpcInJlbW92ZUluXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlQYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjQ3NH1dfSxcIiN1cGRhdGVJblwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJOb3RlOiBgdXBkYXRlSW5gIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cXG5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiYE1hcCN1cGRhdGVJbmBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fSx7XCJuYW1lXCI6XCJ1cGRhdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjQ4Mn0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX0se1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxN319fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo0ODN9XX0sXCIjbWVyZ2VJblwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJOb3RlOiBgbWVyZ2VJbmAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI21lcmdlSW5gXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlQYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX19LHtcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NDkwfV19LFwiI21lcmdlRGVlcEluXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIk5vdGU6IGBtZXJnZURlZXBJbmAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI21lcmdlRGVlcEluYFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5UGF0aFwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19fSx7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjQ5N31dfX19LHtcInRpdGxlXCI6XCJUcmFuc2llbnQgY2hhbmdlc1wiLFwibWVtYmVyc1wiOntcIiN3aXRoTXV0YXRpb25zXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIk5vdGU6IE5vdCBhbGwgbWV0aG9kcyBjYW4gYmUgc2FmZWx5IHVzZWQgb24gYSBtdXRhYmxlIGNvbGxlY3Rpb24gb3Igd2l0aGluXFxuYHdpdGhNdXRhdGlvbnNgISBDaGVjayB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgZWFjaCBtZXRob2QgdG8gc2VlIGlmIGl0XFxuYWxsb3dzIGJlaW5nIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI3dpdGhNdXRhdGlvbnNgXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtdXRhdG9yXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibXV0YWJsZVwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MTd9fX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NTA4fV19LFwiI2FzTXV0YWJsZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJBbiBhbHRlcm5hdGl2ZSBBUEkgZm9yIHdpdGhNdXRhdGlvbnMoKVwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IE5vdCBhbGwgbWV0aG9kcyBjYW4gYmUgc2FmZWx5IHVzZWQgb24gYSBtdXRhYmxlIGNvbGxlY3Rpb24gb3Igd2l0aGluXFxuYHdpdGhNdXRhdGlvbnNgISBDaGVjayB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgZWFjaCBtZXRob2QgdG8gc2VlIGlmIGl0XFxuYWxsb3dzIGJlaW5nIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI2FzTXV0YWJsZWBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NTE5fV19LFwiI3dhc0FsdGVyZWRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcImBNYXAjd2FzQWx0ZXJlZGBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo1MjR9XX0sXCIjYXNJbW11dGFibGVcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcImBNYXAjYXNJbW11dGFibGVgXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjUyOX1dfX19LHtcInRpdGxlXCI6XCJTZXF1ZW5jZSBhbGdvcml0aG1zXCIsXCJtZW1iZXJzXCI6e1wiI2NvbmNhdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IExpc3Qgd2l0aCBvdGhlciB2YWx1ZXMgb3IgY29sbGVjdGlvbnMgY29uY2F0ZW5hdGVkIHRvIHRoaXMgb25lLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBjb25jYXRgIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cXG5cIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcImFsaWFzXCIsXCJib2R5XCI6XCJtZXJnZVwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZXNPckNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIkNcIn1dfSx7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifV19XX0sXCJsaW5lXCI6NTQwfV19LFwiI21hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IExpc3Qgd2l0aCB2YWx1ZXMgcGFzc2VkIHRocm91Z2ggYVxcbmBtYXBwZXJgIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuTGlzdChbIDEsIDIgXSkubWFwKHggPT4gMTAgKiB4KVxcbi8vIExpc3QgWyAxMCwgMjAgXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk1cIn19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6NTU1fV19LFwiI2ZsYXRNYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRmxhdC1tYXBzIHRoZSBMaXN0LCByZXR1cm5pbmcgYSBuZXcgTGlzdC5cIixcImRlc2NyaXB0aW9uXCI6XCJTaW1pbGFyIHRvIGBsaXN0Lm1hcCguLi4pLmZsYXR0ZW4odHJ1ZSlgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjU2NX1dfSxcIiNmaWx0ZXJcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBMaXN0IHdpdGggb25seSB0aGUgdmFsdWVzIGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWBcXG5mdW5jdGlvbiByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYGZpbHRlcigpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCByZXN1bHRzIGluXFxubm90IGZpbHRlcmluZyBvdXQgYW55IHZhbHVlcy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiRlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIkZcIn1dfSxcImxpbmVcIjo1Nzd9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxN319fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NTgxfV19LFwiI3ppcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgTGlzdCBcXFwiemlwcGVkXFxcIiB3aXRoIHRoZSBwcm92aWRlZCBjb2xsZWN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIkxpa2UgYHppcFdpdGhgLCBidXQgdXNpbmcgdGhlIGRlZmF1bHQgYHppcHBlcmA6IGNyZWF0aW5nIGFuIGBBcnJheWAuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5jb25zdCBhID0gTGlzdChbIDEsIDIsIDMgXSk7XFxuY29uc3QgYiA9IExpc3QoWyA0LCA1LCA2IF0pO1xcbmNvbnN0IGMgPSBhLnppcChiKTsgLy8gTGlzdCBbIFsgMSwgNCBdLCBbIDIsIDUgXSwgWyAzLCA2IF0gXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJVXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19XX0sXCJsaW5lXCI6NjAwfSx7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiLFwiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlclwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX0se1wibmFtZVwiOlwib3RoZXIyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfSxcImxpbmVcIjo2MDF9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJsaW5lXCI6NjAyfV19LFwiI3ppcEFsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgTGlzdCBcXFwiemlwcGVkXFxcIiB3aXRoIHRoZSBwcm92aWRlZCBjb2xsZWN0aW9ucy5cIixcImRlc2NyaXB0aW9uXCI6XCJVbmxpa2UgYHppcGAsIGB6aXBBbGxgIGNvbnRpbnVlcyB6aXBwaW5nIHVudGlsIHRoZSBsb25nZXN0IGNvbGxlY3Rpb24gaXNcXG5leGhhdXN0ZWQuIE1pc3NpbmcgdmFsdWVzIGZyb20gc2hvcnRlciBjb2xsZWN0aW9ucyBhcmUgZmlsbGVkIHdpdGggYHVuZGVmaW5lZGAuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5jb25zdCBhID0gTGlzdChbIDEsIDIgXSk7XFxuY29uc3QgYiA9IExpc3QoWyAzLCA0LCA1IF0pO1xcbmNvbnN0IGMgPSBhLnppcEFsbChiKTsgLy8gTGlzdCBbIFsgMSwgMyBdLCBbIDIsIDQgXSwgWyB1bmRlZmluZWQsIDUgXSBdXFxuYGBgXFxuXFxuTm90ZTogU2luY2UgemlwQWxsIHdpbGwgcmV0dXJuIGEgY29sbGVjdGlvbiBhcyBsYXJnZSBhcyB0aGUgbGFyZ2VzdFxcbmlucHV0LCBzb21lIHJlc3VsdHMgbWF5IGNvbnRhaW4gdW5kZWZpbmVkIHZhbHVlcy4gVHlwZVNjcmlwdCBjYW5ub3RcXG5hY2NvdW50IGZvciB0aGVzZSB3aXRob3V0IGNhc2VzIChhcyBvZiB2Mi41KS5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlclwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfV19LFwibGluZVwiOjYyM30se1widHlwZVBhcmFtc1wiOltcIlVcIixcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib3RoZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19LHtcIm5hbWVcIjpcIm90aGVyMlwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XX0sXCJsaW5lXCI6NjI0fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwibGluZVwiOjYyNX1dfSxcIiN6aXBXaXRoXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBMaXN0IFxcXCJ6aXBwZWRcXFwiIHdpdGggdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb25zIGJ5IHVzaW5nIGFcXG5jdXN0b20gYHppcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5jb25zdCBhID0gTGlzdChbIDEsIDIsIDMgXSk7XFxuY29uc3QgYiA9IExpc3QoWyA0LCA1LCA2IF0pO1xcbmNvbnN0IGMgPSBhLnppcFdpdGgoKGEsIGIpID0+IGEgKyBiLCBiKTtcXG4vLyBMaXN0IFsgNSwgNywgOSBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlVcIixcIlpcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiemlwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJvdGhlclZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlpcIn19fSx7XCJuYW1lXCI6XCJvdGhlckNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifV19LFwibGluZVwiOjY0MX0se1widHlwZVBhcmFtc1wiOltcIlVcIixcIlZcIixcIlpcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiemlwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJvdGhlclZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifX0se1wibmFtZVwiOlwidGhpcmRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9fX0se1wibmFtZVwiOlwib3RoZXJDb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fSx7XCJuYW1lXCI6XCJ0aGlyZENvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifV19LFwibGluZVwiOjY0NX0se1widHlwZVBhcmFtc1wiOltcIlpcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiemlwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiYW55XCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlpcIn19fSx7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9XX0sXCJsaW5lXCI6NjUwfV19fX1dfX0sXCJNYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiSW1tdXRhYmxlIE1hcCBpcyBhbiB1bm9yZGVyZWQgQ29sbGVjdGlvbi5LZXllZCBvZiAoa2V5LCB2YWx1ZSkgcGFpcnMgd2l0aFxcbmBPKGxvZzMyIE4pYCBnZXRzIGFuZCBgTyhsb2czMiBOKWAgcGVyc2lzdGVudCBzZXRzLlwiLFwiZGVzY3JpcHRpb25cIjpcIkl0ZXJhdGlvbiBvcmRlciBvZiBhIE1hcCBpcyB1bmRlZmluZWQsIGhvd2V2ZXIgaXMgc3RhYmxlLiBNdWx0aXBsZVxcbml0ZXJhdGlvbnMgb2YgdGhlIHNhbWUgTWFwIHdpbGwgaXRlcmF0ZSBpbiB0aGUgc2FtZSBvcmRlci5cXG5cXG5NYXAncyBrZXlzIGNhbiBiZSBvZiBhbnkgdHlwZSwgYW5kIHVzZSBgSW1tdXRhYmxlLmlzYCB0byBkZXRlcm1pbmUga2V5XFxuZXF1YWxpdHkuIFRoaXMgYWxsb3dzIHRoZSB1c2Ugb2YgYW55IHZhbHVlIChpbmNsdWRpbmcgTmFOKSBhcyBhIGtleS5cXG5cXG5CZWNhdXNlIGBJbW11dGFibGUuaXNgIHJldHVybnMgZXF1YWxpdHkgYmFzZWQgb24gdmFsdWUgc2VtYW50aWNzLCBhbmRcXG5JbW11dGFibGUgY29sbGVjdGlvbnMgYXJlIHRyZWF0ZWQgYXMgdmFsdWVzLCBhbnkgSW1tdXRhYmxlIGNvbGxlY3Rpb24gbWF5XFxuYmUgdXNlZCBhcyBhIGtleS5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwLCBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXG5NYXAoKS5zZXQoTGlzdChbIDEgXSksICdsaXN0b2ZvbmUnKS5nZXQoTGlzdChbIDEgXSkpO1xcbi8vICdsaXN0b2ZvbmUnXFxuYGBgXFxuXFxuQW55IEphdmFTY3JpcHQgb2JqZWN0IG1heSBiZSB1c2VkIGFzIGEga2V5LCBob3dldmVyIHN0cmljdCBpZGVudGl0eSBpcyB1c2VkXFxudG8gZXZhbHVhdGUga2V5IGVxdWFsaXR5LiBUd28gc2ltaWxhciBsb29raW5nIG9iamVjdHMgd2lsbCByZXByZXNlbnQgdHdvXFxuZGlmZmVyZW50IGtleXMuXFxuXFxuSW1wbGVtZW50ZWQgYnkgYSBoYXNoLWFycmF5IG1hcHBlZCB0cmllLlwiLFwibm90ZXNcIjpbXX0sXCJtb2R1bGVcIjp7XCJpc01hcFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYSBNYXBcIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbk1hcC5pc01hcCh7fSkgLy8gZmFsc2VcXG5NYXAuaXNNYXAoTWFwKCkpIC8vIHRydWVcXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVNYXBcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjY5Nn1dfX19LFwiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDcmVhdGVzIGEgbmV3IEltbXV0YWJsZSBNYXAuXCIsXCJkZXNjcmlwdGlvblwiOlwiQ3JlYXRlZCB3aXRoIHRoZSBzYW1lIGtleSB2YWx1ZSBwYWlycyBhcyB0aGUgcHJvdmlkZWQgQ29sbGVjdGlvbi5LZXllZCBvclxcbkphdmFTY3JpcHQgT2JqZWN0IG9yIGV4cGVjdHMgYSBDb2xsZWN0aW9uIG9mIFtLLCBWXSB0dXBsZSBlbnRyaWVzLlxcblxcbk5vdGU6IGBNYXBgIGlzIGEgZmFjdG9yeSBmdW5jdGlvbiBhbmQgbm90IGEgY2xhc3MsIGFuZCBkb2VzIG5vdCB1c2UgdGhlXFxuYG5ld2Aga2V5d29yZCBkdXJpbmcgY29uc3RydWN0aW9uLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuTWFwKHsga2V5OiBcXFwidmFsdWVcXFwiIH0pXFxuTWFwKFsgWyBcXFwia2V5XFxcIiwgXFxcInZhbHVlXFxcIiBdIF0pXFxuYGBgXFxuXFxuS2VlcCBpbiBtaW5kLCB3aGVuIHVzaW5nIEpTIG9iamVjdHMgdG8gY29uc3RydWN0IEltbXV0YWJsZSBNYXBzLCB0aGF0XFxuSmF2YVNjcmlwdCBPYmplY3QgcHJvcGVydGllcyBhcmUgYWx3YXlzIHN0cmluZ3MsIGV2ZW4gaWYgd3JpdHRlbiBpbiBhXFxucXVvdGUtbGVzcyBzaG9ydGhhbmQsIHdoaWxlIEltbXV0YWJsZSBNYXBzIGFjY2VwdCBrZXlzIG9mIGFueSB0eXBlLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IE1hcCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5sZXQgb2JqID0geyAxOiBcXFwib25lXFxcIiB9XFxuT2JqZWN0LmtleXMob2JqKSAvLyBbIFxcXCIxXFxcIiBdXFxuYXNzZXJ0LmVxdWFsKG9ialtcXFwiMVxcXCJdLCBvYmpbMV0pIC8vIFxcXCJvbmVcXFwiID09PSBcXFwib25lXFxcIlxcblxcbmxldCBtYXAgPSBNYXAob2JqKVxcbmFzc2VydC5ub3RFcXVhbChtYXAuZ2V0KFxcXCIxXFxcIiksIG1hcC5nZXQoMSkpIC8vIFxcXCJvbmVcXFwiICE9PSB1bmRlZmluZWRcXG5gYGBcXG5cXG5Qcm9wZXJ0eSBhY2Nlc3MgZm9yIEphdmFTY3JpcHQgT2JqZWN0cyBmaXJzdCBjb252ZXJ0cyB0aGUga2V5IHRvIGEgc3RyaW5nLFxcbmJ1dCBzaW5jZSBJbW11dGFibGUgTWFwIGtleXMgY2FuIGJlIG9mIGFueSB0eXBlIHRoZSBhcmd1bWVudCB0byBgZ2V0KClgIGlzXFxubm90IGFsdGVyZWQuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktcIixcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTWFwXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjc1M30se1widHlwZVBhcmFtc1wiOltcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib2JqXCIsXCJ0eXBlXCI6e1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJNYXBcIixcImFyZ3NcIjpbe1wia1wiOjN9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjo3NTR9LHtcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCJdLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTWFwXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjc1NX0se1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTWFwXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19LFwibGluZVwiOjc1Nn1dfSxcImludGVyZmFjZVwiOntcImxpbmVcIjo3NTgsXCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiXSxcImV4dGVuZHNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XSxcImdyb3Vwc1wiOlt7XCJtZW1iZXJzXCI6e1wiI3NpemVcIjp7XCJsaW5lXCI6NzYzfX19LHtcInRpdGxlXCI6XCJQZXJzaXN0ZW50IGNoYW5nZXNcIixcIm1lbWJlcnNcIjp7XCIjc2V0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTWFwIGFsc28gY29udGFpbmluZyB0aGUgbmV3IGtleSwgdmFsdWUgcGFpci4gSWYgYW4gZXF1aXZhbGVudFxcbmtleSBhbHJlYWR5IGV4aXN0cyBpbiB0aGlzIE1hcCwgaXQgd2lsbCBiZSByZXBsYWNlZC5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG9yaWdpbmFsTWFwID0gTWFwKClcXG5jb25zdCBuZXdlck1hcCA9IG9yaWdpbmFsTWFwLnNldCgna2V5JywgJ3ZhbHVlJylcXG5jb25zdCBuZXdlc3RNYXAgPSBuZXdlck1hcC5zZXQoJ2tleScsICduZXdlciB2YWx1ZScpXFxuXFxub3JpZ2luYWxNYXBcXG4vLyBNYXAge31cXG5uZXdlck1hcFxcbi8vIE1hcCB7IFxcXCJrZXlcXFwiOiBcXFwidmFsdWVcXFwiIH1cXG5uZXdlc3RNYXBcXG4vLyBNYXAgeyBcXFwia2V5XFxcIjogXFxcIm5ld2VyIHZhbHVlXFxcIiB9XFxuYGBgXFxuXFxuTm90ZTogYHNldGAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjc4OH1dfSxcIiNkZWxldGVcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBNYXAgd2hpY2ggZXhjbHVkZXMgdGhpcyBga2V5YC5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgZGVsZXRlYCBjYW5ub3QgYmUgc2FmZWx5IHVzZWQgaW4gSUU4LCBidXQgaXMgcHJvdmlkZWQgdG8gbWlycm9yXFxudGhlIEVTNiBjb2xsZWN0aW9uIEFQSS5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG9yaWdpbmFsTWFwID0gTWFwKHtcXG4gIGtleTogJ3ZhbHVlJyxcXG4gIG90aGVyS2V5OiAnb3RoZXIgdmFsdWUnXFxufSlcXG4vLyBNYXAgeyBcXFwia2V5XFxcIjogXFxcInZhbHVlXFxcIiwgXFxcIm90aGVyS2V5XFxcIjogXFxcIm90aGVyIHZhbHVlXFxcIiB9XFxub3JpZ2luYWxNYXAuZGVsZXRlKCdvdGhlcktleScpXFxuLy8gTWFwIHsgXFxcImtleVxcXCI6IFxcXCJ2YWx1ZVxcXCIgfVxcbmBgYFxcblxcbk5vdGU6IGBkZWxldGVgIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cXG5cIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcImFsaWFzXCIsXCJib2R5XCI6XCJyZW1vdmVcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjgxMn1dfSxcIiNkZWxldGVBbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBNYXAgd2hpY2ggZXhjbHVkZXMgdGhlIHByb3ZpZGVkIGBrZXlzYC5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG5hbWVzID0gTWFwKHsgYTogXFxcIkFhcm9uXFxcIiwgYjogXFxcIkJhcnJ5XFxcIiwgYzogXFxcIkNvbm5vclxcXCIgfSlcXG5uYW1lcy5kZWxldGVBbGwoWyAnYScsICdjJyBdKVxcbi8vIE1hcCB7IFxcXCJiXFxcIjogXFxcIkJhcnJ5XFxcIiB9XFxuYGBgXFxuXFxuTm90ZTogYGRlbGV0ZUFsbGAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwiYWxpYXNcIixcImJvZHlcIjpcInJlbW92ZUFsbFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5c1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifV19fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo4MzB9XX0sXCIjY2xlYXJcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBNYXAgY29udGFpbmluZyBubyBrZXlzIG9yIHZhbHVlcy5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbk1hcCh7IGtleTogJ3ZhbHVlJyB9KS5jbGVhcigpXFxuLy8gTWFwIHt9XFxuYGBgXFxuXFxuTm90ZTogYGNsZWFyYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6ODQ1fV19LFwiI3VwZGF0ZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IE1hcCBoYXZpbmcgdXBkYXRlZCB0aGUgdmFsdWUgYXQgdGhpcyBga2V5YCB3aXRoIHRoZSByZXR1cm5cXG52YWx1ZSBvZiBjYWxsaW5nIGB1cGRhdGVyYCB3aXRoIHRoZSBleGlzdGluZyB2YWx1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJTaW1pbGFyIHRvOiBgbWFwLnNldChrZXksIHVwZGF0ZXIobWFwLmdldChrZXkpKSlgLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3QgYU1hcCA9IE1hcCh7IGtleTogJ3ZhbHVlJyB9KVxcbmNvbnN0IG5ld01hcCA9IGFNYXAudXBkYXRlKCdrZXknLCB2YWx1ZSA9PiB2YWx1ZSArIHZhbHVlKVxcbi8vIE1hcCB7IFxcXCJrZXlcXFwiOiBcXFwidmFsdWV2YWx1ZVxcXCIgfVxcbmBgYFxcblxcblRoaXMgaXMgbW9zdCBjb21tb25seSB1c2VkIHRvIGNhbGwgbWV0aG9kcyBvbiBjb2xsZWN0aW9ucyB3aXRoaW4gYVxcbnN0cnVjdHVyZSBvZiBkYXRhLiBGb3IgZXhhbXBsZSwgaW4gb3JkZXIgdG8gYC5wdXNoKClgIG9udG8gYSBuZXN0ZWQgYExpc3RgLFxcbmB1cGRhdGVgIGFuZCBgcHVzaGAgY2FuIGJlIHVzZWQgdG9nZXRoZXI6XFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTWFwLCBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmNvbnN0IGFNYXAgPSBNYXAoeyBuZXN0ZWRMaXN0OiBMaXN0KFsgMSwgMiwgMyBdKSB9KVxcbmNvbnN0IG5ld01hcCA9IGFNYXAudXBkYXRlKCduZXN0ZWRMaXN0JywgbGlzdCA9PiBsaXN0LnB1c2goNCkpXFxuLy8gTWFwIHsgXFxcIm5lc3RlZExpc3RcXFwiOiBMaXN0IFsgMSwgMiwgMywgNCBdIH1cXG5gYGBcXG5cXG5XaGVuIGEgYG5vdFNldFZhbHVlYCBpcyBwcm92aWRlZCwgaXQgaXMgcHJvdmlkZWQgdG8gdGhlIGB1cGRhdGVyYFxcbmZ1bmN0aW9uIHdoZW4gdGhlIHZhbHVlIGF0IHRoZSBrZXkgZG9lcyBub3QgZXhpc3QgaW4gdGhlIE1hcC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuY29uc3QgYU1hcCA9IE1hcCh7IGtleTogJ3ZhbHVlJyB9KVxcbmNvbnN0IG5ld01hcCA9IGFNYXAudXBkYXRlKCdub0tleScsICdubyB2YWx1ZScsIHZhbHVlID0+IHZhbHVlICsgdmFsdWUpXFxuLy8gTWFwIHsgXFxcImtleVxcXCI6IFxcXCJ2YWx1ZVxcXCIsIFxcXCJub0tleVxcXCI6IFxcXCJubyB2YWx1ZW5vIHZhbHVlXFxcIiB9XFxuYGBgXFxuXFxuSG93ZXZlciwgaWYgdGhlIGB1cGRhdGVyYCBmdW5jdGlvbiByZXR1cm5zIHRoZSBzYW1lIHZhbHVlIGl0IHdhcyBjYWxsZWRcXG53aXRoLCB0aGVuIG5vIGNoYW5nZSB3aWxsIG9jY3VyLiBUaGlzIGlzIHN0aWxsIHRydWUgaWYgYG5vdFNldFZhbHVlYFxcbmlzIHByb3ZpZGVkLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IE1hcCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5jb25zdCBhTWFwID0gTWFwKHsgYXBwbGVzOiAxMCB9KVxcbmNvbnN0IG5ld01hcCA9IGFNYXAudXBkYXRlKCdvcmFuZ2VzJywgMCwgdmFsID0+IHZhbClcXG4vLyBNYXAgeyBcXFwiYXBwbGVzXFxcIjogMTAgfVxcbmFzc2VydC5zdHJpY3RFcXVhbChuZXdNYXAsIG1hcCk7XFxuYGBgXFxuXFxuRm9yIGNvZGUgdXNpbmcgRVMyMDE1IG9yIGxhdGVyLCB1c2luZyBgbm90U2V0VmFsdWVgIGlzIGRpc2NvdXJnZWQgaW5cXG5mYXZvciBvZiBmdW5jdGlvbiBwYXJhbWV0ZXIgZGVmYXVsdCB2YWx1ZXMuIFRoaXMgaGVscHMgdG8gYXZvaWQgYW55XFxucG90ZW50aWFsIGNvbmZ1c2lvbiB3aXRoIGlkZW50aWZ5IGZ1bmN0aW9ucyBhcyBkZXNjcmliZWQgYWJvdmUuXFxuXFxuVGhlIHByZXZpb3VzIGV4YW1wbGUgYmVoYXZlcyBkaWZmZXJlbnRseSB3aGVuIHdyaXR0ZW4gd2l0aCBkZWZhdWx0IHZhbHVlczpcXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuY29uc3QgYU1hcCA9IE1hcCh7IGFwcGxlczogMTAgfSlcXG5jb25zdCBuZXdNYXAgPSBhTWFwLnVwZGF0ZSgnb3JhbmdlcycsICh2YWwgPSAwKSA9PiB2YWwpXFxuLy8gTWFwIHsgXFxcImFwcGxlc1xcXCI6IDEwLCBcXFwib3Jhbmdlc1xcXCI6IDAgfVxcbmBgYFxcblxcbklmIG5vIGtleSBpcyBwcm92aWRlZCwgdGhlbiB0aGUgYHVwZGF0ZXJgIGZ1bmN0aW9uIHJldHVybiB2YWx1ZSBpc1xcbnJldHVybmVkIGFzIHdlbGwuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmNvbnN0IGFNYXAgPSBNYXAoeyBrZXk6ICd2YWx1ZScgfSlcXG5jb25zdCByZXN1bHQgPSBhTWFwLnVwZGF0ZShhTWFwID0+IGFNYXAuZ2V0KCdrZXknKSlcXG4vLyBcXFwidmFsdWVcXFwiXFxuYGBgXFxuXFxuVGhpcyBjYW4gYmUgdmVyeSB1c2VmdWwgYXMgYSB3YXkgdG8gXFxcImNoYWluXFxcIiBhIG5vcm1hbCBmdW5jdGlvbiBpbnRvIGFcXG5zZXF1ZW5jZSBvZiBtZXRob2RzLiBSeEpTIGNhbGxzIHRoaXMgXFxcImxldFxcXCIgYW5kIGxvZGFzaCBjYWxscyBpdCBcXFwidGhydVxcXCIuXFxuXFxuRm9yIGV4YW1wbGUsIHRvIHN1bSB0aGUgdmFsdWVzIGluIGEgTWFwXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmZ1bmN0aW9uIHN1bShjb2xsZWN0aW9uKSB7XFxuICByZXR1cm4gY29sbGVjdGlvbi5yZWR1Y2UoKHN1bSwgeCkgPT4gc3VtICsgeCwgMClcXG59XFxuXFxuTWFwKHsgeDogMSwgeTogMiwgejogMyB9KVxcbiAgLm1hcCh4ID0+IHggKyAxKVxcbiAgLmZpbHRlcih4ID0+IHggJSAyID09PSAwKVxcbiAgLnVwZGF0ZShzdW0pXFxuLy8gNlxcbmBgYFxcblxcbk5vdGU6IGB1cGRhdGUoa2V5KWAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6OTQ5fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo5NTB9LHtcInR5cGVQYXJhbXNcIjpbXCJSXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJSXCJ9fX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlJcIn0sXCJsaW5lXCI6OTUxfV19LFwiI21lcmdlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTWFwIHJlc3VsdGluZyBmcm9tIG1lcmdpbmcgdGhlIHByb3ZpZGVkIENvbGxlY3Rpb25zXFxuKG9yIEpTIG9iamVjdHMpIGludG8gdGhpcyBNYXAuIEluIG90aGVyIHdvcmRzLCB0aGlzIHRha2VzIGVhY2ggZW50cnkgb2ZcXG5lYWNoIGNvbGxlY3Rpb24gYW5kIHNldHMgaXQgb24gdGhpcyBNYXAuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogVmFsdWVzIHByb3ZpZGVkIHRvIGBtZXJnZWAgYXJlIHNoYWxsb3dseSBjb252ZXJ0ZWQgYmVmb3JlIGJlaW5nXFxubWVyZ2VkLiBObyBuZXN0ZWQgdmFsdWVzIGFyZSBhbHRlcmVkLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgb25lID0gTWFwKHsgYTogMTAsIGI6IDIwLCBjOiAzMCB9KVxcbmNvbnN0IHR3byA9IE1hcCh7IGI6IDQwLCBhOiA1MCwgZDogNjAgfSlcXG5vbmUubWVyZ2UodHdvKSAvLyBNYXAgeyBcXFwiYVxcXCI6IDUwLCBcXFwiYlxcXCI6IDQwLCBcXFwiY1xcXCI6IDMwLCBcXFwiZFxcXCI6IDYwIH1cXG50d28ubWVyZ2Uob25lKSAvLyBNYXAgeyBcXFwiYlxcXCI6IDIwLCBcXFwiYVxcXCI6IDEwLCBcXFwiZFxcXCI6IDYwLCBcXFwiY1xcXCI6IDMwIH1cXG5gYGBcXG5cXG5Ob3RlOiBgbWVyZ2VgIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cXG5cIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcImFsaWFzXCIsXCJib2R5XCI6XCJjb25jYXRcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktDXCIsXCJWQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLQ1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWQ1wifV19XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJNYXBcIixcImFyZ3NcIjpbe1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJLQ1wifV19LHtcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVkNcIn1dfV19LFwibGluZVwiOjk3NH0se1widHlwZVBhcmFtc1wiOltcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjozfV19LHtcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifV19XX0sXCJsaW5lXCI6OTc1fV19LFwiI21lcmdlV2l0aFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJMaWtlIGBtZXJnZSgpYCwgYG1lcmdlV2l0aCgpYCByZXR1cm5zIGEgbmV3IE1hcCByZXN1bHRpbmcgZnJvbSBtZXJnaW5nXFxudGhlIHByb3ZpZGVkIENvbGxlY3Rpb25zIChvciBKUyBvYmplY3RzKSBpbnRvIHRoaXMgTWFwLCBidXQgdXNlcyB0aGVcXG5gbWVyZ2VyYCBmdW5jdGlvbiBmb3IgZGVhbGluZyB3aXRoIGNvbmZsaWN0cy5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG9uZSA9IE1hcCh7IGE6IDEwLCBiOiAyMCwgYzogMzAgfSlcXG5jb25zdCB0d28gPSBNYXAoeyBiOiA0MCwgYTogNTAsIGQ6IDYwIH0pXFxub25lLm1lcmdlV2l0aCgob2xkVmFsLCBuZXdWYWwpID0+IG9sZFZhbCAvIG5ld1ZhbCwgdHdvKVxcbi8vIHsgXFxcImFcXFwiOiAwLjIsIFxcXCJiXFxcIjogMC41LCBcXFwiY1xcXCI6IDMwLCBcXFwiZFxcXCI6IDYwIH1cXG50d28ubWVyZ2VXaXRoKChvbGRWYWwsIG5ld1ZhbCkgPT4gb2xkVmFsIC8gbmV3VmFsLCBvbmUpXFxuLy8geyBcXFwiYlxcXCI6IDIsIFxcXCJhXFxcIjogNSwgXFxcImRcXFwiOiA2MCwgXFxcImNcXFwiOiAzMCB9XFxuYGBgXFxuXFxuTm90ZTogYG1lcmdlV2l0aGAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtZXJnZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvbGRWYWxcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJuZXdWYWxcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX19LHtcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XX0se1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV19XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo5OTd9XX0sXCIjbWVyZ2VEZWVwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkxpa2UgYG1lcmdlKClgLCBidXQgd2hlbiB0d28gQ29sbGVjdGlvbnMgY29uZmxpY3QsIGl0IG1lcmdlcyB0aGVtIGFzIHdlbGwsXFxucmVjdXJzaW5nIGRlZXBseSB0aHJvdWdoIHRoZSBuZXN0ZWQgZGF0YS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBWYWx1ZXMgcHJvdmlkZWQgdG8gYG1lcmdlYCBhcmUgc2hhbGxvd2x5IGNvbnZlcnRlZCBiZWZvcmUgYmVpbmdcXG5tZXJnZWQuIE5vIG5lc3RlZCB2YWx1ZXMgYXJlIGFsdGVyZWQgdW5sZXNzIHRoZXkgd2lsbCBhbHNvIGJlIG1lcmdlZCBhdFxcbmEgZGVlcGVyIGxldmVsLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgb25lID0gTWFwKHsgYTogTWFwKHsgeDogMTAsIHk6IDEwIH0pLCBiOiBNYXAoeyB4OiAyMCwgeTogNTAgfSkgfSlcXG5jb25zdCB0d28gPSBNYXAoeyBhOiBNYXAoeyB4OiAyIH0pLCBiOiBNYXAoeyB5OiA1IH0pLCBjOiBNYXAoeyB6OiAzIH0pIH0pXFxub25lLm1lcmdlRGVlcCh0d28pXFxuLy8gTWFwIHtcXG4vLyAgIFxcXCJhXFxcIjogTWFwIHsgXFxcInhcXFwiOiAyLCBcXFwieVxcXCI6IDEwIH0sXFxuLy8gICBcXFwiYlxcXCI6IE1hcCB7IFxcXCJ4XFxcIjogMjAsIFxcXCJ5XFxcIjogNSB9LFxcbi8vICAgXFxcImNcXFwiOiBNYXAgeyBcXFwielxcXCI6IDMgfVxcbi8vIH1cXG5gYGBcXG5cXG5Ob3RlOiBgbWVyZ2VEZWVwYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XX0se1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV19XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxMDI1fV19LFwiI21lcmdlRGVlcFdpdGhcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiTGlrZSBgbWVyZ2VEZWVwKClgLCBidXQgd2hlbiB0d28gbm9uLUNvbGxlY3Rpb25zIGNvbmZsaWN0LCBpdCB1c2VzIHRoZVxcbmBtZXJnZXJgIGZ1bmN0aW9uIHRvIGRldGVybWluZSB0aGUgcmVzdWx0aW5nIHZhbHVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgb25lID0gTWFwKHsgYTogTWFwKHsgeDogMTAsIHk6IDEwIH0pLCBiOiBNYXAoeyB4OiAyMCwgeTogNTAgfSkgfSlcXG5jb25zdCB0d28gPSBNYXAoeyBhOiBNYXAoeyB4OiAyIH0pLCBiOiBNYXAoeyB5OiA1IH0pLCBjOiBNYXAoeyB6OiAzIH0pIH0pXFxub25lLm1lcmdlRGVlcFdpdGgoKG9sZFZhbCwgbmV3VmFsKSA9PiBvbGRWYWwgLyBuZXdWYWwsIHR3bylcXG4vLyBNYXAge1xcbi8vICAgXFxcImFcXFwiOiBNYXAgeyBcXFwieFxcXCI6IDUsIFxcXCJ5XFxcIjogMTAgfSxcXG4vLyAgIFxcXCJiXFxcIjogTWFwIHsgXFxcInhcXFwiOiAyMCwgXFxcInlcXFwiOiAxMCB9LFxcbi8vICAgXFxcImNcXFwiOiBNYXAgeyBcXFwielxcXCI6IDMgfVxcbi8vIH1cXG5gYGBcXG5cXG5Ob3RlOiBgbWVyZ2VEZWVwV2l0aGAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtZXJnZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvbGRWYWxcIixcInR5cGVcIjp7XCJrXCI6MTd9fSx7XCJuYW1lXCI6XCJuZXdWYWxcIixcInR5cGVcIjp7XCJrXCI6MTd9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19LHtcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XX0se1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV19XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxMDQ2fV19fX0se1widGl0bGVcIjpcIkRlZXAgcGVyc2lzdGVudCBjaGFuZ2VzXCIsXCJtZW1iZXJzXCI6e1wiI3NldEluXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTWFwIGhhdmluZyBzZXQgYHZhbHVlYCBhdCB0aGlzIGBrZXlQYXRoYC4gSWYgYW55IGtleXMgaW5cXG5ga2V5UGF0aGAgZG8gbm90IGV4aXN0LCBhIG5ldyBpbW11dGFibGUgTWFwIHdpbGwgYmUgY3JlYXRlZCBhdCB0aGF0IGtleS5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG9yaWdpbmFsTWFwID0gTWFwKHtcXG4gIHN1Yk9iamVjdDogTWFwKHtcXG4gICAgc3ViS2V5OiAnc3VidmFsdWUnLFxcbiAgICBzdWJTdWJPYmplY3Q6IE1hcCh7XFxuICAgICAgc3ViU3ViS2V5OiAnc3ViU3ViVmFsdWUnXFxuICAgIH0pXFxuICB9KVxcbn0pXFxuXFxuY29uc3QgbmV3TWFwID0gb3JpZ2luYWxNYXAuc2V0SW4oWydzdWJPYmplY3QnLCAnc3ViS2V5J10sICdoYSBoYSEnKVxcbi8vIE1hcCB7XFxuLy8gICBcXFwic3ViT2JqZWN0XFxcIjogTWFwIHtcXG4vLyAgICAgXFxcInN1YktleVxcXCI6IFxcXCJoYSBoYSFcXFwiLFxcbi8vICAgICBcXFwic3ViU3ViT2JqZWN0XFxcIjogTWFwIHsgXFxcInN1YlN1YktleVxcXCI6IFxcXCJzdWJTdWJWYWx1ZVxcXCIgfVxcbi8vICAgfVxcbi8vIH1cXG5cXG5jb25zdCBuZXdlck1hcCA9IG9yaWdpbmFsTWFwLnNldEluKFxcbiAgWydzdWJPYmplY3QnLCAnc3ViU3ViT2JqZWN0JywgJ3N1YlN1YktleSddLFxcbiAgJ2hhIGhhIGhhISdcXG4pXFxuLy8gTWFwIHtcXG4vLyAgIFxcXCJzdWJPYmplY3RcXFwiOiBNYXAge1xcbi8vICAgICBcXFwic3ViS2V5XFxcIjogXFxcInN1YnZhbHVlXFxcIixcXG4vLyAgICAgXFxcInN1YlN1Yk9iamVjdFxcXCI6IE1hcCB7IFxcXCJzdWJTdWJLZXlcXFwiOiBcXFwiaGEgaGEgaGEhXFxcIiB9XFxuLy8gICB9XFxuLy8gfVxcbmBgYFxcblxcblBsYWluIEphdmFTY3JpcHQgT2JqZWN0IG9yIEFycmF5cyBtYXkgYmUgbmVzdGVkIHdpdGhpbiBhbiBJbW11dGFibGUuanNcXG5Db2xsZWN0aW9uLCBhbmQgc2V0SW4oKSBjYW4gdXBkYXRlIHRob3NlIHZhbHVlcyBhcyB3ZWxsLCB0cmVhdGluZyB0aGVtXFxuaW1tdXRhYmx5IGJ5IGNyZWF0aW5nIG5ldyBjb3BpZXMgb2YgdGhvc2UgdmFsdWVzIHdpdGggdGhlIGNoYW5nZXMgYXBwbGllZC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG9yaWdpbmFsTWFwID0gTWFwKHtcXG4gIHN1Yk9iamVjdDoge1xcbiAgICBzdWJLZXk6ICdzdWJ2YWx1ZScsXFxuICAgIHN1YlN1Yk9iamVjdDoge1xcbiAgICAgIHN1YlN1YktleTogJ3N1YlN1YlZhbHVlJ1xcbiAgICB9XFxuICB9XFxufSlcXG5cXG5vcmlnaW5hbE1hcC5zZXRJbihbJ3N1Yk9iamVjdCcsICdzdWJLZXknXSwgJ2hhIGhhIScpXFxuLy8gTWFwIHtcXG4vLyAgIFxcXCJzdWJPYmplY3RcXFwiOiB7XFxuLy8gICAgIHN1YktleTogXFxcImhhIGhhIVxcXCIsXFxuLy8gICAgIHN1YlN1Yk9iamVjdDogeyBzdWJTdWJLZXk6IFxcXCJzdWJTdWJWYWx1ZVxcXCIgfVxcbi8vICAgfVxcbi8vIH1cXG5gYGBcXG5cXG5JZiBhbnkga2V5IGluIHRoZSBwYXRoIGV4aXN0cyBidXQgY2Fubm90IGJlIHVwZGF0ZWQgKHN1Y2ggYXMgYSBwcmltaXRpdmVcXG5saWtlIG51bWJlciBvciBhIGN1c3RvbSBPYmplY3QgbGlrZSBEYXRlKSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXFxuXFxuTm90ZTogYHNldEluYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX0se1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxMTIwfV19LFwiI2RlbGV0ZUluXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTWFwIGhhdmluZyByZW1vdmVkIHRoZSB2YWx1ZSBhdCB0aGlzIGBrZXlQYXRoYC4gSWYgYW55IGtleXNcXG5pbiBga2V5UGF0aGAgZG8gbm90IGV4aXN0LCBubyBjaGFuZ2Ugd2lsbCBvY2N1ci5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgZGVsZXRlSW5gIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cXG5cIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcImFsaWFzXCIsXCJib2R5XCI6XCJyZW1vdmVJblwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5UGF0aFwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxMTMwfV19LFwiI3VwZGF0ZUluXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTWFwIGhhdmluZyBhcHBsaWVkIHRoZSBgdXBkYXRlcmAgdG8gdGhlIGVudHJ5IGZvdW5kIGF0IHRoZVxcbmtleVBhdGguXCIsXCJkZXNjcmlwdGlvblwiOlwiVGhpcyBpcyBtb3N0IGNvbW1vbmx5IHVzZWQgdG8gY2FsbCBtZXRob2RzIG9uIGNvbGxlY3Rpb25zIG5lc3RlZCB3aXRoaW4gYVxcbnN0cnVjdHVyZSBvZiBkYXRhLiBGb3IgZXhhbXBsZSwgaW4gb3JkZXIgdG8gYC5wdXNoKClgIG9udG8gYSBuZXN0ZWQgYExpc3RgLFxcbmB1cGRhdGVJbmAgYW5kIGBwdXNoYCBjYW4gYmUgdXNlZCB0b2dldGhlcjpcXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwLCBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG1hcCA9IE1hcCh7IGluTWFwOiBNYXAoeyBpbkxpc3Q6IExpc3QoWyAxLCAyLCAzIF0pIH0pIH0pXFxuY29uc3QgbmV3TWFwID0gbWFwLnVwZGF0ZUluKFsnaW5NYXAnLCAnaW5MaXN0J10sIGxpc3QgPT4gbGlzdC5wdXNoKDQpKVxcbi8vIE1hcCB7IFxcXCJpbk1hcFxcXCI6IE1hcCB7IFxcXCJpbkxpc3RcXFwiOiBMaXN0IFsgMSwgMiwgMywgNCBdIH0gfVxcbmBgYFxcblxcbklmIGFueSBrZXlzIGluIGBrZXlQYXRoYCBkbyBub3QgZXhpc3QsIG5ldyBJbW11dGFibGUgYE1hcGBzIHdpbGxcXG5iZSBjcmVhdGVkIGF0IHRob3NlIGtleXMuIElmIHRoZSBga2V5UGF0aGAgZG9lcyBub3QgYWxyZWFkeSBjb250YWluIGFcXG52YWx1ZSwgdGhlIGB1cGRhdGVyYCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aXRoIGBub3RTZXRWYWx1ZWAsIGlmXFxucHJvdmlkZWQsIG90aGVyd2lzZSBgdW5kZWZpbmVkYC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxcIiB9XFxuLS0+XFxuYGBganNcXG5jb25zdCBtYXAgPSBNYXAoeyBhOiBNYXAoeyBiOiBNYXAoeyBjOiAxMCB9KSB9KSB9KVxcbmNvbnN0IG5ld01hcCA9IG1hcC51cGRhdGVJbihbJ2EnLCAnYicsICdjJ10sIHZhbCA9PiB2YWwgKiAyKVxcbi8vIE1hcCB7IFxcXCJhXFxcIjogTWFwIHsgXFxcImJcXFwiOiBNYXAgeyBcXFwiY1xcXCI6IDIwIH0gfSB9XFxuYGBgXFxuXFxuSWYgdGhlIGB1cGRhdGVyYCBmdW5jdGlvbiByZXR1cm5zIHRoZSBzYW1lIHZhbHVlIGl0IHdhcyBjYWxsZWQgd2l0aCwgdGhlblxcbm5vIGNoYW5nZSB3aWxsIG9jY3VyLiBUaGlzIGlzIHN0aWxsIHRydWUgaWYgYG5vdFNldFZhbHVlYCBpcyBwcm92aWRlZC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxcIiB9XFxuLS0+XFxuYGBganNcXG5jb25zdCBtYXAgPSBNYXAoeyBhOiBNYXAoeyBiOiBNYXAoeyBjOiAxMCB9KSB9KSB9KVxcbmNvbnN0IG5ld01hcCA9IG1hcC51cGRhdGVJbihbJ2EnLCAnYicsICd4J10sIDEwMCwgdmFsID0+IHZhbClcXG4vLyBNYXAgeyBcXFwiYVxcXCI6IE1hcCB7IFxcXCJiXFxcIjogTWFwIHsgXFxcImNcXFwiOiAxMCB9IH0gfVxcbmFzc2VydC5zdHJpY3RFcXVhbChuZXdNYXAsIGFNYXApXFxuYGBgXFxuXFxuRm9yIGNvZGUgdXNpbmcgRVMyMDE1IG9yIGxhdGVyLCB1c2luZyBgbm90U2V0VmFsdWVgIGlzIGRpc2NvdXJnZWQgaW5cXG5mYXZvciBvZiBmdW5jdGlvbiBwYXJhbWV0ZXIgZGVmYXVsdCB2YWx1ZXMuIFRoaXMgaGVscHMgdG8gYXZvaWQgYW55XFxucG90ZW50aWFsIGNvbmZ1c2lvbiB3aXRoIGlkZW50aWZ5IGZ1bmN0aW9ucyBhcyBkZXNjcmliZWQgYWJvdmUuXFxuXFxuVGhlIHByZXZpb3VzIGV4YW1wbGUgYmVoYXZlcyBkaWZmZXJlbnRseSB3aGVuIHdyaXR0ZW4gd2l0aCBkZWZhdWx0IHZhbHVlczpcXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxcIiB9XFxuLS0+XFxuYGBganNcXG5jb25zdCBtYXAgPSBNYXAoeyBhOiBNYXAoeyBiOiBNYXAoeyBjOiAxMCB9KSB9KSB9KVxcbmNvbnN0IG5ld01hcCA9IG1hcC51cGRhdGVJbihbJ2EnLCAnYicsICd4J10sICh2YWwgPSAxMDApID0+IHZhbClcXG4vLyBNYXAgeyBcXFwiYVxcXCI6IE1hcCB7IFxcXCJiXFxcIjogTWFwIHsgXFxcImNcXFwiOiAxMCwgXFxcInhcXFwiOiAxMDAgfSB9IH1cXG5gYGBcXG5cXG5QbGFpbiBKYXZhU2NyaXB0IE9iamVjdCBvciBBcnJheXMgbWF5IGJlIG5lc3RlZCB3aXRoaW4gYW4gSW1tdXRhYmxlLmpzXFxuQ29sbGVjdGlvbiwgYW5kIHVwZGF0ZUluKCkgY2FuIHVwZGF0ZSB0aG9zZSB2YWx1ZXMgYXMgd2VsbCwgdHJlYXRpbmcgdGhlbVxcbmltbXV0YWJseSBieSBjcmVhdGluZyBuZXcgY29waWVzIG9mIHRob3NlIHZhbHVlcyB3aXRoIHRoZSBjaGFuZ2VzIGFwcGxpZWQuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcXCIgfVxcbi0tPlxcbmBgYGpzXFxuY29uc3QgbWFwID0gTWFwKHsgYTogeyBiOiB7IGM6IDEwIH0gfSB9KVxcbmNvbnN0IG5ld01hcCA9IG1hcC51cGRhdGVJbihbJ2EnLCAnYicsICdjJ10sIHZhbCA9PiB2YWwgKiAyKVxcbi8vIE1hcCB7IFxcXCJhXFxcIjogeyBiOiB7IGM6IDIwIH0gfSB9XFxuYGBgXFxuXFxuSWYgYW55IGtleSBpbiB0aGUgcGF0aCBleGlzdHMgYnV0IGNhbm5vdCBiZSB1cGRhdGVkIChzdWNoIGFzIGEgcHJpbWl0aXZlXFxubGlrZSBudW1iZXIgb3IgYSBjdXN0b20gT2JqZWN0IGxpa2UgRGF0ZSksIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxcblxcbk5vdGU6IGB1cGRhdGVJbmAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlQYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX19LHtcIm5hbWVcIjpcIm5vdFNldFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX0se1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxN319fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxMjA5fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5UGF0aFwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19fSx7XCJuYW1lXCI6XCJ1cGRhdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjEyMTB9XX0sXCIjbWVyZ2VJblwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJBIGNvbWJpbmF0aW9uIG9mIGB1cGRhdGVJbmAgYW5kIGBtZXJnZWAsIHJldHVybmluZyBhIG5ldyBNYXAsIGJ1dFxcbnBlcmZvcm1pbmcgdGhlIG1lcmdlIGF0IGEgcG9pbnQgYXJyaXZlZCBhdCBieSBmb2xsb3dpbmcgdGhlIGtleVBhdGguXFxuSW4gb3RoZXIgd29yZHMsIHRoZXNlIHR3byBsaW5lcyBhcmUgZXF1aXZhbGVudDpcIixcImRlc2NyaXB0aW9uXCI6XCJgYGBqc1xcbm1hcC51cGRhdGVJbihbJ2EnLCAnYicsICdjJ10sIGFiYyA9PiBhYmMubWVyZ2UoeSkpXFxubWFwLm1lcmdlSW4oWydhJywgJ2InLCAnYyddLCB5KVxcbmBgYFxcblxcbk5vdGU6IGBtZXJnZUluYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX0se1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxMjI0fV19LFwiI21lcmdlRGVlcEluXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkEgY29tYmluYXRpb24gb2YgYHVwZGF0ZUluYCBhbmQgYG1lcmdlRGVlcGAsIHJldHVybmluZyBhIG5ldyBNYXAsIGJ1dFxcbnBlcmZvcm1pbmcgdGhlIGRlZXAgbWVyZ2UgYXQgYSBwb2ludCBhcnJpdmVkIGF0IGJ5IGZvbGxvd2luZyB0aGUga2V5UGF0aC5cXG5JbiBvdGhlciB3b3JkcywgdGhlc2UgdHdvIGxpbmVzIGFyZSBlcXVpdmFsZW50OlwiLFwiZGVzY3JpcHRpb25cIjpcImBgYGpzXFxubWFwLnVwZGF0ZUluKFsnYScsICdiJywgJ2MnXSwgYWJjID0+IGFiYy5tZXJnZURlZXAoeSkpXFxubWFwLm1lcmdlRGVlcEluKFsnYScsICdiJywgJ2MnXSwgeSlcXG5gYGBcXG5cXG5Ob3RlOiBgbWVyZ2VEZWVwSW5gIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5UGF0aFwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19fSx7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjEyMzh9XX19fSx7XCJ0aXRsZVwiOlwiVHJhbnNpZW50IGNoYW5nZXNcIixcIm1lbWJlcnNcIjp7XCIjd2l0aE11dGF0aW9uc1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJFdmVyeSB0aW1lIHlvdSBjYWxsIG9uZSBvZiB0aGUgYWJvdmUgZnVuY3Rpb25zLCBhIG5ldyBpbW11dGFibGUgTWFwIGlzXFxuY3JlYXRlZC4gSWYgYSBwdXJlIGZ1bmN0aW9uIGNhbGxzIGEgbnVtYmVyIG9mIHRoZXNlIHRvIHByb2R1Y2UgYSBmaW5hbFxcbnJldHVybiB2YWx1ZSwgdGhlbiBhIHBlbmFsdHkgb24gcGVyZm9ybWFuY2UgYW5kIG1lbW9yeSBoYXMgYmVlbiBwYWlkIGJ5XFxuY3JlYXRpbmcgYWxsIG9mIHRoZSBpbnRlcm1lZGlhdGUgaW1tdXRhYmxlIE1hcHMuXCIsXCJkZXNjcmlwdGlvblwiOlwiSWYgeW91IG5lZWQgdG8gYXBwbHkgYSBzZXJpZXMgb2YgbXV0YXRpb25zIHRvIHByb2R1Y2UgYSBuZXcgaW1tdXRhYmxlXFxuTWFwLCBgd2l0aE11dGF0aW9ucygpYCBjcmVhdGVzIGEgdGVtcG9yYXJ5IG11dGFibGUgY29weSBvZiB0aGUgTWFwIHdoaWNoXFxuY2FuIGFwcGx5IG11dGF0aW9ucyBpbiBhIGhpZ2hseSBwZXJmb3JtYW50IG1hbm5lci4gSW4gZmFjdCwgdGhpcyBpc1xcbmV4YWN0bHkgaG93IGNvbXBsZXggbXV0YXRpb25zIGxpa2UgYG1lcmdlYCBhcmUgZG9uZS5cXG5cXG5BcyBhbiBleGFtcGxlLCB0aGlzIHJlc3VsdHMgaW4gdGhlIGNyZWF0aW9uIG9mIDIsIG5vdCA0LCBuZXcgTWFwczpcXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG1hcDEgPSBNYXAoKVxcbmNvbnN0IG1hcDIgPSBtYXAxLndpdGhNdXRhdGlvbnMobWFwID0+IHtcXG4gIG1hcC5zZXQoJ2EnLCAxKS5zZXQoJ2InLCAyKS5zZXQoJ2MnLCAzKVxcbn0pXFxuYXNzZXJ0LmVxdWFsKG1hcDEuc2l6ZSwgMClcXG5hc3NlcnQuZXF1YWwobWFwMi5zaXplLCAzKVxcbmBgYFxcblxcbk5vdGU6IE5vdCBhbGwgbWV0aG9kcyBjYW4gYmUgdXNlZCBvbiBhIG11dGFibGUgY29sbGVjdGlvbiBvciB3aXRoaW5cXG5gd2l0aE11dGF0aW9uc2AhIFJlYWQgdGhlIGRvY3VtZW50YXRpb24gZm9yIGVhY2ggbWV0aG9kIHRvIHNlZSBpZiBpdFxcbmlzIHNhZmUgdG8gdXNlIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibXV0YXRvclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm11dGFibGVcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjEyNzB9XX0sXCIjYXNNdXRhYmxlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkFub3RoZXIgd2F5IHRvIGF2b2lkIGNyZWF0aW9uIG9mIGludGVybWVkaWF0ZSBJbW11dGFibGUgbWFwcyBpcyB0byBjcmVhdGVcXG5hIG11dGFibGUgY29weSBvZiB0aGlzIGNvbGxlY3Rpb24uIE11dGFibGUgY29waWVzICphbHdheXMqIHJldHVybiBgdGhpc2AsXFxuYW5kIHRodXMgc2hvdWxkbid0IGJlIHVzZWQgZm9yIGVxdWFsaXR5LiBZb3VyIGZ1bmN0aW9uIHNob3VsZCBuZXZlciByZXR1cm5cXG5hIG11dGFibGUgY29weSBvZiBhIGNvbGxlY3Rpb24sIG9ubHkgdXNlIGl0IGludGVybmFsbHkgdG8gY3JlYXRlIGEgbmV3XFxuY29sbGVjdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJJZiBwb3NzaWJsZSwgdXNlIGB3aXRoTXV0YXRpb25zYCB0byB3b3JrIHdpdGggdGVtcG9yYXJ5IG11dGFibGUgY29waWVzIGFzXFxuaXQgcHJvdmlkZXMgYW4gZWFzaWVyIHRvIHVzZSBBUEkgYW5kIGNvbnNpZGVycyBtYW55IGNvbW1vbiBvcHRpbWl6YXRpb25zLlxcblxcbk5vdGU6IGlmIHRoZSBjb2xsZWN0aW9uIGlzIGFscmVhZHkgbXV0YWJsZSwgYGFzTXV0YWJsZWAgcmV0dXJucyBpdHNlbGYuXFxuXFxuTm90ZTogTm90IGFsbCBtZXRob2RzIGNhbiBiZSB1c2VkIG9uIGEgbXV0YWJsZSBjb2xsZWN0aW9uIG9yIHdpdGhpblxcbmB3aXRoTXV0YXRpb25zYCEgUmVhZCB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgZWFjaCBtZXRob2QgdG8gc2VlIGlmIGl0XFxuaXMgc2FmZSB0byB1c2UgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI2FzSW1tdXRhYmxlYFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxMjkwfV19LFwiI3dhc0FsdGVyZWRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyB0cnVlIGlmIHRoaXMgaXMgYSBtdXRhYmxlIGNvcHkgKHNlZSBgYXNNdXRhYmxlKClgKSBhbmQgbXV0YXRpdmVcXG5hbHRlcmF0aW9ucyBoYXZlIGJlZW4gYXBwbGllZC5cXG5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiYE1hcCNhc011dGFibGVgXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6MTI5OH1dfSxcIiNhc0ltbXV0YWJsZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUaGUgeWluIHRvIGBhc011dGFibGVgJ3MgeWFuZy4gQmVjYXVzZSBpdCBhcHBsaWVzIHRvIG11dGFibGUgY29sbGVjdGlvbnMsXFxudGhpcyBvcGVyYXRpb24gaXMgKm11dGFibGUqIGFuZCBtYXkgcmV0dXJuIGl0c2VsZiAodGhvdWdoIG1heSBub3RcXG5yZXR1cm4gaXRzZWxmLCBpLmUuIGlmIHRoZSByZXN1bHQgaXMgYW4gZW1wdHkgY29sbGVjdGlvbikuIE9uY2VcXG5wZXJmb3JtZWQsIHRoZSBvcmlnaW5hbCBtdXRhYmxlIGNvcHkgbXVzdCBubyBsb25nZXIgYmUgbXV0YXRlZCBzaW5jZSBpdFxcbm1heSBiZSB0aGUgaW1tdXRhYmxlIHJlc3VsdC5cIixcImRlc2NyaXB0aW9uXCI6XCJJZiBwb3NzaWJsZSwgdXNlIGB3aXRoTXV0YXRpb25zYCB0byB3b3JrIHdpdGggdGVtcG9yYXJ5IG11dGFibGUgY29waWVzIGFzXFxuaXQgcHJvdmlkZXMgYW4gZWFzaWVyIHRvIHVzZSBBUEkgYW5kIGNvbnNpZGVycyBtYW55IGNvbW1vbiBvcHRpbWl6YXRpb25zLlxcblwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI2FzTXV0YWJsZWBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MTMxMn1dfX19LHtcInRpdGxlXCI6XCJTZXF1ZW5jZSBhbGdvcml0aG1zXCIsXCJtZW1iZXJzXCI6e1wiI21hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IE1hcCB3aXRoIHZhbHVlcyBwYXNzZWQgdGhyb3VnaCBhXFxuYG1hcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiICAgIE1hcCh7IGE6IDEsIGI6IDIgfSkubWFwKHggPT4gMTAgKiB4KVxcbiAgICAvLyBNYXAgeyBhOiAxMCwgYjogMjAgfVwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjoxMzIzfV19LFwiI21hcEtleXNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcIkNvbGxlY3Rpb24uS2V5ZWQubWFwS2V5c1wifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJNYXBcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6MTMzMX1dfSxcIiNtYXBFbnRyaWVzXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJDb2xsZWN0aW9uLktleWVkLm1hcEVudHJpZXNcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktNXCIsXCJWTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJlbnRyeVwiLFwidHlwZVwiOntcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19fSx7XCJuYW1lXCI6XCJpbmRleFwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLTVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWTVwifV19fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLTVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWTVwifV19LFwibGluZVwiOjEzMzl9XX0sXCIjZmxhdE1hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJGbGF0LW1hcHMgdGhlIE1hcCwgcmV0dXJuaW5nIGEgbmV3IE1hcC5cIixcImRlc2NyaXB0aW9uXCI6XCJTaW1pbGFyIHRvIGBkYXRhLm1hcCguLi4pLmZsYXR0ZW4odHJ1ZSlgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJLTVwiLFwiVk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS01cIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVk1cIn1dfV19fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLTVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWTVwifV19LFwibGluZVwiOjEzNDl9XX0sXCIjZmlsdGVyXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTWFwIHdpdGggb25seSB0aGUgZW50cmllcyBmb3Igd2hpY2ggdGhlIGBwcmVkaWNhdGVgXFxuZnVuY3Rpb24gcmV0dXJucyB0cnVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBmaWx0ZXIoKWAgYWx3YXlzIHJldHVybnMgYSBuZXcgaW5zdGFuY2UsIGV2ZW4gaWYgaXQgcmVzdWx0cyBpblxcbm5vdCBmaWx0ZXJpbmcgb3V0IGFueSB2YWx1ZXMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJNYXBcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJGXCJ9XX0sXCJsaW5lXCI6MTM2MX0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MTd9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjEzNjV9XX0sXCIjZmxpcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiQ29sbGVjdGlvbi5LZXllZC5mbGlwXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIktcIn1dfSxcImxpbmVcIjoxMzczfV19fX1dfX0sXCJPcmRlcmVkTWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkEgdHlwZSBvZiBNYXAgdGhhdCBoYXMgdGhlIGFkZGl0aW9uYWwgZ3VhcmFudGVlIHRoYXQgdGhlIGl0ZXJhdGlvbiBvcmRlciBvZlxcbmVudHJpZXMgd2lsbCBiZSB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSB3ZXJlIHNldCgpLlwiLFwiZGVzY3JpcHRpb25cIjpcIlRoZSBpdGVyYXRpb24gYmVoYXZpb3Igb2YgT3JkZXJlZE1hcCBpcyB0aGUgc2FtZSBhcyBuYXRpdmUgRVM2IE1hcCBhbmRcXG5KYXZhU2NyaXB0IE9iamVjdC5cXG5cXG5Ob3RlIHRoYXQgYE9yZGVyZWRNYXBgIGFyZSBtb3JlIGV4cGVuc2l2ZSB0aGFuIG5vbi1vcmRlcmVkIGBNYXBgIGFuZCBtYXlcXG5jb25zdW1lIG1vcmUgbWVtb3J5LiBgT3JkZXJlZE1hcCNzZXRgIGlzIGFtb3J0aXplZCBPKGxvZzMyIE4pLCBidXQgbm90XFxuc3RhYmxlLlwiLFwibm90ZXNcIjpbXX0sXCJtb2R1bGVcIjp7XCJpc09yZGVyZWRNYXBcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGFuIE9yZGVyZWRNYXAuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlT3JkZXJlZE1hcFwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6MTM5NH1dfX19LFwiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDcmVhdGVzIGEgbmV3IEltbXV0YWJsZSBPcmRlcmVkTWFwLlwiLFwiZGVzY3JpcHRpb25cIjpcIkNyZWF0ZWQgd2l0aCB0aGUgc2FtZSBrZXkgdmFsdWUgcGFpcnMgYXMgdGhlIHByb3ZpZGVkIENvbGxlY3Rpb24uS2V5ZWQgb3JcXG5KYXZhU2NyaXB0IE9iamVjdCBvciBleHBlY3RzIGEgQ29sbGVjdGlvbiBvZiBbSywgVl0gdHVwbGUgZW50cmllcy5cXG5cXG5UaGUgaXRlcmF0aW9uIG9yZGVyIG9mIGtleS12YWx1ZSBwYWlycyBwcm92aWRlZCB0byB0aGlzIGNvbnN0cnVjdG9yIHdpbGxcXG5iZSBwcmVzZXJ2ZWQgaW4gdGhlIE9yZGVyZWRNYXAuXFxuXFxuICAgIGxldCBuZXdPcmRlcmVkTWFwID0gT3JkZXJlZE1hcCh7a2V5OiBcXFwidmFsdWVcXFwifSlcXG4gICAgbGV0IG5ld09yZGVyZWRNYXAgPSBPcmRlcmVkTWFwKFtbXFxcImtleVxcXCIsIFxcXCJ2YWx1ZVxcXCJdXSlcXG5cXG5Ob3RlOiBgT3JkZXJlZE1hcGAgaXMgYSBmYWN0b3J5IGZ1bmN0aW9uIGFuZCBub3QgYSBjbGFzcywgYW5kIGRvZXMgbm90IHVzZVxcbnRoZSBgbmV3YCBrZXl3b3JkIGR1cmluZyBjb25zdHJ1Y3Rpb24uXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktcIixcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZE1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjoxNDEyfSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvYmpcIixcInR5cGVcIjp7XCJrXCI6NCxcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRNYXBcIixcImFyZ3NcIjpbe1wia1wiOjN9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjoxNDEzfSx7XCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiXSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRNYXBcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6MTQxNH0se1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZE1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfSxcImxpbmVcIjoxNDE1fV19LFwiaW50ZXJmYWNlXCI6e1wibGluZVwiOjE0MTcsXCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiXSxcImV4dGVuZHNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJNYXBcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dLFwiZ3JvdXBzXCI6W3tcIm1lbWJlcnNcIjp7XCIjc2l6ZVwiOntcImxpbmVcIjoxNDIyfSxcIiNzZXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBPcmRlcmVkTWFwIGFsc28gY29udGFpbmluZyB0aGUgbmV3IGtleSwgdmFsdWUgcGFpci4gSWYgYW5cXG5lcXVpdmFsZW50IGtleSBhbHJlYWR5IGV4aXN0cyBpbiB0aGlzIE9yZGVyZWRNYXAsIGl0IHdpbGwgYmUgcmVwbGFjZWRcXG53aGlsZSBtYWludGFpbmluZyB0aGUgZXhpc3Rpbmcgb3JkZXIuXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IE9yZGVyZWRNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgb3JpZ2luYWxNYXAgPSBPcmRlcmVkTWFwKHthOjEsIGI6MSwgYzoxfSlcXG5jb25zdCB1cGRhdGVkTWFwID0gb3JpZ2luYWxNYXAuc2V0KCdiJywgMilcXG5cXG5vcmlnaW5hbE1hcFxcbi8vIE9yZGVyZWRNYXAge2E6IDEsIGI6IDEsIGM6IDF9XFxudXBkYXRlZE1hcFxcbi8vIE9yZGVyZWRNYXAge2E6IDEsIGI6IDIsIGM6IDF9XFxuYGBgXFxuXFxuTm90ZTogYHNldGAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjE0NDN9XX0sXCIjbWVyZ2VcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBPcmRlcmVkTWFwIHJlc3VsdGluZyBmcm9tIG1lcmdpbmcgdGhlIHByb3ZpZGVkIENvbGxlY3Rpb25zXFxuKG9yIEpTIG9iamVjdHMpIGludG8gdGhpcyBPcmRlcmVkTWFwLiBJbiBvdGhlciB3b3JkcywgdGhpcyB0YWtlcyBlYWNoXFxuZW50cnkgb2YgZWFjaCBjb2xsZWN0aW9uIGFuZCBzZXRzIGl0IG9uIHRoaXMgT3JkZXJlZE1hcC5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBWYWx1ZXMgcHJvdmlkZWQgdG8gYG1lcmdlYCBhcmUgc2hhbGxvd2x5IGNvbnZlcnRlZCBiZWZvcmUgYmVpbmdcXG5tZXJnZWQuIE5vIG5lc3RlZCB2YWx1ZXMgYXJlIGFsdGVyZWQuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IE9yZGVyZWRNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgb25lID0gT3JkZXJlZE1hcCh7IGE6IDEwLCBiOiAyMCwgYzogMzAgfSlcXG5jb25zdCB0d28gPSBPcmRlcmVkTWFwKHsgYjogNDAsIGE6IDUwLCBkOiA2MCB9KVxcbm9uZS5tZXJnZSh0d28pIC8vIE9yZGVyZWRNYXAgeyBcXFwiYVxcXCI6IDUwLCBcXFwiYlxcXCI6IDQwLCBcXFwiY1xcXCI6IDMwLCBcXFwiZFxcXCI6IDYwIH1cXG50d28ubWVyZ2Uob25lKSAvLyBPcmRlcmVkTWFwIHsgXFxcImJcXFwiOiAyMCwgXFxcImFcXFwiOiAxMCwgXFxcImRcXFwiOiA2MCwgXFxcImNcXFwiOiAzMCB9XFxuYGBgXFxuXFxuTm90ZTogYG1lcmdlYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXFxuXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJhbGlhc1wiLFwiYm9keVwiOlwiY29uY2F0XCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJLQ1wiLFwiVkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS0NcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVkNcIn1dfV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZE1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIktDXCJ9XX0se1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWQ1wifV19XX0sXCJsaW5lXCI6MTQ2Nn0se1widHlwZVBhcmFtc1wiOltcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRNYXBcIixcImFyZ3NcIjpbe1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6M31dfSx7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIkNcIn1dfV19LFwibGluZVwiOjE0Njd9XX19fSx7XCJ0aXRsZVwiOlwiU2VxdWVuY2UgYWxnb3JpdGhtc1wiLFwibWVtYmVyc1wiOntcIiNtYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBPcmRlcmVkTWFwIHdpdGggdmFsdWVzIHBhc3NlZCB0aHJvdWdoIGFcXG5gbWFwcGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCIgICAgT3JkZXJlZE1hcCh7IGE6IDEsIGI6IDIgfSkubWFwKHggPT4gMTAgKiB4KVxcbiAgICAvLyBPcmRlcmVkTWFwIHsgXFxcImFcXFwiOiAxMCwgXFxcImJcXFwiOiAyMCB9XFxuXFxuTm90ZTogYG1hcCgpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCBwcm9kdWNlZCB0aGUgc2FtZVxcbnZhbHVlIGF0IGV2ZXJ5IHN0ZXAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk1cIn19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZE1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjoxNDgzfV19LFwiI21hcEtleXNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcIkNvbGxlY3Rpb24uS2V5ZWQubWFwS2V5c1wifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkTWFwXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjE0OTF9XX0sXCIjbWFwRW50cmllc1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiQ29sbGVjdGlvbi5LZXllZC5tYXBFbnRyaWVzXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJLTVwiLFwiVk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiZW50cnlcIixcInR5cGVcIjp7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX0se1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS01cIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVk1cIn1dfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkTWFwXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZNXCJ9XX0sXCJsaW5lXCI6MTQ5OX1dfSxcIiNmbGF0TWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkZsYXQtbWFwcyB0aGUgT3JkZXJlZE1hcCwgcmV0dXJuaW5nIGEgbmV3IE9yZGVyZWRNYXAuXCIsXCJkZXNjcmlwdGlvblwiOlwiU2ltaWxhciB0byBgZGF0YS5tYXAoLi4uKS5mbGF0dGVuKHRydWUpYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS01cIixcIlZNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZNXCJ9XX1dfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkTWFwXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZNXCJ9XX0sXCJsaW5lXCI6MTUwOX1dfSxcIiNmaWx0ZXJcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBPcmRlcmVkTWFwIHdpdGggb25seSB0aGUgZW50cmllcyBmb3Igd2hpY2ggdGhlIGBwcmVkaWNhdGVgXFxuZnVuY3Rpb24gcmV0dXJucyB0cnVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBmaWx0ZXIoKWAgYWx3YXlzIHJldHVybnMgYSBuZXcgaW5zdGFuY2UsIGV2ZW4gaWYgaXQgcmVzdWx0cyBpblxcbm5vdCBmaWx0ZXJpbmcgb3V0IGFueSB2YWx1ZXMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkTWFwXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiRlwifV19LFwibGluZVwiOjE1MjF9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxNTI1fV19LFwiI2ZsaXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcIkNvbGxlY3Rpb24uS2V5ZWQuZmxpcFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkTWFwXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifV19LFwibGluZVwiOjE1MzN9XX19fV19fSxcIlNldFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJBIENvbGxlY3Rpb24gb2YgdW5pcXVlIHZhbHVlcyB3aXRoIGBPKGxvZzMyIE4pYCBhZGRzIGFuZCBoYXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiV2hlbiBpdGVyYXRpbmcgYSBTZXQsIHRoZSBlbnRyaWVzIHdpbGwgYmUgKHZhbHVlLCB2YWx1ZSkgcGFpcnMuIEl0ZXJhdGlvblxcbm9yZGVyIG9mIGEgU2V0IGlzIHVuZGVmaW5lZCwgaG93ZXZlciBpcyBzdGFibGUuIE11bHRpcGxlIGl0ZXJhdGlvbnMgb2YgdGhlXFxuc2FtZSBTZXQgd2lsbCBpdGVyYXRlIGluIHRoZSBzYW1lIG9yZGVyLlxcblxcblNldCB2YWx1ZXMsIGxpa2UgTWFwIGtleXMsIG1heSBiZSBvZiBhbnkgdHlwZS4gRXF1YWxpdHkgaXMgZGV0ZXJtaW5lZCB1c2luZ1xcbmBJbW11dGFibGUuaXNgLCBlbmFibGluZyBTZXRzIHRvIHVuaXF1ZWx5IGluY2x1ZGUgb3RoZXIgSW1tdXRhYmxlXFxuY29sbGVjdGlvbnMsIGN1c3RvbSB2YWx1ZSB0eXBlcywgYW5kIE5hTi5cIixcIm5vdGVzXCI6W119LFwibW9kdWxlXCI6e1wiaXNTZXRcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGEgU2V0XCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlU2V0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjoxNTUzfV19fSxcIm9mXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDcmVhdGVzIGEgbmV3IFNldCBjb250YWluaW5nIGB2YWx1ZXNgLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTU1OH1dfX0sXCJmcm9tS2V5c1wiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiYFNldC5mcm9tS2V5cygpYCBjcmVhdGVzIGEgbmV3IGltbXV0YWJsZSBTZXQgY29udGFpbmluZyB0aGUga2V5cyBmcm9tXFxudGhpcyBDb2xsZWN0aW9uIG9yIEphdmFTY3JpcHQgT2JqZWN0LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6MTd9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTU2NH0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm9ialwiLFwidHlwZVwiOntcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2V0XCIsXCJhcmdzXCI6W3tcImtcIjozfV19LFwibGluZVwiOjE1NjV9XX19LFwiaW50ZXJzZWN0XCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJgU2V0LmludGVyc2VjdCgpYCBjcmVhdGVzIGEgbmV3IGltbXV0YWJsZSBTZXQgdGhhdCBpcyB0aGUgaW50ZXJzZWN0aW9uIG9mXFxuYSBjb2xsZWN0aW9uIG9mIG90aGVyIHNldHMuXCIsXCJkZXNjcmlwdGlvblwiOlwiYGBganNcXG5jb25zdCB7IFNldCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBpbnRlcnNlY3RlZCA9IFNldC5pbnRlcnNlY3QoW1xcbiAgU2V0KFsgJ2EnLCAnYicsICdjJyBdKVxcbiAgU2V0KFsgJ2MnLCAnYScsICd0JyBdKVxcbl0pXFxuLy8gU2V0IFsgXFxcImFcXFwiLCBcXFwiY1xcXCIgXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInNldHNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTU4MH1dfX0sXCJ1bmlvblwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiYFNldC51bmlvbigpYCBjcmVhdGVzIGEgbmV3IGltbXV0YWJsZSBTZXQgdGhhdCBpcyB0aGUgdW5pb24gb2YgYVxcbmNvbGxlY3Rpb24gb2Ygb3RoZXIgc2V0cy5cIixcImRlc2NyaXB0aW9uXCI6XCJgYGBqc1xcbmNvbnN0IHsgU2V0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IHVuaW9uZWQgPSBTZXQudW5pb24oW1xcbiAgU2V0KFsgJ2EnLCAnYicsICdjJyBdKVxcbiAgU2V0KFsgJ2MnLCAnYScsICd0JyBdKVxcbl0pXFxuLy8gU2V0IFsgXFxcImFcXFwiLCBcXFwiYlxcXCIsIFxcXCJjXFxcIiwgXFxcInRcXFwiIF1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzZXRzXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjE1OTV9XX19fSxcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQ3JlYXRlIGEgbmV3IGltbXV0YWJsZSBTZXQgY29udGFpbmluZyB0aGUgdmFsdWVzIG9mIHRoZSBwcm92aWRlZFxcbmNvbGxlY3Rpb24tbGlrZS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgU2V0YCBpcyBhIGZhY3RvcnkgZnVuY3Rpb24gYW5kIG5vdCBhIGNsYXNzLCBhbmQgZG9lcyBub3QgdXNlIHRoZVxcbmBuZXdgIGtleXdvcmQgZHVyaW5nIGNvbnN0cnVjdGlvbi5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTYwNX0se1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjE2MDZ9LHtcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJsaW5lXCI6MTYwN31dfSxcImludGVyZmFjZVwiOntcImxpbmVcIjoxNjA5LFwidHlwZVBhcmFtc1wiOltcIlRcIl0sXCJleHRlbmRzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5TZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19XSxcImdyb3Vwc1wiOlt7XCJtZW1iZXJzXCI6e1wiI3NpemVcIjp7XCJsaW5lXCI6MTYxNH19fSx7XCJ0aXRsZVwiOlwiUGVyc2lzdGVudCBjaGFuZ2VzXCIsXCJtZW1iZXJzXCI6e1wiI2FkZFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFNldCB3aGljaCBhbHNvIGluY2x1ZGVzIHRoaXMgdmFsdWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYGFkZGAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjE2MjN9XX0sXCIjZGVsZXRlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU2V0IHdoaWNoIGV4Y2x1ZGVzIHRoaXMgdmFsdWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYGRlbGV0ZWAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblxcbk5vdGU6IGBkZWxldGVgICoqY2Fubm90KiogYmUgc2FmZWx5IHVzZWQgaW4gSUU4LCB1c2UgYHJlbW92ZWAgaWZcXG5zdXBwb3J0aW5nIG9sZCBicm93c2Vycy5cXG5cIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcImFsaWFzXCIsXCJib2R5XCI6XCJyZW1vdmVcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MTYzNX1dfSxcIiNjbGVhclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFNldCBjb250YWluaW5nIG5vIHZhbHVlcy5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgY2xlYXJgIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxNjQzfV19LFwiI3VuaW9uXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBTZXQgaW5jbHVkaW5nIGFueSB2YWx1ZSBmcm9tIGBjb2xsZWN0aW9uc2AgdGhhdCBkb2VzIG5vdCBhbHJlYWR5XFxuZXhpc3QgaW4gdGhpcyBTZXQuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYHVuaW9uYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJhbGlhc1wiLFwiYm9keVwiOlwibWVyZ2VcIn0se1wibmFtZVwiOlwiYWxpYXNcIixcImJvZHlcIjpcImNvbmNhdFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXRcIixcImFyZ3NcIjpbe1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9XX1dfSxcImxpbmVcIjoxNjUzfV19LFwiI2ludGVyc2VjdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgU2V0IHdoaWNoIGhhcyByZW1vdmVkIGFueSB2YWx1ZXMgbm90IGFsc28gY29udGFpbmVkXFxud2l0aGluIGBjb2xsZWN0aW9uc2AuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYGludGVyc2VjdGAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxNjYzfV19LFwiI3N1YnRyYWN0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBTZXQgZXhjbHVkaW5nIGFueSB2YWx1ZXMgY29udGFpbmVkIHdpdGhpbiBgY29sbGVjdGlvbnNgLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBPcmRlcmVkU2V0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbk9yZGVyZWRTZXQoWyAxLCAyLCAzIF0pLnN1YnRyYWN0KFsxLCAzXSlcXG4vLyBPcmRlcmVkU2V0IFsyXVxcbmBgYFxcblxcbk5vdGU6IGBzdWJ0cmFjdGAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxNjc3fV19fX0se1widGl0bGVcIjpcIlRyYW5zaWVudCBjaGFuZ2VzXCIsXCJtZW1iZXJzXCI6e1wiI3dpdGhNdXRhdGlvbnNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiTm90ZTogTm90IGFsbCBtZXRob2RzIGNhbiBiZSB1c2VkIG9uIGEgbXV0YWJsZSBjb2xsZWN0aW9uIG9yIHdpdGhpblxcbmB3aXRoTXV0YXRpb25zYCEgQ2hlY2sgdGhlIGRvY3VtZW50YXRpb24gZm9yIGVhY2ggbWV0aG9kIHRvIHNlZSBpZiBpdFxcbm1lbnRpb25zIGJlaW5nIHNhZmUgdG8gdXNlIGluIGB3aXRoTXV0YXRpb25zYC5cXG5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiYE1hcCN3aXRoTXV0YXRpb25zYFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibXV0YXRvclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm11dGFibGVcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjE2ODl9XX0sXCIjYXNNdXRhYmxlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIk5vdGU6IE5vdCBhbGwgbWV0aG9kcyBjYW4gYmUgdXNlZCBvbiBhIG11dGFibGUgY29sbGVjdGlvbiBvciB3aXRoaW5cXG5gd2l0aE11dGF0aW9uc2AhIENoZWNrIHRoZSBkb2N1bWVudGF0aW9uIGZvciBlYWNoIG1ldGhvZCB0byBzZWUgaWYgaXRcXG5tZW50aW9ucyBiZWluZyBzYWZlIHRvIHVzZSBpbiBgd2l0aE11dGF0aW9uc2AuXFxuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcImBNYXAjYXNNdXRhYmxlYFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxNjk4fV19LFwiI3dhc0FsdGVyZWRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcImBNYXAjd2FzQWx0ZXJlZGBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjoxNzAzfV19LFwiI2FzSW1tdXRhYmxlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI2FzSW1tdXRhYmxlYFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxNzA4fV19fX0se1widGl0bGVcIjpcIlNlcXVlbmNlIGFsZ29yaXRobXNcIixcIm1lbWJlcnNcIjp7XCIjbWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU2V0IHdpdGggdmFsdWVzIHBhc3NlZCB0aHJvdWdoIGFcXG5gbWFwcGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCIgICAgU2V0KFsxLDJdKS5tYXAoeCA9PiAxMCAqIHgpXFxuICAgIC8vIFNldCBbMTAsMjBdXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk1cIn19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjoxNzE5fV19LFwiI2ZsYXRNYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRmxhdC1tYXBzIHRoZSBTZXQsIHJldHVybmluZyBhIG5ldyBTZXQuXCIsXCJkZXNjcmlwdGlvblwiOlwiU2ltaWxhciB0byBgc2V0Lm1hcCguLi4pLmZsYXR0ZW4odHJ1ZSlgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjE3Mjl9XX0sXCIjZmlsdGVyXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU2V0IHdpdGggb25seSB0aGUgdmFsdWVzIGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWBcXG5mdW5jdGlvbiByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYGZpbHRlcigpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCByZXN1bHRzIGluXFxubm90IGZpbHRlcmluZyBvdXQgYW55IHZhbHVlcy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiRlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJGXCJ9XX0sXCJsaW5lXCI6MTc0MX0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MTd9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjE3NDV9XX19fV19fSxcIk9yZGVyZWRTZXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQSB0eXBlIG9mIFNldCB0aGF0IGhhcyB0aGUgYWRkaXRpb25hbCBndWFyYW50ZWUgdGhhdCB0aGUgaXRlcmF0aW9uIG9yZGVyIG9mXFxudmFsdWVzIHdpbGwgYmUgdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgd2VyZSBgYWRkYGVkLlwiLFwiZGVzY3JpcHRpb25cIjpcIlRoZSBpdGVyYXRpb24gYmVoYXZpb3Igb2YgT3JkZXJlZFNldCBpcyB0aGUgc2FtZSBhcyBuYXRpdmUgRVM2IFNldC5cXG5cXG5Ob3RlIHRoYXQgYE9yZGVyZWRTZXRgIGFyZSBtb3JlIGV4cGVuc2l2ZSB0aGFuIG5vbi1vcmRlcmVkIGBTZXRgIGFuZCBtYXlcXG5jb25zdW1lIG1vcmUgbWVtb3J5LiBgT3JkZXJlZFNldCNhZGRgIGlzIGFtb3J0aXplZCBPKGxvZzMyIE4pLCBidXQgbm90XFxuc3RhYmxlLlwiLFwibm90ZXNcIjpbXX0sXCJtb2R1bGVcIjp7XCJpc09yZGVyZWRTZXRcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGFuIE9yZGVyZWRTZXQuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlT3JkZXJlZFNldFwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6MTc2N31dfX0sXCJvZlwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQ3JlYXRlcyBhIG5ldyBPcmRlcmVkU2V0IGNvbnRhaW5pbmcgYHZhbHVlc2AuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVzXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZFNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTc3Mn1dfX0sXCJmcm9tS2V5c1wiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiYE9yZGVyZWRTZXQuZnJvbUtleXMoKWAgY3JlYXRlcyBhIG5ldyBpbW11dGFibGUgT3JkZXJlZFNldCBjb250YWluaW5nXFxudGhlIGtleXMgZnJvbSB0aGlzIENvbGxlY3Rpb24gb3IgSmF2YVNjcmlwdCBPYmplY3QuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjoxN31dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZFNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTc3OH0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm9ialwiLFwidHlwZVwiOntcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZFNldFwiLFwiYXJnc1wiOlt7XCJrXCI6M31dfSxcImxpbmVcIjoxNzc5fV19fX0sXCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkNyZWF0ZSBhIG5ldyBpbW11dGFibGUgT3JkZXJlZFNldCBjb250YWluaW5nIHRoZSB2YWx1ZXMgb2YgdGhlIHByb3ZpZGVkXFxuY29sbGVjdGlvbi1saWtlLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBPcmRlcmVkU2V0YCBpcyBhIGZhY3RvcnkgZnVuY3Rpb24gYW5kIG5vdCBhIGNsYXNzLCBhbmQgZG9lcyBub3QgdXNlXFxudGhlIGBuZXdgIGtleXdvcmQgZHVyaW5nIGNvbnN0cnVjdGlvbi5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRTZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjE3ODl9LHtcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZFNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTc5MH0se1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZFNldFwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJsaW5lXCI6MTc5MX1dfSxcImludGVyZmFjZVwiOntcImxpbmVcIjoxNzkzLFwidHlwZVBhcmFtc1wiOltcIlRcIl0sXCJleHRlbmRzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfV0sXCJncm91cHNcIjpbe1wibWVtYmVyc1wiOntcIiNzaXplXCI6e1wibGluZVwiOjE3OTh9LFwiI3VuaW9uXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYW4gT3JkZXJlZFNldCBpbmNsdWRpbmcgYW55IHZhbHVlIGZyb20gYGNvbGxlY3Rpb25zYCB0aGF0IGRvZXNcXG5ub3QgYWxyZWFkeSBleGlzdCBpbiB0aGlzIE9yZGVyZWRTZXQuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYHVuaW9uYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJhbGlhc1wiLFwiYm9keVwiOlwibWVyZ2VcIn0se1wibmFtZVwiOlwiYWxpYXNcIixcImJvZHlcIjpcImNvbmNhdFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkU2V0XCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifV19XX0sXCJsaW5lXCI6MTgwOH1dfX19LHtcInRpdGxlXCI6XCJTZXF1ZW5jZSBhbGdvcml0aG1zXCIsXCJtZW1iZXJzXCI6e1wiI21hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFNldCB3aXRoIHZhbHVlcyBwYXNzZWQgdGhyb3VnaCBhXFxuYG1hcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiICAgIE9yZGVyZWRTZXQoWyAxLCAyIF0pLm1hcCh4ID0+IDEwICogeClcXG4gICAgLy8gT3JkZXJlZFNldCBbMTAsIDIwXVwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRTZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjE4MjF9XX0sXCIjZmxhdE1hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJGbGF0LW1hcHMgdGhlIE9yZGVyZWRTZXQsIHJldHVybmluZyBhIG5ldyBPcmRlcmVkU2V0LlwiLFwiZGVzY3JpcHRpb25cIjpcIlNpbWlsYXIgdG8gYHNldC5tYXAoLi4uKS5mbGF0dGVuKHRydWUpYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZFNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6MTgzMX1dfSxcIiNmaWx0ZXJcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBPcmRlcmVkU2V0IHdpdGggb25seSB0aGUgdmFsdWVzIGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWBcXG5mdW5jdGlvbiByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYGZpbHRlcigpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCByZXN1bHRzIGluXFxubm90IGZpbHRlcmluZyBvdXQgYW55IHZhbHVlcy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiRlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRTZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiRlwifV19LFwibGluZVwiOjE4NDN9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxODQ3fV19LFwiI3ppcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGFuIE9yZGVyZWRTZXQgb2YgdGhlIHNhbWUgdHlwZSBcXFwiemlwcGVkXFxcIiB3aXRoIHRoZSBwcm92aWRlZFxcbmNvbGxlY3Rpb25zLlwiLFwiZGVzY3JpcHRpb25cIjpcIkxpa2UgYHppcFdpdGhgLCBidXQgdXNpbmcgdGhlIGRlZmF1bHQgYHppcHBlcmA6IGNyZWF0aW5nIGFuIGBBcnJheWAuXFxuXFxuYGBganNcXG5jb25zdCBhID0gT3JkZXJlZFNldChbIDEsIDIsIDMgXSlcXG5jb25zdCBiID0gT3JkZXJlZFNldChbIDQsIDUsIDYgXSlcXG5jb25zdCBjID0gYS56aXAoYilcXG4vLyBPcmRlcmVkU2V0IFsgWyAxLCA0IF0sIFsgMiwgNSBdLCBbIDMsIDYgXSBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlVcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib3RoZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRTZXRcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX1dfSxcImxpbmVcIjoxODY1fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiLFwiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlcjFcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19LHtcIm5hbWVcIjpcIm90aGVyMlwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZFNldFwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XX0sXCJsaW5lXCI6MTg2Nn0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6MTd9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkU2V0XCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcImxpbmVcIjoxODY3fV19LFwiI3ppcEFsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgT3JkZXJlZFNldCBvZiB0aGUgc2FtZSB0eXBlIFxcXCJ6aXBwZWRcXFwiIHdpdGggdGhlIHByb3ZpZGVkXFxuY29sbGVjdGlvbnMuXCIsXCJkZXNjcmlwdGlvblwiOlwiVW5saWtlIGB6aXBgLCBgemlwQWxsYCBjb250aW51ZXMgemlwcGluZyB1bnRpbCB0aGUgbG9uZ2VzdCBjb2xsZWN0aW9uIGlzXFxuZXhoYXVzdGVkLiBNaXNzaW5nIHZhbHVlcyBmcm9tIHNob3J0ZXIgY29sbGVjdGlvbnMgYXJlIGZpbGxlZCB3aXRoIGB1bmRlZmluZWRgLlxcblxcbmBgYGpzXFxuY29uc3QgYSA9IE9yZGVyZWRTZXQoWyAxLCAyIF0pO1xcbmNvbnN0IGIgPSBPcmRlcmVkU2V0KFsgMywgNCwgNSBdKTtcXG5jb25zdCBjID0gYS56aXBBbGwoYik7IC8vIE9yZGVyZWRTZXQgWyBbIDEsIDMgXSwgWyAyLCA0IF0sIFsgdW5kZWZpbmVkLCA1IF0gXVxcbmBgYFxcblxcbk5vdGU6IFNpbmNlIHppcEFsbCB3aWxsIHJldHVybiBhIGNvbGxlY3Rpb24gYXMgbGFyZ2UgYXMgdGhlIGxhcmdlc3RcXG5pbnB1dCwgc29tZSByZXN1bHRzIG1heSBjb250YWluIHVuZGVmaW5lZCB2YWx1ZXMuIFR5cGVTY3JpcHQgY2Fubm90XFxuYWNjb3VudCBmb3IgdGhlc2Ugd2l0aG91dCBjYXNlcyAoYXMgb2YgdjIuNSkuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlVcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib3RoZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRTZXRcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX1dfSxcImxpbmVcIjoxODg2fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiLFwiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlcjFcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19LHtcIm5hbWVcIjpcIm90aGVyMlwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZFNldFwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XX0sXCJsaW5lXCI6MTg4N30se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6MTd9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkU2V0XCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcImxpbmVcIjoxODg4fV19LFwiI3ppcFdpdGhcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhbiBPcmRlcmVkU2V0IG9mIHRoZSBzYW1lIHR5cGUgXFxcInppcHBlZFxcXCIgd2l0aCB0aGUgcHJvdmlkZWRcXG5jb2xsZWN0aW9ucyBieSB1c2luZyBhIGN1c3RvbSBgemlwcGVyYCBmdW5jdGlvbi5cXG5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiU2VxLkluZGV4ZWQuemlwV2l0aFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiLFwiWlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ6aXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIm90aGVyVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifX19LHtcIm5hbWVcIjpcIm90aGVyQ29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZFNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9XX0sXCJsaW5lXCI6MTg5Nn0se1widHlwZVBhcmFtc1wiOltcIlVcIixcIlZcIixcIlpcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiemlwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJvdGhlclZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifX0se1wibmFtZVwiOlwidGhpcmRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9fX0se1wibmFtZVwiOlwib3RoZXJDb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fSx7XCJuYW1lXCI6XCJ0aGlyZENvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRTZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifV19LFwibGluZVwiOjE5MDB9LHtcInR5cGVQYXJhbXNcIjpbXCJaXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInppcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImFueVwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9fX0se1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRTZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifV19LFwibGluZVwiOjE5MDV9XX19fV19fSxcIlN0YWNrXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlN0YWNrcyBhcmUgaW5kZXhlZCBjb2xsZWN0aW9ucyB3aGljaCBzdXBwb3J0IHZlcnkgZWZmaWNpZW50IE8oMSkgYWRkaXRpb25cXG5hbmQgcmVtb3ZhbCBmcm9tIHRoZSBmcm9udCB1c2luZyBgdW5zaGlmdCh2KWAgYW5kIGBzaGlmdCgpYC5cIixcImRlc2NyaXB0aW9uXCI6XCJGb3IgZmFtaWxpYXJpdHksIFN0YWNrIGFsc28gcHJvdmlkZXMgYHB1c2godilgLCBgcG9wKClgLCBhbmQgYHBlZWsoKWAsIGJ1dFxcbmJlIGF3YXJlIHRoYXQgdGhleSBhbHNvIG9wZXJhdGUgb24gdGhlIGZyb250IG9mIHRoZSBsaXN0LCB1bmxpa2UgTGlzdCBvclxcbmEgSmF2YVNjcmlwdCBBcnJheS5cXG5cXG5Ob3RlOiBgcmV2ZXJzZSgpYCBvciBhbnkgaW5oZXJlbnQgcmV2ZXJzZSB0cmF2ZXJzYWwgKGByZWR1Y2VSaWdodGAsXFxuYGxhc3RJbmRleE9mYCwgZXRjLikgaXMgbm90IGVmZmljaWVudCB3aXRoIGEgU3RhY2suXFxuXFxuU3RhY2sgaXMgaW1wbGVtZW50ZWQgd2l0aCBhIFNpbmdsZS1MaW5rZWQgTGlzdC5cIixcIm5vdGVzXCI6W119LFwibW9kdWxlXCI6e1wiaXNTdGFja1wiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYSBTdGFja1wiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXliZVN0YWNrXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjoxOTMxfV19fSxcIm9mXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDcmVhdGVzIGEgbmV3IFN0YWNrIGNvbnRhaW5pbmcgYHZhbHVlc2AuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVzXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU3RhY2tcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjE5MzZ9XX19fSxcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQ3JlYXRlIGEgbmV3IGltbXV0YWJsZSBTdGFjayBjb250YWluaW5nIHRoZSB2YWx1ZXMgb2YgdGhlIHByb3ZpZGVkXFxuY29sbGVjdGlvbi1saWtlLlwiLFwiZGVzY3JpcHRpb25cIjpcIlRoZSBpdGVyYXRpb24gb3JkZXIgb2YgdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb24gaXMgcHJlc2VydmVkIGluIHRoZVxcbnJlc3VsdGluZyBgU3RhY2tgLlxcblxcbk5vdGU6IGBTdGFja2AgaXMgYSBmYWN0b3J5IGZ1bmN0aW9uIGFuZCBub3QgYSBjbGFzcywgYW5kIGRvZXMgbm90IHVzZSB0aGVcXG5gbmV3YCBrZXl3b3JkIGR1cmluZyBjb25zdHJ1Y3Rpb24uXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTdGFja1wiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTk0OX0se1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTdGFja1wiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTk1MH0se1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU3RhY2tcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwibGluZVwiOjE5NTF9XX0sXCJpbnRlcmZhY2VcIjp7XCJsaW5lXCI6MTk1MyxcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwiZXh0ZW5kc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX1dLFwiZ3JvdXBzXCI6W3tcIm1lbWJlcnNcIjp7XCIjc2l6ZVwiOntcImxpbmVcIjoxOTU4fX19LHtcInRpdGxlXCI6XCJSZWFkaW5nIHZhbHVlc1wiLFwibWVtYmVyc1wiOntcIiNwZWVrXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkFsaWFzIGZvciBgU3RhY2suZmlyc3QoKWAuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjExfV19LFwibGluZVwiOjE5NjV9XX19fSx7XCJ0aXRsZVwiOlwiUGVyc2lzdGVudCBjaGFuZ2VzXCIsXCJtZW1iZXJzXCI6e1wiI2NsZWFyXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU3RhY2sgd2l0aCAwIHNpemUgYW5kIG5vIHZhbHVlcy5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgY2xlYXJgIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTdGFja1wiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTk3NX1dfSxcIiN1bnNoaWZ0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU3RhY2sgd2l0aCB0aGUgcHJvdmlkZWQgYHZhbHVlc2AgcHJlcGVuZGVkLCBzaGlmdGluZyBvdGhlclxcbnZhbHVlcyBhaGVhZCB0byBoaWdoZXIgaW5kaWNlcy5cIixcImRlc2NyaXB0aW9uXCI6XCJUaGlzIGlzIHZlcnkgZWZmaWNpZW50IGZvciBTdGFjay5cXG5cXG5Ob3RlOiBgdW5zaGlmdGAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZXNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTdGFja1wiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTk4NX1dfSxcIiN1bnNoaWZ0QWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkxpa2UgYFN0YWNrI3Vuc2hpZnRgLCBidXQgYWNjZXB0cyBhIGNvbGxlY3Rpb24gcmF0aGVyIHRoYW4gdmFyYXJncy5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgdW5zaGlmdEFsbGAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlN0YWNrXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoxOTkyfV19LFwiI3NoaWZ0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU3RhY2sgd2l0aCBhIHNpemUgb25lcyBsZXNzIHRoYW4gdGhpcyBTdGFjaywgZXhjbHVkaW5nXFxudGhlIGZpcnN0IGl0ZW0gaW4gdGhpcyBTdGFjaywgc2hpZnRpbmcgYWxsIG90aGVyIHZhbHVlcyB0byBhIGxvd2VyIGluZGV4LlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IHRoaXMgZGlmZmVycyBmcm9tIGBBcnJheSNzaGlmdGAgYmVjYXVzZSBpdCByZXR1cm5zIGEgbmV3XFxuU3RhY2sgcmF0aGVyIHRoYW4gdGhlIHJlbW92ZWQgdmFsdWUuIFVzZSBgZmlyc3QoKWAgb3IgYHBlZWsoKWAgdG8gZ2V0IHRoZVxcbmZpcnN0IHZhbHVlIGluIHRoaXMgU3RhY2suXFxuXFxuTm90ZTogYHNoaWZ0YCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU3RhY2tcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjIwMDR9XX0sXCIjcHVzaFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJBbGlhcyBmb3IgYFN0YWNrI3Vuc2hpZnRgIGFuZCBpcyBub3QgZXF1aXZhbGVudCB0byBgTGlzdCNwdXNoYC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVzXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU3RhY2tcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjIwMDl9XX0sXCIjcHVzaEFsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJBbGlhcyBmb3IgYFN0YWNrI3Vuc2hpZnRBbGxgLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlN0YWNrXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoyMDE0fV19LFwiI3BvcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJBbGlhcyBmb3IgYFN0YWNrI3NoaWZ0YCBhbmQgaXMgbm90IGVxdWl2YWxlbnQgdG8gYExpc3QjcG9wYC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTdGFja1wiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MjAxOX1dfX19LHtcInRpdGxlXCI6XCJUcmFuc2llbnQgY2hhbmdlc1wiLFwibWVtYmVyc1wiOntcIiN3aXRoTXV0YXRpb25zXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIk5vdGU6IE5vdCBhbGwgbWV0aG9kcyBjYW4gYmUgdXNlZCBvbiBhIG11dGFibGUgY29sbGVjdGlvbiBvciB3aXRoaW5cXG5gd2l0aE11dGF0aW9uc2AhIENoZWNrIHRoZSBkb2N1bWVudGF0aW9uIGZvciBlYWNoIG1ldGhvZCB0byBzZWUgaWYgaXRcXG5tZW50aW9ucyBiZWluZyBzYWZlIHRvIHVzZSBpbiBgd2l0aE11dGF0aW9uc2AuXFxuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcImBNYXAjd2l0aE11dGF0aW9uc2BcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm11dGF0b3JcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtdXRhYmxlXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxN319fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoyMDMxfV19LFwiI2FzTXV0YWJsZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJOb3RlOiBOb3QgYWxsIG1ldGhvZHMgY2FuIGJlIHVzZWQgb24gYSBtdXRhYmxlIGNvbGxlY3Rpb24gb3Igd2l0aGluXFxuYHdpdGhNdXRhdGlvbnNgISBDaGVjayB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgZWFjaCBtZXRob2QgdG8gc2VlIGlmIGl0XFxubWVudGlvbnMgYmVpbmcgc2FmZSB0byB1c2UgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI2FzTXV0YWJsZWBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MjA0MH1dfSxcIiN3YXNBbHRlcmVkXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI3dhc0FsdGVyZWRgXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6MjA0NX1dfSxcIiNhc0ltbXV0YWJsZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiYE1hcCNhc0ltbXV0YWJsZWBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MjA1MH1dfX19LHtcInRpdGxlXCI6XCJTZXF1ZW5jZSBhbGdvcml0aG1zXCIsXCJtZW1iZXJzXCI6e1wiI2NvbmNhdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFN0YWNrIHdpdGggb3RoZXIgY29sbGVjdGlvbnMgY29uY2F0ZW5hdGVkIHRvIHRoaXMgb25lLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlc09yQ29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifV19LHtcImtcIjo4LFwicGFyYW1cIjpcIkNcIn1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlN0YWNrXCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifV19XX0sXCJsaW5lXCI6MjA1N31dfSxcIiNtYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBTdGFjayB3aXRoIHZhbHVlcyBwYXNzZWQgdGhyb3VnaCBhXFxuYG1hcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiICAgIFN0YWNrKFsgMSwgMiBdKS5tYXAoeCA9PiAxMCAqIHgpXFxuICAgIC8vIFN0YWNrIFsgMTAsIDIwIF1cXG5cXG5Ob3RlOiBgbWFwKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHByb2R1Y2VkIHRoZSBzYW1lXFxudmFsdWUgYXQgZXZlcnkgc3RlcC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlN0YWNrXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjoyMDY5fV19LFwiI2ZsYXRNYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRmxhdC1tYXBzIHRoZSBTdGFjaywgcmV0dXJuaW5nIGEgbmV3IFN0YWNrLlwiLFwiZGVzY3JpcHRpb25cIjpcIlNpbWlsYXIgdG8gYHN0YWNrLm1hcCguLi4pLmZsYXR0ZW4odHJ1ZSlgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlN0YWNrXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjoyMDc5fV19LFwiI2ZpbHRlclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFNldCB3aXRoIG9ubHkgdGhlIHZhbHVlcyBmb3Igd2hpY2ggdGhlIGBwcmVkaWNhdGVgXFxuZnVuY3Rpb24gcmV0dXJucyB0cnVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBmaWx0ZXIoKWAgYWx3YXlzIHJldHVybnMgYSBuZXcgaW5zdGFuY2UsIGV2ZW4gaWYgaXQgcmVzdWx0cyBpblxcbm5vdCBmaWx0ZXJpbmcgb3V0IGFueSB2YWx1ZXMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJpbmRleFwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIkZcIn1dfSxcImxpbmVcIjoyMDkxfSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJpbmRleFwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MTd9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjIwOTV9XX0sXCIjemlwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBTdGFjayBcXFwiemlwcGVkXFxcIiB3aXRoIHRoZSBwcm92aWRlZCBjb2xsZWN0aW9ucy5cIixcImRlc2NyaXB0aW9uXCI6XCJMaWtlIGB6aXBXaXRoYCwgYnV0IHVzaW5nIHRoZSBkZWZhdWx0IGB6aXBwZXJgOiBjcmVhdGluZyBhbiBgQXJyYXlgLlxcblxcbmBgYGpzXFxuY29uc3QgYSA9IFN0YWNrKFsgMSwgMiwgMyBdKTtcXG5jb25zdCBiID0gU3RhY2soWyA0LCA1LCA2IF0pO1xcbmNvbnN0IGMgPSBhLnppcChiKTsgLy8gU3RhY2sgWyBbIDEsIDQgXSwgWyAyLCA1IF0sIFsgMywgNiBdIF1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlclwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU3RhY2tcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX1dfSxcImxpbmVcIjoyMTExfSx7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiLFwiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlclwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX0se1wibmFtZVwiOlwib3RoZXIyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTdGFja1wiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XX0sXCJsaW5lXCI6MjExMn0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6MTd9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTdGFja1wiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJsaW5lXCI6MjExM31dfSxcIiN6aXBBbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIFN0YWNrIFxcXCJ6aXBwZWRcXFwiIHdpdGggdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb25zLlwiLFwiZGVzY3JpcHRpb25cIjpcIlVubGlrZSBgemlwYCwgYHppcEFsbGAgY29udGludWVzIHppcHBpbmcgdW50aWwgdGhlIGxvbmdlc3QgY29sbGVjdGlvbiBpc1xcbmV4aGF1c3RlZC4gTWlzc2luZyB2YWx1ZXMgZnJvbSBzaG9ydGVyIGNvbGxlY3Rpb25zIGFyZSBmaWxsZWQgd2l0aCBgdW5kZWZpbmVkYC5cXG5cXG5gYGBqc1xcbmNvbnN0IGEgPSBTdGFjayhbIDEsIDIgXSk7XFxuY29uc3QgYiA9IFN0YWNrKFsgMywgNCwgNSBdKTtcXG5jb25zdCBjID0gYS56aXBBbGwoYik7IC8vIFN0YWNrIFsgWyAxLCAzIF0sIFsgMiwgNCBdLCBbIHVuZGVmaW5lZCwgNSBdIF1cXG5gYGBcXG5cXG5Ob3RlOiBTaW5jZSB6aXBBbGwgd2lsbCByZXR1cm4gYSBjb2xsZWN0aW9uIGFzIGxhcmdlIGFzIHRoZSBsYXJnZXN0XFxuaW5wdXQsIHNvbWUgcmVzdWx0cyBtYXkgY29udGFpbiB1bmRlZmluZWQgdmFsdWVzLiBUeXBlU2NyaXB0IGNhbm5vdFxcbmFjY291bnQgZm9yIHRoZXNlIHdpdGhvdXQgY2FzZXMgKGFzIG9mIHYyLjUpLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJVXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTdGFja1wiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfV19LFwibGluZVwiOjIxMzF9LHtcInR5cGVQYXJhbXNcIjpbXCJVXCIsXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fSx7XCJuYW1lXCI6XCJvdGhlcjJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlN0YWNrXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfSxcImxpbmVcIjoyMTMyfSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlN0YWNrXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcImxpbmVcIjoyMTMzfV19LFwiI3ppcFdpdGhcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIFN0YWNrIFxcXCJ6aXBwZWRcXFwiIHdpdGggdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb25zIGJ5IHVzaW5nIGFcXG5jdXN0b20gYHppcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiYGBganNcXG5jb25zdCBhID0gU3RhY2soWyAxLCAyLCAzIF0pO1xcbmNvbnN0IGIgPSBTdGFjayhbIDQsIDUsIDYgXSk7XFxuY29uc3QgYyA9IGEuemlwV2l0aCgoYSwgYikgPT4gYSArIGIsIGIpO1xcbi8vIFN0YWNrIFsgNSwgNywgOSBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlVcIixcIlpcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiemlwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJvdGhlclZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlpcIn19fSx7XCJuYW1lXCI6XCJvdGhlckNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlN0YWNrXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlpcIn1dfSxcImxpbmVcIjoyMTQ2fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiLFwiVlwiLFwiWlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ6aXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIm90aGVyVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9fSx7XCJuYW1lXCI6XCJ0aGlyZFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlpcIn19fSx7XCJuYW1lXCI6XCJvdGhlckNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19LHtcIm5hbWVcIjpcInRoaXJkQ29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU3RhY2tcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifV19LFwibGluZVwiOjIxNTB9LHtcInR5cGVQYXJhbXNcIjpbXCJaXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInppcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImFueVwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9fX0se1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlN0YWNrXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlpcIn1dfSxcImxpbmVcIjoyMTU1fV19fX1dfX0sXCJSYW5nZVwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIFNlcS5JbmRleGVkIG9mIG51bWJlcnMgZnJvbSBgc3RhcnRgIChpbmNsdXNpdmUpIHRvIGBlbmRgXFxuKGV4Y2x1c2l2ZSksIGJ5IGBzdGVwYCwgd2hlcmUgYHN0YXJ0YCBkZWZhdWx0cyB0byAwLCBgc3RlcGAgdG8gMSwgYW5kIGBlbmRgIHRvXFxuaW5maW5pdHkuIFdoZW4gYHN0YXJ0YCBpcyBlcXVhbCB0byBgZW5kYCwgcmV0dXJucyBlbXB0eSByYW5nZS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgUmFuZ2VgIGlzIGEgZmFjdG9yeSBmdW5jdGlvbiBhbmQgbm90IGEgY2xhc3MsIGFuZCBkb2VzIG5vdCB1c2UgdGhlXFxuYG5ld2Aga2V5d29yZCBkdXJpbmcgY29uc3RydWN0aW9uLlxcblxcbmBgYGpzXFxuY29uc3QgeyBSYW5nZSB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5SYW5nZSgpIC8vIFsgMCwgMSwgMiwgMywgLi4uIF1cXG5SYW5nZSgxMCkgLy8gWyAxMCwgMTEsIDEyLCAxMywgLi4uIF1cXG5SYW5nZSgxMCwgMTUpIC8vIFsgMTAsIDExLCAxMiwgMTMsIDE0IF1cXG5SYW5nZSgxMCwgMzAsIDUpIC8vIFsgMTAsIDE1LCAyMCwgMjUgXVxcblJhbmdlKDMwLCAxMCwgNSkgLy8gWyAzMCwgMjUsIDIwLCAxNSBdXFxuUmFuZ2UoMzAsIDMwLCA1KSAvLyBbXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzdGFydFwiLFwidHlwZVwiOntcImtcIjoyfSxcIm9wdGlvbmFsXCI6dHJ1ZX0se1wibmFtZVwiOlwiZW5kXCIsXCJ0eXBlXCI6e1wia1wiOjJ9LFwib3B0aW9uYWxcIjp0cnVlfSx7XCJuYW1lXCI6XCJzdGVwXCIsXCJ0eXBlXCI6e1wia1wiOjJ9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6Mn1dfSxcImxpbmVcIjoyMTgwfV19fSxcIlJlcGVhdFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIFNlcS5JbmRleGVkIG9mIGB2YWx1ZWAgcmVwZWF0ZWQgYHRpbWVzYCB0aW1lcy4gV2hlbiBgdGltZXNgIGlzXFxubm90IGRlZmluZWQsIHJldHVybnMgYW4gaW5maW5pdGUgYFNlcWAgb2YgYHZhbHVlYC5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgUmVwZWF0YCBpcyBhIGZhY3RvcnkgZnVuY3Rpb24gYW5kIG5vdCBhIGNsYXNzLCBhbmQgZG9lcyBub3QgdXNlIHRoZVxcbmBuZXdgIGtleXdvcmQgZHVyaW5nIGNvbnN0cnVjdGlvbi5cXG5cXG5gYGBqc1xcbmNvbnN0IHsgUmVwZWF0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcblJlcGVhdCgnZm9vJykgLy8gWyAnZm9vJywgJ2ZvbycsICdmb28nLCAuLi4gXVxcblJlcGVhdCgnYmFyJywgNCkgLy8gWyAnYmFyJywgJ2JhcicsICdiYXInLCAnYmFyJyBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJ0aW1lc1wiLFwidHlwZVwiOntcImtcIjoyfSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjIxOTZ9XX19LFwiUmVjb3JkXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkEgcmVjb3JkIGlzIHNpbWlsYXIgdG8gYSBKUyBvYmplY3QsIGJ1dCBlbmZvcmNlcyBhIHNwZWNpZmljIHNldCBvZiBhbGxvd2VkXFxuc3RyaW5nIGtleXMsIGFuZCBoYXMgZGVmYXVsdCB2YWx1ZXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiVGhlIGBSZWNvcmQoKWAgZnVuY3Rpb24gcHJvZHVjZXMgbmV3IFJlY29yZCBGYWN0b3JpZXMsIHdoaWNoIHdoZW4gY2FsbGVkXFxuY3JlYXRlIFJlY29yZCBpbnN0YW5jZXMuXFxuXFxuYGBganNcXG5jb25zdCB7IFJlY29yZCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBBQlJlY29yZCA9IFJlY29yZCh7IGE6IDEsIGI6IDIgfSlcXG5jb25zdCBteVJlY29yZCA9IEFCUmVjb3JkKHsgYjogMyB9KVxcbmBgYFxcblxcblJlY29yZHMgYWx3YXlzIGhhdmUgYSB2YWx1ZSBmb3IgdGhlIGtleXMgdGhleSBkZWZpbmUuIGByZW1vdmVgaW5nIGEga2V5XFxuZnJvbSBhIHJlY29yZCBzaW1wbHkgcmVzZXRzIGl0IHRvIHRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGF0IGtleS5cXG5cXG5gYGBqc1xcbm15UmVjb3JkLnNpemUgLy8gMlxcbm15UmVjb3JkLmdldCgnYScpIC8vIDFcXG5teVJlY29yZC5nZXQoJ2InKSAvLyAzXFxuY29uc3QgbXlSZWNvcmRXaXRob3V0QiA9IG15UmVjb3JkLnJlbW92ZSgnYicpXFxubXlSZWNvcmRXaXRob3V0Qi5nZXQoJ2InKSAvLyAyXFxubXlSZWNvcmRXaXRob3V0Qi5zaXplIC8vIDJcXG5gYGBcXG5cXG5WYWx1ZXMgcHJvdmlkZWQgdG8gdGhlIGNvbnN0cnVjdG9yIG5vdCBmb3VuZCBpbiB0aGUgUmVjb3JkIHR5cGUgd2lsbFxcbmJlIGlnbm9yZWQuIEZvciBleGFtcGxlLCBpbiB0aGlzIGNhc2UsIEFCUmVjb3JkIGlzIHByb3ZpZGVkIGEga2V5IFxcXCJ4XFxcIiBldmVuXFxudGhvdWdoIG9ubHkgXFxcImFcXFwiIGFuZCBcXFwiYlxcXCIgaGF2ZSBiZWVuIGRlZmluZWQuIFRoZSB2YWx1ZSBmb3IgXFxcInhcXFwiIHdpbGwgYmVcXG5pZ25vcmVkIGZvciB0aGlzIHJlY29yZC5cXG5cXG5gYGBqc1xcbmNvbnN0IG15UmVjb3JkID0gQUJSZWNvcmQoeyBiOiAzLCB4OiAxMCB9KVxcbm15UmVjb3JkLmdldCgneCcpIC8vIHVuZGVmaW5lZFxcbmBgYFxcblxcbkJlY2F1c2UgUmVjb3JkcyBoYXZlIGEga25vd24gc2V0IG9mIHN0cmluZyBrZXlzLCBwcm9wZXJ0eSBnZXQgYWNjZXNzIHdvcmtzXFxuYXMgZXhwZWN0ZWQsIGhvd2V2ZXIgcHJvcGVydHkgc2V0cyB3aWxsIHRocm93IGFuIEVycm9yLlxcblxcbk5vdGU6IElFOCBkb2VzIG5vdCBzdXBwb3J0IHByb3BlcnR5IGFjY2Vzcy4gT25seSB1c2UgYGdldCgpYCB3aGVuXFxuc3VwcG9ydGluZyBJRTguXFxuXFxuYGBganNcXG5teVJlY29yZC5iIC8vIDNcXG5teVJlY29yZC5iID0gNSAvLyB0aHJvd3MgRXJyb3JcXG5gYGBcXG5cXG5SZWNvcmQgVHlwZXMgY2FuIGJlIGV4dGVuZGVkIGFzIHdlbGwsIGFsbG93aW5nIGZvciBjdXN0b20gbWV0aG9kcyBvbiB5b3VyXFxuUmVjb3JkLiBUaGlzIGlzIG5vdCBhIGNvbW1vbiBwYXR0ZXJuIGluIGZ1bmN0aW9uYWwgZW52aXJvbm1lbnRzLCBidXQgaXMgaW5cXG5tYW55IEpTIHByb2dyYW1zLlxcblxcbkhvd2V2ZXIgUmVjb3JkIFR5cGVzIGFyZSBtb3JlIHJlc3RyaWN0ZWQgdGhhbiB0eXBpY2FsIEphdmFTY3JpcHQgY2xhc3Nlcy5cXG5UaGV5IGRvIG5vdCB1c2UgYSBjbGFzcyBjb25zdHJ1Y3Rvciwgd2hpY2ggYWxzbyBtZWFucyB0aGV5IGNhbm5vdCB1c2VcXG5jbGFzcyBwcm9wZXJ0aWVzIChzaW5jZSB0aG9zZSBhcmUgdGVjaG5pY2FsbHkgcGFydCBvZiBhIGNvbnN0cnVjdG9yKS5cXG5cXG5XaGlsZSBSZWNvcmQgVHlwZXMgY2FuIGJlIHN5bnRhY3RpY2FsbHkgY3JlYXRlZCB3aXRoIHRoZSBKYXZhU2NyaXB0IGBjbGFzc2BcXG5mb3JtLCB0aGUgcmVzdWx0aW5nIFJlY29yZCBmdW5jdGlvbiBpcyBhY3R1YWxseSBhIGZhY3RvcnkgZnVuY3Rpb24sIG5vdCBhXFxuY2xhc3MgY29uc3RydWN0b3IuIEV2ZW4gdGhvdWdoIFJlY29yZCBUeXBlcyBhcmUgbm90IGNsYXNzZXMsIEphdmFTY3JpcHRcXG5jdXJyZW50bHkgcmVxdWlyZXMgdGhlIHVzZSBvZiBgbmV3YCB3aGVuIGNyZWF0aW5nIG5ldyBSZWNvcmQgaW5zdGFuY2VzIGlmXFxudGhleSBhcmUgZGVmaW5lZCBhcyBhIGBjbGFzc2AuXFxuXFxuYGBgXFxuY2xhc3MgQUJSZWNvcmQgZXh0ZW5kcyBSZWNvcmQoeyBhOiAxLCBiOiAyIH0pIHtcXG4gIGdldEFCKCkge1xcbiAgICByZXR1cm4gdGhpcy5hICsgdGhpcy5iO1xcbiAgfVxcbn1cXG5cXG52YXIgbXlSZWNvcmQgPSBuZXcgQUJSZWNvcmQoe2I6IDN9KVxcbm15UmVjb3JkLmdldEFCKCkgLy8gNFxcbmBgYFxcblxcblxcbioqRmxvdyBUeXBpbmcgUmVjb3JkczoqKlxcblxcbkltbXV0YWJsZS5qcyBleHBvcnRzIHR3byBGbG93IHR5cGVzIGRlc2lnbmVkIHRvIG1ha2UgaXQgZWFzaWVyIHRvIHVzZVxcblJlY29yZHMgd2l0aCBmbG93IHR5cGVkIGNvZGUsIGBSZWNvcmRPZjxUUHJvcHM+YCBhbmQgYFJlY29yZEZhY3Rvcnk8VFByb3BzPmAuXFxuXFxuV2hlbiBkZWZpbmluZyBhIG5ldyBraW5kIG9mIFJlY29yZCBmYWN0b3J5IGZ1bmN0aW9uLCB1c2UgYSBmbG93IHR5cGUgdGhhdFxcbmRlc2NyaWJlcyB0aGUgdmFsdWVzIHRoZSByZWNvcmQgY29udGFpbnMgYWxvbmcgd2l0aCBgUmVjb3JkRmFjdG9yeTxUUHJvcHM+YC5cXG5UbyB0eXBlIGluc3RhbmNlcyBvZiB0aGUgUmVjb3JkICh3aGljaCB0aGUgZmFjdG9yeSBmdW5jdGlvbiByZXR1cm5zKSxcXG51c2UgYFJlY29yZE9mPFRQcm9wcz5gLlxcblxcblR5cGljYWxseSwgbmV3IFJlY29yZCBkZWZpbml0aW9ucyB3aWxsIGV4cG9ydCBib3RoIHRoZSBSZWNvcmQgZmFjdG9yeVxcbmZ1bmN0aW9uIGFzIHdlbGwgYXMgdGhlIFJlY29yZCBpbnN0YW5jZSB0eXBlIGZvciB1c2UgaW4gb3RoZXIgY29kZS5cXG5cXG5gYGBqc1xcbmltcG9ydCB0eXBlIHsgUmVjb3JkRmFjdG9yeSwgUmVjb3JkT2YgfSBmcm9tICdpbW11dGFibGUnO1xcblxcbi8vIFVzZSBSZWNvcmRGYWN0b3J5PFRQcm9wcz4gZm9yIGRlZmluaW5nIG5ldyBSZWNvcmQgZmFjdG9yeSBmdW5jdGlvbnMuXFxudHlwZSBQb2ludDNEUHJvcHMgPSB7IHg6IG51bWJlciwgeTogbnVtYmVyLCB6OiBudW1iZXIgfTtcXG5jb25zdCBkZWZhdWx0VmFsdWVzOiBQb2ludDNEUHJvcHMgPSB7IHg6IDAsIHk6IDAsIHo6IDAgfTtcXG5jb25zdCBtYWtlUG9pbnQzRDogUmVjb3JkRmFjdG9yeTxQb2ludDNEUHJvcHM+ID0gUmVjb3JkKGRlZmF1bHRWYWx1ZXMpO1xcbmV4cG9ydCBtYWtlUG9pbnQzRDtcXG5cXG4vLyBVc2UgUmVjb3JkT2Y8VD4gZm9yIGRlZmluaW5nIG5ldyBpbnN0YW5jZXMgb2YgdGhhdCBSZWNvcmQuXFxuZXhwb3J0IHR5cGUgUG9pbnQzRCA9IFJlY29yZE9mPFBvaW50M0RQcm9wcz47XFxuY29uc3Qgc29tZTNEUG9pbnQ6IFBvaW50M0QgPSBtYWtlUG9pbnQzRCh7IHg6IDEwLCB5OiAyMCwgejogMzAgfSk7XFxuYGBgXFxuXFxuKipGbG93IFR5cGluZyBSZWNvcmQgU3ViY2xhc3NlczoqKlxcblxcblJlY29yZHMgY2FuIGJlIHN1YmNsYXNzZWQgYXMgYSBtZWFucyB0byBhZGQgYWRkaXRpb25hbCBtZXRob2RzIHRvIFJlY29yZFxcbmluc3RhbmNlcy4gVGhpcyBpcyBnZW5lcmFsbHkgZGlzY291cmFnZWQgaW4gZmF2b3Igb2YgYSBtb3JlIGZ1bmN0aW9uYWwgQVBJLFxcbnNpbmNlIFN1YmNsYXNzZXMgaGF2ZSBzb21lIG1pbm9yIG92ZXJoZWFkLiBIb3dldmVyIHRoZSBhYmlsaXR5IHRvIGNyZWF0ZVxcbmEgcmljaCBBUEkgb24gUmVjb3JkIHR5cGVzIGNhbiBiZSBxdWl0ZSB2YWx1YWJsZS5cXG5cXG5XaGVuIHVzaW5nIEZsb3cgdG8gdHlwZSBTdWJjbGFzc2VzLCBkbyBub3QgdXNlIGBSZWNvcmRGYWN0b3J5PFRQcm9wcz5gLFxcbmluc3RlYWQgYXBwbHkgdGhlIHByb3BzIHR5cGUgd2hlbiBzdWJjbGFzc2luZzpcXG5cXG5gYGBqc1xcbnR5cGUgUGVyc29uUHJvcHMgPSB7bmFtZTogc3RyaW5nLCBhZ2U6IG51bWJlcn07XFxuY29uc3QgZGVmYXVsdFZhbHVlczogUGVyc29uUHJvcHMgPSB7bmFtZTogJ0FyaXN0b3RsZScsIGFnZTogMjQwMH07XFxuY29uc3QgUGVyc29uUmVjb3JkID0gUmVjb3JkKGRlZmF1bHRWYWx1ZXMpO1xcbmNsYXNzIFBlcnNvbiBleHRlbmRzIFBlcnNvblJlY29yZDxQZXJzb25Qcm9wcz4ge1xcbiAgZ2V0TmFtZSgpOiBzdHJpbmcge1xcbiAgICByZXR1cm4gdGhpcy5nZXQoJ25hbWUnKVxcbiAgfVxcblxcbiAgc2V0TmFtZShuYW1lOiBzdHJpbmcpOiB0aGlzIHtcXG4gICAgcmV0dXJuIHRoaXMuc2V0KCduYW1lJywgbmFtZSk7XFxuICB9XFxufVxcbmBgYFxcblxcbioqQ2hvb3NpbmcgUmVjb3JkcyB2cyBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMqKlxcblxcblJlY29yZHMgb2ZmZXIgYSBwZXJzaXN0ZW50bHkgaW1tdXRhYmxlIGFsdGVybmF0aXZlIHRvIHBsYWluIEphdmFTY3JpcHRcXG5vYmplY3RzLCBob3dldmVyIHRoZXkncmUgbm90IHJlcXVpcmVkIHRvIGJlIHVzZWQgd2l0aGluIEltbXV0YWJsZS5qc1xcbmNvbGxlY3Rpb25zLiBJbiBmYWN0LCB0aGUgZGVlcC1hY2Nlc3MgYW5kIGRlZXAtdXBkYXRpbmcgZnVuY3Rpb25zXFxubGlrZSBgZ2V0SW4oKWAgYW5kIGBzZXRJbigpYCB3b3JrIHdpdGggcGxhaW4gSmF2YVNjcmlwdCBPYmplY3RzIGFzIHdlbGwuXFxuXFxuRGVjaWRpbmcgdG8gdXNlIFJlY29yZHMgb3IgT2JqZWN0cyBpbiB5b3VyIGFwcGxpY2F0aW9uIHNob3VsZCBiZSBpbmZvcm1lZFxcbmJ5IHRoZSB0cmFkZW9mZnMgYW5kIHJlbGF0aXZlIGJlbmVmaXRzIG9mIGVhY2g6XFxuXFxuLSAqUnVudGltZSBpbW11dGFiaWxpdHkqOiBwbGFpbiBKUyBvYmplY3RzIG1heSBiZSBjYXJlZnVsbHkgdHJlYXRlZCBhc1xcbiAgaW1tdXRhYmxlLCBob3dldmVyIFJlY29yZCBpbnN0YW5jZXMgd2lsbCAqdGhyb3cqIGlmIGF0dGVtcHRlZCB0byBiZVxcbiAgbXV0YXRlZCBkaXJlY3RseS4gUmVjb3JkcyBwcm92aWRlIHRoaXMgYWRkaXRpb25hbCBndWFyYW50ZWUsIGhvd2V2ZXIgYXRcXG4gIHNvbWUgbWFyZ2luYWwgcnVudGltZSBjb3N0LiBXaGlsZSBKUyBvYmplY3RzIGFyZSBtdXRhYmxlIGJ5IG5hdHVyZSwgdGhlXFxuICB1c2Ugb2YgdHlwZS1jaGVja2luZyB0b29scyBsaWtlIFtGbG93XShodHRwczovL21lZGl1bS5jb20vQGdjYW50aS9pbW11dGFiaWxpdHktd2l0aC1mbG93LWZhYTA1MGExYWVmNClcXG4gIGNhbiBoZWxwIGdhaW4gY29uZmlkZW5jZSBpbiBjb2RlIHdyaXR0ZW4gdG8gZmF2b3IgaW1tdXRhYmlsaXR5Llxcblxcbi0gKlZhbHVlIGVxdWFsaXR5KjogUmVjb3JkcyB1c2UgdmFsdWUgZXF1YWxpdHkgd2hlbiBjb21wYXJlZCB3aXRoIGBpcygpYFxcbiAgb3IgYHJlY29yZC5lcXVhbHMoKWAuIFRoYXQgaXMsIHR3byBSZWNvcmRzIHdpdGggdGhlIHNhbWUga2V5cyBhbmQgdmFsdWVzXFxuICBhcmUgZXF1YWwuIFBsYWluIG9iamVjdHMgdXNlICpyZWZlcmVuY2UgZXF1YWxpdHkqLiBUd28gb2JqZWN0cyB3aXRoIHRoZVxcbiAgc2FtZSBrZXlzIGFuZCB2YWx1ZXMgYXJlIG5vdCBlcXVhbCBzaW5jZSB0aGV5IGFyZSBkaWZmZXJlbnQgb2JqZWN0cy5cXG4gIFRoaXMgaXMgaW1wb3J0YW50IHRvIGNvbnNpZGVyIHdoZW4gdXNpbmcgb2JqZWN0cyBhcyBrZXlzIGluIGEgYE1hcGAgb3JcXG4gIHZhbHVlcyBpbiBhIGBTZXRgLCB3aGljaCB1c2UgZXF1YWxpdHkgd2hlbiByZXRyaWV2aW5nIHZhbHVlcy5cXG5cXG4tICpBUEkgbWV0aG9kcyo6IFJlY29yZHMgaGF2ZSBhIGZ1bGwgZmVhdHVyZWQgQVBJLCB3aXRoIG1ldGhvZHMgbGlrZVxcbiAgYC5nZXRJbigpYCwgYW5kIGAuZXF1YWxzKClgLiBUaGVzZSBjYW4gbWFrZSB3b3JraW5nIHdpdGggdGhlc2UgdmFsdWVzXFxuICBlYXNpZXIsIGJ1dCBjb21lcyBhdCB0aGUgY29zdCBvZiBub3QgYWxsb3dpbmcga2V5cyB3aXRoIHRob3NlIG5hbWVzLlxcblxcbi0gKkRlZmF1bHQgdmFsdWVzKjogUmVjb3JkcyBwcm92aWRlIGRlZmF1bHQgdmFsdWVzIGZvciBldmVyeSBrZXksIHdoaWNoXFxuICBjYW4gYmUgdXNlZnVsIHdoZW4gY29uc3RydWN0aW5nIFJlY29yZHMgd2l0aCBvZnRlbiB1bmNoYW5naW5nIHZhbHVlcy5cXG4gIEhvd2V2ZXIgZGVmYXVsdCB2YWx1ZXMgY2FuIG1ha2UgdXNpbmcgRmxvdyBhbmQgVHlwZVNjcmlwdCBtb3JlIGxhYm9yaW91cy5cXG5cXG4tICpTZXJpYWxpemF0aW9uKjogUmVjb3JkcyB1c2UgYSBjdXN0b20gaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gdG9cXG4gIGVmZmljaWVudGx5IHN0b3JlIGFuZCB1cGRhdGUgdGhlaXIgdmFsdWVzLiBDb252ZXJ0aW5nIHRvIGFuZCBmcm9tIHRoaXNcXG4gIGZvcm0gaXNuJ3QgZnJlZS4gSWYgY29udmVydGluZyBSZWNvcmRzIHRvIHBsYWluIG9iamVjdHMgaXMgY29tbW9uLFxcbiAgY29uc2lkZXIgc3RpY2tpbmcgd2l0aCBwbGFpbiBvYmplY3RzIHRvIGJlZ2luIHdpdGguXCIsXCJub3Rlc1wiOltdfSxcIm1vZHVsZVwiOntcImlzUmVjb3JkXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGBtYXliZVJlY29yZGAgaXMgYW4gaW5zdGFuY2Ugb2YgYSBSZWNvcmQuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlUmVjb3JkXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjoyMzY1fV19fSxcImdldERlc2NyaXB0aXZlTmFtZVwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmVjb3JkcyBhbGxvdyBwYXNzaW5nIGEgc2Vjb25kIHBhcmFtZXRlciB0byBzdXBwbHkgYSBkZXNjcmlwdGl2ZSBuYW1lXFxudGhhdCBhcHBlYXJzIHdoZW4gY29udmVydGluZyBhIFJlY29yZCB0byBhIHN0cmluZyBvciBpbiBhbnkgZXJyb3JcXG5tZXNzYWdlcy4gQSBkZXNjcmlwdGl2ZSBuYW1lIGZvciBhbnkgcmVjb3JkIGNhbiBiZSBhY2Nlc3NlZCBieSB1c2luZyB0aGlzXFxubWV0aG9kLiBJZiBvbmUgd2FzIG5vdCBwcm92aWRlZCwgdGhlIHN0cmluZyBcXFwiUmVjb3JkXFxcIiBpcyByZXR1cm5lZC5cIixcImRlc2NyaXB0aW9uXCI6XCJgYGBqc1xcbmNvbnN0IHsgUmVjb3JkIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IFBlcnNvbiA9IFJlY29yZCh7XFxuICBuYW1lOiBudWxsXFxufSwgJ1BlcnNvbicpXFxuXFxudmFyIG1lID0gUGVyc29uKHsgbmFtZTogJ015IE5hbWUnIH0pXFxubWUudG9TdHJpbmcoKSAvLyBcXFwiUGVyc29uIHsgXFxcIm5hbWVcXFwiOiBcXFwiTXkgTmFtZVxcXCIgfVxcXCJcXG5SZWNvcmQuZ2V0RGVzY3JpcHRpdmVOYW1lKG1lKSAvLyBcXFwiUGVyc29uXFxcIlxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJyZWNvcmRcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlJlY29yZFwiLFwiYXJnc1wiOlt7XCJrXCI6MH1dfX1dLFwidHlwZVwiOntcImtcIjozfSxcImxpbmVcIjoyMzg0fV19fSxcIkZhY3RvcnlcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQSBSZWNvcmQuRmFjdG9yeSBpcyBjcmVhdGVkIGJ5IHRoZSBgUmVjb3JkKClgIGZ1bmN0aW9uLiBSZWNvcmQgaW5zdGFuY2VzXFxuYXJlIGNyZWF0ZWQgYnkgcGFzc2luZyBpdCBzb21lIG9mIHRoZSBhY2NlcHRlZCB2YWx1ZXMgZm9yIHRoYXQgUmVjb3JkXFxudHlwZTpcIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBSZWNvcmQgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxcIiB9XFxuLS0+XFxuYGBganNcXG4vLyBtYWtlUGVyc29uIGlzIGEgUmVjb3JkIEZhY3RvcnkgZnVuY3Rpb25cXG5jb25zdCBtYWtlUGVyc29uID0gUmVjb3JkKHsgbmFtZTogbnVsbCwgZmF2b3JpdGVDb2xvcjogJ3Vua25vd24nIH0pO1xcblxcbi8vIGFsYW4gaXMgYSBSZWNvcmQgaW5zdGFuY2VcXG5jb25zdCBhbGFuID0gbWFrZVBlcnNvbih7IG5hbWU6ICdBbGFuJyB9KTtcXG5gYGBcXG5cXG5Ob3RlIHRoYXQgUmVjb3JkIEZhY3RvcmllcyByZXR1cm4gYFJlY29yZDxUUHJvcHM+ICYgUmVhZG9ubHk8VFByb3BzPmAsXFxudGhpcyBhbGxvd3MgdXNlIG9mIGJvdGggdGhlIFJlY29yZCBpbnN0YW5jZSBBUEksIGFuZCBkaXJlY3QgcHJvcGVydHlcXG5hY2Nlc3Mgb24gdGhlIHJlc3VsdGluZyBpbnN0YW5jZXM6XFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgUmVjb3JkIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtjb25zdCBtYWtlUGVyc29uID0gUmVjb3JkKHsgbmFtZTogbnVsbCwgZmF2b3JpdGVDb2xvcjogJ3Vua25vd24nIH0pO2NvbnN0IGFsYW4gPSBtYWtlUGVyc29uKHsgbmFtZTogJ0FsYW4nIH0pO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuLy8gVXNlIHRoZSBSZWNvcmQgQVBJXFxuY29uc29sZS5sb2coJ1JlY29yZCBBUEk6ICcgKyBhbGFuLmdldCgnbmFtZScpKVxcblxcbi8vIE9yIGRpcmVjdCBwcm9wZXJ0eSBhY2Nlc3MgKFJlYWRvbmx5KVxcbmNvbnNvbGUubG9nKCdwcm9wZXJ0eSBhY2Nlc3M6ICcgKyBhbGFuLm5hbWUpXFxuYGBgXFxuXFxuKipGbG93IFR5cGluZyBSZWNvcmRzOioqXFxuXFxuVXNlIHRoZSBgUmVjb3JkRmFjdG9yeTxUUHJvcHM+YCBGbG93IHR5cGUgdG8gZ2V0IGhpZ2ggcXVhbGl0eSB0eXBlIGNoZWNraW5nIG9mXFxuUmVjb3JkczpcXG5cXG5gYGBqc1xcbmltcG9ydCB0eXBlIHsgUmVjb3JkRmFjdG9yeSwgUmVjb3JkT2YgfSBmcm9tICdpbW11dGFibGUnO1xcblxcbi8vIFVzZSBSZWNvcmRGYWN0b3J5PFRQcm9wcz4gZm9yIGRlZmluaW5nIG5ldyBSZWNvcmQgZmFjdG9yeSBmdW5jdGlvbnMuXFxudHlwZSBQZXJzb25Qcm9wcyA9IHsgbmFtZTogP3N0cmluZywgZmF2b3JpdGVDb2xvcjogc3RyaW5nIH07XFxuY29uc3QgbWFrZVBlcnNvbjogUmVjb3JkRmFjdG9yeTxQZXJzb25Qcm9wcz4gPSBSZWNvcmQoeyBuYW1lOiBudWxsLCBmYXZvcml0ZUNvbG9yOiAndW5rbm93bicgfSk7XFxuXFxuLy8gVXNlIFJlY29yZE9mPFQ+IGZvciBkZWZpbmluZyBuZXcgaW5zdGFuY2VzIG9mIHRoYXQgUmVjb3JkLlxcbnR5cGUgUGVyc29uID0gUmVjb3JkT2Y8UGVyc29uUHJvcHM+O1xcbmNvbnN0IGFsYW46IFBlcnNvbiA9IG1ha2VQZXJzb24oeyBuYW1lOiAnQWxhbicgfSk7XFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcIm1vZHVsZVwiOnt9LFwiaW50ZXJmYWNlXCI6e1wibGluZVwiOjI0MzYsXCJ0eXBlUGFyYW1zXCI6W1wiVFByb3BzXCJdLFwiZ3JvdXBzXCI6W3tcIm1lbWJlcnNcIjp7XCIjZGlzcGxheU5hbWVcIjp7XCJsaW5lXCI6MjQ0NH19fV19LFwiY2FsbFwiOntcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRQcm9wc1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZXNcIixcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIlBhcnRpYWxcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9XX0se1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6M30se1wia1wiOjE3fV19XX1dfSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMyxcInR5cGVzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiUmVjb3JkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRQcm9wc1wifV19LHtcImtcIjo5LFwibmFtZVwiOlwiUmVhZG9ubHlcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9XX1dfSxcImxpbmVcIjoyNDQ3fV19fX0sXCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlVubGlrZSBvdGhlciB0eXBlcyBpbiBJbW11dGFibGUuanMsIHRoZSBgUmVjb3JkKClgIGZ1bmN0aW9uIGNyZWF0ZXMgYSBuZXdcXG5SZWNvcmQgRmFjdG9yeSwgd2hpY2ggaXMgYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgUmVjb3JkIGluc3RhbmNlcy5cIixcImRlc2NyaXB0aW9uXCI6XCJTZWUgYWJvdmUgZm9yIGV4YW1wbGVzIG9mIHVzaW5nIGBSZWNvcmQoKWAuXFxuXFxuTm90ZTogYFJlY29yZGAgaXMgYSBmYWN0b3J5IGZ1bmN0aW9uIGFuZCBub3QgYSBjbGFzcywgYW5kIGRvZXMgbm90IHVzZSB0aGVcXG5gbmV3YCBrZXl3b3JkIGR1cmluZyBjb25zdHJ1Y3Rpb24uXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRQcm9wc1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJkZWZhdWx0VmFsdWVzXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9fSx7XCJuYW1lXCI6XCJuYW1lXCIsXCJ0eXBlXCI6e1wia1wiOjN9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJSZWNvcmQuRmFjdG9yeVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn1dfSxcImxpbmVcIjoyNDU5fV19LFwiaW50ZXJmYWNlXCI6e1wibGluZVwiOjI0NjEsXCJ0eXBlUGFyYW1zXCI6W1wiVFByb3BzXCJdLFwiZ3JvdXBzXCI6W3tcInRpdGxlXCI6XCJSZWFkaW5nIHZhbHVlc1wiLFwibWVtYmVyc1wiOntcIiNoYXNcIjp7XCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6MjQ2NX1dfSxcIiNnZXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm92aWRlZCBrZXksIHdoaWNoIG1heSBiZSB0aGVcXG5kZWZhdWx0IHZhbHVlIGRlZmluZWQgd2hlbiBjcmVhdGluZyB0aGUgUmVjb3JkIGZhY3RvcnkgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiSWYgdGhlIHJlcXVlc3RlZCBrZXkgaXMgbm90IGRlZmluZWQgYnkgdGhpcyBSZWNvcmQgdHlwZSwgdGhlblxcbm5vdFNldFZhbHVlIHdpbGwgYmUgcmV0dXJuZWQgaWYgcHJvdmlkZWQuIE5vdGUgdGhhdCB0aGlzIHNjZW5hcmlvIHdvdWxkXFxucHJvZHVjZSBhbiBlcnJvciB3aGVuIHVzaW5nIEZsb3cgb3IgVHlwZVNjcmlwdC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTUsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9LFwiaW5kZXhcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSxcImxpbmVcIjoyNDc1fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319LHtcIm5hbWVcIjpcIm5vdFNldFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0sXCJsaW5lXCI6MjQ3Nn1dfX19LHtcInRpdGxlXCI6XCJSZWFkaW5nIGRlZXAgdmFsdWVzXCIsXCJtZW1iZXJzXCI6e1wiI2hhc0luXCI6e1wic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5UGF0aFwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjI0ODB9XX0sXCIjZ2V0SW5cIjp7XCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlQYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX19XSxcInR5cGVcIjp7XCJrXCI6MTd9LFwibGluZVwiOjI0ODF9XX19fSx7XCJ0aXRsZVwiOlwiVmFsdWUgZXF1YWxpdHlcIixcIm1lbWJlcnNcIjp7XCIjZXF1YWxzXCI6e1wic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib3RoZXJcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjI0ODV9XX0sXCIjaGFzaENvZGVcIjp7XCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6Mn0sXCJsaW5lXCI6MjQ4Nn1dfX19LHtcInRpdGxlXCI6XCJQZXJzaXN0ZW50IGNoYW5nZXNcIixcIm1lbWJlcnNcIjp7XCIjc2V0XCI6e1wic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxNSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn0sXCJpbmRleFwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoyNDkwfV19LFwiI3VwZGF0ZVwiOntcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE1LFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRQcm9wc1wifSxcImluZGV4XCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX19XSxcInR5cGVcIjp7XCJrXCI6MTUsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9LFwiaW5kZXhcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fX19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjI0OTF9XX0sXCIjbWVyZ2VcIjp7XCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJQYXJ0aWFsXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRQcm9wc1wifV19LHtcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjN9LHtcImtcIjoxN31dfV19XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoyNDkyfV19LFwiI21lcmdlRGVlcFwiOntcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIlBhcnRpYWxcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9XX0se1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6M30se1wia1wiOjE3fV19XX1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjI0OTN9XX0sXCIjbWVyZ2VXaXRoXCI6e1wic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWVyZ2VyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib2xkVmFsXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX0se1wibmFtZVwiOlwibmV3VmFsXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjE2LFwib3BlcmF0b3JcIjpcImtleW9mXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9fX1dLFwidHlwZVwiOntcImtcIjoxN319fSx7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJQYXJ0aWFsXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRQcm9wc1wifV19LHtcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjN9LHtcImtcIjoxN31dfV19XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoyNDk1fV19LFwiI21lcmdlRGVlcFdpdGhcIjp7XCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtZXJnZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvbGRWYWxcIixcInR5cGVcIjp7XCJrXCI6MTd9fSx7XCJuYW1lXCI6XCJuZXdWYWxcIixcInR5cGVcIjp7XCJrXCI6MTd9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19LHtcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIlBhcnRpYWxcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9XX0se1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6M30se1wia1wiOjE3fV19XX1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjI0OTl9XX0sXCIjZGVsZXRlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhpcyBSZWNvcmQgdHlwZSB3aXRoIHRoZSB2YWx1ZSBmb3IgdGhlXFxuc3BlY2lmaWMga2V5IHNldCB0byBpdHMgZGVmYXVsdCB2YWx1ZS5cXG5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcImFsaWFzXCIsXCJib2R5XCI6XCJyZW1vdmVcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MjUxMH1dfSxcIiNjbGVhclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIHRoaXMgUmVjb3JkIHR5cGUgd2l0aCBhbGwgdmFsdWVzIHNldFxcbnRvIHRoZWlyIGRlZmF1bHQgdmFsdWVzLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjI1MTd9XX19fSx7XCJ0aXRsZVwiOlwiRGVlcCBwZXJzaXN0ZW50IGNoYW5nZXNcIixcIm1lbWJlcnNcIjp7XCIjc2V0SW5cIjp7XCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlQYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MjUyMX1dfSxcIiN1cGRhdGVJblwiOntcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX0se1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxN319fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoyNTIyfV19LFwiI21lcmdlSW5cIjp7XCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlQYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX19LHtcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MjUyM31dfSxcIiNtZXJnZURlZXBJblwiOntcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX0se1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoyNTI0fV19LFwiI2RlbGV0ZUluXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwiYWxpYXNcIixcImJvZHlcIjpcInJlbW92ZUluXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlQYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjI1Mjl9XX19fSx7XCJ0aXRsZVwiOlwiQ29udmVyc2lvbiB0byBKYXZhU2NyaXB0IHR5cGVzXCIsXCJtZW1iZXJzXCI6e1wiI3RvSlNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRGVlcGx5IGNvbnZlcnRzIHRoaXMgUmVjb3JkIHRvIGVxdWl2YWxlbnQgbmF0aXZlIEphdmFTY3JpcHQgT2JqZWN0LlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IFRoaXMgbWV0aG9kIG1heSBub3QgYmUgb3ZlcnJpZGRlbi4gT2JqZWN0cyB3aXRoIGN1c3RvbVxcbnNlcmlhbGl6YXRpb24gdG8gcGxhaW4gSlMgbWF5IG92ZXJyaWRlIHRvSlNPTigpIGluc3RlYWQuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX1dfSxcImxpbmVcIjoyNTQwfV19LFwiI3RvSlNPTlwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJTaGFsbG93bHkgY29udmVydHMgdGhpcyBSZWNvcmQgdG8gZXF1aXZhbGVudCBuYXRpdmUgSmF2YVNjcmlwdCBPYmplY3QuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRQcm9wc1wifSxcImxpbmVcIjoyNTQ1fV19LFwiI3RvT2JqZWN0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNoYWxsb3dseSBjb252ZXJ0cyB0aGlzIFJlY29yZCB0byBlcXVpdmFsZW50IEphdmFTY3JpcHQgT2JqZWN0LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn0sXCJsaW5lXCI6MjU1MH1dfX19LHtcInRpdGxlXCI6XCJUcmFuc2llbnQgY2hhbmdlc1wiLFwibWVtYmVyc1wiOntcIiN3aXRoTXV0YXRpb25zXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIk5vdGU6IE5vdCBhbGwgbWV0aG9kcyBjYW4gYmUgdXNlZCBvbiBhIG11dGFibGUgY29sbGVjdGlvbiBvciB3aXRoaW5cXG5gd2l0aE11dGF0aW9uc2AhIE9ubHkgYHNldGAgbWF5IGJlIHVzZWQgbXV0YXRpdmVseS5cXG5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiYE1hcCN3aXRoTXV0YXRpb25zYFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibXV0YXRvclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm11dGFibGVcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjI1NjB9XX0sXCIjYXNNdXRhYmxlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI2FzTXV0YWJsZWBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MjU2NX1dfSxcIiN3YXNBbHRlcmVkXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI3dhc0FsdGVyZWRgXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6MjU3MH1dfSxcIiNhc0ltbXV0YWJsZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiYE1hcCNhc0ltbXV0YWJsZWBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MjU3NX1dfX19LHtcInRpdGxlXCI6XCJTZXF1ZW5jZSBhbGdvcml0aG1zXCIsXCJtZW1iZXJzXCI6e1wiI3RvU2VxXCI6e1wic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjE2LFwib3BlcmF0b3JcIjpcImtleW9mXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9fSx7XCJrXCI6MTUsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9LFwiaW5kZXhcIjp7XCJrXCI6MTYsXCJvcGVyYXRvclwiOlwia2V5b2ZcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn19fV19LFwibGluZVwiOjI1Nzl9XX0sXCIjW1N5bWJvbC5pdGVyYXRvcl1cIjp7XCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlSXRlcmF0b3JcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjE2LFwib3BlcmF0b3JcIjpcImtleW9mXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9fSx7XCJrXCI6MTUsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9LFwiaW5kZXhcIjp7XCJrXCI6MTYsXCJvcGVyYXRvclwiOlwia2V5b2ZcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn19fV19XX0sXCJsaW5lXCI6MjU4MX1dfX19XX19LFwiU2VxXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcImBTZXFgIGRlc2NyaWJlcyBhIGxhenkgb3BlcmF0aW9uLCBhbGxvd2luZyB0aGVtIHRvIGVmZmljaWVudGx5IGNoYWluXFxudXNlIG9mIGFsbCB0aGUgaGlnaGVyLW9yZGVyIGNvbGxlY3Rpb24gbWV0aG9kcyAoc3VjaCBhcyBgbWFwYCBhbmQgYGZpbHRlcmApXFxuYnkgbm90IGNyZWF0aW5nIGludGVybWVkaWF0ZSBjb2xsZWN0aW9ucy5cIixcImRlc2NyaXB0aW9uXCI6XCIqKlNlcSBpcyBpbW11dGFibGUqKiDigJQgT25jZSBhIFNlcSBpcyBjcmVhdGVkLCBpdCBjYW5ub3QgYmVcXG5jaGFuZ2VkLCBhcHBlbmRlZCB0bywgcmVhcnJhbmdlZCBvciBvdGhlcndpc2UgbW9kaWZpZWQuIEluc3RlYWQsIGFueVxcbm11dGF0aXZlIG1ldGhvZCBjYWxsZWQgb24gYSBgU2VxYCB3aWxsIHJldHVybiBhIG5ldyBgU2VxYC5cXG5cXG4qKlNlcSBpcyBsYXp5Kiog4oCUIGBTZXFgIGRvZXMgYXMgbGl0dGxlIHdvcmsgYXMgbmVjZXNzYXJ5IHRvIHJlc3BvbmQgdG8gYW55XFxubWV0aG9kIGNhbGwuIFZhbHVlcyBhcmUgb2Z0ZW4gY3JlYXRlZCBkdXJpbmcgaXRlcmF0aW9uLCBpbmNsdWRpbmcgaW1wbGljaXRcXG5pdGVyYXRpb24gd2hlbiByZWR1Y2luZyBvciBjb252ZXJ0aW5nIHRvIGEgY29uY3JldGUgZGF0YSBzdHJ1Y3R1cmUgc3VjaCBhc1xcbmEgYExpc3RgIG9yIEphdmFTY3JpcHQgYEFycmF5YC5cXG5cXG5Gb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZyBwZXJmb3JtcyBubyB3b3JrLCBiZWNhdXNlIHRoZSByZXN1bHRpbmdcXG5gU2VxYCdzIHZhbHVlcyBhcmUgbmV2ZXIgaXRlcmF0ZWQ6XFxuXFxuYGBganNcXG5jb25zdCB7IFNlcSB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBvZGRTcXVhcmVzID0gU2VxKFsgMSwgMiwgMywgNCwgNSwgNiwgNywgOCBdKVxcbiAgLmZpbHRlcih4ID0+IHggJSAyICE9PSAwKVxcbiAgLm1hcCh4ID0+IHggKiB4KVxcbmBgYFxcblxcbk9uY2UgdGhlIGBTZXFgIGlzIHVzZWQsIGl0IHBlcmZvcm1zIG9ubHkgdGhlIHdvcmsgbmVjZXNzYXJ5LiBJbiB0aGlzXFxuZXhhbXBsZSwgbm8gaW50ZXJtZWRpYXRlIGFycmF5cyBhcmUgZXZlciBjcmVhdGVkLCBmaWx0ZXIgaXMgY2FsbGVkIHRocmVlXFxudGltZXMsIGFuZCBtYXAgaXMgb25seSBjYWxsZWQgb25jZTpcXG5cXG5gYGBqc1xcbm9kZFNxdWFyZXMuZ2V0KDEpOyAvLyA5XFxuYGBgXFxuXFxuQW55IGNvbGxlY3Rpb24gY2FuIGJlIGNvbnZlcnRlZCB0byBhIGxhenkgU2VxIHdpdGggYFNlcSgpYC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG1hcCA9IE1hcCh7IGE6IDEsIGI6IDIsIGM6IDMgfSlcXG5jb25zdCBsYXp5U2VxID0gU2VxKG1hcClcXG5gYGBcXG5cXG5gU2VxYCBhbGxvd3MgZm9yIHRoZSBlZmZpY2llbnQgY2hhaW5pbmcgb2Ygb3BlcmF0aW9ucywgYWxsb3dpbmcgZm9yIHRoZVxcbmV4cHJlc3Npb24gb2YgbG9naWMgdGhhdCBjYW4gb3RoZXJ3aXNlIGJlIHZlcnkgdGVkaW91czpcXG5cXG5gYGBqc1xcbmxhenlTZXFcXG4gIC5mbGlwKClcXG4gIC5tYXAoa2V5ID0+IGtleS50b1VwcGVyQ2FzZSgpKVxcbiAgLmZsaXAoKVxcbi8vIFNlcSB7IEE6IDEsIEI6IDEsIEM6IDEgfVxcbmBgYFxcblxcbkFzIHdlbGwgYXMgZXhwcmVzc2luZyBsb2dpYyB0aGF0IHdvdWxkIG90aGVyd2lzZSBzZWVtIG1lbW9yeSBvciB0aW1lXFxubGltaXRlZCwgZm9yIGV4YW1wbGUgYFJhbmdlYCBpcyBhIHNwZWNpYWwga2luZCBvZiBMYXp5IHNlcXVlbmNlLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBSYW5nZSB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5SYW5nZSgxLCBJbmZpbml0eSlcXG4gIC5za2lwKDEwMDApXFxuICAubWFwKG4gPT4gLW4pXFxuICAuZmlsdGVyKG4gPT4gbiAlIDIgPT09IDApXFxuICAudGFrZSgyKVxcbiAgLnJlZHVjZSgociwgbikgPT4gciAqIG4sIDEpXFxuLy8gMTAwNjAwOFxcbmBgYFxcblxcblNlcSBpcyBvZnRlbiB1c2VkIHRvIHByb3ZpZGUgYSByaWNoIGNvbGxlY3Rpb24gQVBJIHRvIEphdmFTY3JpcHQgT2JqZWN0LlxcblxcbmBgYGpzXFxuU2VxKHsgeDogMCwgeTogMSwgejogMiB9KS5tYXAodiA9PiB2ICogMikudG9PYmplY3QoKTtcXG4vLyB7IHg6IDAsIHk6IDIsIHo6IDQgfVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJtb2R1bGVcIjp7XCJpc1NlcVwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVTZXFgIGlzIGEgU2VxLCBpdCBpcyBub3QgYmFja2VkIGJ5IGEgY29uY3JldGVcXG5zdHJ1Y3R1cmUgc3VjaCBhcyBNYXAsIExpc3QsIG9yIFNldC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVTZXFcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjI2NzN9XX19LFwiS2V5ZWRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiYFNlcWAgd2hpY2ggcmVwcmVzZW50cyBrZXktdmFsdWUgcGFpcnMuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcIm1vZHVsZVwiOnt9LFwiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJBbHdheXMgcmV0dXJucyBhIFNlcS5LZXllZCwgaWYgaW5wdXQgaXMgbm90IGtleWVkLCBleHBlY3RzIGFuXFxuY29sbGVjdGlvbiBvZiBbSywgVl0gdHVwbGVzLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBTZXEuS2V5ZWRgIGlzIGEgY29udmVyc2lvbiBmdW5jdGlvbiBhbmQgbm90IGEgY2xhc3MsIGFuZCBkb2VzIG5vdFxcbnVzZSB0aGUgYG5ld2Aga2V5d29yZCBkdXJpbmcgY29uc3RydWN0aW9uLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjoyNjg4fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvYmpcIixcInR5cGVcIjp7XCJrXCI6NCxcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6M30se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjI2ODl9LHtcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCJdLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjI2OTB9LHtcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfSxcImxpbmVcIjoyNjkxfV19LFwiaW50ZXJmYWNlXCI6e1wibGluZVwiOjI2OTMsXCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiXSxcImV4dGVuZHNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJTZXFcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0se1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XSxcImdyb3Vwc1wiOlt7XCJtZW1iZXJzXCI6e1wiI3RvSlNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRGVlcGx5IGNvbnZlcnRzIHRoaXMgS2V5ZWQgU2VxIHRvIGVxdWl2YWxlbnQgbmF0aXZlIEphdmFTY3JpcHQgT2JqZWN0LlwiLFwiZGVzY3JpcHRpb25cIjpcIkNvbnZlcnRzIGtleXMgdG8gU3RyaW5ncy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6MTd9fV19LFwibGluZVwiOjI2OTl9XX0sXCIjdG9KU09OXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNoYWxsb3dseSBjb252ZXJ0cyB0aGlzIEtleWVkIFNlcSB0byBlcXVpdmFsZW50IG5hdGl2ZSBKYXZhU2NyaXB0IE9iamVjdC5cIixcImRlc2NyaXB0aW9uXCI6XCJDb252ZXJ0cyBrZXlzIHRvIFN0cmluZ3MuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dfSxcImxpbmVcIjoyNzA2fV19LFwiI3RvQXJyYXlcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiU2hhbGxvd2x5IGNvbnZlcnRzIHRoaXMgY29sbGVjdGlvbiB0byBhbiBBcnJheS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfV19LFwibGluZVwiOjI3MTF9XX0sXCIjdG9TZXFcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBpdHNlbGZcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoyNzE2fV19LFwiI2NvbmNhdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFNlcSB3aXRoIG90aGVyIGNvbGxlY3Rpb25zIGNvbmNhdGVuYXRlZCB0byB0aGlzIG9uZS5cIixcImRlc2NyaXB0aW9uXCI6XCJBbGwgZW50cmllcyB3aWxsIGJlIHByZXNlbnQgaW4gdGhlIHJlc3VsdGluZyBTZXEsIGV2ZW4gaWYgdGhleVxcbmhhdmUgdGhlIHNhbWUga2V5LlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJLQ1wiLFwiVkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS0NcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVkNcIn1dfV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiS0NcIn1dfSx7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZDXCJ9XX1dfSxcImxpbmVcIjoyNzI0fSx7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjN9XX0se1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9XX1dfSxcImxpbmVcIjoyNzI1fV19LFwiI21hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFNlcS5LZXllZCB3aXRoIHZhbHVlcyBwYXNzZWQgdGhyb3VnaCBhXFxuYG1hcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiYGBganNcXG5jb25zdCB7IFNlcSB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5TZXEuS2V5ZWQoeyBhOiAxLCBiOiAyIH0pLm1hcCh4ID0+IDEwICogeClcXG4vLyBTZXEgeyBcXFwiYVxcXCI6IDEwLCBcXFwiYlxcXCI6IDIwIH1cXG5gYGBcXG5cXG5Ob3RlOiBgbWFwKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHByb2R1Y2VkIHRoZVxcbnNhbWUgdmFsdWUgYXQgZXZlcnkgc3RlcC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6Mjc0MH1dfSxcIiNtYXBLZXlzXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJDb2xsZWN0aW9uLktleWVkLm1hcEtleXNcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk1cIn19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjI3NDh9XX0sXCIjbWFwRW50cmllc1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiQ29sbGVjdGlvbi5LZXllZC5tYXBFbnRyaWVzXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJLTVwiLFwiVk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiZW50cnlcIixcInR5cGVcIjp7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX0se1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS01cIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVk1cIn1dfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS01cIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVk1cIn1dfSxcImxpbmVcIjoyNzU2fV19LFwiI2ZsYXRNYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRmxhdC1tYXBzIHRoZSBTZXEsIHJldHVybmluZyBhIFNlcSBvZiB0aGUgc2FtZSB0eXBlLlwiLFwiZGVzY3JpcHRpb25cIjpcIlNpbWlsYXIgdG8gYHNlcS5tYXAoLi4uKS5mbGF0dGVuKHRydWUpYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS01cIixcIlZNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZNXCJ9XX1dfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS01cIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVk1cIn1dfSxcImxpbmVcIjoyNzY2fV19LFwiI2ZpbHRlclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFNlcSB3aXRoIG9ubHkgdGhlIGVudHJpZXMgZm9yIHdoaWNoIHRoZSBgcHJlZGljYXRlYFxcbmZ1bmN0aW9uIHJldHVybnMgdHJ1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgZmlsdGVyKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHJlc3VsdHMgaW5cXG5ub3QgZmlsdGVyaW5nIG91dCBhbnkgdmFsdWVzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJGXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiRlwifV19LFwibGluZVwiOjI3Nzh9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoyNzgyfV19LFwiI2ZsaXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcIkNvbGxlY3Rpb24uS2V5ZWQuZmxpcFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9XX0sXCJsaW5lXCI6Mjc5MH1dfX19XX19LFwiSW5kZXhlZFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJgU2VxYCB3aGljaCByZXByZXNlbnRzIGFuIG9yZGVyZWQgaW5kZXhlZCBsaXN0IG9mIHZhbHVlcy5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwibW9kdWxlXCI6e1wib2ZcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlByb3ZpZGVzIGFuIFNlcS5JbmRleGVkIG9mIHRoZSB2YWx1ZXMgcHJvdmlkZWQuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVzXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjI4MDJ9XX19fSxcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQWx3YXlzIHJldHVybnMgU2VxLkluZGV4ZWQsIGRpc2NhcmRpbmcgYXNzb2NpYXRlZCBrZXlzIGFuZFxcbnN1cHBseWluZyBpbmNyZW1lbnRpbmcgaW5kaWNlcy5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgU2VxLkluZGV4ZWRgIGlzIGEgY29udmVyc2lvbiBmdW5jdGlvbiBhbmQgbm90IGEgY2xhc3MsIGFuZCBkb2VzXFxubm90IHVzZSB0aGUgYG5ld2Aga2V5d29yZCBkdXJpbmcgY29uc3RydWN0aW9uLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjI4MTJ9LHtcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjI4MTN9LHtcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcImxpbmVcIjoyODE0fV19LFwiaW50ZXJmYWNlXCI6e1wibGluZVwiOjI4MTYsXCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcImV4dGVuZHNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJTZXFcIixcImFyZ3NcIjpbe1wia1wiOjJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSx7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX1dLFwiZ3JvdXBzXCI6W3tcIm1lbWJlcnNcIjp7XCIjdG9KU1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJEZWVwbHkgY29udmVydHMgdGhpcyBJbmRleGVkIFNlcSB0byBlcXVpdmFsZW50IG5hdGl2ZSBKYXZhU2NyaXB0IEFycmF5LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcImxpbmVcIjoyODIwfV19LFwiI3RvSlNPTlwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJTaGFsbG93bHkgY29udmVydHMgdGhpcyBJbmRleGVkIFNlcSB0byBlcXVpdmFsZW50IG5hdGl2ZSBKYXZhU2NyaXB0IEFycmF5LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoyODI1fV19LFwiI3RvQXJyYXlcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiU2hhbGxvd2x5IGNvbnZlcnRzIHRoaXMgY29sbGVjdGlvbiB0byBhbiBBcnJheS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MjgzMH1dfSxcIiN0b1NlcVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGl0c2VsZlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjI4MzV9XX0sXCIjY29uY2F0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU2VxIHdpdGggb3RoZXIgY29sbGVjdGlvbnMgY29uY2F0ZW5hdGVkIHRvIHRoaXMgb25lLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlc09yQ29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifV19LHtcImtcIjo4LFwicGFyYW1cIjpcIkNcIn1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifV19XX0sXCJsaW5lXCI6Mjg0MH1dfSxcIiNtYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBTZXEuSW5kZXhlZCB3aXRoIHZhbHVlcyBwYXNzZWQgdGhyb3VnaCBhXFxuYG1hcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiYGBganNcXG5jb25zdCB7IFNlcSB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5TZXEuSW5kZXhlZChbIDEsIDIgXSkubWFwKHggPT4gMTAgKiB4KVxcbi8vIFNlcSBbIDEwLCAyMCBdXFxuYGBgXFxuXFxuTm90ZTogYG1hcCgpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCBwcm9kdWNlZCB0aGVcXG5zYW1lIHZhbHVlIGF0IGV2ZXJ5IHN0ZXAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6Mjg1NX1dfSxcIiNmbGF0TWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkZsYXQtbWFwcyB0aGUgU2VxLCByZXR1cm5pbmcgYSBhIFNlcSBvZiB0aGUgc2FtZSB0eXBlLlwiLFwiZGVzY3JpcHRpb25cIjpcIlNpbWlsYXIgdG8gYHNlcS5tYXAoLi4uKS5mbGF0dGVuKHRydWUpYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6Mjg2NX1dfSxcIiNmaWx0ZXJcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBTZXEgd2l0aCBvbmx5IHRoZSB2YWx1ZXMgZm9yIHdoaWNoIHRoZSBgcHJlZGljYXRlYFxcbmZ1bmN0aW9uIHJldHVybnMgdHJ1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgZmlsdGVyKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHJlc3VsdHMgaW5cXG5ub3QgZmlsdGVyaW5nIG91dCBhbnkgdmFsdWVzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJGXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIkZcIn1dfSxcImxpbmVcIjoyODc3fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJpbmRleFwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MTd9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjI4ODF9XX0sXCIjemlwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBTZXEgXFxcInppcHBlZFxcXCIgd2l0aCB0aGUgcHJvdmlkZWQgY29sbGVjdGlvbnMuXCIsXCJkZXNjcmlwdGlvblwiOlwiTGlrZSBgemlwV2l0aGAsIGJ1dCB1c2luZyB0aGUgZGVmYXVsdCBgemlwcGVyYDogY3JlYXRpbmcgYW4gYEFycmF5YC5cXG5cXG5gYGBqc1xcbmNvbnN0IGEgPSBTZXEoWyAxLCAyLCAzIF0pO1xcbmNvbnN0IGIgPSBTZXEoWyA0LCA1LCA2IF0pO1xcbmNvbnN0IGMgPSBhLnppcChiKTsgLy8gU2VxIFsgWyAxLCA0IF0sIFsgMiwgNSBdLCBbIDMsIDYgXSBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlVcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib3RoZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19XX0sXCJsaW5lXCI6Mjg5N30se1widHlwZVBhcmFtc1wiOltcIlVcIixcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib3RoZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19LHtcIm5hbWVcIjpcIm90aGVyMlwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfV19LFwibGluZVwiOjI4OTh9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwibGluZVwiOjI4OTl9XX0sXCIjemlwQWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBTZXEgXFxcInppcHBlZFxcXCIgd2l0aCB0aGUgcHJvdmlkZWQgY29sbGVjdGlvbnMuXCIsXCJkZXNjcmlwdGlvblwiOlwiVW5saWtlIGB6aXBgLCBgemlwQWxsYCBjb250aW51ZXMgemlwcGluZyB1bnRpbCB0aGUgbG9uZ2VzdCBjb2xsZWN0aW9uIGlzXFxuZXhoYXVzdGVkLiBNaXNzaW5nIHZhbHVlcyBmcm9tIHNob3J0ZXIgY29sbGVjdGlvbnMgYXJlIGZpbGxlZCB3aXRoIGB1bmRlZmluZWRgLlxcblxcbmBgYGpzXFxuY29uc3QgYSA9IFNlcShbIDEsIDIgXSk7XFxuY29uc3QgYiA9IFNlcShbIDMsIDQsIDUgXSk7XFxuY29uc3QgYyA9IGEuemlwQWxsKGIpOyAvLyBTZXEgWyBbIDEsIDMgXSwgWyAyLCA0IF0sIFsgdW5kZWZpbmVkLCA1IF0gXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJVXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfV19LFwibGluZVwiOjI5MTN9LHtcInR5cGVQYXJhbXNcIjpbXCJVXCIsXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fSx7XCJuYW1lXCI6XCJvdGhlcjJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfSxcImxpbmVcIjoyOTE0fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcImxpbmVcIjoyOTE1fV19LFwiI3ppcFdpdGhcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIFNlcSBcXFwiemlwcGVkXFxcIiB3aXRoIHRoZSBwcm92aWRlZCBjb2xsZWN0aW9ucyBieSB1c2luZyBhXFxuY3VzdG9tIGB6aXBwZXJgIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcImBgYGpzXFxuY29uc3QgYSA9IFNlcShbIDEsIDIsIDMgXSk7XFxuY29uc3QgYiA9IFNlcShbIDQsIDUsIDYgXSk7XFxuY29uc3QgYyA9IGEuemlwV2l0aCgoYSwgYikgPT4gYSArIGIsIGIpO1xcbi8vIFNlcSBbIDUsIDcsIDkgXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJVXCIsXCJaXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInppcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwib3RoZXJWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlVcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9fX0se1wibmFtZVwiOlwib3RoZXJDb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9XX0sXCJsaW5lXCI6MjkyOH0se1widHlwZVBhcmFtc1wiOltcIlVcIixcIlZcIixcIlpcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiemlwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJvdGhlclZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifX0se1wibmFtZVwiOlwidGhpcmRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9fX0se1wibmFtZVwiOlwib3RoZXJDb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fSx7XCJuYW1lXCI6XCJ0aGlyZENvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlpcIn1dfSxcImxpbmVcIjoyOTMyfSx7XCJ0eXBlUGFyYW1zXCI6W1wiWlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ6aXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJhbnlcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifX19LHtcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6MTd9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9XX0sXCJsaW5lXCI6MjkzN31dfX19XX19LFwiU2V0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcImBTZXFgIHdoaWNoIHJlcHJlc2VudHMgYSBzZXQgb2YgdmFsdWVzLlwiLFwiZGVzY3JpcHRpb25cIjpcIkJlY2F1c2UgYFNlcWAgYXJlIG9mdGVuIGxhenksIGBTZXEuU2V0YCBkb2VzIG5vdCBwcm92aWRlIHRoZSBzYW1lIGd1YXJhbnRlZVxcbm9mIHZhbHVlIHVuaXF1ZW5lc3MgYXMgdGhlIGNvbmNyZXRlIGBTZXRgLlwiLFwibm90ZXNcIjpbXX0sXCJtb2R1bGVcIjp7XCJvZlwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIFNlcS5TZXQgb2YgdGhlIHByb3ZpZGVkIHZhbHVlc1wiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5TZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjI5NTV9XX19fSxcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQWx3YXlzIHJldHVybnMgYSBTZXEuU2V0LCBkaXNjYXJkaW5nIGFzc29jaWF0ZWQgaW5kaWNlcyBvciBrZXlzLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBTZXEuU2V0YCBpcyBhIGNvbnZlcnNpb24gZnVuY3Rpb24gYW5kIG5vdCBhIGNsYXNzLCBhbmQgZG9lcyBub3RcXG51c2UgdGhlIGBuZXdgIGtleXdvcmQgZHVyaW5nIGNvbnN0cnVjdGlvbi5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5TZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjI5NjR9LHtcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6Mjk2NX0se1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJsaW5lXCI6Mjk2Nn1dfSxcImludGVyZmFjZVwiOntcImxpbmVcIjoyOTY4LFwidHlwZVBhcmFtc1wiOltcIlRcIl0sXCJleHRlbmRzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiU2VxXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LHtcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5TZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19XSxcImdyb3Vwc1wiOlt7XCJtZW1iZXJzXCI6e1wiI3RvSlNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRGVlcGx5IGNvbnZlcnRzIHRoaXMgU2V0IFNlcSB0byBlcXVpdmFsZW50IG5hdGl2ZSBKYXZhU2NyaXB0IEFycmF5LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcImxpbmVcIjoyOTcyfV19LFwiI3RvSlNPTlwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJTaGFsbG93bHkgY29udmVydHMgdGhpcyBTZXQgU2VxIHRvIGVxdWl2YWxlbnQgbmF0aXZlIEphdmFTY3JpcHQgQXJyYXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjI5Nzd9XX0sXCIjdG9BcnJheVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJTaGFsbG93bHkgY29udmVydHMgdGhpcyBjb2xsZWN0aW9uIHRvIGFuIEFycmF5LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoyOTgyfV19LFwiI3RvU2VxXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgaXRzZWxmXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6Mjk4N31dfSxcIiNjb25jYXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBTZXEgd2l0aCBvdGhlciBjb2xsZWN0aW9ucyBjb25jYXRlbmF0ZWQgdG8gdGhpcyBvbmUuXCIsXCJkZXNjcmlwdGlvblwiOlwiQWxsIGVudHJpZXMgd2lsbCBiZSBwcmVzZW50IGluIHRoZSByZXN1bHRpbmcgU2VxLCBldmVuIGlmIHRoZXlcXG5hcmUgZHVwbGljYXRlcy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuU2V0XCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19XX0sXCJsaW5lXCI6Mjk5NX1dfSxcIiNtYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBTZXEuU2V0IHdpdGggdmFsdWVzIHBhc3NlZCB0aHJvdWdoIGFcXG5gbWFwcGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJgYGBqc1xcblNlcS5TZXQoWyAxLCAyIF0pLm1hcCh4ID0+IDEwICogeClcXG4vLyBTZXEgeyAxMCwgMjAgfVxcbmBgYFxcblxcbk5vdGU6IGBtYXAoKWAgYWx3YXlzIHJldHVybnMgYSBuZXcgaW5zdGFuY2UsIGV2ZW4gaWYgaXQgcHJvZHVjZWQgdGhlXFxuc2FtZSB2YWx1ZSBhdCBldmVyeSBzdGVwLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5TZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjMwMDl9XX0sXCIjZmxhdE1hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJGbGF0LW1hcHMgdGhlIFNlcSwgcmV0dXJuaW5nIGEgU2VxIG9mIHRoZSBzYW1lIHR5cGUuXCIsXCJkZXNjcmlwdGlvblwiOlwiU2ltaWxhciB0byBgc2VxLm1hcCguLi4pLmZsYXR0ZW4odHJ1ZSlgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjozMDE5fV19LFwiI2ZpbHRlclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFNlcSB3aXRoIG9ubHkgdGhlIHZhbHVlcyBmb3Igd2hpY2ggdGhlIGBwcmVkaWNhdGVgXFxuZnVuY3Rpb24gcmV0dXJucyB0cnVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBmaWx0ZXIoKWAgYWx3YXlzIHJldHVybnMgYSBuZXcgaW5zdGFuY2UsIGV2ZW4gaWYgaXQgcmVzdWx0cyBpblxcbm5vdCBmaWx0ZXJpbmcgb3V0IGFueSB2YWx1ZXMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIkZcIn1dfSxcImxpbmVcIjozMDMxfSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxN319fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MzAzNX1dfX19XX19fSxcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQ3JlYXRlcyBhIFNlcS5cIixcImRlc2NyaXB0aW9uXCI6XCJSZXR1cm5zIGEgcGFydGljdWxhciBraW5kIG9mIGBTZXFgIGJhc2VkIG9uIHRoZSBpbnB1dC5cXG5cXG4gICogSWYgYSBgU2VxYCwgdGhhdCBzYW1lIGBTZXFgLlxcbiAgKiBJZiBhbiBgQ29sbGVjdGlvbmAsIGEgYFNlcWAgb2YgdGhlIHNhbWUga2luZCAoS2V5ZWQsIEluZGV4ZWQsIG9yIFNldCkuXFxuICAqIElmIGFuIEFycmF5LWxpa2UsIGFuIGBTZXEuSW5kZXhlZGAuXFxuICAqIElmIGFuIEl0ZXJhYmxlIE9iamVjdCwgYW4gYFNlcS5JbmRleGVkYC5cXG4gICogSWYgYW4gT2JqZWN0LCBhIGBTZXEuS2V5ZWRgLlxcblxcbk5vdGU6IEFuIEl0ZXJhdG9yIGl0c2VsZiB3aWxsIGJlIHRyZWF0ZWQgYXMgYW4gb2JqZWN0LCBiZWNvbWluZyBhIGBTZXEuS2V5ZWRgLFxcbndoaWNoIGlzIHVzdWFsbHkgbm90IHdoYXQgeW91IHdhbnQuIFlvdSBzaG91bGQgdHVybiB5b3VyIEl0ZXJhdG9yIE9iamVjdCBpbnRvXFxuYW4gaXRlcmFibGUgb2JqZWN0IGJ5IGRlZmluaW5nIGEgU3ltYm9sLml0ZXJhdG9yIChvciBAQGl0ZXJhdG9yKSBtZXRob2Qgd2hpY2hcXG5yZXR1cm5zIGB0aGlzYC5cXG5cXG5Ob3RlOiBgU2VxYCBpcyBhIGNvbnZlcnNpb24gZnVuY3Rpb24gYW5kIG5vdCBhIGNsYXNzLCBhbmQgZG9lcyBub3QgdXNlIHRoZVxcbmBuZXdgIGtleXdvcmQgZHVyaW5nIGNvbnN0cnVjdGlvbi5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiU1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzZXFcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJTXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiU1wifSxcImxpbmVcIjozMDYyfSx7XCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6MzA2M30se1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjMwNjR9LHtcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MzA2NX0se1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MzA2Nn0se1widHlwZVBhcmFtc1wiOltcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib2JqXCIsXCJ0eXBlXCI6e1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjN9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjozMDY3fSx7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXFcIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6MTd9XX0sXCJsaW5lXCI6MzA2OH1dfSxcImludGVyZmFjZVwiOntcImxpbmVcIjozMDcwLFwidHlwZVBhcmFtc1wiOltcIktcIixcIlZcIl0sXCJleHRlbmRzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfV0sXCJncm91cHNcIjpbe1wibWVtYmVyc1wiOntcIiNzaXplXCI6e1wibGluZVwiOjMwODJ9fX0se1widGl0bGVcIjpcIkZvcmNlIGV2YWx1YXRpb25cIixcIm1lbWJlcnNcIjp7XCIjY2FjaGVSZXN1bHRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQmVjYXVzZSBTZXF1ZW5jZXMgYXJlIGxhenkgYW5kIGRlc2lnbmVkIHRvIGJlIGNoYWluZWQgdG9nZXRoZXIsIHRoZXkgZG9cXG5ub3QgY2FjaGUgdGhlaXIgcmVzdWx0cy4gRm9yIGV4YW1wbGUsIHRoaXMgbWFwIGZ1bmN0aW9uIGlzIGNhbGxlZCBhIHRvdGFsXFxub2YgNiB0aW1lcywgYXMgZWFjaCBgam9pbmAgaXRlcmF0ZXMgdGhlIFNlcSBvZiB0aHJlZSB2YWx1ZXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiICAgIHZhciBzcXVhcmVzID0gU2VxKFsgMSwgMiwgMyBdKS5tYXAoeCA9PiB4ICogeClcXG4gICAgc3F1YXJlcy5qb2luKCkgKyBzcXVhcmVzLmpvaW4oKVxcblxcbklmIHlvdSBrbm93IGEgYFNlcWAgd2lsbCBiZSB1c2VkIG11bHRpcGxlIHRpbWVzLCBpdCBtYXkgYmUgbW9yZVxcbmVmZmljaWVudCB0byBmaXJzdCBjYWNoZSBpdCBpbiBtZW1vcnkuIEhlcmUsIHRoZSBtYXAgZnVuY3Rpb24gaXMgY2FsbGVkXFxub25seSAzIHRpbWVzLlxcblxcbiAgICB2YXIgc3F1YXJlcyA9IFNlcShbIDEsIDIsIDMgXSkubWFwKHggPT4geCAqIHgpLmNhY2hlUmVzdWx0KClcXG4gICAgc3F1YXJlcy5qb2luKCkgKyBzcXVhcmVzLmpvaW4oKVxcblxcblVzZSB0aGlzIG1ldGhvZCBqdWRpY2lvdXNseSwgYXMgaXQgbXVzdCBmdWxseSBldmFsdWF0ZSBhIFNlcSB3aGljaCBjYW4gYmVcXG5hIGJ1cmRlbiBvbiBtZW1vcnkgYW5kIHBvc3NpYmx5IHBlcmZvcm1hbmNlLlxcblxcbk5vdGU6IGFmdGVyIGNhbGxpbmcgYGNhY2hlUmVzdWx0YCwgYSBTZXEgd2lsbCBhbHdheXMgaGF2ZSBhIGBzaXplYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjozMTA3fV19fX0se1widGl0bGVcIjpcIlNlcXVlbmNlIGFsZ29yaXRobXNcIixcIm1lbWJlcnNcIjp7XCIjbWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU2VxIHdpdGggdmFsdWVzIHBhc3NlZCB0aHJvdWdoIGFcXG5gbWFwcGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJgYGBqc1xcbmNvbnN0IHsgU2VxIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcblNlcShbIDEsIDIgXSkubWFwKHggPT4gMTAgKiB4KVxcbi8vIFNlcSBbIDEwLCAyMCBdXFxuYGBgXFxuXFxuTm90ZTogYG1hcCgpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCBwcm9kdWNlZCB0aGUgc2FtZVxcbnZhbHVlIGF0IGV2ZXJ5IHN0ZXAuXFxuTm90ZTogdXNlZCBvbmx5IGZvciBzZXRzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjozMTI0fSx7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXFcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6MzE0M31dfSxcIiNmbGF0TWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkZsYXQtbWFwcyB0aGUgU2VxLCByZXR1cm5pbmcgYSBTZXEgb2YgdGhlIHNhbWUgdHlwZS5cIixcImRlc2NyaXB0aW9uXCI6XCJTaW1pbGFyIHRvIGBzZXEubWFwKC4uLikuZmxhdHRlbih0cnVlKWAuXFxuTm90ZTogVXNlZCBvbmx5IGZvciBzZXRzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXFcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6MzE1M30se1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjozMTY0fV19LFwiI2ZpbHRlclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFNlcSB3aXRoIG9ubHkgdGhlIHZhbHVlcyBmb3Igd2hpY2ggdGhlIGBwcmVkaWNhdGVgXFxuZnVuY3Rpb24gcmV0dXJucyB0cnVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBmaWx0ZXIoKWAgYWx3YXlzIHJldHVybnMgYSBuZXcgaW5zdGFuY2UsIGV2ZW4gaWYgaXQgcmVzdWx0cyBpblxcbm5vdCBmaWx0ZXJpbmcgb3V0IGFueSB2YWx1ZXMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXFcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJGXCJ9XX0sXCJsaW5lXCI6MzE3Nn0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MTd9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjMxODB9XX19fV19fSxcIkNvbGxlY3Rpb25cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVGhlIGBDb2xsZWN0aW9uYCBpcyBhIHNldCBvZiAoa2V5LCB2YWx1ZSkgZW50cmllcyB3aGljaCBjYW4gYmUgaXRlcmF0ZWQsIGFuZFxcbmlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgY29sbGVjdGlvbnMgaW4gYGltbXV0YWJsZWAsIGFsbG93aW5nIHRoZW0gdG9cXG5tYWtlIHVzZSBvZiBhbGwgdGhlIENvbGxlY3Rpb24gbWV0aG9kcyAoc3VjaCBhcyBgbWFwYCBhbmQgYGZpbHRlcmApLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IEEgY29sbGVjdGlvbiBpcyBhbHdheXMgaXRlcmF0ZWQgaW4gdGhlIHNhbWUgb3JkZXIsIGhvd2V2ZXIgdGhhdCBvcmRlclxcbm1heSBub3QgYWx3YXlzIGJlIHdlbGwgZGVmaW5lZCwgYXMgaXMgdGhlIGNhc2UgZm9yIHRoZSBgTWFwYCBhbmQgYFNldGAuXFxuXFxuQ29sbGVjdGlvbiBpcyB0aGUgYWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgY29uY3JldGUgZGF0YSBzdHJ1Y3R1cmVzLiBJdFxcbmNhbm5vdCBiZSBjb25zdHJ1Y3RlZCBkaXJlY3RseS5cXG5cXG5JbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGV4dGVuZCBvbmUgb2YgdGhlIHN1YmNsYXNzZXMsIGBDb2xsZWN0aW9uLktleWVkYCxcXG5gQ29sbGVjdGlvbi5JbmRleGVkYCwgb3IgYENvbGxlY3Rpb24uU2V0YC5cIixcIm5vdGVzXCI6W119LFwibW9kdWxlXCI6e1wiS2V5ZWRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiS2V5ZWQgQ29sbGVjdGlvbnMgaGF2ZSBkaXNjcmV0ZSBrZXlzIHRpZWQgdG8gZWFjaCB2YWx1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJXaGVuIGl0ZXJhdGluZyBgQ29sbGVjdGlvbi5LZXllZGAsIGVhY2ggaXRlcmF0aW9uIHdpbGwgeWllbGQgYSBgW0ssIFZdYFxcbnR1cGxlLCBpbiBvdGhlciB3b3JkcywgYENvbGxlY3Rpb24jZW50cmllc2AgaXMgdGhlIGRlZmF1bHQgaXRlcmF0b3IgZm9yXFxuS2V5ZWQgQ29sbGVjdGlvbnMuXCIsXCJub3Rlc1wiOltdfSxcIm1vZHVsZVwiOnt9LFwiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDcmVhdGVzIGEgQ29sbGVjdGlvbi5LZXllZFwiLFwiZGVzY3JpcHRpb25cIjpcIlNpbWlsYXIgdG8gYENvbGxlY3Rpb24oKWAsIGhvd2V2ZXIgaXQgZXhwZWN0cyBjb2xsZWN0aW9uLWxpa2VzIG9mIFtLLCBWXVxcbnR1cGxlcyBpZiBub3QgY29uc3RydWN0ZWQgZnJvbSBhIENvbGxlY3Rpb24uS2V5ZWQgb3IgSlMgT2JqZWN0Llxcblxcbk5vdGU6IGBDb2xsZWN0aW9uLktleWVkYCBpcyBhIGNvbnZlcnNpb24gZnVuY3Rpb24gYW5kIG5vdCBhIGNsYXNzLCBhbmRcXG5kb2VzIG5vdCB1c2UgdGhlIGBuZXdgIGtleXdvcmQgZHVyaW5nIGNvbnN0cnVjdGlvbi5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjMyNDF9LHtcInR5cGVQYXJhbXNcIjpbXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm9ialwiLFwidHlwZVwiOntcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6M30se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjMyNDJ9XX0sXCJpbnRlcmZhY2VcIjp7XCJsaW5lXCI6MzI0NCxcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCJdLFwiZXh0ZW5kc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dLFwiZ3JvdXBzXCI6W3tcIm1lbWJlcnNcIjp7XCIjdG9KU1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJEZWVwbHkgY29udmVydHMgdGhpcyBLZXllZCBjb2xsZWN0aW9uIHRvIGVxdWl2YWxlbnQgbmF0aXZlIEphdmFTY3JpcHQgT2JqZWN0LlwiLFwiZGVzY3JpcHRpb25cIjpcIkNvbnZlcnRzIGtleXMgdG8gU3RyaW5ncy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6MTd9fV19LFwibGluZVwiOjMyNTB9XX0sXCIjdG9KU09OXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNoYWxsb3dseSBjb252ZXJ0cyB0aGlzIEtleWVkIGNvbGxlY3Rpb24gdG8gZXF1aXZhbGVudCBuYXRpdmUgSmF2YVNjcmlwdCBPYmplY3QuXCIsXCJkZXNjcmlwdGlvblwiOlwiQ29udmVydHMga2V5cyB0byBTdHJpbmdzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6NCxcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XX0sXCJsaW5lXCI6MzI1N31dfSxcIiN0b0FycmF5XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNoYWxsb3dseSBjb252ZXJ0cyB0aGlzIGNvbGxlY3Rpb24gdG8gYW4gQXJyYXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfSxcImxpbmVcIjozMjYyfV19LFwiI3RvU2VxXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgU2VxLktleWVkLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjozMjY4fV19fX0se1widGl0bGVcIjpcIlNlcXVlbmNlIGZ1bmN0aW9uc1wiLFwibWVtYmVyc1wiOntcIiNmbGlwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbi5LZXllZCBvZiB0aGUgc2FtZSB0eXBlIHdoZXJlIHRoZSBrZXlzIGFuZCB2YWx1ZXNcXG5oYXZlIGJlZW4gZmxpcHBlZC5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbk1hcCh7IGE6ICd6JywgYjogJ3knIH0pLmZsaXAoKVxcbi8vIE1hcCB7IFxcXCJ6XFxcIjogXFxcImFcXFwiLCBcXFwieVxcXCI6IFxcXCJiXFxcIiB9XFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIktcIn1dfSxcImxpbmVcIjozMjg0fV19LFwiI2NvbmNhdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gd2l0aCBvdGhlciBjb2xsZWN0aW9ucyBjb25jYXRlbmF0ZWQgdG8gdGhpcyBvbmUuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktDXCIsXCJWQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLQ1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWQ1wifV19XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiS0NcIn1dfSx7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZDXCJ9XX1dfSxcImxpbmVcIjozMjg5fSx7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjozfV19LHtcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifV19XX0sXCJsaW5lXCI6MzI5MH1dfSxcIiNtYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uLktleWVkIHdpdGggdmFsdWVzIHBhc3NlZCB0aHJvdWdoIGFcXG5gbWFwcGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJgYGBqc1xcbmNvbnN0IHsgQ29sbGVjdGlvbiB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5Db2xsZWN0aW9uLktleWVkKHsgYTogMSwgYjogMiB9KS5tYXAoeCA9PiAxMCAqIHgpXFxuLy8gU2VxIHsgXFxcImFcXFwiOiAxMCwgXFxcImJcXFwiOiAyMCB9XFxuYGBgXFxuXFxuTm90ZTogYG1hcCgpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCBwcm9kdWNlZCB0aGVcXG5zYW1lIHZhbHVlIGF0IGV2ZXJ5IHN0ZXAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk1cIn19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjozMzA1fV19LFwiI21hcEtleXNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uLktleWVkIG9mIHRoZSBzYW1lIHR5cGUgd2l0aCBrZXlzIHBhc3NlZCB0aHJvdWdoXFxuYSBgbWFwcGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbk1hcCh7IGE6IDEsIGI6IDIgfSkubWFwS2V5cyh4ID0+IHgudG9VcHBlckNhc2UoKSlcXG4vLyBNYXAgeyBcXFwiQVxcXCI6IDEsIFxcXCJCXFxcIjogMiB9XFxuYGBgXFxuXFxuTm90ZTogYG1hcEtleXMoKWAgYWx3YXlzIHJldHVybnMgYSBuZXcgaW5zdGFuY2UsIGV2ZW4gaWYgaXQgcHJvZHVjZWRcXG50aGUgc2FtZSBrZXkgYXQgZXZlcnkgc3RlcC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjMzMjR9XX0sXCIjbWFwRW50cmllc1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24uS2V5ZWQgb2YgdGhlIHNhbWUgdHlwZSB3aXRoIGVudHJpZXNcXG4oW2tleSwgdmFsdWVdIHR1cGxlcykgcGFzc2VkIHRocm91Z2ggYSBgbWFwcGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbk1hcCh7IGE6IDEsIGI6IDIgfSlcXG4gIC5tYXBFbnRyaWVzKChbIGssIHYgXSkgPT4gWyBrLnRvVXBwZXJDYXNlKCksIHYgKiAyIF0pXFxuLy8gTWFwIHsgXFxcIkFcXFwiOiAyLCBcXFwiQlxcXCI6IDQgfVxcbmBgYFxcblxcbk5vdGU6IGBtYXBFbnRyaWVzKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHByb2R1Y2VkXFxudGhlIHNhbWUgZW50cnkgYXQgZXZlcnkgc3RlcC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS01cIixcIlZNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImVudHJ5XCIsXCJ0eXBlXCI6e1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19LHtcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZNXCJ9XX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLTVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWTVwifV19LFwibGluZVwiOjMzNDR9XX0sXCIjZmxhdE1hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJGbGF0LW1hcHMgdGhlIENvbGxlY3Rpb24sIHJldHVybmluZyBhIENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZS5cIixcImRlc2NyaXB0aW9uXCI6XCJTaW1pbGFyIHRvIGBjb2xsZWN0aW9uLm1hcCguLi4pLmZsYXR0ZW4odHJ1ZSlgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJLTVwiLFwiVk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS01cIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVk1cIn1dfV19fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS01cIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVk1cIn1dfSxcImxpbmVcIjozMzU0fV19LFwiI2ZpbHRlclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gd2l0aCBvbmx5IHRoZSB2YWx1ZXMgZm9yIHdoaWNoIHRoZSBgcHJlZGljYXRlYFxcbmZ1bmN0aW9uIHJldHVybnMgdHJ1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgZmlsdGVyKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHJlc3VsdHMgaW5cXG5ub3QgZmlsdGVyaW5nIG91dCBhbnkgdmFsdWVzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJGXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIkZcIn1dfSxcImxpbmVcIjozMzY2fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxN319fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MzM3MH1dfSxcIiNbU3ltYm9sLml0ZXJhdG9yXVwiOntcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVJdGVyYXRvclwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfV19LFwibGluZVwiOjMzNzV9XX19fV19fSxcIkluZGV4ZWRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiSW5kZXhlZCBDb2xsZWN0aW9ucyBoYXZlIGluY3JlbWVudGluZyBudW1lcmljIGtleXMuIFRoZXkgZXhoaWJpdFxcbnNsaWdodGx5IGRpZmZlcmVudCBiZWhhdmlvciB0aGFuIGBDb2xsZWN0aW9uLktleWVkYCBmb3Igc29tZSBtZXRob2RzIGluIG9yZGVyXFxudG8gYmV0dGVyIG1pcnJvciB0aGUgYmVoYXZpb3Igb2YgSmF2YVNjcmlwdCdzIGBBcnJheWAsIGFuZCBhZGQgbWV0aG9kc1xcbndoaWNoIGRvIG5vdCBtYWtlIHNlbnNlIG9uIG5vbi1pbmRleGVkIENvbGxlY3Rpb25zIHN1Y2ggYXMgYGluZGV4T2ZgLlwiLFwiZGVzY3JpcHRpb25cIjpcIlVubGlrZSBKYXZhU2NyaXB0IGFycmF5cywgYENvbGxlY3Rpb24uSW5kZXhlZGBzIGFyZSBhbHdheXMgZGVuc2UuIFxcXCJVbnNldFxcXCJcXG5pbmRpY2VzIGFuZCBgdW5kZWZpbmVkYCBpbmRpY2VzIGFyZSBpbmRpc3Rpbmd1aXNoYWJsZSwgYW5kIGFsbCBpbmRpY2VzIGZyb21cXG4wIHRvIGBzaXplYCBhcmUgdmlzaXRlZCB3aGVuIGl0ZXJhdGVkLlxcblxcbkFsbCBDb2xsZWN0aW9uLkluZGV4ZWQgbWV0aG9kcyByZXR1cm4gcmUtaW5kZXhlZCBDb2xsZWN0aW9ucy4gSW4gb3RoZXIgd29yZHMsXFxuaW5kaWNlcyBhbHdheXMgc3RhcnQgYXQgMCBhbmQgaW5jcmVtZW50IHVudGlsIHNpemUuIElmIHlvdSB3aXNoIHRvXFxucHJlc2VydmUgaW5kaWNlcywgdXNpbmcgdGhlbSBhcyBrZXlzLCBjb252ZXJ0IHRvIGEgQ29sbGVjdGlvbi5LZXllZCBieVxcbmNhbGxpbmcgYHRvS2V5ZWRTZXFgLlwiLFwibm90ZXNcIjpbXX0sXCJtb2R1bGVcIjp7fSxcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQ3JlYXRlcyBhIG5ldyBDb2xsZWN0aW9uLkluZGV4ZWQuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYENvbGxlY3Rpb24uSW5kZXhlZGAgaXMgYSBjb252ZXJzaW9uIGZ1bmN0aW9uIGFuZCBub3QgYSBjbGFzcywgYW5kXFxuZG9lcyBub3QgdXNlIHRoZSBgbmV3YCBrZXl3b3JkIGR1cmluZyBjb25zdHJ1Y3Rpb24uXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjM0MDJ9XX0sXCJpbnRlcmZhY2VcIjp7XCJsaW5lXCI6MzQwNCxcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwiZXh0ZW5kc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfV0sXCJncm91cHNcIjpbe1wibWVtYmVyc1wiOntcIiN0b0pTXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkRlZXBseSBjb252ZXJ0cyB0aGlzIEluZGV4ZWQgY29sbGVjdGlvbiB0byBlcXVpdmFsZW50IG5hdGl2ZSBKYXZhU2NyaXB0IEFycmF5LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcImxpbmVcIjozNDA4fV19LFwiI3RvSlNPTlwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJTaGFsbG93bHkgY29udmVydHMgdGhpcyBJbmRleGVkIGNvbGxlY3Rpb24gdG8gZXF1aXZhbGVudCBuYXRpdmUgSmF2YVNjcmlwdCBBcnJheS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MzQxM31dfSxcIiN0b0FycmF5XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNoYWxsb3dseSBjb252ZXJ0cyB0aGlzIGNvbGxlY3Rpb24gdG8gYW4gQXJyYXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjM0MTh9XX19fSx7XCJ0aXRsZVwiOlwiUmVhZGluZyB2YWx1ZXNcIixcIm1lbWJlcnNcIjp7XCIjZ2V0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQgaW5kZXgsIG9yIG5vdFNldFZhbHVlIGlmXFxudGhlIGluZGV4IGlzIGJleW9uZCB0aGUgYm91bmRzIG9mIHRoZSBDb2xsZWN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcImBpbmRleGAgbWF5IGJlIGEgbmVnYXRpdmUgbnVtYmVyLCB3aGljaCBpbmRleGVzIGJhY2sgZnJvbSB0aGUgZW5kIG9mIHRoZVxcbkNvbGxlY3Rpb24uIGBzLmdldCgtMSlgIGdldHMgdGhlIGxhc3QgaXRlbSBpbiB0aGUgQ29sbGVjdGlvbi5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTlNWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifX1dLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiTlNWXCJ9XX0sXCJsaW5lXCI6MzQyOX0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fV0sXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6MTF9XX0sXCJsaW5lXCI6MzQzMH1dfX19LHtcInRpdGxlXCI6XCJDb252ZXJzaW9uIHRvIFNlcVwiLFwibWVtYmVyc1wiOntcIiN0b1NlcVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIFNlcS5JbmRleGVkLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjozNDM5fV19LFwiI2Zyb21FbnRyeVNlcVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJJZiB0aGlzIGlzIGEgY29sbGVjdGlvbiBvZiBba2V5LCB2YWx1ZV0gZW50cnkgdHVwbGVzLCBpdCB3aWxsIHJldHVybiBhXFxuU2VxLktleWVkIG9mIHRob3NlIGVudHJpZXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19LFwibGluZVwiOjM0NDV9XX19fSx7XCJ0aXRsZVwiOlwiQ29tYmluYXRpb25cIixcIm1lbWJlcnNcIjp7XCIjaW50ZXJwb3NlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgd2l0aCBgc2VwYXJhdG9yYCBiZXR3ZWVuIGVhY2ggaXRlbVxcbmluIHRoaXMgQ29sbGVjdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwic2VwYXJhdG9yXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MzQ1NH1dfSxcIiNpbnRlcmxlYXZlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgd2l0aCB0aGUgcHJvdmlkZWQgYGNvbGxlY3Rpb25zYFxcbmludGVybGVhdmVkIGludG8gdGhpcyBjb2xsZWN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIlRoZSByZXN1bHRpbmcgQ29sbGVjdGlvbiBpbmNsdWRlcyB0aGUgZmlyc3QgaXRlbSBmcm9tIGVhY2gsIHRoZW4gdGhlXFxuc2Vjb25kIGZyb20gZWFjaCwgZXRjLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJyZXF1aXJlKCdpbW11dGFibGUnKVxcXCJ9XFxuLS0+XFxuYGBganNcXG5jb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuTGlzdChbIDEsIDIsIDMgXSkuaW50ZXJsZWF2ZShMaXN0KFsgJ0EnLCAnQicsICdDJyBdKSlcXG4vLyBMaXN0IFsgMSwgXFxcIkFcXFwiLCAyLCBcXFwiQlxcXCIsIDMsIFxcXCJDXFxcIiBdXFxuYGBgXFxuXFxuVGhlIHNob3J0ZXN0IENvbGxlY3Rpb24gc3RvcHMgaW50ZXJsZWF2ZS5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcXCIgfVxcbi0tPlxcbmBgYGpzXFxuTGlzdChbIDEsIDIsIDMgXSkuaW50ZXJsZWF2ZShcXG4gIExpc3QoWyAnQScsICdCJyBdKSxcXG4gIExpc3QoWyAnWCcsICdZJywgJ1onIF0pXFxuKVxcbi8vIExpc3QgWyAxLCBcXFwiQVxcXCIsIFxcXCJYXFxcIiwgMiwgXFxcIkJcXFwiLCBcXFwiWVxcXCIgXVxcbmBgYFxcblxcblNpbmNlIGBpbnRlcmxlYXZlKClgIHJlLWluZGV4ZXMgdmFsdWVzLCBpdCBwcm9kdWNlcyBhIGNvbXBsZXRlIGNvcHksXFxud2hpY2ggaGFzIGBPKE4pYCBjb21wbGV4aXR5Llxcblxcbk5vdGU6IGBpbnRlcmxlYXZlYCAqY2Fubm90KiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjM0OTB9XX0sXCIjc3BsaWNlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNwbGljZSByZXR1cm5zIGEgbmV3IGluZGV4ZWQgQ29sbGVjdGlvbiBieSByZXBsYWNpbmcgYSByZWdpb24gb2YgdGhpc1xcbkNvbGxlY3Rpb24gd2l0aCBuZXcgdmFsdWVzLiBJZiB2YWx1ZXMgYXJlIG5vdCBwcm92aWRlZCwgaXQgb25seSBza2lwcyB0aGVcXG5yZWdpb24gdG8gYmUgcmVtb3ZlZC5cIixcImRlc2NyaXB0aW9uXCI6XCJgaW5kZXhgIG1heSBiZSBhIG5lZ2F0aXZlIG51bWJlciwgd2hpY2ggaW5kZXhlcyBiYWNrIGZyb20gdGhlIGVuZCBvZiB0aGVcXG5Db2xsZWN0aW9uLiBgcy5zcGxpY2UoLTIpYCBzcGxpY2VzIGFmdGVyIHRoZSBzZWNvbmQgdG8gbGFzdCBpdGVtLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbkxpc3QoWyAnYScsICdiJywgJ2MnLCAnZCcgXSkuc3BsaWNlKDEsIDIsICdxJywgJ3InLCAncycpXFxuLy8gTGlzdCBbIFxcXCJhXFxcIiwgXFxcInFcXFwiLCBcXFwiclxcXCIsIFxcXCJzXFxcIiwgXFxcImRcXFwiIF1cXG5gYGBcXG5cXG5TaW5jZSBgc3BsaWNlKClgIHJlLWluZGV4ZXMgdmFsdWVzLCBpdCBwcm9kdWNlcyBhIGNvbXBsZXRlIGNvcHksIHdoaWNoXFxuaGFzIGBPKE4pYCBjb21wbGV4aXR5Llxcblxcbk5vdGU6IGBzcGxpY2VgICpjYW5ub3QqIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJpbmRleFwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwicmVtb3ZlTnVtXCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZXNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjozNTEyfV19LFwiI3ppcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIFxcXCJ6aXBwZWRcXFwiIHdpdGggdGhlIHByb3ZpZGVkXFxuY29sbGVjdGlvbnMuXCIsXCJkZXNjcmlwdGlvblwiOlwiTGlrZSBgemlwV2l0aGAsIGJ1dCB1c2luZyB0aGUgZGVmYXVsdCBgemlwcGVyYDogY3JlYXRpbmcgYW4gYEFycmF5YC5cXG5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcXCIgfVxcbi0tPlxcbmBgYGpzXFxuY29uc3QgYSA9IExpc3QoWyAxLCAyLCAzIF0pO1xcbmNvbnN0IGIgPSBMaXN0KFsgNCwgNSwgNiBdKTtcXG5jb25zdCBjID0gYS56aXAoYik7IC8vIExpc3QgWyBbIDEsIDQgXSwgWyAyLCA1IF0sIFsgMywgNiBdIF1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlclwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19XX0sXCJsaW5lXCI6MzUzNH0se1widHlwZVBhcmFtc1wiOltcIlVcIixcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib3RoZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19LHtcIm5hbWVcIjpcIm90aGVyMlwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfSxcImxpbmVcIjozNTM1fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJsaW5lXCI6MzUzNn1dfSxcIiN6aXBBbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIENvbGxlY3Rpb24gXFxcInppcHBlZFxcXCIgd2l0aCB0aGUgcHJvdmlkZWQgY29sbGVjdGlvbnMuXCIsXCJkZXNjcmlwdGlvblwiOlwiVW5saWtlIGB6aXBgLCBgemlwQWxsYCBjb250aW51ZXMgemlwcGluZyB1bnRpbCB0aGUgbG9uZ2VzdCBjb2xsZWN0aW9uIGlzXFxuZXhoYXVzdGVkLiBNaXNzaW5nIHZhbHVlcyBmcm9tIHNob3J0ZXIgY29sbGVjdGlvbnMgYXJlIGZpbGxlZCB3aXRoIGB1bmRlZmluZWRgLlxcblxcbmBgYGpzXFxuY29uc3QgYSA9IExpc3QoWyAxLCAyIF0pO1xcbmNvbnN0IGIgPSBMaXN0KFsgMywgNCwgNSBdKTtcXG5jb25zdCBjID0gYS56aXBBbGwoYik7IC8vIExpc3QgWyBbIDEsIDMgXSwgWyAyLCA0IF0sIFsgdW5kZWZpbmVkLCA1IF0gXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJVXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX1dfSxcImxpbmVcIjozNTUwfSx7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiLFwiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlclwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX0se1wibmFtZVwiOlwib3RoZXIyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfV19LFwibGluZVwiOjM1NTF9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcImxpbmVcIjozNTUyfV19LFwiI3ppcFdpdGhcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZSBcXFwiemlwcGVkXFxcIiB3aXRoIHRoZSBwcm92aWRlZFxcbmNvbGxlY3Rpb25zIGJ5IHVzaW5nIGEgY3VzdG9tIGB6aXBwZXJgIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxcIiB9XFxuLS0+XFxuYGBganNcXG5jb25zdCBhID0gTGlzdChbIDEsIDIsIDMgXSk7XFxuY29uc3QgYiA9IExpc3QoWyA0LCA1LCA2IF0pO1xcbmNvbnN0IGMgPSBhLnppcFdpdGgoKGEsIGIpID0+IGEgKyBiLCBiKTtcXG4vLyBMaXN0IFsgNSwgNywgOSBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlVcIixcIlpcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiemlwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJvdGhlclZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlpcIn19fSx7XCJuYW1lXCI6XCJvdGhlckNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9XX0sXCJsaW5lXCI6MzU2OH0se1widHlwZVBhcmFtc1wiOltcIlVcIixcIlZcIixcIlpcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiemlwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJvdGhlclZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifX0se1wibmFtZVwiOlwidGhpcmRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9fX0se1wibmFtZVwiOlwib3RoZXJDb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fSx7XCJuYW1lXCI6XCJ0aGlyZENvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9XX0sXCJsaW5lXCI6MzU3Mn0se1widHlwZVBhcmFtc1wiOltcIlpcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiemlwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiYW55XCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlpcIn19fSx7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlpcIn1dfSxcImxpbmVcIjozNTc3fV19fX0se1widGl0bGVcIjpcIlNlYXJjaCBmb3IgdmFsdWVcIixcIm1lbWJlcnNcIjp7XCIjaW5kZXhPZlwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIHZhbHVlIGNhbiBiZSBmb3VuZCBpbiB0aGVcXG5Db2xsZWN0aW9uLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwic2VhcmNoVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjJ9LFwibGluZVwiOjM1ODl9XX0sXCIjbGFzdEluZGV4T2ZcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyB0aGUgbGFzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIHZhbHVlIGNhbiBiZSBmb3VuZCBpbiB0aGVcXG5Db2xsZWN0aW9uLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwic2VhcmNoVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjJ9LFwibGluZVwiOjM1OTV9XX0sXCIjZmluZEluZGV4XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgdGhlIGZpcnN0IGluZGV4IGluIHRoZSBDb2xsZWN0aW9uIHdoZXJlIGEgdmFsdWUgc2F0aXNmaWVzIHRoZVxcbnByb3ZpZGVkIHByZWRpY2F0ZSBmdW5jdGlvbi4gT3RoZXJ3aXNlIC0xIGlzIHJldHVybmVkLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjJ9LFwibGluZVwiOjM2MDF9XX0sXCIjZmluZExhc3RJbmRleFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRoZSBsYXN0IGluZGV4IGluIHRoZSBDb2xsZWN0aW9uIHdoZXJlIGEgdmFsdWUgc2F0aXNmaWVzIHRoZVxcbnByb3ZpZGVkIHByZWRpY2F0ZSBmdW5jdGlvbi4gT3RoZXJ3aXNlIC0xIGlzIHJldHVybmVkLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjJ9LFwibGluZVwiOjM2MTB9XX19fSx7XCJ0aXRsZVwiOlwiU2VxdWVuY2UgYWxnb3JpdGhtc1wiLFwibWVtYmVyc1wiOntcIiNjb25jYXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIHdpdGggb3RoZXIgY29sbGVjdGlvbnMgY29uY2F0ZW5hdGVkIHRvIHRoaXMgb25lLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlc09yQ29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifV19LHtcImtcIjo4LFwicGFyYW1cIjpcIkNcIn1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIkNcIn1dfV19LFwibGluZVwiOjM2MjB9XX0sXCIjbWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbi5JbmRleGVkIHdpdGggdmFsdWVzIHBhc3NlZCB0aHJvdWdoIGFcXG5gbWFwcGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJgYGBqc1xcbmNvbnN0IHsgQ29sbGVjdGlvbiB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5Db2xsZWN0aW9uLkluZGV4ZWQoWzEsMl0pLm1hcCh4ID0+IDEwICogeClcXG4vLyBTZXEgWyAxLCAyIF1cXG5gYGBcXG5cXG5Ob3RlOiBgbWFwKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHByb2R1Y2VkIHRoZVxcbnNhbWUgdmFsdWUgYXQgZXZlcnkgc3RlcC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6MzYzNX1dfSxcIiNmbGF0TWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkZsYXQtbWFwcyB0aGUgQ29sbGVjdGlvbiwgcmV0dXJuaW5nIGEgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlLlwiLFwiZGVzY3JpcHRpb25cIjpcIlNpbWlsYXIgdG8gYGNvbGxlY3Rpb24ubWFwKC4uLikuZmxhdHRlbih0cnVlKWAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjozNjQ1fV19LFwiI2ZpbHRlclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gd2l0aCBvbmx5IHRoZSB2YWx1ZXMgZm9yIHdoaWNoIHRoZSBgcHJlZGljYXRlYFxcbmZ1bmN0aW9uIHJldHVybnMgdHJ1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgZmlsdGVyKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHJlc3VsdHMgaW5cXG5ub3QgZmlsdGVyaW5nIG91dCBhbnkgdmFsdWVzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJGXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJGXCJ9XX0sXCJsaW5lXCI6MzY1N30se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjozNjYxfV19LFwiI1tTeW1ib2wuaXRlcmF0b3JdXCI6e1wic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZUl0ZXJhdG9yXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjozNjY2fV19fX1dfX0sXCJTZXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiU2V0IENvbGxlY3Rpb25zIG9ubHkgcmVwcmVzZW50IHZhbHVlcy4gVGhleSBoYXZlIG5vIGFzc29jaWF0ZWQga2V5cyBvclxcbmluZGljZXMuIER1cGxpY2F0ZSB2YWx1ZXMgYXJlIHBvc3NpYmxlIGluIHRoZSBsYXp5IGBTZXEuU2V0YHMsIGhvd2V2ZXJcXG50aGUgY29uY3JldGUgYFNldGAgQ29sbGVjdGlvbiBkb2VzIG5vdCBhbGxvdyBkdXBsaWNhdGUgdmFsdWVzLlwiLFwiZGVzY3JpcHRpb25cIjpcIkNvbGxlY3Rpb24gbWV0aG9kcyBvbiBDb2xsZWN0aW9uLlNldCBzdWNoIGFzIGBtYXBgIGFuZCBgZm9yRWFjaGAgd2lsbCBwcm92aWRlXFxudGhlIHZhbHVlIGFzIGJvdGggdGhlIGZpcnN0IGFuZCBzZWNvbmQgYXJndW1lbnRzIHRvIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cXG5cXG5gYGBqc1xcbmNvbnN0IHsgQ29sbGVjdGlvbiB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBzZXEgPSBDb2xsZWN0aW9uLlNldChbICdBJywgJ0InLCAnQycgXSlcXG4vLyBTZXEgeyBcXFwiQVxcXCIsIFxcXCJCXFxcIiwgXFxcIkNcXFwiIH1cXG5zZXEuZm9yRWFjaCgodiwgaykgPT5cXG4gYXNzZXJ0LmVxdWFsKHYsIGspXFxuKVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJtb2R1bGVcIjp7fSxcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiU2ltaWxhciB0byBgQ29sbGVjdGlvbigpYCwgYnV0IGFsd2F5cyByZXR1cm5zIGEgQ29sbGVjdGlvbi5TZXQuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYENvbGxlY3Rpb24uU2V0YCBpcyBhIGZhY3RvcnkgZnVuY3Rpb24gYW5kIG5vdCBhIGNsYXNzLCBhbmQgZG9lc1xcbm5vdCB1c2UgdGhlIGBuZXdgIGtleXdvcmQgZHVyaW5nIGNvbnN0cnVjdGlvbi5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjozNjk1fV19LFwiaW50ZXJmYWNlXCI6e1wibGluZVwiOjM2OTcsXCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcImV4dGVuZHNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19XSxcImdyb3Vwc1wiOlt7XCJtZW1iZXJzXCI6e1wiI3RvSlNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRGVlcGx5IGNvbnZlcnRzIHRoaXMgU2V0IGNvbGxlY3Rpb24gdG8gZXF1aXZhbGVudCBuYXRpdmUgSmF2YVNjcmlwdCBBcnJheS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJsaW5lXCI6MzcwMX1dfSxcIiN0b0pTT05cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiU2hhbGxvd2x5IGNvbnZlcnRzIHRoaXMgU2V0IGNvbGxlY3Rpb24gdG8gZXF1aXZhbGVudCBuYXRpdmUgSmF2YVNjcmlwdCBBcnJheS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MzcwNn1dfSxcIiN0b0FycmF5XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNoYWxsb3dseSBjb252ZXJ0cyB0aGlzIGNvbGxlY3Rpb24gdG8gYW4gQXJyYXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjM3MTF9XX0sXCIjdG9TZXFcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBTZXEuU2V0LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5TZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjM3MTd9XX19fSx7XCJ0aXRsZVwiOlwiU2VxdWVuY2UgYWxnb3JpdGhtc1wiLFwibWVtYmVyc1wiOntcIiNjb25jYXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIHdpdGggb3RoZXIgY29sbGVjdGlvbnMgY29uY2F0ZW5hdGVkIHRvIHRoaXMgb25lLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJVXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uU2V0XCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19XX0sXCJsaW5lXCI6MzcyNH1dfSxcIiNtYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uLlNldCB3aXRoIHZhbHVlcyBwYXNzZWQgdGhyb3VnaCBhXFxuYG1hcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiYGBgXFxuQ29sbGVjdGlvbi5TZXQoWyAxLCAyIF0pLm1hcCh4ID0+IDEwICogeClcXG4vLyBTZXEgeyAxLCAyIH1cXG5gYGBcXG5cXG5Ob3RlOiBgbWFwKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHByb2R1Y2VkIHRoZVxcbnNhbWUgdmFsdWUgYXQgZXZlcnkgc3RlcC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6MzczOH1dfSxcIiNmbGF0TWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkZsYXQtbWFwcyB0aGUgQ29sbGVjdGlvbiwgcmV0dXJuaW5nIGEgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlLlwiLFwiZGVzY3JpcHRpb25cIjpcIlNpbWlsYXIgdG8gYGNvbGxlY3Rpb24ubWFwKC4uLikuZmxhdHRlbih0cnVlKWAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjozNzQ4fV19LFwiI2ZpbHRlclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gd2l0aCBvbmx5IHRoZSB2YWx1ZXMgZm9yIHdoaWNoIHRoZSBgcHJlZGljYXRlYFxcbmZ1bmN0aW9uIHJldHVybnMgdHJ1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgZmlsdGVyKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHJlc3VsdHMgaW5cXG5ub3QgZmlsdGVyaW5nIG91dCBhbnkgdmFsdWVzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJGXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5TZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiRlwifV19LFwibGluZVwiOjM3NjB9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjozNzY0fV19LFwiI1tTeW1ib2wuaXRlcmF0b3JdXCI6e1wic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZUl0ZXJhdG9yXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjozNzY5fV19fX1dfX19LFwiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDcmVhdGVzIGEgQ29sbGVjdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJUaGUgdHlwZSBvZiBDb2xsZWN0aW9uIGNyZWF0ZWQgaXMgYmFzZWQgb24gdGhlIGlucHV0LlxcblxcbiAgKiBJZiBhbiBgQ29sbGVjdGlvbmAsIHRoYXQgc2FtZSBgQ29sbGVjdGlvbmAuXFxuICAqIElmIGFuIEFycmF5LWxpa2UsIGFuIGBDb2xsZWN0aW9uLkluZGV4ZWRgLlxcbiAgKiBJZiBhbiBPYmplY3Qgd2l0aCBhbiBJdGVyYXRvciBkZWZpbmVkLCBhbiBgQ29sbGVjdGlvbi5JbmRleGVkYC5cXG4gICogSWYgYW4gT2JqZWN0LCBhbiBgQ29sbGVjdGlvbi5LZXllZGAuXFxuXFxuVGhpcyBtZXRob2RzIGZvcmNlcyB0aGUgY29udmVyc2lvbiBvZiBPYmplY3RzIGFuZCBTdHJpbmdzIHRvIENvbGxlY3Rpb25zLlxcbklmIHlvdSB3YW50IHRvIGVuc3VyZSB0aGF0IGEgQ29sbGVjdGlvbiBvZiBvbmUgaXRlbSBpcyByZXR1cm5lZCwgdXNlXFxuYFNlcS5vZmAuXFxuXFxuTm90ZTogQW4gSXRlcmF0b3IgaXRzZWxmIHdpbGwgYmUgdHJlYXRlZCBhcyBhbiBvYmplY3QsIGJlY29taW5nIGEgYFNlcS5LZXllZGAsXFxud2hpY2ggaXMgdXN1YWxseSBub3Qgd2hhdCB5b3Ugd2FudC4gWW91IHNob3VsZCB0dXJuIHlvdXIgSXRlcmF0b3IgT2JqZWN0IGludG9cXG5hbiBpdGVyYWJsZSBvYmplY3QgYnkgZGVmaW5pbmcgYSBTeW1ib2wuaXRlcmF0b3IgKG9yIEBAaXRlcmF0b3IpIG1ldGhvZCB3aGljaFxcbnJldHVybnMgYHRoaXNgLlxcblxcbk5vdGU6IGBDb2xsZWN0aW9uYCBpcyBhIGNvbnZlcnNpb24gZnVuY3Rpb24gYW5kIG5vdCBhIGNsYXNzLCBhbmQgZG9lcyBub3RcXG51c2UgdGhlIGBuZXdgIGtleXdvcmQgZHVyaW5nIGNvbnN0cnVjdGlvbi5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiSVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiSVwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIklcIn0sXCJsaW5lXCI6Mzc5Nn0se1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjM3OTd9LHtcInR5cGVQYXJhbXNcIjpbXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm9ialwiLFwidHlwZVwiOntcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6M30se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjM3OTh9XX0sXCJpbnRlcmZhY2VcIjp7XCJsaW5lXCI6MzgwMCxcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCJdLFwiZXh0ZW5kc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIlZhbHVlT2JqZWN0XCJ9XSxcImdyb3Vwc1wiOlt7XCJ0aXRsZVwiOlwiVmFsdWUgZXF1YWxpdHlcIixcIm1lbWJlcnNcIjp7XCIjZXF1YWxzXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgdGhpcyBhbmQgdGhlIG90aGVyIENvbGxlY3Rpb24gaGF2ZSB2YWx1ZSBlcXVhbGl0eSwgYXMgZGVmaW5lZFxcbmJ5IGBJbW11dGFibGUuaXMoKWAuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogVGhpcyBpcyBlcXVpdmFsZW50IHRvIGBJbW11dGFibGUuaXModGhpcywgb3RoZXIpYCwgYnV0IHByb3ZpZGVkIHRvXFxuYWxsb3cgZm9yIGNoYWluZWQgZXhwcmVzc2lvbnMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjozODExfV19LFwiI2hhc2hDb2RlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkNvbXB1dGVzIGFuZCByZXR1cm5zIHRoZSBoYXNoZWQgaWRlbnRpdHkgZm9yIHRoaXMgQ29sbGVjdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJUaGUgYGhhc2hDb2RlYCBvZiBhIENvbGxlY3Rpb24gaXMgdXNlZCB0byBkZXRlcm1pbmUgcG90ZW50aWFsIGVxdWFsaXR5LFxcbmFuZCBpcyB1c2VkIHdoZW4gYWRkaW5nIHRoaXMgdG8gYSBgU2V0YCBvciBhcyBhIGtleSBpbiBhIGBNYXBgLCBlbmFibGluZ1xcbmxvb2t1cCB2aWEgYSBkaWZmZXJlbnQgaW5zdGFuY2UuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgU2V0LCAgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmNvbnN0IGEgPSBMaXN0KFsgMSwgMiwgMyBdKTtcXG5jb25zdCBiID0gTGlzdChbIDEsIDIsIDMgXSk7XFxuYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKGEsIGIpOyAvLyBkaWZmZXJlbnQgaW5zdGFuY2VzXFxuY29uc3Qgc2V0ID0gU2V0KFsgYSBdKTtcXG5hc3NlcnQuZXF1YWwoc2V0LmhhcyhiKSwgdHJ1ZSk7XFxuYGBgXFxuXFxuSWYgdHdvIHZhbHVlcyBoYXZlIHRoZSBzYW1lIGBoYXNoQ29kZWAsIHRoZXkgYXJlIFtub3QgZ3VhcmFudGVlZFxcbnRvIGJlIGVxdWFsXVtIYXNoIENvbGxpc2lvbl0uIElmIHR3byB2YWx1ZXMgaGF2ZSBkaWZmZXJlbnQgYGhhc2hDb2RlYHMsXFxudGhleSBtdXN0IG5vdCBiZSBlcXVhbC5cXG5cXG5bSGFzaCBDb2xsaXNpb25dOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2xsaXNpb25fKGNvbXB1dGVyX3NjaWVuY2UpXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoyfSxcImxpbmVcIjozODM3fV19fX0se1widGl0bGVcIjpcIlJlYWRpbmcgdmFsdWVzXCIsXCJtZW1iZXJzXCI6e1wiI2dldFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3ZpZGVkIGtleSwgb3Igbm90U2V0VmFsdWUgaWZcXG50aGUgQ29sbGVjdGlvbiBkb2VzIG5vdCBjb250YWluIHRoaXMga2V5LlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGl0IGlzIHBvc3NpYmxlIGEga2V5IG1heSBiZSBhc3NvY2lhdGVkIHdpdGggYW4gYHVuZGVmaW5lZGAgdmFsdWUsXFxuc28gaWYgYG5vdFNldFZhbHVlYCBpcyBub3QgcHJvdmlkZWQgYW5kIHRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAsXFxudGhhdCBkb2VzIG5vdCBndWFyYW50ZWUgdGhlIGtleSB3YXMgbm90IGZvdW5kLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJOU1ZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn19XSxcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifV19LFwibGluZVwiOjM4NTB9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6MTF9XX0sXCJsaW5lXCI6Mzg1MX1dfSxcIiNoYXNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBhIGtleSBleGlzdHMgd2l0aGluIHRoaXMgYENvbGxlY3Rpb25gLCB1c2luZyBgSW1tdXRhYmxlLmlzYFxcbnRvIGRldGVybWluZSBlcXVhbGl0eVwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjM4NTd9XX0sXCIjaW5jbHVkZXNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBhIHZhbHVlIGV4aXN0cyB3aXRoaW4gdGhpcyBgQ29sbGVjdGlvbmAsIHVzaW5nIGBJbW11dGFibGUuaXNgXFxudG8gZGV0ZXJtaW5lIGVxdWFsaXR5XCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJhbGlhc1wiLFwiYm9keVwiOlwiY29udGFpbnNcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjozODY0fV19LFwiI2ZpcnN0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkluIGNhc2UgdGhlIGBDb2xsZWN0aW9uYCBpcyBub3QgZW1wdHkgcmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGVcXG5gQ29sbGVjdGlvbmAuXFxuSW4gY2FzZSB0aGUgYENvbGxlY3Rpb25gIGlzIGVtcHR5IHJldHVybnMgdGhlIG9wdGlvbmFsIGRlZmF1bHRcXG52YWx1ZSBpZiBwcm92aWRlZCwgaWYgbm8gZGVmYXVsdCB2YWx1ZSBpcyBwcm92aWRlZCByZXR1cm5zIHVuZGVmaW5lZC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTlNWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm5vdFNldFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiTlNWXCJ9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn1dfSxcImxpbmVcIjozODczfV19LFwiI2xhc3RcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiSW4gY2FzZSB0aGUgYENvbGxlY3Rpb25gIGlzIG5vdCBlbXB0eSByZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlXFxuYENvbGxlY3Rpb25gLlxcbkluIGNhc2UgdGhlIGBDb2xsZWN0aW9uYCBpcyBlbXB0eSByZXR1cm5zIHRoZSBvcHRpb25hbCBkZWZhdWx0XFxudmFsdWUgaWYgcHJvdmlkZWQsIGlmIG5vIGRlZmF1bHQgdmFsdWUgaXMgcHJvdmlkZWQgcmV0dXJucyB1bmRlZmluZWQuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk5TVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiTlNWXCJ9XX0sXCJsaW5lXCI6Mzg4MX1dfX19LHtcInRpdGxlXCI6XCJSZWFkaW5nIGRlZXAgdmFsdWVzXCIsXCJtZW1iZXJzXCI6e1wiI2dldEluXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgdGhlIHZhbHVlIGZvdW5kIGJ5IGZvbGxvd2luZyBhIHBhdGggb2Yga2V5cyBvciBpbmRpY2VzIHRocm91Z2hcXG5uZXN0ZWQgQ29sbGVjdGlvbnMuXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IE1hcCwgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBkZWVwRGF0YSA9IE1hcCh7IHg6IExpc3QoWyBNYXAoeyB5OiAxMjMgfSkgXSkgfSk7XFxuZGVlcERhdGEuZ2V0SW4oWyd4JywgMCwgJ3knXSkgLy8gMTIzXFxuYGBgXFxuXFxuUGxhaW4gSmF2YVNjcmlwdCBPYmplY3Qgb3IgQXJyYXlzIG1heSBiZSBuZXN0ZWQgd2l0aGluIGFuIEltbXV0YWJsZS5qc1xcbkNvbGxlY3Rpb24sIGFuZCBnZXRJbigpIGNhbiBhY2Nlc3MgdGhvc2UgdmFsdWVzIGFzIHdlbGw6XFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IE1hcCwgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBkZWVwRGF0YSA9IE1hcCh7IHg6IFsgeyB5OiAxMjMgfSBdIH0pO1xcbmRlZXBEYXRhLmdldEluKFsneCcsIDAsICd5J10pIC8vIDEyM1xcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzZWFyY2hLZXlQYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX19LHtcIm5hbWVcIjpcIm5vdFNldFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxN30sXCJsaW5lXCI6MzkwNn1dfSxcIiNoYXNJblwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIHRoZSByZXN1bHQgb2YgZm9sbG93aW5nIGEgcGF0aCBvZiBrZXlzIG9yIGluZGljZXMgdGhyb3VnaCBuZXN0ZWRcXG5Db2xsZWN0aW9ucyByZXN1bHRzIGluIGEgc2V0IHZhbHVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzZWFyY2hLZXlQYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX19XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6MzkxMn1dfX19LHtcInRpdGxlXCI6XCJQZXJzaXN0ZW50IGNoYW5nZXNcIixcIm1lbWJlcnNcIjp7XCIjdXBkYXRlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRoaXMgY2FuIGJlIHZlcnkgdXNlZnVsIGFzIGEgd2F5IHRvIFxcXCJjaGFpblxcXCIgYSBub3JtYWwgZnVuY3Rpb24gaW50byBhXFxuc2VxdWVuY2Ugb2YgbWV0aG9kcy4gUnhKUyBjYWxscyB0aGlzIFxcXCJsZXRcXFwiIGFuZCBsb2Rhc2ggY2FsbHMgaXQgXFxcInRocnVcXFwiLlwiLFwiZGVzY3JpcHRpb25cIjpcIkZvciBleGFtcGxlLCB0byBzdW0gYSBTZXEgYWZ0ZXIgbWFwcGluZyBhbmQgZmlsdGVyaW5nOlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBTZXEgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuXFxuZnVuY3Rpb24gc3VtKGNvbGxlY3Rpb24pIHtcXG4gIHJldHVybiBjb2xsZWN0aW9uLnJlZHVjZSgoc3VtLCB4KSA9PiBzdW0gKyB4LCAwKVxcbn1cXG5cXG5TZXEoWyAxLCAyLCAzIF0pXFxuICAubWFwKHggPT4geCArIDEpXFxuICAuZmlsdGVyKHggPT4geCAlIDIgPT09IDApXFxuICAudXBkYXRlKHN1bSlcXG4vLyA2XFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlJcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlJcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiUlwifSxcImxpbmVcIjozOTM3fV19fX0se1widGl0bGVcIjpcIkNvbnZlcnNpb24gdG8gSmF2YVNjcmlwdCB0eXBlc1wiLFwibWVtYmVyc1wiOntcIiN0b0pTXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkRlZXBseSBjb252ZXJ0cyB0aGlzIENvbGxlY3Rpb24gdG8gZXF1aXZhbGVudCBuYXRpdmUgSmF2YVNjcmlwdCBBcnJheSBvciBPYmplY3QuXCIsXCJkZXNjcmlwdGlvblwiOlwiYENvbGxlY3Rpb24uSW5kZXhlZGAsIGFuZCBgQ29sbGVjdGlvbi5TZXRgIGJlY29tZSBgQXJyYXlgLCB3aGlsZVxcbmBDb2xsZWN0aW9uLktleWVkYCBiZWNvbWUgYE9iamVjdGAsIGNvbnZlcnRpbmcga2V5cyB0byBTdHJpbmdzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSx7XCJrXCI6NCxcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjoxN319XX1dfSxcImxpbmVcIjozOTQ4fV19LFwiI3RvSlNPTlwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJTaGFsbG93bHkgY29udmVydHMgdGhpcyBDb2xsZWN0aW9uIHRvIGVxdWl2YWxlbnQgbmF0aXZlIEphdmFTY3JpcHQgQXJyYXkgb3IgT2JqZWN0LlwiLFwiZGVzY3JpcHRpb25cIjpcImBDb2xsZWN0aW9uLkluZGV4ZWRgLCBhbmQgYENvbGxlY3Rpb24uU2V0YCBiZWNvbWUgYEFycmF5YCwgd2hpbGVcXG5gQ29sbGVjdGlvbi5LZXllZGAgYmVjb21lIGBPYmplY3RgLCBjb252ZXJ0aW5nIGtleXMgdG8gU3RyaW5ncy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0se1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV19XX0sXCJsaW5lXCI6Mzk1Nn1dfSxcIiN0b0FycmF5XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNoYWxsb3dseSBjb252ZXJ0cyB0aGlzIGNvbGxlY3Rpb24gdG8gYW4gQXJyYXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiYENvbGxlY3Rpb24uSW5kZXhlZGAsIGFuZCBgQ29sbGVjdGlvbi5TZXRgIHByb2R1Y2UgYW4gQXJyYXkgb2YgdmFsdWVzLlxcbmBDb2xsZWN0aW9uLktleWVkYCBwcm9kdWNlIGFuIEFycmF5IG9mIFtrZXksIHZhbHVlXSB0dXBsZXMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LHtcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfV19LFwibGluZVwiOjM5NjR9XX0sXCIjdG9PYmplY3RcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiU2hhbGxvd2x5IGNvbnZlcnRzIHRoaXMgQ29sbGVjdGlvbiB0byBhbiBPYmplY3QuXCIsXCJkZXNjcmlwdGlvblwiOlwiQ29udmVydHMga2V5cyB0byBTdHJpbmdzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6NCxcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XX0sXCJsaW5lXCI6Mzk3MX1dfX19LHtcInRpdGxlXCI6XCJDb252ZXJzaW9uIHRvIENvbGxlY3Rpb25zXCIsXCJtZW1iZXJzXCI6e1wiI3RvTWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkNvbnZlcnRzIHRoaXMgQ29sbGVjdGlvbiB0byBhIE1hcCwgVGhyb3dzIGlmIGtleXMgYXJlIG5vdCBoYXNoYWJsZS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gYE1hcCh0aGlzLnRvS2V5ZWRTZXEoKSlgLCBidXQgcHJvdmlkZWRcXG5mb3IgY29udmVuaWVuY2UgYW5kIHRvIGFsbG93IGZvciBjaGFpbmVkIGV4cHJlc3Npb25zLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjozOTgyfV19LFwiI3RvT3JkZXJlZE1hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDb252ZXJ0cyB0aGlzIENvbGxlY3Rpb24gdG8gYSBNYXAsIG1haW50YWluaW5nIHRoZSBvcmRlciBvZiBpdGVyYXRpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogVGhpcyBpcyBlcXVpdmFsZW50IHRvIGBPcmRlcmVkTWFwKHRoaXMudG9LZXllZFNlcSgpKWAsIGJ1dFxcbnByb3ZpZGVkIGZvciBjb252ZW5pZW5jZSBhbmQgdG8gYWxsb3cgZm9yIGNoYWluZWQgZXhwcmVzc2lvbnMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZE1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjozOTkwfV19LFwiI3RvU2V0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkNvbnZlcnRzIHRoaXMgQ29sbGVjdGlvbiB0byBhIFNldCwgZGlzY2FyZGluZyBrZXlzLiBUaHJvd3MgaWYgdmFsdWVzXFxuYXJlIG5vdCBoYXNoYWJsZS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gYFNldCh0aGlzKWAsIGJ1dCBwcm92aWRlZCB0byBhbGxvdyBmb3JcXG5jaGFpbmVkIGV4cHJlc3Npb25zLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6Mzk5OX1dfSxcIiN0b09yZGVyZWRTZXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQ29udmVydHMgdGhpcyBDb2xsZWN0aW9uIHRvIGEgU2V0LCBtYWludGFpbmluZyB0aGUgb3JkZXIgb2YgaXRlcmF0aW9uIGFuZFxcbmRpc2NhcmRpbmcga2V5cy5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gYE9yZGVyZWRTZXQodGhpcy52YWx1ZVNlcSgpKWAsIGJ1dCBwcm92aWRlZFxcbmZvciBjb252ZW5pZW5jZSBhbmQgdG8gYWxsb3cgZm9yIGNoYWluZWQgZXhwcmVzc2lvbnMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZFNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6NDAwOH1dfSxcIiN0b0xpc3RcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQ29udmVydHMgdGhpcyBDb2xsZWN0aW9uIHRvIGEgTGlzdCwgZGlzY2FyZGluZyBrZXlzLlwiLFwiZGVzY3JpcHRpb25cIjpcIlRoaXMgaXMgc2ltaWxhciB0byBgTGlzdChjb2xsZWN0aW9uKWAsIGJ1dCBwcm92aWRlZCB0byBhbGxvdyBmb3IgY2hhaW5lZFxcbmV4cHJlc3Npb25zLiBIb3dldmVyLCB3aGVuIGNhbGxlZCBvbiBgTWFwYCBvciBvdGhlciBrZXllZCBjb2xsZWN0aW9ucyxcXG5gY29sbGVjdGlvbi50b0xpc3QoKWAgZGlzY2FyZHMgdGhlIGtleXMgYW5kIGNyZWF0ZXMgYSBsaXN0IG9mIG9ubHkgdGhlXFxudmFsdWVzLCB3aGVyZWFzIGBMaXN0KGNvbGxlY3Rpb24pYCBjcmVhdGVzIGEgbGlzdCBvZiBlbnRyeSB0dXBsZXMuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IE1hcCwgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG52YXIgbXlNYXAgPSBNYXAoeyBhOiAnQXBwbGUnLCBiOiAnQmFuYW5hJyB9KVxcbkxpc3QobXlNYXApIC8vIExpc3QgWyBbIFxcXCJhXFxcIiwgXFxcIkFwcGxlXFxcIiBdLCBbIFxcXCJiXFxcIiwgXFxcIkJhbmFuYVxcXCIgXSBdXFxubXlNYXAudG9MaXN0KCkgLy8gTGlzdCBbIFxcXCJBcHBsZVxcXCIsIFxcXCJCYW5hbmFcXFwiIF1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjo0MDI2fV19LFwiI3RvU3RhY2tcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQ29udmVydHMgdGhpcyBDb2xsZWN0aW9uIHRvIGEgU3RhY2ssIGRpc2NhcmRpbmcga2V5cy4gVGhyb3dzIGlmIHZhbHVlc1xcbmFyZSBub3QgaGFzaGFibGUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogVGhpcyBpcyBlcXVpdmFsZW50IHRvIGBTdGFjayh0aGlzKWAsIGJ1dCBwcm92aWRlZCB0byBhbGxvdyBmb3JcXG5jaGFpbmVkIGV4cHJlc3Npb25zLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlN0YWNrXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjo0MDM1fV19fX0se1widGl0bGVcIjpcIkNvbnZlcnNpb24gdG8gU2VxXCIsXCJtZW1iZXJzXCI6e1wiI3RvU2VxXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkNvbnZlcnRzIHRoaXMgQ29sbGVjdGlvbiB0byBhIFNlcSBvZiB0aGUgc2FtZSBraW5kIChpbmRleGVkLFxcbmtleWVkLCBvciBzZXQpLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjo0MDQ0fV19LFwiI3RvS2V5ZWRTZXFcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIFNlcS5LZXllZCBmcm9tIHRoaXMgQ29sbGVjdGlvbiB3aGVyZSBpbmRpY2VzIGFyZSB0cmVhdGVkIGFzIGtleXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gb3BlcmF0ZSBvbiBhblxcbkNvbGxlY3Rpb24uSW5kZXhlZCBhbmQgcHJlc2VydmUgdGhlIFtpbmRleCwgdmFsdWVdIHBhaXJzLlxcblxcblRoZSByZXR1cm5lZCBTZXEgd2lsbCBoYXZlIGlkZW50aWNhbCBpdGVyYXRpb24gb3JkZXIgYXNcXG50aGlzIENvbGxlY3Rpb24uXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IFNlcSB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBpbmRleGVkU2VxID0gU2VxKFsgJ0EnLCAnQicsICdDJyBdKVxcbi8vIFNlcSBbIFxcXCJBXFxcIiwgXFxcIkJcXFwiLCBcXFwiQ1xcXCIgXVxcbmluZGV4ZWRTZXEuZmlsdGVyKHYgPT4gdiA9PT0gJ0InKVxcbi8vIFNlcSBbIFxcXCJCXFxcIiBdXFxuY29uc3Qga2V5ZWRTZXEgPSBpbmRleGVkU2VxLnRvS2V5ZWRTZXEoKVxcbi8vIFNlcSB7IDA6IFxcXCJBXFxcIiwgMTogXFxcIkJcXFwiLCAyOiBcXFwiQ1xcXCIgfVxcbmtleWVkU2VxLmZpbHRlcih2ID0+IHYgPT09ICdCJylcXG4vLyBTZXEgeyAxOiBcXFwiQlxcXCIgfVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjo0MDY4fV19LFwiI3RvSW5kZXhlZFNlcVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGFuIFNlcS5JbmRleGVkIG9mIHRoZSB2YWx1ZXMgb2YgdGhpcyBDb2xsZWN0aW9uLCBkaXNjYXJkaW5nIGtleXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjQwNzN9XX0sXCIjdG9TZXRTZXFcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIFNlcS5TZXQgb2YgdGhlIHZhbHVlcyBvZiB0aGlzIENvbGxlY3Rpb24sIGRpc2NhcmRpbmcga2V5cy5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjo0MDc4fV19fX0se1widGl0bGVcIjpcIkl0ZXJhdG9yc1wiLFwibWVtYmVyc1wiOntcIiNrZXlzXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkFuIGl0ZXJhdG9yIG9mIHRoaXMgYENvbGxlY3Rpb25gJ3Mga2V5cy5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiB0aGlzIHdpbGwgcmV0dXJuIGFuIEVTNiBpdGVyYXRvciB3aGljaCBkb2VzIG5vdCBzdXBwb3J0XFxuSW1tdXRhYmxlLmpzIHNlcXVlbmNlIGFsZ29yaXRobXMuIFVzZSBga2V5U2VxYCBpbnN0ZWFkLCBpZiB0aGlzIGlzXFxud2hhdCB5b3Ugd2FudC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZUl0ZXJhdG9yXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn1dfSxcImxpbmVcIjo0MDkwfV19LFwiI3ZhbHVlc1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJBbiBpdGVyYXRvciBvZiB0aGlzIGBDb2xsZWN0aW9uYCdzIHZhbHVlcy5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiB0aGlzIHdpbGwgcmV0dXJuIGFuIEVTNiBpdGVyYXRvciB3aGljaCBkb2VzIG5vdCBzdXBwb3J0XFxuSW1tdXRhYmxlLmpzIHNlcXVlbmNlIGFsZ29yaXRobXMuIFVzZSBgdmFsdWVTZXFgIGluc3RlYWQsIGlmIHRoaXMgaXNcXG53aGF0IHlvdSB3YW50LlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlSXRlcmF0b3JcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjQwOTl9XX0sXCIjZW50cmllc1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJBbiBpdGVyYXRvciBvZiB0aGlzIGBDb2xsZWN0aW9uYCdzIGVudHJpZXMgYXMgYFsga2V5LCB2YWx1ZSBdYCB0dXBsZXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogdGhpcyB3aWxsIHJldHVybiBhbiBFUzYgaXRlcmF0b3Igd2hpY2ggZG9lcyBub3Qgc3VwcG9ydFxcbkltbXV0YWJsZS5qcyBzZXF1ZW5jZSBhbGdvcml0aG1zLiBVc2UgYGVudHJ5U2VxYCBpbnN0ZWFkLCBpZiB0aGlzIGlzXFxud2hhdCB5b3Ugd2FudC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZUl0ZXJhdG9yXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XX0sXCJsaW5lXCI6NDEwOH1dfX19LHtcInRpdGxlXCI6XCJDb2xsZWN0aW9ucyAoU2VxKVwiLFwibWVtYmVyc1wiOntcIiNrZXlTZXFcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBTZXEuSW5kZXhlZCBvZiB0aGUga2V5cyBvZiB0aGlzIENvbGxlY3Rpb24sXFxuZGlzY2FyZGluZyB2YWx1ZXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifV19LFwibGluZVwiOjQxMTd9XX0sXCIjdmFsdWVTZXFcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhbiBTZXEuSW5kZXhlZCBvZiB0aGUgdmFsdWVzIG9mIHRoaXMgQ29sbGVjdGlvbiwgZGlzY2FyZGluZyBrZXlzLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjo0MTIyfV19LFwiI2VudHJ5U2VxXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU2VxLkluZGV4ZWQgb2YgW2tleSwgdmFsdWVdIHR1cGxlcy5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfV19LFwibGluZVwiOjQxMjd9XX19fSx7XCJ0aXRsZVwiOlwiU2VxdWVuY2UgYWxnb3JpdGhtc1wiLFwibWVtYmVyc1wiOntcIiNtYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgd2l0aCB2YWx1ZXMgcGFzc2VkIHRocm91Z2ggYVxcbmBtYXBwZXJgIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBDb2xsZWN0aW9uIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbkNvbGxlY3Rpb24oeyBhOiAxLCBiOiAyIH0pLm1hcCh4ID0+IDEwICogeClcXG4vLyBTZXEgeyBcXFwiYVxcXCI6IDEwLCBcXFwiYlxcXCI6IDIwIH1cXG5gYGBcXG5cXG5Ob3RlOiBgbWFwKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHByb2R1Y2VkIHRoZSBzYW1lXFxudmFsdWUgYXQgZXZlcnkgc3RlcC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjQxNDZ9XX0sXCIjZmlsdGVyXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIHdpdGggb25seSB0aGUgZW50cmllcyBmb3Igd2hpY2hcXG50aGUgYHByZWRpY2F0ZWAgZnVuY3Rpb24gcmV0dXJucyB0cnVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuTWFwKHsgYTogMSwgYjogMiwgYzogMywgZDogNH0pLmZpbHRlcih4ID0+IHggJSAyID09PSAwKVxcbi8vIE1hcCB7IFxcXCJiXFxcIjogMiwgXFxcImRcXFwiOiA0IH1cXG5gYGBcXG5cXG5Ob3RlOiBgZmlsdGVyKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHJlc3VsdHMgaW5cXG5ub3QgZmlsdGVyaW5nIG91dCBhbnkgdmFsdWVzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJGXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIkZcIn1dfSxcImxpbmVcIjo0MTczfSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxN319fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NDE3N31dfSxcIiNmaWx0ZXJOb3RcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgd2l0aCBvbmx5IHRoZSBlbnRyaWVzIGZvciB3aGljaFxcbnRoZSBgcHJlZGljYXRlYCBmdW5jdGlvbiByZXR1cm5zIGZhbHNlLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuTWFwKHsgYTogMSwgYjogMiwgYzogMywgZDogNH0pLmZpbHRlck5vdCh4ID0+IHggJSAyID09PSAwKVxcbi8vIE1hcCB7IFxcXCJhXFxcIjogMSwgXFxcImNcXFwiOiAzIH1cXG5gYGBcXG5cXG5Ob3RlOiBgZmlsdGVyTm90KClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHJlc3VsdHMgaW5cXG5ub3QgZmlsdGVyaW5nIG91dCBhbnkgdmFsdWVzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjQxOTZ9XX0sXCIjcmV2ZXJzZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZSBpbiByZXZlcnNlIG9yZGVyLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjQyMDR9XX0sXCIjc29ydFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZSB3aGljaCBpbmNsdWRlcyB0aGUgc2FtZSBlbnRyaWVzLFxcbnN0YWJseSBzb3J0ZWQgYnkgdXNpbmcgYSBgY29tcGFyYXRvcmAuXCIsXCJkZXNjcmlwdGlvblwiOlwiSWYgYSBgY29tcGFyYXRvcmAgaXMgbm90IHByb3ZpZGVkLCBhIGRlZmF1bHQgY29tcGFyYXRvciB1c2VzIGA8YCBhbmQgYD5gLlxcblxcbmBjb21wYXJhdG9yKHZhbHVlQSwgdmFsdWVCKWA6XFxuXFxuICAqIFJldHVybnMgYDBgIGlmIHRoZSBlbGVtZW50cyBzaG91bGQgbm90IGJlIHN3YXBwZWQuXFxuICAqIFJldHVybnMgYC0xYCAob3IgYW55IG5lZ2F0aXZlIG51bWJlcikgaWYgYHZhbHVlQWAgY29tZXMgYmVmb3JlIGB2YWx1ZUJgXFxuICAqIFJldHVybnMgYDFgIChvciBhbnkgcG9zaXRpdmUgbnVtYmVyKSBpZiBgdmFsdWVBYCBjb21lcyBhZnRlciBgdmFsdWVCYFxcbiAgKiBJcyBwdXJlLCBpLmUuIGl0IG11c3QgYWx3YXlzIHJldHVybiB0aGUgc2FtZSB2YWx1ZSBmb3IgdGhlIHNhbWUgcGFpclxcbiAgICBvZiB2YWx1ZXMuXFxuXFxuV2hlbiBzb3J0aW5nIGNvbGxlY3Rpb25zIHdoaWNoIGhhdmUgbm8gZGVmaW5lZCBvcmRlciwgdGhlaXIgb3JkZXJlZFxcbmVxdWl2YWxlbnRzIHdpbGwgYmUgcmV0dXJuZWQuIGUuZy4gYG1hcC5zb3J0KClgIHJldHVybnMgT3JkZXJlZE1hcC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbk1hcCh7IFxcXCJjXFxcIjogMywgXFxcImFcXFwiOiAxLCBcXFwiYlxcXCI6IDIgfSkuc29ydCgoYSwgYikgPT4ge1xcbiAgaWYgKGEgPCBiKSB7IHJldHVybiAtMTsgfVxcbiAgaWYgKGEgPiBiKSB7IHJldHVybiAxOyB9XFxuICBpZiAoYSA9PT0gYikgeyByZXR1cm4gMDsgfVxcbn0pO1xcbi8vIE9yZGVyZWRNYXAgeyBcXFwiYVxcXCI6IDEsIFxcXCJiXFxcIjogMiwgXFxcImNcXFwiOiAzIH1cXG5gYGBcXG5cXG5Ob3RlOiBgc29ydCgpYCBBbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiB0aGUgb3JpZ2luYWwgd2FzXFxuYWxyZWFkeSBzb3J0ZWQuXFxuXFxuTm90ZTogVGhpcyBpcyBhbHdheXMgYW4gZWFnZXIgb3BlcmF0aW9uLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb21wYXJhdG9yXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVBXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwidmFsdWVCXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjoyfX0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjQyMzl9XX0sXCIjc29ydEJ5XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkxpa2UgYHNvcnRgLCBidXQgYWxzbyBhY2NlcHRzIGEgYGNvbXBhcmF0b3JWYWx1ZU1hcHBlcmAgd2hpY2ggYWxsb3dzIGZvclxcbnNvcnRpbmcgYnkgbW9yZSBzb3BoaXN0aWNhdGVkIG1lYW5zOlwiLFwiZGVzY3JpcHRpb25cIjpcIiAgICBoaXR0ZXJzLnNvcnRCeShoaXR0ZXIgPT4gaGl0dGVyLmF2Z0hpdHMpXFxuXFxuTm90ZTogYHNvcnRCeSgpYCBBbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiB0aGUgb3JpZ2luYWwgd2FzXFxuYWxyZWFkeSBzb3J0ZWQuXFxuXFxuTm90ZTogVGhpcyBpcyBhbHdheXMgYW4gZWFnZXIgb3BlcmF0aW9uLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbXBhcmF0b3JWYWx1ZU1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fX0se1wibmFtZVwiOlwiY29tcGFyYXRvclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlQVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcInZhbHVlQlwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19XSxcInR5cGVcIjp7XCJrXCI6Mn19LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo0MjUyfV19LFwiI2dyb3VwQnlcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIGBDb2xsZWN0aW9uLktleWVkYCBvZiBgQ29sbGVjdGlvbi5LZXllZHNgLCBncm91cGVkIGJ5IHRoZSByZXR1cm5cXG52YWx1ZSBvZiB0aGUgYGdyb3VwZXJgIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IFRoaXMgaXMgYWx3YXlzIGFuIGVhZ2VyIG9wZXJhdGlvbi5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTGlzdCwgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IGxpc3RPZk1hcHMgPSBMaXN0KFtcXG4gIE1hcCh7IHY6IDAgfSksXFxuICBNYXAoeyB2OiAxIH0pLFxcbiAgTWFwKHsgdjogMSB9KSxcXG4gIE1hcCh7IHY6IDAgfSksXFxuICBNYXAoeyB2OiAyIH0pXFxuXSlcXG5jb25zdCBncm91cHNPZk1hcHMgPSBsaXN0T2ZNYXBzLmdyb3VwQnkoeCA9PiB4LmdldCgndicpKVxcbi8vIE1hcCB7XFxuLy8gICAwOiBMaXN0IFsgTWFweyBcXFwidlxcXCI6IDAgfSwgTWFwIHsgXFxcInZcXFwiOiAwIH0gXSxcXG4vLyAgIDE6IExpc3QgWyBNYXB7IFxcXCJ2XFxcIjogMSB9LCBNYXAgeyBcXFwidlxcXCI6IDEgfSBdLFxcbi8vICAgMjogTGlzdCBbIE1hcHsgXFxcInZcXFwiOiAyIH0gXSxcXG4vLyB9XFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkdcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiZ3JvdXBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJHXCJ9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJHXCJ9LHtcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfV19LFwibGluZVwiOjQyODF9XX19fSx7XCJ0aXRsZVwiOlwiU2lkZSBlZmZlY3RzXCIsXCJtZW1iZXJzXCI6e1wiI2ZvckVhY2hcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVGhlIGBzaWRlRWZmZWN0YCBpcyBleGVjdXRlZCBmb3IgZXZlcnkgZW50cnkgaW4gdGhlIENvbGxlY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiVW5saWtlIGBBcnJheSNmb3JFYWNoYCwgaWYgYW55IGNhbGwgb2YgYHNpZGVFZmZlY3RgIHJldHVybnNcXG5gZmFsc2VgLCB0aGUgaXRlcmF0aW9uIHdpbGwgc3RvcC4gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVudHJpZXMgaXRlcmF0ZWRcXG4oaW5jbHVkaW5nIHRoZSBsYXN0IGl0ZXJhdGlvbiB3aGljaCByZXR1cm5lZCBmYWxzZSkuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInNpZGVFZmZlY3RcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjJ9LFwibGluZVwiOjQyOTZ9XX19fSx7XCJ0aXRsZVwiOlwiQ3JlYXRpbmcgc3Vic2V0c1wiLFwibWVtYmVyc1wiOntcIiNzbGljZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZSByZXByZXNlbnRpbmcgYSBwb3J0aW9uIG9mIHRoaXNcXG5Db2xsZWN0aW9uIGZyb20gc3RhcnQgdXAgdG8gYnV0IG5vdCBpbmNsdWRpbmcgZW5kLlwiLFwiZGVzY3JpcHRpb25cIjpcIklmIGJlZ2luIGlzIG5lZ2F0aXZlLCBpdCBpcyBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBDb2xsZWN0aW9uLiBlLmcuXFxuYHNsaWNlKC0yKWAgcmV0dXJucyBhIENvbGxlY3Rpb24gb2YgdGhlIGxhc3QgdHdvIGVudHJpZXMuIElmIGl0IGlzIG5vdFxcbnByb3ZpZGVkIHRoZSBuZXcgQ29sbGVjdGlvbiB3aWxsIGJlZ2luIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBDb2xsZWN0aW9uLlxcblxcbklmIGVuZCBpcyBuZWdhdGl2ZSwgaXQgaXMgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgQ29sbGVjdGlvbi4gZS5nLlxcbmBzbGljZSgwLCAtMSlgIHJldHVybnMgYSBDb2xsZWN0aW9uIG9mIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5LiBJZlxcbml0IGlzIG5vdCBwcm92aWRlZCwgdGhlIG5ldyBDb2xsZWN0aW9uIHdpbGwgY29udGludWUgdGhyb3VnaCB0aGUgZW5kIG9mXFxudGhpcyBDb2xsZWN0aW9uLlxcblxcbklmIHRoZSByZXF1ZXN0ZWQgc2xpY2UgaXMgZXF1aXZhbGVudCB0byB0aGUgY3VycmVudCBDb2xsZWN0aW9uLCB0aGVuIGl0XFxud2lsbCByZXR1cm4gaXRzZWxmLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJiZWdpblwiLFwidHlwZVwiOntcImtcIjoyfSxcIm9wdGlvbmFsXCI6dHJ1ZX0se1wibmFtZVwiOlwiZW5kXCIsXCJ0eXBlXCI6e1wia1wiOjJ9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo0MzIwfV19LFwiI3Jlc3RcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgY29udGFpbmluZyBhbGwgZW50cmllcyBleGNlcHRcXG50aGUgZmlyc3QuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NDMyNn1dfSxcIiNidXRMYXN0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIGNvbnRhaW5pbmcgYWxsIGVudHJpZXMgZXhjZXB0XFxudGhlIGxhc3QuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NDMzMn1dfSxcIiNza2lwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIHdoaWNoIGV4Y2x1ZGVzIHRoZSBmaXJzdCBgYW1vdW50YFxcbmVudHJpZXMgZnJvbSB0aGlzIENvbGxlY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImFtb3VudFwiLFwidHlwZVwiOntcImtcIjoyfX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NDMzOH1dfSxcIiNza2lwTGFzdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZSB3aGljaCBleGNsdWRlcyB0aGUgbGFzdCBgYW1vdW50YFxcbmVudHJpZXMgZnJvbSB0aGlzIENvbGxlY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImFtb3VudFwiLFwidHlwZVwiOntcImtcIjoyfX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NDM0NH1dfSxcIiNza2lwV2hpbGVcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgd2hpY2ggaW5jbHVkZXMgZW50cmllcyBzdGFydGluZ1xcbmZyb20gd2hlbiBgcHJlZGljYXRlYCBmaXJzdCByZXR1cm5zIGZhbHNlLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbkxpc3QoWyAnZG9nJywgJ2Zyb2cnLCAnY2F0JywgJ2hhdCcsICdnb2QnIF0pXFxuICAuc2tpcFdoaWxlKHggPT4geC5tYXRjaCgvZy8pKVxcbi8vIExpc3QgWyBcXFwiY2F0XFxcIiwgXFxcImhhdFxcXCIsIFxcXCJnb2RcXFwiIF1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo0MzU4fV19LFwiI3NraXBVbnRpbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZSB3aGljaCBpbmNsdWRlcyBlbnRyaWVzIHN0YXJ0aW5nXFxuZnJvbSB3aGVuIGBwcmVkaWNhdGVgIGZpcnN0IHJldHVybnMgdHJ1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5MaXN0KFsgJ2RvZycsICdmcm9nJywgJ2NhdCcsICdoYXQnLCAnZ29kJyBdKVxcbiAgLnNraXBVbnRpbCh4ID0+IHgubWF0Y2goL2hhdC8pKVxcbi8vIExpc3QgWyBcXFwiaGF0XFxcIiwgXFxcImdvZFxcXCIgXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjQzNzV9XX0sXCIjdGFrZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZSB3aGljaCBpbmNsdWRlcyB0aGUgZmlyc3QgYGFtb3VudGBcXG5lbnRyaWVzIGZyb20gdGhpcyBDb2xsZWN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJhbW91bnRcIixcInR5cGVcIjp7XCJrXCI6Mn19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjQzODR9XX0sXCIjdGFrZUxhc3RcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgd2hpY2ggaW5jbHVkZXMgdGhlIGxhc3QgYGFtb3VudGBcXG5lbnRyaWVzIGZyb20gdGhpcyBDb2xsZWN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJhbW91bnRcIixcInR5cGVcIjp7XCJrXCI6Mn19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjQzOTB9XX0sXCIjdGFrZVdoaWxlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIHdoaWNoIGluY2x1ZGVzIGVudHJpZXMgZnJvbSB0aGlzXFxuQ29sbGVjdGlvbiBhcyBsb25nIGFzIHRoZSBgcHJlZGljYXRlYCByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuTGlzdChbICdkb2cnLCAnZnJvZycsICdjYXQnLCAnaGF0JywgJ2dvZCcgXSlcXG4gIC50YWtlV2hpbGUoeCA9PiB4Lm1hdGNoKC9vLykpXFxuLy8gTGlzdCBbIFxcXCJkb2dcXFwiLCBcXFwiZnJvZ1xcXCIgXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjQ0MDR9XX0sXCIjdGFrZVVudGlsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIHdoaWNoIGluY2x1ZGVzIGVudHJpZXMgZnJvbSB0aGlzXFxuQ29sbGVjdGlvbiBhcyBsb25nIGFzIHRoZSBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNlLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbkxpc3QoWyAnZG9nJywgJ2Zyb2cnLCAnY2F0JywgJ2hhdCcsICdnb2QnIF0pXFxuICAudGFrZVVudGlsKHggPT4geC5tYXRjaCgvYXQvKSlcXG4vLyBMaXN0IFsgXFxcImRvZ1xcXCIsIFxcXCJmcm9nXFxcIiBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NDQyMX1dfX19LHtcInRpdGxlXCI6XCJDb21iaW5hdGlvblwiLFwibWVtYmVyc1wiOntcIiNjb25jYXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgd2l0aCBvdGhlciB2YWx1ZXMgYW5kXFxuY29sbGVjdGlvbi1saWtlIGNvbmNhdGVuYXRlZCB0byB0aGlzIG9uZS5cIixcImRlc2NyaXB0aW9uXCI6XCJGb3IgU2VxcywgYWxsIGVudHJpZXMgd2lsbCBiZSBwcmVzZW50IGluIHRoZSByZXN1bHRpbmcgU2VxLCBldmVuIGlmIHRoZXlcXG5oYXZlIHRoZSBzYW1lIGtleS5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVzT3JDb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6MTd9XX0sXCJsaW5lXCI6NDQzNn1dfSxcIiNmbGF0dGVuXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkZsYXR0ZW5zIG5lc3RlZCBDb2xsZWN0aW9ucy5cIixcImRlc2NyaXB0aW9uXCI6XCJXaWxsIGRlZXBseSBmbGF0dGVuIHRoZSBDb2xsZWN0aW9uIGJ5IGRlZmF1bHQsIHJldHVybmluZyBhIENvbGxlY3Rpb24gb2YgdGhlXFxuc2FtZSB0eXBlLCBidXQgYSBgZGVwdGhgIGNhbiBiZSBwcm92aWRlZCBpbiB0aGUgZm9ybSBvZiBhIG51bWJlciBvclxcbmJvb2xlYW4gKHdoZXJlIHRydWUgbWVhbnMgdG8gc2hhbGxvd2x5IGZsYXR0ZW4gb25lIGxldmVsKS4gQSBkZXB0aCBvZiAwXFxuKG9yIHNoYWxsb3c6IGZhbHNlKSB3aWxsIGRlZXBseSBmbGF0dGVuLlxcblxcbkZsYXR0ZW5zIG9ubHkgb3RoZXJzIENvbGxlY3Rpb24sIG5vdCBBcnJheXMgb3IgT2JqZWN0cy5cXG5cXG5Ob3RlOiBgZmxhdHRlbih0cnVlKWAgb3BlcmF0ZXMgb24gQ29sbGVjdGlvbjx1bmtub3duLCBDb2xsZWN0aW9uPEssIFY+PiBhbmRcXG5yZXR1cm5zIENvbGxlY3Rpb248SywgVj5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiZGVwdGhcIixcInR5cGVcIjp7XCJrXCI6Mn0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6MTd9XX0sXCJsaW5lXCI6NDQ1MX0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInNoYWxsb3dcIixcInR5cGVcIjp7XCJrXCI6MX0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6MTd9XX0sXCJsaW5lXCI6NDQ1Mn1dfSxcIiNmbGF0TWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkZsYXQtbWFwcyB0aGUgQ29sbGVjdGlvbiwgcmV0dXJuaW5nIGEgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlLlwiLFwiZGVzY3JpcHRpb25cIjpcIlNpbWlsYXIgdG8gYGNvbGxlY3Rpb24ubWFwKC4uLikuZmxhdHRlbih0cnVlKWAuXFxuVXNlZCBmb3IgRGljdGlvbmFyaWVzIG9ubHkuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6NDQ1OX0se1widHlwZVBhcmFtc1wiOltcIktNXCIsXCJWTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLTVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWTVwifV19XX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLTVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWTVwifV19LFwibGluZVwiOjQ0NzB9XX19fSx7XCJ0aXRsZVwiOlwiUmVkdWNpbmcgYSB2YWx1ZVwiLFwibWVtYmVyc1wiOntcIiNyZWR1Y2VcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmVkdWNlcyB0aGUgQ29sbGVjdGlvbiB0byBhIHZhbHVlIGJ5IGNhbGxpbmcgdGhlIGByZWR1Y2VyYCBmb3IgZXZlcnkgZW50cnlcXG5pbiB0aGUgQ29sbGVjdGlvbiBhbmQgcGFzc2luZyBhbG9uZyB0aGUgcmVkdWNlZCB2YWx1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJJZiBgaW5pdGlhbFJlZHVjdGlvbmAgaXMgbm90IHByb3ZpZGVkLCB0aGUgZmlyc3QgaXRlbSBpbiB0aGVcXG5Db2xsZWN0aW9uIHdpbGwgYmUgdXNlZC5cXG5cIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiYEFycmF5I3JlZHVjZWAuXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJSXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInJlZHVjZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJyZWR1Y3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJSXCJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiUlwifX19LHtcIm5hbWVcIjpcImluaXRpYWxSZWR1Y3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJSXCJ9fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlJcIn0sXCJsaW5lXCI6NDQ4Nn0se1widHlwZVBhcmFtc1wiOltcIlJcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicmVkdWNlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInJlZHVjdGlvblwiLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiUlwifV19fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiUlwifX19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJSXCJ9LFwibGluZVwiOjQ0OTF9XX0sXCIjcmVkdWNlUmlnaHRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmVkdWNlcyB0aGUgQ29sbGVjdGlvbiBpbiByZXZlcnNlIChmcm9tIHRoZSByaWdodCBzaWRlKS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBTaW1pbGFyIHRvIHRoaXMucmV2ZXJzZSgpLnJlZHVjZSgpLCBhbmQgcHJvdmlkZWQgZm9yIHBhcml0eVxcbndpdGggYEFycmF5I3JlZHVjZVJpZ2h0YC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiUlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJyZWR1Y2VyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicmVkdWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiUlwifX0se1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlJcIn19fSx7XCJuYW1lXCI6XCJpbml0aWFsUmVkdWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiUlwifX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJSXCJ9LFwibGluZVwiOjQ1MDF9LHtcInR5cGVQYXJhbXNcIjpbXCJSXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInJlZHVjZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJyZWR1Y3Rpb25cIixcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlJcIn1dfX0se1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlJcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiUlwifSxcImxpbmVcIjo0NTA2fV19LFwiI2V2ZXJ5XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnVlIGZvciBhbGwgZW50cmllcyBpbiB0aGUgQ29sbGVjdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjQ1MTN9XX0sXCIjc29tZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1ZSBmb3IgYW55IGVudHJ5IGluIHRoZSBDb2xsZWN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6NDUyMX1dfSxcIiNqb2luXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkpvaW5zIHZhbHVlcyB0b2dldGhlciBhcyBhIHN0cmluZywgaW5zZXJ0aW5nIGEgc2VwYXJhdG9yIGJldHdlZW4gZWFjaC5cXG5UaGUgZGVmYXVsdCBzZXBhcmF0b3IgaXMgYFxcXCIsXFxcImAuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInNlcGFyYXRvclwiLFwidHlwZVwiOntcImtcIjozfSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjozfSxcImxpbmVcIjo0NTMwfV19LFwiI2lzRW1wdHlcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyB0cnVlIGlmIHRoaXMgQ29sbGVjdGlvbiBpbmNsdWRlcyBubyB2YWx1ZXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiRm9yIHNvbWUgbGF6eSBgU2VxYCwgYGlzRW1wdHlgIG1pZ2h0IG5lZWQgdG8gaXRlcmF0ZSB0byBkZXRlcm1pbmVcXG5lbXB0aW5lc3MuIEF0IG1vc3Qgb25lIGl0ZXJhdGlvbiB3aWxsIG9jY3VyLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6NDUzOH1dfSxcIiNjb3VudFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRoZSBzaXplIG9mIHRoaXMgQ29sbGVjdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJSZWdhcmRsZXNzIG9mIGlmIHRoaXMgQ29sbGVjdGlvbiBjYW4gZGVzY3JpYmUgaXRzIHNpemUgbGF6aWx5IChzb21lIFNlcXNcXG5jYW5ub3QpLCB0aGlzIG1ldGhvZCB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIGNvcnJlY3Qgc2l6ZS4gRS5nLiBpdFxcbmV2YWx1YXRlcyBhIGxhenkgYFNlcWAgaWYgbmVjZXNzYXJ5LlxcblxcbklmIGBwcmVkaWNhdGVgIGlzIHByb3ZpZGVkLCB0aGVuIHRoaXMgcmV0dXJucyB0aGUgY291bnQgb2YgZW50cmllcyBpbiB0aGVcXG5Db2xsZWN0aW9uIGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnVlLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6Mn0sXCJsaW5lXCI6NDU1MH0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoyfSxcImxpbmVcIjo0NTUxfV19LFwiI2NvdW50QnlcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIGBTZXEuS2V5ZWRgIG9mIGNvdW50cywgZ3JvdXBlZCBieSB0aGUgcmV0dXJuIHZhbHVlIG9mXFxudGhlIGBncm91cGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBUaGlzIGlzIG5vdCBhIGxhenkgb3BlcmF0aW9uLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJHXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImdyb3VwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiR1wifX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJNYXBcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiR1wifSx7XCJrXCI6Mn1dfSxcImxpbmVcIjo0NTYyfV19fX0se1widGl0bGVcIjpcIlNlYXJjaCBmb3IgdmFsdWVcIixcIm1lbWJlcnNcIjp7XCIjZmluZFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRoZSBmaXJzdCB2YWx1ZSBmb3Igd2hpY2ggdGhlIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjoxMX1dfSxcImxpbmVcIjo0NTczfV19LFwiI2ZpbmRMYXN0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgdGhlIGxhc3QgdmFsdWUgZm9yIHdoaWNoIHRoZSBgcHJlZGljYXRlYCByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYHByZWRpY2F0ZWAgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggZW50cnkgaW4gcmV2ZXJzZS5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjoxMX1dfSxcImxpbmVcIjo0NTg0fV19LFwiI2ZpbmRFbnRyeVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRoZSBmaXJzdCBba2V5LCB2YWx1ZV0gZW50cnkgZm9yIHdoaWNoIHRoZSBgcHJlZGljYXRlYCByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0se1wia1wiOjExfV19LFwibGluZVwiOjQ1OTN9XX0sXCIjZmluZExhc3RFbnRyeVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRoZSBsYXN0IFtrZXksIHZhbHVlXSBlbnRyeSBmb3Igd2hpY2ggdGhlIGBwcmVkaWNhdGVgXFxucmV0dXJucyB0cnVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBwcmVkaWNhdGVgIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGVudHJ5IGluIHJldmVyc2UuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0se1wia1wiOjExfV19LFwibGluZVwiOjQ2MDV9XX0sXCIjZmluZEtleVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRoZSBrZXkgZm9yIHdoaWNoIHRoZSBgcHJlZGljYXRlYCByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjExfV19LFwibGluZVwiOjQ2MTR9XX0sXCIjZmluZExhc3RLZXlcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyB0aGUgbGFzdCBrZXkgZm9yIHdoaWNoIHRoZSBgcHJlZGljYXRlYCByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYHByZWRpY2F0ZWAgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggZW50cnkgaW4gcmV2ZXJzZS5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTF9XX0sXCJsaW5lXCI6NDYyNH1dfSxcIiNrZXlPZlwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRoZSBrZXkgYXNzb2NpYXRlZCB3aXRoIHRoZSBzZWFyY2ggdmFsdWUsIG9yIHVuZGVmaW5lZC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwic2VhcmNoVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTF9XX0sXCJsaW5lXCI6NDYzMn1dfSxcIiNsYXN0S2V5T2ZcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyB0aGUgbGFzdCBrZXkgYXNzb2NpYXRlZCB3aXRoIHRoZSBzZWFyY2ggdmFsdWUsIG9yIHVuZGVmaW5lZC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwic2VhcmNoVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTF9XX0sXCJsaW5lXCI6NDYzN31dfSxcIiNtYXhcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZSBpbiB0aGlzIGNvbGxlY3Rpb24uIElmIGFueSB2YWx1ZXMgYXJlXFxuY29tcGFyYXRpdmVseSBlcXVpdmFsZW50LCB0aGUgZmlyc3Qgb25lIGZvdW5kIHdpbGwgYmUgcmV0dXJuZWQuXCIsXCJkZXNjcmlwdGlvblwiOlwiVGhlIGBjb21wYXJhdG9yYCBpcyB1c2VkIGluIHRoZSBzYW1lIHdheSBhcyBgQ29sbGVjdGlvbiNzb3J0YC4gSWYgaXQgaXMgbm90XFxucHJvdmlkZWQsIHRoZSBkZWZhdWx0IGNvbXBhcmF0b3IgaXMgYD5gLlxcblxcbldoZW4gdHdvIHZhbHVlcyBhcmUgY29uc2lkZXJlZCBlcXVpdmFsZW50LCB0aGUgZmlyc3QgZW5jb3VudGVyZWQgd2lsbCBiZVxcbnJldHVybmVkLiBPdGhlcndpc2UsIGBtYXhgIHdpbGwgb3BlcmF0ZSBpbmRlcGVuZGVudCBvZiB0aGUgb3JkZXIgb2YgaW5wdXRcXG5hcyBsb25nIGFzIHRoZSBjb21wYXJhdG9yIGlzIGNvbW11dGF0aXZlLiBUaGUgZGVmYXVsdCBjb21wYXJhdG9yIGA+YCBpc1xcbmNvbW11dGF0aXZlICpvbmx5KiB3aGVuIHR5cGVzIGRvIG5vdCBkaWZmZXIuXFxuXFxuSWYgYGNvbXBhcmF0b3JgIHJldHVybnMgMCBhbmQgZWl0aGVyIHZhbHVlIGlzIE5hTiwgdW5kZWZpbmVkLCBvciBudWxsLFxcbnRoYXQgdmFsdWUgd2lsbCBiZSByZXR1cm5lZC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29tcGFyYXRvclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlQVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcInZhbHVlQlwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6Mn19LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6MTF9XX0sXCJsaW5lXCI6NDY1NH1dfSxcIiNtYXhCeVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJMaWtlIGBtYXhgLCBidXQgYWxzbyBhY2NlcHRzIGEgYGNvbXBhcmF0b3JWYWx1ZU1hcHBlcmAgd2hpY2ggYWxsb3dzIGZvclxcbmNvbXBhcmluZyBieSBtb3JlIHNvcGhpc3RpY2F0ZWQgbWVhbnM6XCIsXCJkZXNjcmlwdGlvblwiOlwiICAgIGhpdHRlcnMubWF4QnkoaGl0dGVyID0+IGhpdHRlci5hdmdIaXRzKTtcXG5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb21wYXJhdG9yVmFsdWVNYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX19LHtcIm5hbWVcIjpcImNvbXBhcmF0b3JcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZUFcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZUJcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjJ9fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjExfV19LFwibGluZVwiOjQ2NjN9XX0sXCIjbWluXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUgaW4gdGhpcyBjb2xsZWN0aW9uLiBJZiBhbnkgdmFsdWVzIGFyZVxcbmNvbXBhcmF0aXZlbHkgZXF1aXZhbGVudCwgdGhlIGZpcnN0IG9uZSBmb3VuZCB3aWxsIGJlIHJldHVybmVkLlwiLFwiZGVzY3JpcHRpb25cIjpcIlRoZSBgY29tcGFyYXRvcmAgaXMgdXNlZCBpbiB0aGUgc2FtZSB3YXkgYXMgYENvbGxlY3Rpb24jc29ydGAuIElmIGl0IGlzIG5vdFxcbnByb3ZpZGVkLCB0aGUgZGVmYXVsdCBjb21wYXJhdG9yIGlzIGA8YC5cXG5cXG5XaGVuIHR3byB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQgZXF1aXZhbGVudCwgdGhlIGZpcnN0IGVuY291bnRlcmVkIHdpbGwgYmVcXG5yZXR1cm5lZC4gT3RoZXJ3aXNlLCBgbWluYCB3aWxsIG9wZXJhdGUgaW5kZXBlbmRlbnQgb2YgdGhlIG9yZGVyIG9mIGlucHV0XFxuYXMgbG9uZyBhcyB0aGUgY29tcGFyYXRvciBpcyBjb21tdXRhdGl2ZS4gVGhlIGRlZmF1bHQgY29tcGFyYXRvciBgPGAgaXNcXG5jb21tdXRhdGl2ZSAqb25seSogd2hlbiB0eXBlcyBkbyBub3QgZGlmZmVyLlxcblxcbklmIGBjb21wYXJhdG9yYCByZXR1cm5zIDAgYW5kIGVpdGhlciB2YWx1ZSBpcyBOYU4sIHVuZGVmaW5lZCwgb3IgbnVsbCxcXG50aGF0IHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbXBhcmF0b3JcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZUFcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZUJcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjJ9fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjExfV19LFwibGluZVwiOjQ2ODN9XX0sXCIjbWluQnlcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiTGlrZSBgbWluYCwgYnV0IGFsc28gYWNjZXB0cyBhIGBjb21wYXJhdG9yVmFsdWVNYXBwZXJgIHdoaWNoIGFsbG93cyBmb3JcXG5jb21wYXJpbmcgYnkgbW9yZSBzb3BoaXN0aWNhdGVkIG1lYW5zOlwiLFwiZGVzY3JpcHRpb25cIjpcIiAgICBoaXR0ZXJzLm1pbkJ5KGhpdHRlciA9PiBoaXR0ZXIuYXZnSGl0cyk7XFxuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29tcGFyYXRvclZhbHVlTWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19fSx7XCJuYW1lXCI6XCJjb21wYXJhdG9yXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVBXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwidmFsdWVCXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX1dLFwidHlwZVwiOntcImtcIjoyfX0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjoxMX1dfSxcImxpbmVcIjo0NjkyfV19fX0se1widGl0bGVcIjpcIkNvbXBhcmlzb25cIixcIm1lbWJlcnNcIjp7XCIjaXNTdWJzZXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgaXRlcmAgaW5jbHVkZXMgZXZlcnkgdmFsdWUgaW4gdGhpcyBDb2xsZWN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6NDcwM31dfSxcIiNpc1N1cGVyc2V0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgdGhpcyBDb2xsZWN0aW9uIGluY2x1ZGVzIGV2ZXJ5IHZhbHVlIGluIGBpdGVyYC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjQ3MDh9XX19fV19fSxcIlZhbHVlT2JqZWN0XCI6e1wiaW50ZXJmYWNlXCI6e1wibGluZVwiOjQ3MTQsXCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVGhlIGludGVyZmFjZSB0byBmdWxmaWxsIHRvIHF1YWxpZnkgYXMgYSBWYWx1ZSBPYmplY3QuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcImdyb3Vwc1wiOlt7XCJtZW1iZXJzXCI6e1wiI2VxdWFsc1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIHRoaXMgYW5kIHRoZSBvdGhlciBDb2xsZWN0aW9uIGhhdmUgdmFsdWUgZXF1YWxpdHksIGFzIGRlZmluZWRcXG5ieSBgSW1tdXRhYmxlLmlzKClgLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IFRoaXMgaXMgZXF1aXZhbGVudCB0byBgSW1tdXRhYmxlLmlzKHRoaXMsIG90aGVyKWAsIGJ1dCBwcm92aWRlZCB0b1xcbmFsbG93IGZvciBjaGFpbmVkIGV4cHJlc3Npb25zLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlclwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6NDcyMn1dfSxcIiNoYXNoQ29kZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgaGFzaGVkIGlkZW50aXR5IGZvciB0aGlzIENvbGxlY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiVGhlIGBoYXNoQ29kZWAgb2YgYSBDb2xsZWN0aW9uIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHBvdGVudGlhbCBlcXVhbGl0eSxcXG5hbmQgaXMgdXNlZCB3aGVuIGFkZGluZyB0aGlzIHRvIGEgYFNldGAgb3IgYXMgYSBrZXkgaW4gYSBgTWFwYCwgZW5hYmxpbmdcXG5sb29rdXAgdmlhIGEgZGlmZmVyZW50IGluc3RhbmNlLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBMaXN0LCBTZXQgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcbmNvbnN0IGEgPSBMaXN0KFsgMSwgMiwgMyBdKTtcXG5jb25zdCBiID0gTGlzdChbIDEsIDIsIDMgXSk7XFxuYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKGEsIGIpOyAvLyBkaWZmZXJlbnQgaW5zdGFuY2VzXFxuY29uc3Qgc2V0ID0gU2V0KFsgYSBdKTtcXG5hc3NlcnQuZXF1YWwoc2V0LmhhcyhiKSwgdHJ1ZSk7XFxuYGBgXFxuXFxuTm90ZTogaGFzaENvZGUoKSBNVVNUIHJldHVybiBhIFVpbnQzMiBudW1iZXIuIFRoZSBlYXNpZXN0IHdheSB0b1xcbmd1YXJhbnRlZSB0aGlzIGlzIHRvIHJldHVybiBgbXlIYXNoIHwgMGAgZnJvbSBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbi5cXG5cXG5JZiB0d28gdmFsdWVzIGhhdmUgdGhlIHNhbWUgYGhhc2hDb2RlYCwgdGhleSBhcmUgW25vdCBndWFyYW50ZWVkXFxudG8gYmUgZXF1YWxdW0hhc2ggQ29sbGlzaW9uXS4gSWYgdHdvIHZhbHVlcyBoYXZlIGRpZmZlcmVudCBgaGFzaENvZGVgcyxcXG50aGV5IG11c3Qgbm90IGJlIGVxdWFsLlxcblxcbk5vdGU6IGBoYXNoQ29kZSgpYCBpcyBub3QgZ3VhcmFudGVlZCB0byBhbHdheXMgYmUgY2FsbGVkIGJlZm9yZVxcbmBlcXVhbHMoKWAuIE1vc3QgYnV0IG5vdCBhbGwgSW1tdXRhYmxlLmpzIGNvbGxlY3Rpb25zIHVzZSBoYXNoIGNvZGVzIHRvXFxub3JnYW5pemUgdGhlaXIgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmVzLCB3aGlsZSBhbGwgSW1tdXRhYmxlLmpzXFxuY29sbGVjdGlvbnMgdXNlIGVxdWFsaXR5IGR1cmluZyBsb29rdXBzLlxcblxcbltIYXNoIENvbGxpc2lvbl06IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbGxpc2lvbl8oY29tcHV0ZXJfc2NpZW5jZSlcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjJ9LFwibGluZVwiOjQ3NTV9XX19fV19fSxcImZyb21KU1wiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRGVlcGx5IGNvbnZlcnRzIHBsYWluIEpTIG9iamVjdHMgYW5kIGFycmF5cyB0byBJbW11dGFibGUgTWFwcyBhbmQgTGlzdHMuXCIsXCJkZXNjcmlwdGlvblwiOlwiSWYgYSBgcmV2aXZlcmAgaXMgb3B0aW9uYWxseSBwcm92aWRlZCwgaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBldmVyeVxcbmNvbGxlY3Rpb24gYXMgYSBTZXEgKGJlZ2lubmluZyB3aXRoIHRoZSBtb3N0IG5lc3RlZCBjb2xsZWN0aW9uc1xcbmFuZCBwcm9jZWVkaW5nIHRvIHRoZSB0b3AtbGV2ZWwgY29sbGVjdGlvbiBpdHNlbGYpLCBhbG9uZyB3aXRoIHRoZSBrZXlcXG5yZWZlcnJpbmcgdG8gZWFjaCBjb2xsZWN0aW9uIGFuZCB0aGUgcGFyZW50IEpTIG9iamVjdCBwcm92aWRlZCBhcyBgdGhpc2AuXFxuRm9yIHRoZSB0b3AgbGV2ZWwsIG9iamVjdCwgdGhlIGtleSB3aWxsIGJlIGBcXFwiXFxcImAuIFRoaXMgYHJldml2ZXJgIGlzIGV4cGVjdGVkXFxudG8gcmV0dXJuIGEgbmV3IEltbXV0YWJsZSBDb2xsZWN0aW9uLCBhbGxvd2luZyBmb3IgY3VzdG9tIGNvbnZlcnNpb25zIGZyb21cXG5kZWVwIEpTIG9iamVjdHMuIEZpbmFsbHksIGEgYHBhdGhgIGlzIHByb3ZpZGVkIHdoaWNoIGlzIHRoZSBzZXF1ZW5jZSBvZlxcbmtleXMgdG8gdGhpcyB2YWx1ZSBmcm9tIHRoZSBzdGFydGluZyB2YWx1ZS5cXG5cXG5gcmV2aXZlcmAgYWN0cyBzaW1pbGFybHkgdG8gdGhlIFtzYW1lIHBhcmFtZXRlciBpbiBgSlNPTi5wYXJzZWBdWzFdLlxcblxcbklmIGByZXZpdmVyYCBpcyBub3QgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIHdpbGwgY29udmVydCBPYmplY3RzXFxuaW50byBNYXBzIGFuZCBBcnJheXMgaW50byBMaXN0cyBsaWtlIHNvOlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBmcm9tSlMsIGlzS2V5ZWQgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcXG4gIHJldHVybiBpc0tleWVkKHZhbHVlKSA/IHZhbHVlLnRvTWFwKCkgOiB2YWx1ZS50b0xpc3QoKVxcbn1cXG5gYGBcXG5cXG5gZnJvbUpTYCBpcyBjb25zZXJ2YXRpdmUgaW4gaXRzIGNvbnZlcnNpb24uIEl0IHdpbGwgb25seSBjb252ZXJ0XFxuYXJyYXlzIHdoaWNoIHBhc3MgYEFycmF5LmlzQXJyYXlgIHRvIExpc3RzLCBhbmQgb25seSByYXcgb2JqZWN0cyAobm8gY3VzdG9tXFxucHJvdG90eXBlKSB0byBNYXAuXFxuXFxuQWNjb3JkaW5nbHksIHRoaXMgZXhhbXBsZSBjb252ZXJ0cyBuYXRpdmUgSlMgZGF0YSB0byBPcmRlcmVkTWFwIGFuZCBMaXN0OlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBmcm9tSlMsIGlzS2V5ZWQgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuZnJvbUpTKHsgYToge2I6IFsxMCwgMjAsIDMwXX0sIGM6IDQwfSwgZnVuY3Rpb24gKGtleSwgdmFsdWUsIHBhdGgpIHtcXG4gIGNvbnNvbGUubG9nKGtleSwgdmFsdWUsIHBhdGgpXFxuICByZXR1cm4gaXNLZXllZCh2YWx1ZSkgPyB2YWx1ZS50b09yZGVyZWRNYXAoKSA6IHZhbHVlLnRvTGlzdCgpXFxufSlcXG5cXG4+IFxcXCJiXFxcIiwgWyAxMCwgMjAsIDMwIF0sIFsgXFxcImFcXFwiLCBcXFwiYlxcXCIgXVxcbj4gXFxcImFcXFwiLCB7YjogWzEwLCAyMCwgMzBdfSwgWyBcXFwiYVxcXCIgXVxcbj4gXFxcIlxcXCIsIHthOiB7YjogWzEwLCAyMCwgMzBdfSwgYzogNDB9LCBbXVxcbmBgYFxcblxcbktlZXAgaW4gbWluZCwgd2hlbiB1c2luZyBKUyBvYmplY3RzIHRvIGNvbnN0cnVjdCBJbW11dGFibGUgTWFwcywgdGhhdFxcbkphdmFTY3JpcHQgT2JqZWN0IHByb3BlcnRpZXMgYXJlIGFsd2F5cyBzdHJpbmdzLCBldmVuIGlmIHdyaXR0ZW4gaW4gYVxcbnF1b3RlLWxlc3Mgc2hvcnRoYW5kLCB3aGlsZSBJbW11dGFibGUgTWFwcyBhY2NlcHQga2V5cyBvZiBhbnkgdHlwZS5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmxldCBvYmogPSB7IDE6IFxcXCJvbmVcXFwiIH07XFxuT2JqZWN0LmtleXMob2JqKTsgLy8gWyBcXFwiMVxcXCIgXVxcbmFzc2VydC5lcXVhbChvYmpbXFxcIjFcXFwiXSwgb2JqWzFdKTsgLy8gXFxcIm9uZVxcXCIgPT09IFxcXCJvbmVcXFwiXFxuXFxubGV0IG1hcCA9IE1hcChvYmopO1xcbmFzc2VydC5ub3RFcXVhbChtYXAuZ2V0KFxcXCIxXFxcIiksIG1hcC5nZXQoMSkpOyAvLyBcXFwib25lXFxcIiAhPT0gdW5kZWZpbmVkXFxuYGBgXFxuXFxuUHJvcGVydHkgYWNjZXNzIGZvciBKYXZhU2NyaXB0IE9iamVjdHMgZmlyc3QgY29udmVydHMgdGhlIGtleSB0byBhIHN0cmluZyxcXG5idXQgc2luY2UgSW1tdXRhYmxlIE1hcCBrZXlzIGNhbiBiZSBvZiBhbnkgdHlwZSB0aGUgYXJndW1lbnQgdG8gYGdldCgpYCBpc1xcbm5vdCBhbHRlcmVkLlxcblxcblsxXTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSlNPTi9wYXJzZSNFeGFtcGxlLjNBX1VzaW5nX3RoZV9yZXZpdmVyX3BhcmFtZXRlclxcbiAgICAgXFxcIlVzaW5nIHRoZSByZXZpdmVyIHBhcmFtZXRlclxcXCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwianNWYWx1ZVwiLFwidHlwZVwiOntcImtcIjoxN319LHtcIm5hbWVcIjpcInJldml2ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6M30se1wia1wiOjJ9XX19LHtcIm5hbWVcIjpcInNlcXVlbmNlXCIsXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjozfSx7XCJrXCI6MTd9XX0se1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19XX19LHtcIm5hbWVcIjpcInBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjozfSx7XCJrXCI6Mn1dfV19LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjE3fX0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTd9LFwibGluZVwiOjQ4MjR9XX19LFwiaXNcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlZhbHVlIGVxdWFsaXR5IGNoZWNrIHdpdGggc2VtYW50aWNzIHNpbWlsYXIgdG8gYE9iamVjdC5pc2AsIGJ1dCB0cmVhdHNcXG5JbW11dGFibGUgYENvbGxlY3Rpb25gcyBhcyB2YWx1ZXMsIGVxdWFsIGlmIHRoZSBzZWNvbmQgYENvbGxlY3Rpb25gIGluY2x1ZGVzXFxuZXF1aXZhbGVudCB2YWx1ZXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiSXQncyB1c2VkIHRocm91Z2hvdXQgSW1tdXRhYmxlIHdoZW4gY2hlY2tpbmcgZm9yIGVxdWFsaXR5LCBpbmNsdWRpbmcgYE1hcGBcXG5rZXkgZXF1YWxpdHkgYW5kIGBTZXRgIG1lbWJlcnNoaXAuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IE1hcCwgaXMgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3QgbWFwMSA9IE1hcCh7IGE6IDEsIGI6IDEsIGM6IDEgfSlcXG5jb25zdCBtYXAyID0gTWFwKHsgYTogMSwgYjogMSwgYzogMSB9KVxcbmFzc2VydC5lcXVhbChtYXAxICE9PSBtYXAyLCB0cnVlKVxcbmFzc2VydC5lcXVhbChPYmplY3QuaXMobWFwMSwgbWFwMiksIGZhbHNlKVxcbmFzc2VydC5lcXVhbChpcyhtYXAxLCBtYXAyKSwgdHJ1ZSlcXG5gYGBcXG5cXG5gaXMoKWAgY29tcGFyZXMgcHJpbWl0aXZlIHR5cGVzIGxpa2Ugc3RyaW5ncyBhbmQgbnVtYmVycywgSW1tdXRhYmxlLmpzXFxuY29sbGVjdGlvbnMgbGlrZSBgTWFwYCBhbmQgYExpc3RgLCBidXQgYWxzbyBhbnkgY3VzdG9tIG9iamVjdCB3aGljaFxcbmltcGxlbWVudHMgYFZhbHVlT2JqZWN0YCBieSBwcm92aWRpbmcgYGVxdWFscygpYCBhbmQgYGhhc2hDb2RlKClgIG1ldGhvZHMuXFxuXFxuTm90ZTogVW5saWtlIGBPYmplY3QuaXNgLCBgSW1tdXRhYmxlLmlzYCBhc3N1bWVzIGAwYCBhbmQgYC0wYCBhcmUgdGhlIHNhbWVcXG52YWx1ZSwgbWF0Y2hpbmcgdGhlIGJlaGF2aW9yIG9mIEVTNiBNYXAga2V5IGVxdWFsaXR5LlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJmaXJzdFwiLFwidHlwZVwiOntcImtcIjoxN319LHtcIm5hbWVcIjpcInNlY29uZFwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6NDg1OH1dfX0sXCJoYXNoXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUaGUgYGhhc2goKWAgZnVuY3Rpb24gaXMgYW4gaW1wb3J0YW50IHBhcnQgb2YgaG93IEltbXV0YWJsZSBkZXRlcm1pbmVzIGlmXFxudHdvIHZhbHVlcyBhcmUgZXF1aXZhbGVudCBhbmQgaXMgdXNlZCB0byBkZXRlcm1pbmUgaG93IHRvIHN0b3JlIHRob3NlXFxudmFsdWVzLiBQcm92aWRlZCB3aXRoIGFueSB2YWx1ZSwgYGhhc2goKWAgd2lsbCByZXR1cm4gYSAzMS1iaXQgaW50ZWdlci5cIixcImRlc2NyaXB0aW9uXCI6XCJXaGVuIGRlc2lnbmluZyBPYmplY3RzIHdoaWNoIG1heSBiZSBlcXVhbCwgaXQncyBpbXBvcnRhbnQgdGhhdCB3aGVuIGFcXG5gLmVxdWFscygpYCBtZXRob2QgcmV0dXJucyB0cnVlLCB0aGF0IGJvdGggdmFsdWVzIGAuaGFzaENvZGUoKWAgbWV0aG9kXFxucmV0dXJuIHRoZSBzYW1lIHZhbHVlLiBgaGFzaCgpYCBtYXkgYmUgdXNlZCB0byBwcm9kdWNlIHRob3NlIHZhbHVlcy5cXG5cXG5Gb3Igbm9uLUltbXV0YWJsZSBPYmplY3RzIHRoYXQgZG8gbm90IHByb3ZpZGUgYSBgLmhhc2hDb2RlKClgIGZ1bmN0aW9uc1xcbihpbmNsdWRpbmcgcGxhaW4gT2JqZWN0cywgcGxhaW4gQXJyYXlzLCBEYXRlIG9iamVjdHMsIGV0YyksIGEgdW5pcXVlIGhhc2hcXG52YWx1ZSB3aWxsIGJlIGNyZWF0ZWQgZm9yIGVhY2ggKmluc3RhbmNlKi4gVGhhdCBpcywgdGhlIGNyZWF0ZSBoYXNoXFxucmVwcmVzZW50cyByZWZlcmVudGlhbCBlcXVhbGl0eSwgYW5kIG5vdCB2YWx1ZSBlcXVhbGl0eSBmb3IgT2JqZWN0cy4gVGhpc1xcbmVuc3VyZXMgdGhhdCBpZiB0aGF0IE9iamVjdCBpcyBtdXRhdGVkIG92ZXIgdGltZSB0aGF0IGl0cyBoYXNoIGNvZGUgd2lsbFxcbnJlbWFpbiBjb25zaXN0ZW50LCBhbGxvd2luZyBPYmplY3RzIHRvIGJlIHVzZWQgYXMga2V5cyBhbmQgdmFsdWVzIGluXFxuSW1tdXRhYmxlLmpzIGNvbGxlY3Rpb25zLlxcblxcbk5vdGUgdGhhdCBgaGFzaCgpYCBhdHRlbXB0cyB0byBiYWxhbmNlIGJldHdlZW4gc3BlZWQgYW5kIGF2b2lkaW5nXFxuY29sbGlzaW9ucywgaG93ZXZlciBpdCBtYWtlcyBubyBhdHRlbXB0IHRvIHByb2R1Y2Ugc2VjdXJlIGhhc2hlcy5cXG5cXG4qTmV3IGluIFZlcnNpb24gNC4wKlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6Mn0sXCJsaW5lXCI6NDg4Mn1dfX0sXCJpc0ltbXV0YWJsZVwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVJbW11dGFibGVgIGlzIGFuIEltbXV0YWJsZSBDb2xsZWN0aW9uIG9yIFJlY29yZC5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBTdGlsbCByZXR1cm5zIHRydWUgZXZlbiBpZiB0aGUgY29sbGVjdGlvbnMgaXMgd2l0aGluIGEgYHdpdGhNdXRhdGlvbnMoKWAuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IGlzSW1tdXRhYmxlLCBNYXAsIExpc3QsIFN0YWNrIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXG5pc0ltbXV0YWJsZShbXSk7IC8vIGZhbHNlXFxuaXNJbW11dGFibGUoe30pOyAvLyBmYWxzZVxcbmlzSW1tdXRhYmxlKE1hcCgpKTsgLy8gdHJ1ZVxcbmlzSW1tdXRhYmxlKExpc3QoKSk7IC8vIHRydWVcXG5pc0ltbXV0YWJsZShTdGFjaygpKTsgLy8gdHJ1ZVxcbmlzSW1tdXRhYmxlKE1hcCgpLmFzTXV0YWJsZSgpKTsgLy8gdHJ1ZVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXliZUltbXV0YWJsZVwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6NDkwMH1dfX0sXCJpc0NvbGxlY3Rpb25cIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgYG1heWJlQ29sbGVjdGlvbmAgaXMgYSBDb2xsZWN0aW9uLCBvciBhbnkgb2YgaXRzIHN1YmNsYXNzZXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IGlzQ29sbGVjdGlvbiwgTWFwLCBMaXN0LCBTdGFjayB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxuaXNDb2xsZWN0aW9uKFtdKTsgLy8gZmFsc2VcXG5pc0NvbGxlY3Rpb24oe30pOyAvLyBmYWxzZVxcbmlzQ29sbGVjdGlvbihNYXAoKSk7IC8vIHRydWVcXG5pc0NvbGxlY3Rpb24oTGlzdCgpKTsgLy8gdHJ1ZVxcbmlzQ29sbGVjdGlvbihTdGFjaygpKTsgLy8gdHJ1ZVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXliZUNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjQ5MTV9XX19LFwiaXNLZXllZFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVLZXllZGAgaXMgYSBDb2xsZWN0aW9uLktleWVkLCBvciBhbnkgb2YgaXRzIHN1YmNsYXNzZXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IGlzS2V5ZWQsIE1hcCwgTGlzdCwgU3RhY2sgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcbmlzS2V5ZWQoW10pOyAvLyBmYWxzZVxcbmlzS2V5ZWQoe30pOyAvLyBmYWxzZVxcbmlzS2V5ZWQoTWFwKCkpOyAvLyB0cnVlXFxuaXNLZXllZChMaXN0KCkpOyAvLyBmYWxzZVxcbmlzS2V5ZWQoU3RhY2soKSk7IC8vIGZhbHNlXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlS2V5ZWRcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjQ5MzB9XX19LFwiaXNJbmRleGVkXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGBtYXliZUluZGV4ZWRgIGlzIGEgQ29sbGVjdGlvbi5JbmRleGVkLCBvciBhbnkgb2YgaXRzIHN1YmNsYXNzZXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IGlzSW5kZXhlZCwgTWFwLCBMaXN0LCBTdGFjaywgU2V0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXG5pc0luZGV4ZWQoW10pOyAvLyBmYWxzZVxcbmlzSW5kZXhlZCh7fSk7IC8vIGZhbHNlXFxuaXNJbmRleGVkKE1hcCgpKTsgLy8gZmFsc2VcXG5pc0luZGV4ZWQoTGlzdCgpKTsgLy8gdHJ1ZVxcbmlzSW5kZXhlZChTdGFjaygpKTsgLy8gdHJ1ZVxcbmlzSW5kZXhlZChTZXQoKSk7IC8vIGZhbHNlXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlSW5kZXhlZFwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6NDk0Nn1dfX0sXCJpc0Fzc29jaWF0aXZlXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGBtYXliZUFzc29jaWF0aXZlYCBpcyBlaXRoZXIgYSBLZXllZCBvciBJbmRleGVkIENvbGxlY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IGlzQXNzb2NpYXRpdmUsIE1hcCwgTGlzdCwgU3RhY2ssIFNldCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxuaXNBc3NvY2lhdGl2ZShbXSk7IC8vIGZhbHNlXFxuaXNBc3NvY2lhdGl2ZSh7fSk7IC8vIGZhbHNlXFxuaXNBc3NvY2lhdGl2ZShNYXAoKSk7IC8vIHRydWVcXG5pc0Fzc29jaWF0aXZlKExpc3QoKSk7IC8vIHRydWVcXG5pc0Fzc29jaWF0aXZlKFN0YWNrKCkpOyAvLyB0cnVlXFxuaXNBc3NvY2lhdGl2ZShTZXQoKSk7IC8vIGZhbHNlXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlQXNzb2NpYXRpdmVcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjQ5NjJ9XX19LFwiaXNPcmRlcmVkXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGBtYXliZU9yZGVyZWRgIGlzIGEgQ29sbGVjdGlvbiB3aGVyZSBpdGVyYXRpb24gb3JkZXIgaXMgd2VsbFxcbmRlZmluZWQuIFRydWUgZm9yIENvbGxlY3Rpb24uSW5kZXhlZCBhcyB3ZWxsIGFzIE9yZGVyZWRNYXAgYW5kIE9yZGVyZWRTZXQuXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IGlzT3JkZXJlZCwgTWFwLCBPcmRlcmVkTWFwLCBMaXN0LCBTZXQgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcbmlzT3JkZXJlZChbXSk7IC8vIGZhbHNlXFxuaXNPcmRlcmVkKHt9KTsgLy8gZmFsc2VcXG5pc09yZGVyZWQoTWFwKCkpOyAvLyBmYWxzZVxcbmlzT3JkZXJlZChPcmRlcmVkTWFwKCkpOyAvLyB0cnVlXFxuaXNPcmRlcmVkKExpc3QoKSk7IC8vIHRydWVcXG5pc09yZGVyZWQoU2V0KCkpOyAvLyBmYWxzZVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXliZU9yZGVyZWRcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjQ5Nzl9XX19LFwiaXNWYWx1ZU9iamVjdFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVWYWx1ZWAgaXMgYSBKYXZhU2NyaXB0IE9iamVjdCB3aGljaCBoYXMgKmJvdGgqIGBlcXVhbHMoKWBcXG5hbmQgYGhhc2hDb2RlKClgIG1ldGhvZHMuXCIsXCJkZXNjcmlwdGlvblwiOlwiQW55IHR3byBpbnN0YW5jZXMgb2YgKnZhbHVlIG9iamVjdHMqIGNhbiBiZSBjb21wYXJlZCBmb3IgdmFsdWUgZXF1YWxpdHkgd2l0aFxcbmBJbW11dGFibGUuaXMoKWAgYW5kIGNhbiBiZSB1c2VkIGFzIGtleXMgaW4gYSBgTWFwYCBvciBtZW1iZXJzIGluIGEgYFNldGAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjQ5ODh9XX19LFwiaXNTZXFcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgYG1heWJlU2VxYCBpcyBhIFNlcS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVTZXFcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjQ5OTR9XX19LFwiaXNMaXN0XCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGBtYXliZUxpc3RgIGlzIGEgTGlzdC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVMaXN0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo0OTk5fV19fSxcImlzTWFwXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGBtYXliZU1hcGAgaXMgYSBNYXAuXCIsXCJkZXNjcmlwdGlvblwiOlwiQWxzbyB0cnVlIGZvciBPcmRlcmVkTWFwcy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVNYXBcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjUwMDZ9XX19LFwiaXNPcmRlcmVkTWFwXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGBtYXliZU9yZGVyZWRNYXBgIGlzIGFuIE9yZGVyZWRNYXAuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlT3JkZXJlZE1hcFwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6NTAxMX1dfX0sXCJpc1N0YWNrXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGBtYXliZVN0YWNrYCBpcyBhIFN0YWNrLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXliZVN0YWNrXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo1MDE2fV19fSxcImlzU2V0XCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGBtYXliZVNldGAgaXMgYSBTZXQuXCIsXCJkZXNjcmlwdGlvblwiOlwiQWxzbyB0cnVlIGZvciBPcmRlcmVkU2V0cy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVTZXRcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjUwMjN9XX19LFwiaXNPcmRlcmVkU2V0XCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGBtYXliZU9yZGVyZWRTZXRgIGlzIGFuIE9yZGVyZWRTZXQuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlT3JkZXJlZFNldFwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6NTAyOH1dfX0sXCJpc1JlY29yZFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVSZWNvcmRgIGlzIGEgUmVjb3JkLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXliZVJlY29yZFwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6NTAzM31dfX0sXCJnZXRcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgdGhlIHZhbHVlIHdpdGhpbiB0aGUgcHJvdmlkZWQgY29sbGVjdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlXFxucHJvdmlkZWQga2V5LCBvciBub3RTZXRWYWx1ZSBpZiB0aGUga2V5IGlzIG5vdCBkZWZpbmVkIGluIHRoZSBjb2xsZWN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIkEgZnVuY3Rpb25hbCBhbHRlcm5hdGl2ZSB0byBgY29sbGVjdGlvbi5nZXQoa2V5KWAgd2hpY2ggd2lsbCBhbHNvIHdvcmsgb25cXG5wbGFpbiBPYmplY3RzIGFuZCBBcnJheXMgYXMgYW4gYWx0ZXJuYXRpdmUgZm9yIGBjb2xsZWN0aW9uW2tleV1gLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBnZXQgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuZ2V0KFsgJ2RvZycsICdmcm9nJywgJ2NhdCcgXSwgMikgLy8gJ2Zyb2cnXFxuZ2V0KHsgeDogMTIzLCB5OiA0NTYgfSwgJ3gnKSAvLyAxMjNcXG5nZXQoeyB4OiAxMjMsIHk6IDQ1NiB9LCAneicsICdpZk5vdFNldCcpIC8vICdpZk5vdFNldCdcXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6MTF9XX0sXCJsaW5lXCI6NTA1Mn0se1widHlwZVBhcmFtc1wiOltcIktcIixcIlZcIixcIk5TVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifX1dLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiTlNWXCJ9XX0sXCJsaW5lXCI6NTA1M30se1widHlwZVBhcmFtc1wiOltcIlRQcm9wc1wiLFwiS1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJyZWNvcmRcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlJlY29yZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn1dfX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjE1LFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRQcm9wc1wifSxcImluZGV4XCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0sXCJsaW5lXCI6NTA1NH0se1widHlwZVBhcmFtc1wiOltcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6Mn19XSxcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjoxMX1dfSxcImxpbmVcIjo1MDU1fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiLFwiTlNWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifX1dLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiTlNWXCJ9XX0sXCJsaW5lXCI6NTA1Nn0se1widHlwZVBhcmFtc1wiOltcIkNcIixcIktcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib2JqZWN0XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjE1LFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJpbmRleFwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LFwibGluZVwiOjUwNTd9LHtcInR5cGVQYXJhbXNcIjpbXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6NCxcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XX19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjExfV19LFwibGluZVwiOjUwNTh9LHtcInR5cGVQYXJhbXNcIjpbXCJWXCIsXCJOU1ZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dfX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifX1dLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiTlNWXCJ9XX0sXCJsaW5lXCI6NTA1OX1dfX0sXCJoYXNcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgdHJ1ZSBpZiB0aGUga2V5IGlzIGRlZmluZWQgaW4gdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiQSBmdW5jdGlvbmFsIGFsdGVybmF0aXZlIHRvIGBjb2xsZWN0aW9uLmhhcyhrZXkpYCB3aGljaCB3aWxsIGFsc28gd29yayB3aXRoXFxucGxhaW4gT2JqZWN0cyBhbmQgQXJyYXlzIGFzIGFuIGFsdGVybmF0aXZlIGZvclxcbmBjb2xsZWN0aW9uLmhhc093blByb3BlcnR5KGtleSlgLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBoYXMgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuaGFzKFsgJ2RvZycsICdmcm9nJywgJ2NhdCcgXSwgMikgLy8gdHJ1ZVxcbmhhcyhbICdkb2cnLCAnZnJvZycsICdjYXQnIF0sIDUpIC8vIGZhbHNlXFxuaGFzKHsgeDogMTIzLCB5OiA0NTYgfSwgJ3gnKSAvLyB0cnVlXFxuaGFzKHsgeDogMTIzLCB5OiA0NTYgfSwgJ3onKSAvLyBmYWxzZVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPYmplY3RcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6NTA3N31dfX0sXCJyZW1vdmVcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBjb3B5IG9mIHRoZSBjb2xsZWN0aW9uIHdpdGggdGhlIHZhbHVlIGF0IGtleSByZW1vdmVkLlwiLFwiZGVzY3JpcHRpb25cIjpcIkEgZnVuY3Rpb25hbCBhbHRlcm5hdGl2ZSB0byBgY29sbGVjdGlvbi5yZW1vdmUoa2V5KWAgd2hpY2ggd2lsbCBhbHNvIHdvcmtcXG53aXRoIHBsYWluIE9iamVjdHMgYW5kIEFycmF5cyBhcyBhbiBhbHRlcm5hdGl2ZSBmb3JcXG5gZGVsZXRlIGNvbGxlY3Rpb25Db3B5W2tleV1gLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyByZW1vdmUgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgb3JpZ2luYWxBcnJheSA9IFsgJ2RvZycsICdmcm9nJywgJ2NhdCcgXVxcbnJlbW92ZShvcmlnaW5hbEFycmF5LCAxKSAvLyBbICdkb2cnLCAnY2F0JyBdXFxuY29uc29sZS5sb2cob3JpZ2luYWxBcnJheSkgLy8gWyAnZG9nJywgJ2Zyb2cnLCAnY2F0JyBdXFxuY29uc3Qgb3JpZ2luYWxPYmplY3QgPSB7IHg6IDEyMywgeTogNDU2IH1cXG5yZW1vdmUob3JpZ2luYWxPYmplY3QsICd4JykgLy8geyB5OiA0NTYgfVxcbmNvbnNvbGUubG9nKG9yaWdpbmFsT2JqZWN0KSAvLyB7IHg6IDEyMywgeTogNDU2IH1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJsaW5lXCI6NTA5N30se1widHlwZVBhcmFtc1wiOltcIlRQcm9wc1wiLFwiQ1wiLFwiS1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJsaW5lXCI6NTA5OH0se1widHlwZVBhcmFtc1wiOltcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoyfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJsaW5lXCI6NTA5OX0se1widHlwZVBhcmFtc1wiOltcIkNcIixcIktcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUxMDB9LHtcInR5cGVQYXJhbXNcIjpbXCJDXCIsXCJLXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjo1MTAxfV19fSxcInNldFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIGNvcHkgb2YgdGhlIGNvbGxlY3Rpb24gd2l0aCB0aGUgdmFsdWUgYXQga2V5IHNldCB0byB0aGUgcHJvdmlkZWRcXG52YWx1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJBIGZ1bmN0aW9uYWwgYWx0ZXJuYXRpdmUgdG8gYGNvbGxlY3Rpb24uc2V0KGtleSwgdmFsdWUpYCB3aGljaCB3aWxsIGFsc29cXG53b3JrIHdpdGggcGxhaW4gT2JqZWN0cyBhbmQgQXJyYXlzIGFzIGFuIGFsdGVybmF0aXZlIGZvclxcbmBjb2xsZWN0aW9uQ29weVtrZXldID0gdmFsdWVgLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBzZXQgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgb3JpZ2luYWxBcnJheSA9IFsgJ2RvZycsICdmcm9nJywgJ2NhdCcgXVxcbnNldChvcmlnaW5hbEFycmF5LCAxLCAnY293JykgLy8gWyAnZG9nJywgJ2NvdycsICdjYXQnIF1cXG5jb25zb2xlLmxvZyhvcmlnaW5hbEFycmF5KSAvLyBbICdkb2cnLCAnZnJvZycsICdjYXQnIF1cXG5jb25zdCBvcmlnaW5hbE9iamVjdCA9IHsgeDogMTIzLCB5OiA0NTYgfVxcbnNldChvcmlnaW5hbE9iamVjdCwgJ3gnLCA3ODkpIC8vIHsgeDogNzg5LCB5OiA0NTYgfVxcbmNvbnNvbGUubG9nKG9yaWdpbmFsT2JqZWN0KSAvLyB7IHg6IDEyMywgeTogNDU2IH1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiLFwiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjo1MTIyfSx7XCJ0eXBlUGFyYW1zXCI6W1wiVFByb3BzXCIsXCJDXCIsXCJLXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInJlY29yZFwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE1LFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRQcm9wc1wifSxcImluZGV4XCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUxMjN9LHtcInR5cGVQYXJhbXNcIjpbXCJWXCIsXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJsaW5lXCI6NTEyNH0se1widHlwZVBhcmFtc1wiOltcIkNcIixcIktcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib2JqZWN0XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTUsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifSxcImluZGV4XCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUxMjV9LHtcInR5cGVQYXJhbXNcIjpbXCJWXCIsXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJsaW5lXCI6NTEyNn1dfX0sXCJ1cGRhdGVcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBjb3B5IG9mIHRoZSBjb2xsZWN0aW9uIHdpdGggdGhlIHZhbHVlIGF0IGtleSBzZXQgdG8gdGhlIHJlc3VsdCBvZlxcbnByb3ZpZGluZyB0aGUgZXhpc3RpbmcgdmFsdWUgdG8gdGhlIHVwZGF0aW5nIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIkEgZnVuY3Rpb25hbCBhbHRlcm5hdGl2ZSB0byBgY29sbGVjdGlvbi51cGRhdGUoa2V5LCBmbilgIHdoaWNoIHdpbGwgYWxzb1xcbndvcmsgd2l0aCBwbGFpbiBPYmplY3RzIGFuZCBBcnJheXMgYXMgYW4gYWx0ZXJuYXRpdmUgZm9yXFxuYGNvbGxlY3Rpb25Db3B5W2tleV0gPSBmbihjb2xsZWN0aW9uW2tleV0pYC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgdXBkYXRlIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG9yaWdpbmFsQXJyYXkgPSBbICdkb2cnLCAnZnJvZycsICdjYXQnIF1cXG51cGRhdGUob3JpZ2luYWxBcnJheSwgMSwgdmFsID0+IHZhbC50b1VwcGVyQ2FzZSgpKSAvLyBbICdkb2cnLCAnRlJPRycsICdjYXQnIF1cXG5jb25zb2xlLmxvZyhvcmlnaW5hbEFycmF5KSAvLyBbICdkb2cnLCAnZnJvZycsICdjYXQnIF1cXG5jb25zdCBvcmlnaW5hbE9iamVjdCA9IHsgeDogMTIzLCB5OiA0NTYgfVxcbnVwZGF0ZShvcmlnaW5hbE9iamVjdCwgJ3gnLCB2YWwgPT4gdmFsICogNikgLy8geyB4OiA3MzgsIHk6IDQ1NiB9XFxuY29uc29sZS5sb2cob3JpZ2luYWxPYmplY3QpIC8vIHsgeDogMTIzLCB5OiA0NTYgfVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCIsXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJ1cGRhdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUxNDd9LHtcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCIsXCJDXCIsXCJOU1ZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIm5vdFNldFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiTlNWXCJ9fSx7XCJuYW1lXCI6XCJ1cGRhdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUxNDh9LHtcInR5cGVQYXJhbXNcIjpbXCJUUHJvcHNcIixcIkNcIixcIktcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicmVjb3JkXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE1LFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRQcm9wc1wifSxcImluZGV4XCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX19XSxcInR5cGVcIjp7XCJrXCI6MTUsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9LFwiaW5kZXhcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fX19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUxNDl9LHtcInR5cGVQYXJhbXNcIjpbXCJUUHJvcHNcIixcIkNcIixcIktcIixcIk5TVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJyZWNvcmRcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifX0se1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjE1LFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRQcm9wc1wifSxcImluZGV4XCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wia1wiOjgsXCJwYXJhbVwiOlwiTlNWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6MTUsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9LFwiaW5kZXhcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fX19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUxNTB9LHtcInR5cGVQYXJhbXNcIjpbXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJ1cGRhdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjo1MTUxfSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiLFwiTlNWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifX0se1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn1dfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6NTE1Mn0se1widHlwZVBhcmFtc1wiOltcIkNcIixcIktcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib2JqZWN0XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE1LFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJpbmRleFwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjE1LFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJpbmRleFwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19fX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJsaW5lXCI6NTE1M30se1widHlwZVBhcmFtc1wiOltcIkNcIixcIktcIixcIk5TVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvYmplY3RcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifX0se1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjE1LFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJpbmRleFwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjE1LFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJpbmRleFwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19fX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJsaW5lXCI6NTE1NH0se1widHlwZVBhcmFtc1wiOltcIlZcIixcIkNcIixcIktcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fX1dLFwidHlwZVwiOntcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dfSxcImxpbmVcIjo1MTU1fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiLFwiQ1wiLFwiS1wiLFwiTlNWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifX0se1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn1dfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV19LFwibGluZVwiOjUxNTZ9XX19LFwiZ2V0SW5cIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgdGhlIHZhbHVlIGF0IHRoZSBwcm92aWRlZCBrZXkgcGF0aCBzdGFydGluZyBhdCB0aGUgcHJvdmlkZWRcXG5jb2xsZWN0aW9uLCBvciBub3RTZXRWYWx1ZSBpZiB0aGUga2V5IHBhdGggaXMgbm90IGRlZmluZWQuXCIsXCJkZXNjcmlwdGlvblwiOlwiQSBmdW5jdGlvbmFsIGFsdGVybmF0aXZlIHRvIGBjb2xsZWN0aW9uLmdldEluKGtleXBhdGgpYCB3aGljaCB3aWxsIGFsc29cXG53b3JrIHdpdGggcGxhaW4gT2JqZWN0cyBhbmQgQXJyYXlzLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBnZXRJbiB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5nZXRJbih7IHg6IHsgeTogeyB6OiAxMjMgfX19LCBbJ3gnLCAneScsICd6J10pIC8vIDEyM1xcbmdldEluKHsgeDogeyB5OiB7IHo6IDEyMyB9fX0sIFsneCcsICdxJywgJ3AnXSwgJ2lmTm90U2V0JykgLy8gJ2lmTm90U2V0J1xcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX0se1wibmFtZVwiOlwia2V5UGF0aFwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19fSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MTd9LFwibGluZVwiOjUxNzJ9XX19LFwiaGFzSW5cIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgdHJ1ZSBpZiB0aGUga2V5IHBhdGggaXMgZGVmaW5lZCBpbiB0aGUgcHJvdmlkZWQgY29sbGVjdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJBIGZ1bmN0aW9uYWwgYWx0ZXJuYXRpdmUgdG8gYGNvbGxlY3Rpb24uaGFzSW4oa2V5cGF0aClgIHdoaWNoIHdpbGwgYWxzb1xcbndvcmsgd2l0aCBwbGFpbiBPYmplY3RzIGFuZCBBcnJheXMuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IGhhc0luIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmhhc0luKHsgeDogeyB5OiB7IHo6IDEyMyB9fX0sIFsneCcsICd5JywgJ3onXSkgLy8gdHJ1ZVxcbmhhc0luKHsgeDogeyB5OiB7IHo6IDEyMyB9fX0sIFsneCcsICdxJywgJ3AnXSkgLy8gZmFsc2VcXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjoxN319LHtcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo1MTg3fV19fSxcInJlbW92ZUluXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgY29weSBvZiB0aGUgY29sbGVjdGlvbiB3aXRoIHRoZSB2YWx1ZSBhdCB0aGUga2V5IHBhdGggcmVtb3ZlZC5cIixcImRlc2NyaXB0aW9uXCI6XCJBIGZ1bmN0aW9uYWwgYWx0ZXJuYXRpdmUgdG8gYGNvbGxlY3Rpb24ucmVtb3ZlSW4oa2V5cGF0aClgIHdoaWNoIHdpbGwgYWxzb1xcbndvcmsgd2l0aCBwbGFpbiBPYmplY3RzIGFuZCBBcnJheXMuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IHJlbW92ZUluIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG9yaWdpbmFsID0geyB4OiB7IHk6IHsgejogMTIzIH19fVxcbnJlbW92ZUluKG9yaWdpbmFsLCBbJ3gnLCAneScsICd6J10pIC8vIHsgeDogeyB5OiB7fX19XFxuY29uc29sZS5sb2cob3JpZ2luYWwpIC8vIHsgeDogeyB5OiB7IHo6IDEyMyB9fX1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5UGF0aFwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjo1MjAzfV19fSxcInNldEluXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgY29weSBvZiB0aGUgY29sbGVjdGlvbiB3aXRoIHRoZSB2YWx1ZSBhdCB0aGUga2V5IHBhdGggc2V0IHRvIHRoZVxcbnByb3ZpZGVkIHZhbHVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIkEgZnVuY3Rpb25hbCBhbHRlcm5hdGl2ZSB0byBgY29sbGVjdGlvbi5zZXRJbihrZXlwYXRoKWAgd2hpY2ggd2lsbCBhbHNvXFxud29yayB3aXRoIHBsYWluIE9iamVjdHMgYW5kIEFycmF5cy5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgc2V0SW4gfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgb3JpZ2luYWwgPSB7IHg6IHsgeTogeyB6OiAxMjMgfX19XFxuc2V0SW4ob3JpZ2luYWwsIFsneCcsICd5JywgJ3onXSwgNDU2KSAvLyB7IHg6IHsgeTogeyB6OiA0NTYgfX19XFxuY29uc29sZS5sb2cob3JpZ2luYWwpIC8vIHsgeDogeyB5OiB7IHo6IDEyMyB9fX1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5UGF0aFwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUyMjB9XX19LFwidXBkYXRlSW5cIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBjb3B5IG9mIHRoZSBjb2xsZWN0aW9uIHdpdGggdGhlIHZhbHVlIGF0IGtleSBwYXRoIHNldCB0byB0aGVcXG5yZXN1bHQgb2YgcHJvdmlkaW5nIHRoZSBleGlzdGluZyB2YWx1ZSB0byB0aGUgdXBkYXRpbmcgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiQSBmdW5jdGlvbmFsIGFsdGVybmF0aXZlIHRvIGBjb2xsZWN0aW9uLnVwZGF0ZUluKGtleXBhdGgpYCB3aGljaCB3aWxsIGFsc29cXG53b3JrIHdpdGggcGxhaW4gT2JqZWN0cyBhbmQgQXJyYXlzLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyB1cGRhdGVJbiB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBvcmlnaW5hbCA9IHsgeDogeyB5OiB7IHo6IDEyMyB9fX1cXG51cGRhdGVJbihvcmlnaW5hbCwgWyd4JywgJ3knLCAneiddLCB2YWwgPT4gdmFsICogNikgLy8geyB4OiB7IHk6IHsgejogNzM4IH19fVxcbmNvbnNvbGUubG9nKG9yaWdpbmFsKSAvLyB7IHg6IHsgeTogeyB6OiAxMjMgfX19XFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX0se1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxN319fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjo1MjM3fSx7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5UGF0aFwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19fSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjoxN319LHtcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MTd9fX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJsaW5lXCI6NTIzOH1dfX0sXCJtZXJnZVwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIGNvcHkgb2YgdGhlIGNvbGxlY3Rpb24gd2l0aCB0aGUgcmVtYWluaW5nIGNvbGxlY3Rpb25zIG1lcmdlZCBpbi5cIixcImRlc2NyaXB0aW9uXCI6XCJBIGZ1bmN0aW9uYWwgYWx0ZXJuYXRpdmUgdG8gYGNvbGxlY3Rpb24ubWVyZ2UoKWAgd2hpY2ggd2lsbCBhbHNvIHdvcmsgd2l0aFxcbnBsYWluIE9iamVjdHMgYW5kIEFycmF5cy5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgbWVyZ2UgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgb3JpZ2luYWwgPSB7IHg6IDEyMywgeTogNDU2IH1cXG5tZXJnZShvcmlnaW5hbCwgeyB5OiA3ODksIHo6ICdhYmMnIH0pIC8vIHsgeDogMTIzLCB5OiA3ODksIHo6ICdhYmMnIH1cXG5jb25zb2xlLmxvZyhvcmlnaW5hbCkgLy8geyB4OiAxMjMsIHk6IDQ1NiB9XFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSx7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19XX0se1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6MTd9fV19XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjo1MjU0fV19fSxcIm1lcmdlV2l0aFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIGNvcHkgb2YgdGhlIGNvbGxlY3Rpb24gd2l0aCB0aGUgcmVtYWluaW5nIGNvbGxlY3Rpb25zIG1lcmdlZCBpbixcXG5jYWxsaW5nIHRoZSBgbWVyZ2VyYCBmdW5jdGlvbiB3aGVuZXZlciBhbiBleGlzdGluZyB2YWx1ZSBpcyBlbmNvdW50ZXJlZC5cIixcImRlc2NyaXB0aW9uXCI6XCJBIGZ1bmN0aW9uYWwgYWx0ZXJuYXRpdmUgdG8gYGNvbGxlY3Rpb24ubWVyZ2VXaXRoKClgIHdoaWNoIHdpbGwgYWxzbyB3b3JrXFxud2l0aCBwbGFpbiBPYmplY3RzIGFuZCBBcnJheXMuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IG1lcmdlV2l0aCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBvcmlnaW5hbCA9IHsgeDogMTIzLCB5OiA0NTYgfVxcbm1lcmdlV2l0aChcXG4gIChvbGRWYWwsIG5ld1ZhbCkgPT4gb2xkVmFsICsgbmV3VmFsLFxcbiAgb3JpZ2luYWwsXFxuICB7IHk6IDc4OSwgejogJ2FiYycgfVxcbikgLy8geyB4OiAxMjMsIHk6IDEyNDUsIHo6ICdhYmMnIH1cXG5jb25zb2xlLmxvZyhvcmlnaW5hbCkgLy8geyB4OiAxMjMsIHk6IDQ1NiB9XFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWVyZ2VyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib2xkVmFsXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX0se1wibmFtZVwiOlwibmV3VmFsXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxN319fSx7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LHtcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjE3fSx7XCJrXCI6MTd9XX1dfSx7XCJrXCI6NCxcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjoxN319XX1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUyNzh9XX19LFwibWVyZ2VEZWVwXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgY29weSBvZiB0aGUgY29sbGVjdGlvbiB3aXRoIHRoZSByZW1haW5pbmcgY29sbGVjdGlvbnMgbWVyZ2VkIGluXFxuZGVlcGx5IChyZWN1cnNpdmVseSkuXCIsXCJkZXNjcmlwdGlvblwiOlwiQSBmdW5jdGlvbmFsIGFsdGVybmF0aXZlIHRvIGBjb2xsZWN0aW9uLm1lcmdlRGVlcCgpYCB3aGljaCB3aWxsIGFsc28gd29ya1xcbndpdGggcGxhaW4gT2JqZWN0cyBhbmQgQXJyYXlzLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBtZXJnZURlZXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgb3JpZ2luYWwgPSB7IHg6IHsgeTogMTIzIH19XFxubWVyZ2VEZWVwKG9yaWdpbmFsLCB7IHg6IHsgejogNDU2IH19KSAvLyB7IHg6IHsgeTogMTIzLCB6OiA0NTYgfX1cXG5jb25zb2xlLmxvZyhvcmlnaW5hbCkgLy8geyB4OiB7IHk6IDEyMyB9fVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0se1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfV19LHtcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX1dfV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJsaW5lXCI6NTI5OX1dfX0sXCJtZXJnZURlZXBXaXRoXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgY29weSBvZiB0aGUgY29sbGVjdGlvbiB3aXRoIHRoZSByZW1haW5pbmcgY29sbGVjdGlvbnMgbWVyZ2VkIGluXFxuZGVlcGx5IChyZWN1cnNpdmVseSksIGNhbGxpbmcgdGhlIGBtZXJnZXJgIGZ1bmN0aW9uIHdoZW5ldmVyIGFuIGV4aXN0aW5nXFxudmFsdWUgaXMgZW5jb3VudGVyZWQuXCIsXCJkZXNjcmlwdGlvblwiOlwiQSBmdW5jdGlvbmFsIGFsdGVybmF0aXZlIHRvIGBjb2xsZWN0aW9uLm1lcmdlRGVlcFdpdGgoKWAgd2hpY2ggd2lsbCBhbHNvXFxud29yayB3aXRoIHBsYWluIE9iamVjdHMgYW5kIEFycmF5cy5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgbWVyZ2VEZWVwV2l0aCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBvcmlnaW5hbCA9IHsgeDogeyB5OiAxMjMgfX1cXG5tZXJnZURlZXBXaXRoKFxcbiAgKG9sZFZhbCwgbmV3VmFsKSA9PiBvbGRWYWwgKyBuZXdWYWwsXFxuICBvcmlnaW5hbCxcXG4gIHsgeDogeyB5OiA0NTYgfX1cXG4pIC8vIHsgeDogeyB5OiA1NzkgfX1cXG5jb25zb2xlLmxvZyhvcmlnaW5hbCkgLy8geyB4OiB7IHk6IDEyMyB9fVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1lcmdlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm9sZFZhbFwiLFwidHlwZVwiOntcImtcIjoxN319LHtcIm5hbWVcIjpcIm5ld1ZhbFwiLFwidHlwZVwiOntcImtcIjoxN319LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MTd9fX0se1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSx7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19XX0se1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6MTd9fV19XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjo1MzI0fV19fX19LFwiaW1tdXRhYmxlXCI6e1wibW9kdWxlXCI6e319fSIsInZhciBUeXBlS2luZCA9IHtcbiAgQW55OiAwLFxuXG4gIEJvb2xlYW46IDEsXG4gIE51bWJlcjogMixcbiAgU3RyaW5nOiAzLFxuICBPYmplY3Q6IDQsXG4gIEFycmF5OiA1LFxuICBOZXZlcjogNixcbiAgRnVuY3Rpb246IDcsXG5cbiAgUGFyYW06IDgsXG4gIFR5cGU6IDksXG5cbiAgVGhpczogMTAsXG4gIFVuZGVmaW5lZDogMTEsXG4gIFVuaW9uOiAxMixcbiAgSW50ZXJzZWN0aW9uOiAxMyxcbiAgVHVwbGU6IDE0LFxuICBJbmRleGVkOiAxNSxcbiAgT3BlcmF0b3I6IDE2LFxuXG4gIFVua25vd246IDE3LFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUeXBlS2luZDtcbiIsInZhciAkX18wPSAgICByZXF1aXJlKCcuLi8uLi8nKSxTZXE9JF9fMC5TZXE7XG4vLyBOb3RlOiBpbnRlbnRpb25hbGx5IHVzaW5nIHJhdyBkZWZzLCBub3QgZ2V0VHlwZURlZnMgdG8gYXZvaWQgY2lyY3VsYXIgcmVmLlxudmFyIGRlZnMgPSByZXF1aXJlKCcuLi9nZW5lcmF0ZWQvaW1tdXRhYmxlLmQuanNvbicpO1xuXG5mdW5jdGlvbiBjb2xsZWN0TWVtYmVyR3JvdXBzKGludGVyZmFjZURlZiwgb3B0aW9ucykge1xuICB2YXIgbWVtYmVycyA9IHt9O1xuXG4gIGlmIChpbnRlcmZhY2VEZWYpIHtcbiAgICBjb2xsZWN0RnJvbURlZihpbnRlcmZhY2VEZWYpO1xuICB9XG5cbiAgdmFyIGdyb3VwcyA9IHsgJyc6IFtdIH07XG5cbiAgaWYgKG9wdGlvbnMuc2hvd0luR3JvdXBzKSB7XG4gICAgU2VxKG1lbWJlcnMpLmZvckVhY2goZnVuY3Rpb24obWVtYmVyKSAge1xuICAgICAgKGdyb3Vwc1ttZW1iZXIuZ3JvdXBdIHx8IChncm91cHNbbWVtYmVyLmdyb3VwXSA9IFtdKSkucHVzaChtZW1iZXIpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGdyb3Vwc1snJ10gPSBTZXEobWVtYmVycylcbiAgICAgIC5zb3J0QnkoZnVuY3Rpb24obWVtYmVyKSAge3JldHVybiBtZW1iZXIubWVtYmVyTmFtZTt9KVxuICAgICAgLnRvQXJyYXkoKTtcbiAgfVxuXG4gIGlmICghb3B0aW9ucy5zaG93SW5oZXJpdGVkKSB7XG4gICAgZ3JvdXBzID0gU2VxKGdyb3VwcylcbiAgICAgIC5tYXAoZnVuY3Rpb24obWVtYmVycykgIHtyZXR1cm4gbWVtYmVycy5maWx0ZXIoZnVuY3Rpb24obWVtYmVyKSAge3JldHVybiAhbWVtYmVyLmluaGVyaXRlZDt9KTt9KVxuICAgICAgLnRvT2JqZWN0KCk7XG4gIH1cblxuICByZXR1cm4gZ3JvdXBzO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3RGcm9tRGVmKGRlZiwgbmFtZSkge1xuICAgIGRlZi5ncm91cHMgJiZcbiAgICAgIGRlZi5ncm91cHMuZm9yRWFjaChmdW5jdGlvbihnKSAge1xuICAgICAgICBTZXEoZy5tZW1iZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG1lbWJlckRlZiwgbWVtYmVyTmFtZSkgIHtcbiAgICAgICAgICBjb2xsZWN0TWVtYmVyKGcudGl0bGUgfHwgJycsIG1lbWJlck5hbWUsIG1lbWJlckRlZik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICBkZWYuZXh0ZW5kcyAmJlxuICAgICAgZGVmLmV4dGVuZHMuZm9yRWFjaChmdW5jdGlvbihlKSAge1xuICAgICAgICB2YXIgc3VwZXJNb2R1bGUgPSBkZWZzLkltbXV0YWJsZTtcbiAgICAgICAgZS5uYW1lLnNwbGl0KCcuJykuZm9yRWFjaChmdW5jdGlvbihwYXJ0KSAge1xuICAgICAgICAgIHN1cGVyTW9kdWxlID1cbiAgICAgICAgICAgIHN1cGVyTW9kdWxlICYmIHN1cGVyTW9kdWxlLm1vZHVsZSAmJiBzdXBlck1vZHVsZS5tb2R1bGVbcGFydF07XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc3VwZXJJbnRlcmZhY2UgPSBzdXBlck1vZHVsZSAmJiBzdXBlck1vZHVsZS5pbnRlcmZhY2U7XG4gICAgICAgIGlmIChzdXBlckludGVyZmFjZSkge1xuICAgICAgICAgIGNvbGxlY3RGcm9tRGVmKHN1cGVySW50ZXJmYWNlLCBlLm5hbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGNvbGxlY3RNZW1iZXIoZ3JvdXAsIG1lbWJlck5hbWUsIG1lbWJlckRlZikge1xuICAgICAgdmFyIG1lbWJlciA9IG1lbWJlcnNbbWVtYmVyTmFtZV07XG4gICAgICBpZiAobWVtYmVyKSB7XG4gICAgICAgIGlmICghbWVtYmVyLmluaGVyaXRlZCkge1xuICAgICAgICAgIG1lbWJlci5vdmVycmlkZXMgPSB7IG5hbWU6bmFtZSwgZGVmOmRlZiwgbWVtYmVyRGVmOm1lbWJlckRlZiB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWVtYmVyLmdyb3VwICYmIGdyb3VwKSB7XG4gICAgICAgICAgbWVtYmVyLmdyb3VwID0gZ3JvdXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lbWJlciA9IHtcbiAgICAgICAgICBncm91cDpncm91cCxcbiAgICAgICAgICBtZW1iZXJOYW1lOiBtZW1iZXJOYW1lLnN1YnN0cigxKSxcbiAgICAgICAgICBtZW1iZXJEZWY6bWVtYmVyRGVmLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZGVmICE9PSBpbnRlcmZhY2VEZWYpIHtcbiAgICAgICAgICBtZW1iZXIuaW5oZXJpdGVkID0geyBuYW1lOm5hbWUsIGRlZjpkZWYgfTtcbiAgICAgICAgfVxuICAgICAgICBtZW1iZXJzW21lbWJlck5hbWVdID0gbWVtYmVyO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbGxlY3RNZW1iZXJHcm91cHM7XG4iLCJ2YXIgbWFya2Rvd25Eb2NzID0gcmVxdWlyZSgnLi9tYXJrZG93bkRvY3MnKTtcbnZhciBkZWZzID0gcmVxdWlyZSgnLi4vZ2VuZXJhdGVkL2ltbXV0YWJsZS5kLmpzb24nKTtcblxubWFya2Rvd25Eb2NzKGRlZnMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZnM7XG4iLCJ2YXIgbWFya2VkID0gcmVxdWlyZSgnbWFya2VkJyk7XG52YXIgJF9fMD0gICAgcmVxdWlyZSgnLi4vLi4vJyksU2VxPSRfXzAuU2VxO1xudmFyIHByaXNtID0gcmVxdWlyZSgnLi9wcmlzbScpO1xudmFyIGNvbGxlY3RNZW1iZXJHcm91cHMgPSByZXF1aXJlKCcuL2NvbGxlY3RNZW1iZXJHcm91cHMnKTtcbi8vIE5vdGU6IGludGVudGlvbmFsbHkgdXNpbmcgcmF3IGRlZnMsIG5vdCBnZXRUeXBlRGVmcyB0byBhdm9pZCBjaXJjdWxhciByZWYuXG52YXIgZGVmcyA9IHJlcXVpcmUoJy4uL2dlbmVyYXRlZC9pbW11dGFibGUuZC5qc29uJyk7XG5cbmZ1bmN0aW9uIGNvbGxlY3RBbGxNZW1iZXJzRm9yQWxsVHlwZXMoZGVmcykge1xuICB2YXIgYWxsTWVtYmVycyA9IG5ldyBXZWFrTWFwKCk7XG4gIF9jb2xsZWN0QWxsTWVtYmVyc0ZvckFsbFR5cGVzKGRlZnMpO1xuICByZXR1cm4gYWxsTWVtYmVycztcbiAgZnVuY3Rpb24gX2NvbGxlY3RBbGxNZW1iZXJzRm9yQWxsVHlwZXMoZGVmcykge1xuICAgIFNlcShkZWZzKS5mb3JFYWNoKGZ1bmN0aW9uKGRlZikgIHtcbiAgICAgIGlmIChkZWYuaW50ZXJmYWNlKSB7XG4gICAgICAgIHZhciBncm91cHMgPSBjb2xsZWN0TWVtYmVyR3JvdXBzKGRlZi5pbnRlcmZhY2UsIHtcbiAgICAgICAgICBzaG93SW5oZXJpdGVkOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgYWxsTWVtYmVycy5zZXQoXG4gICAgICAgICAgZGVmLmludGVyZmFjZSxcbiAgICAgICAgICBTZXEuS2V5ZWQoXG4gICAgICAgICAgICBncm91cHNbJyddLm1hcChmdW5jdGlvbihtZW1iZXIpICB7cmV0dXJuIFttZW1iZXIubWVtYmVyTmFtZSwgbWVtYmVyLm1lbWJlckRlZl07fSlcbiAgICAgICAgICApLnRvT2JqZWN0KClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWYubW9kdWxlKSB7XG4gICAgICAgIF9jb2xsZWN0QWxsTWVtYmVyc0ZvckFsbFR5cGVzKGRlZi5tb2R1bGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhbGxNZW1iZXJzO1xuICB9XG59XG5cbnZhciBhbGxNZW1iZXJzID0gY29sbGVjdEFsbE1lbWJlcnNGb3JBbGxUeXBlcyhkZWZzKTtcblxuLy8gZnVuY3Rpb25zIGNvbWUgYmVmb3JlIGtleXdvcmRzXG5wcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ2tleXdvcmQnLCB7XG4gIHZhcjogL1xcYih0aGlzKVxcYi9nLFxuICAnYmxvY2sta2V5d29yZCc6IC9cXGIoaWZ8ZWxzZXx3aGlsZXxmb3J8ZnVuY3Rpb24pXFxiL2csXG4gIHByaW1pdGl2ZTogL1xcYih0cnVlfGZhbHNlfG51bGx8dW5kZWZpbmVkKVxcYi9nLFxuICBmdW5jdGlvbjogcHJpc20ubGFuZ3VhZ2VzLmZ1bmN0aW9uLFxufSk7XG5cbnByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCB7XG4gIHF1YWxpZmllcjogL1xcYltBLVpdW2EtejAtOV9dKy9nLFxufSk7XG5cbm1hcmtlZC5zZXRPcHRpb25zKHtcbiAgeGh0bWw6IHRydWUsXG4gIGhpZ2hsaWdodDogZnVuY3Rpb24oY29kZSkgIHtyZXR1cm4gcHJpc20uaGlnaGxpZ2h0KGNvZGUsIHByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0KTt9LFxufSk7XG5cbnZhciByZW5kZXJlciA9IG5ldyBtYXJrZWQuUmVuZGVyZXIoKTtcblxuY29uc3QgcnVua2l0UmVnRXhwID0gL148IS0tXFxzKnJ1bmtpdDphY3RpdmF0ZSgoLnxcXG4pKiktLT4oLnxcXG4pKiQvO1xuY29uc3QgcnVua2l0Q29udGV4dCA9IHsgb3B0aW9uczogJ3t9JywgYWN0aXZhdGVkOiBmYWxzZSB9O1xuXG5yZW5kZXJlci5odG1sID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgY29uc3QgcmVzdWx0ID0gcnVua2l0UmVnRXhwLmV4ZWModGV4dCk7XG5cbiAgaWYgKCFyZXN1bHQpIHJldHVybiB0ZXh0O1xuXG4gIHJ1bmtpdENvbnRleHQuYWN0aXZhdGVkID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICBydW5raXRDb250ZXh0Lm9wdGlvbnMgPSByZXN1bHRbMV0gPyBKU09OLnBhcnNlKHJlc3VsdFsxXSkgOiB7fTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJ1bmtpdENvbnRleHQub3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB0ZXh0O1xufTtcblxucmVuZGVyZXIuY29kZSA9IGZ1bmN0aW9uIChjb2RlLCBsYW5nLCBlc2NhcGVkKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgdmFyIG91dCA9IHRoaXMub3B0aW9ucy5oaWdobGlnaHQoY29kZSwgbGFuZyk7XG4gICAgaWYgKG91dCAhPSBudWxsICYmIG91dCAhPT0gY29kZSkge1xuICAgICAgZXNjYXBlZCA9IHRydWU7XG4gICAgICBjb2RlID0gb3V0O1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJ1bkl0QnV0dG9uID0gcnVua2l0Q29udGV4dC5hY3RpdmF0ZWRcbiAgICA/ICc8YSBjbGFzcz1cInRyeS1pdFwiIGRhdGEtb3B0aW9ucz1cIicgK1xuICAgICAgZXNjYXBlKEpTT04uc3RyaW5naWZ5KHJ1bmtpdENvbnRleHQub3B0aW9ucykpICtcbiAgICAgICdcIiBvbkNsaWNrPVwicnVuSXQodGhpcylcIj5ydW4gaXQ8L2E+J1xuICAgIDogJyc7XG5cbiAgcnVua2l0Q29udGV4dC5hY3RpdmF0ZWQgPSBmYWxzZTtcbiAgcnVua2l0Q29udGV4dC5vcHRpb25zID0gJ3t9JztcblxuICByZXR1cm4gKFxuICAgICc8Y29kZSBjbGFzcz1cImNvZGVCbG9ja1wiPicgK1xuICAgIChlc2NhcGVkID8gY29kZSA6IGVzY2FwZUNvZGUoY29kZSwgdHJ1ZSkpICtcbiAgICBydW5JdEJ1dHRvbiArXG4gICAgJzwvY29kZT4nXG4gICk7XG59O1xuXG52YXIgTUVUSE9EX1JYID0gL14oXFx3KykoPzpbIy5dKFxcdyspKT8oPzpcXChcXCkpPyQvO1xudmFyIFBBUkFNX1JYID0gL15cXHcrJC87XG52YXIgTUROX1RZUEVTID0ge1xuICBBcnJheTogdHJ1ZSxcbiAgT2JqZWN0OiB0cnVlLFxuICBKU09OOiB0cnVlLFxufTtcbnZhciBNRE5fQkFTRV9VUkwgPVxuICAnaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvJztcblxucmVuZGVyZXIuY29kZXNwYW4gPSBmdW5jdGlvbiAodGV4dCkge1xuICByZXR1cm4gJzxjb2RlPicgKyBkZWNvcmF0ZUNvZGVTcGFuKHRleHQsIHRoaXMub3B0aW9ucykgKyAnPC9jb2RlPic7XG59O1xuXG5mdW5jdGlvbiBkZWNvcmF0ZUNvZGVTcGFuKHRleHQsIG9wdGlvbnMpIHtcbiAgdmFyIGNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQ7XG5cbiAgaWYgKFxuICAgIGNvbnRleHQuc2lnbmF0dXJlcyAmJlxuICAgIFBBUkFNX1JYLnRlc3QodGV4dCkgJiZcbiAgICBjb250ZXh0LnNpZ25hdHVyZXMuc29tZShcbiAgICAgIGZ1bmN0aW9uKHNpZykgIHtyZXR1cm4gc2lnLnBhcmFtcyAmJiBzaWcucGFyYW1zLnNvbWUoZnVuY3Rpb24ocGFyYW0pICB7cmV0dXJuIHBhcmFtLm5hbWUgPT09IHRleHQ7fSk7fVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuICc8c3BhbiBjbGFzcz1cInQgcGFyYW1cIj4nICsgdGV4dCArICc8L3NwYW4+JztcbiAgfVxuXG4gIHZhciBtZXRob2QgPSBNRVRIT0RfUlguZXhlYyh0ZXh0KTtcbiAgaWYgKG1ldGhvZCkge1xuICAgIG1ldGhvZCA9IG1ldGhvZC5zbGljZSgxKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgaWYgKE1ETl9UWVBFU1ttZXRob2RbMF1dKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAnPGEgaHJlZj1cIicgKyBNRE5fQkFTRV9VUkwgKyBtZXRob2Quam9pbignLycpICsgJ1wiPicgKyB0ZXh0ICsgJzwvYT4nXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBjb250ZXh0LnR5cGVQYXRoICYmXG4gICAgICAhYXJyRW5kc1dpdGgoY29udGV4dC50eXBlUGF0aCwgbWV0aG9kKSAmJlxuICAgICAgIWFyckVuZHNXaXRoKGNvbnRleHQudHlwZVBhdGguc2xpY2UoMCwgLTEpLCBtZXRob2QpXG4gICAgKSB7XG4gICAgICB2YXIgcGF0aCA9IGZpbmRQYXRoKGNvbnRleHQsIG1ldGhvZCk7XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICB2YXIgcmVsUGF0aCA9IGNvbnRleHQucmVsUGF0aCB8fCAnJztcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAnPGEgdGFyZ2V0PVwiX3NlbGZcIiBocmVmPVwiJyArXG4gICAgICAgICAgcmVsUGF0aCArXG4gICAgICAgICAgJyMvJyArXG4gICAgICAgICAgcGF0aC5zbGljZSgxKS5qb2luKCcvJykgK1xuICAgICAgICAgICdcIj4nICtcbiAgICAgICAgICB0ZXh0ICtcbiAgICAgICAgICAnPC9hPidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5oaWdobGlnaHQodW5lc2NhcGVDb2RlKHRleHQpLCBwcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCk7XG4gIH1cblxuICByZXR1cm4gdGV4dDtcbn1cblxuZnVuY3Rpb24gYXJyRW5kc1dpdGgoYXJyMSwgYXJyMikge1xuICBmb3IgKHZhciBpaSA9IDE7IGlpIDw9IGFycjIubGVuZ3RoOyBpaSsrKSB7XG4gICAgaWYgKGFycjJbYXJyMi5sZW5ndGggLSBpaV0gIT09IGFycjFbYXJyMS5sZW5ndGggLSBpaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGZpbmRQYXRoKGNvbnRleHQsIHNlYXJjaCkge1xuICB2YXIgcmVsYXRpdmUgPSBjb250ZXh0LnR5cGVQYXRoO1xuXG4gIGZvciAodmFyIGlpID0gMDsgaWkgPD0gcmVsYXRpdmUubGVuZ3RoOyBpaSsrKSB7XG4gICAgdmFyIHBhdGggPSByZWxhdGl2ZS5zbGljZSgwLCByZWxhdGl2ZS5sZW5ndGggLSBpaSkuY29uY2F0KHNlYXJjaCk7XG4gICAgaWYgKFxuICAgICAgcGF0aC5yZWR1Y2UoXG4gICAgICAgIGZ1bmN0aW9uKGRlZiwgbmFtZSkgXG4gICAgICAgICAge3JldHVybiBkZWYgJiZcbiAgICAgICAgICAoKGRlZi5tb2R1bGUgJiYgZGVmLm1vZHVsZVtuYW1lXSkgfHxcbiAgICAgICAgICAgIChkZWYuaW50ZXJmYWNlICYmXG4gICAgICAgICAgICAgIGFsbE1lbWJlcnMgJiZcbiAgICAgICAgICAgICAgYWxsTWVtYmVycy5nZXQoZGVmLmludGVyZmFjZSlbbmFtZV0pIHx8XG4gICAgICAgICAgICB1bmRlZmluZWQpO30sXG4gICAgICAgIHsgbW9kdWxlOiBkZWZzIH1cbiAgICAgIClcbiAgICApIHtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBlc2NhcGVDb2RlKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGVcbiAgICAucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgIC5yZXBsYWNlKC8nL2csICcmIzM5OycpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZUNvZGUoY29kZSkge1xuICByZXR1cm4gY29kZVxuICAgIC5yZXBsYWNlKC8mbHQ7L2csICc8JylcbiAgICAucmVwbGFjZSgvJmd0Oy9nLCAnPicpXG4gICAgLnJlcGxhY2UoLyZxdW90Oy9nLCAnXCInKVxuICAgIC5yZXBsYWNlKC8mIzM5Oy9nLCBcIidcIilcbiAgICAucmVwbGFjZSgvJmFtcDsvZywgJyYnKTtcbn1cblxuZnVuY3Rpb24gbWFya2Rvd24oY29udGVudCwgY29udGV4dCkge1xuICBjb250ZXh0IHx8IChjb250ZXh0ID0ge30pO1xuICByZXR1cm4gY29udGVudCA/IG1hcmtlZChjb250ZW50LCB7IHJlbmRlcmVyOnJlbmRlcmVyLCBjb250ZXh0OmNvbnRleHQgfSkgOiBjb250ZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcmtkb3duO1xuIiwidmFyICRfXzA9ICAgIHJlcXVpcmUoJy4uLy4uLycpLFNlcT0kX18wLlNlcTtcbnZhciBtYXJrZG93biA9IHJlcXVpcmUoJy4vbWFya2Rvd24nKTtcblxuZnVuY3Rpb24gbWFya2Rvd25Eb2NzKGRlZnMpIHtcbiAgbWFya2Rvd25UeXBlcyhkZWZzLCBbXSk7XG5cbiAgZnVuY3Rpb24gbWFya2Rvd25UeXBlcyh0eXBlRGVmcywgcGF0aCkge1xuICAgIFNlcSh0eXBlRGVmcykuZm9yRWFjaChmdW5jdGlvbih0eXBlRGVmLCB0eXBlTmFtZSkgIHtcbiAgICAgIHZhciB0eXBlUGF0aCA9IHBhdGguY29uY2F0KHR5cGVOYW1lKTtcbiAgICAgIG1hcmtkb3duRG9jKHR5cGVEZWYuZG9jLCB7IHR5cGVQYXRoOnR5cGVQYXRoIH0pO1xuICAgICAgdHlwZURlZi5jYWxsICYmXG4gICAgICAgIG1hcmtkb3duRG9jKHR5cGVEZWYuY2FsbC5kb2MsIHtcbiAgICAgICAgICB0eXBlUGF0aDp0eXBlUGF0aCxcbiAgICAgICAgICBzaWduYXR1cmVzOiB0eXBlRGVmLmNhbGwuc2lnbmF0dXJlcyxcbiAgICAgICAgfSk7XG4gICAgICBpZiAodHlwZURlZi5pbnRlcmZhY2UpIHtcbiAgICAgICAgbWFya2Rvd25Eb2ModHlwZURlZi5pbnRlcmZhY2UuZG9jLCB7IGRlZnM6ZGVmcywgdHlwZVBhdGg6dHlwZVBhdGggfSk7XG4gICAgICAgIFNlcSh0eXBlRGVmLmludGVyZmFjZS5ncm91cHMpLmZvckVhY2goZnVuY3Rpb24oZ3JvdXApIFxuICAgICAgICAgIHtyZXR1cm4gU2VxKGdyb3VwLm1lbWJlcnMpLmZvckVhY2goZnVuY3Rpb24obWVtYmVyLCBtZW1iZXJOYW1lKSBcbiAgICAgICAgICAgIHtyZXR1cm4gbWFya2Rvd25Eb2MobWVtYmVyLmRvYywge1xuICAgICAgICAgICAgICB0eXBlUGF0aDogdHlwZVBhdGguY29uY2F0KG1lbWJlck5hbWUuc2xpY2UoMSkpLFxuICAgICAgICAgICAgICBzaWduYXR1cmVzOiBtZW1iZXIuc2lnbmF0dXJlcyxcbiAgICAgICAgICAgIH0pO31cbiAgICAgICAgICApO31cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHR5cGVEZWYubW9kdWxlICYmIG1hcmtkb3duVHlwZXModHlwZURlZi5tb2R1bGUsIHR5cGVQYXRoKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrZG93bkRvYyhkb2MsIGNvbnRleHQpIHtcbiAgaWYgKCFkb2MpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZG9jLnN5bm9wc2lzICYmIChkb2Muc3lub3BzaXMgPSBtYXJrZG93bihkb2Muc3lub3BzaXMsIGNvbnRleHQpKTtcbiAgZG9jLmRlc2NyaXB0aW9uICYmIChkb2MuZGVzY3JpcHRpb24gPSBtYXJrZG93bihkb2MuZGVzY3JpcHRpb24sIGNvbnRleHQpKTtcbiAgZG9jLm5vdGVzICYmXG4gICAgZG9jLm5vdGVzLmZvckVhY2goZnVuY3Rpb24obm90ZSkgIHtcbiAgICAgIGlmIChub3RlLm5hbWUgIT09ICdhbGlhcycpIHtcbiAgICAgICAgbm90ZS5ib2R5ID0gbWFya2Rvd24obm90ZS5ib2R5LCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXJrZG93bkRvY3M7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLWNvcmUuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuc2VsZiA9XG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgPyB3aW5kb3cgLy8gaWYgaW4gYnJvd3NlclxuICAgIDogdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlXG4gICAgPyBzZWxmIC8vIGlmIGluIHdvcmtlclxuICAgIDoge307IC8vIGlmIGluIG5vZGUganNcblxuLyoqXG4gKiBQcmlzbTogTGlnaHR3ZWlnaHQsIHJvYnVzdCwgZWxlZ2FudCBzeW50YXggaGlnaGxpZ2h0aW5nXG4gKiBNSVQgbGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC9cbiAqIEBhdXRob3IgTGVhIFZlcm91IGh0dHA6Ly9sZWEudmVyb3UubWVcbiAqL1xuXG52YXIgUHJpc20gPSAoZnVuY3Rpb24gKCkge1xuICAvLyBQcml2YXRlIGhlbHBlciB2YXJzXG4gIHZhciBsYW5nID0gL1xcYmxhbmcoPzp1YWdlKT8tKD8hXFwqKShcXHcrKVxcYi9pO1xuXG4gIHZhciBfID0gKHNlbGYuUHJpc20gPSB7XG4gICAgdXRpbDoge1xuICAgICAgZW5jb2RlOiBmdW5jdGlvbiAodG9rZW5zKSB7XG4gICAgICAgIGlmICh0b2tlbnMgaW5zdGFuY2VvZiBUb2tlbikge1xuICAgICAgICAgIHJldHVybiBuZXcgVG9rZW4oXG4gICAgICAgICAgICB0b2tlbnMudHlwZSxcbiAgICAgICAgICAgIF8udXRpbC5lbmNvZGUodG9rZW5zLmNvbnRlbnQpLFxuICAgICAgICAgICAgdG9rZW5zLmFsaWFzXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChfLnV0aWwudHlwZSh0b2tlbnMpID09PSAnQXJyYXknKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2Vucy5tYXAoXy51dGlsLmVuY29kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRva2Vuc1xuICAgICAgICAgICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHUwMGEwL2csICcgJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHR5cGU6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykubWF0Y2goL1xcW29iamVjdCAoXFx3KylcXF0vKVsxXTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIERlZXAgY2xvbmUgYSBsYW5ndWFnZSBkZWZpbml0aW9uIChlLmcuIHRvIGV4dGVuZCBpdClcbiAgICAgIGNsb25lOiBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgdHlwZSA9IF8udXRpbC50eXBlKG8pO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ09iamVjdCc6XG4gICAgICAgICAgICB2YXIgY2xvbmUgPSB7fTtcblxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG8pIHtcbiAgICAgICAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNsb25lW2tleV0gPSBfLnV0aWwuY2xvbmUob1trZXldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cbiAgICAgICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgICAgICByZXR1cm4gby5zbGljZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9LFxuICAgIH0sXG5cbiAgICBsYW5ndWFnZXM6IHtcbiAgICAgIGV4dGVuZDogZnVuY3Rpb24gKGlkLCByZWRlZikge1xuICAgICAgICB2YXIgbGFuZyA9IF8udXRpbC5jbG9uZShfLmxhbmd1YWdlc1tpZF0pO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiByZWRlZikge1xuICAgICAgICAgIGxhbmdba2V5XSA9IHJlZGVmW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGFuZztcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogSW5zZXJ0IGEgdG9rZW4gYmVmb3JlIGFub3RoZXIgdG9rZW4gaW4gYSBsYW5ndWFnZSBsaXRlcmFsXG4gICAgICAgKiBBcyB0aGlzIG5lZWRzIHRvIHJlY3JlYXRlIHRoZSBvYmplY3QgKHdlIGNhbm5vdCBhY3R1YWxseSBpbnNlcnQgYmVmb3JlIGtleXMgaW4gb2JqZWN0IGxpdGVyYWxzKSxcbiAgICAgICAqIHdlIGNhbm5vdCBqdXN0IHByb3ZpZGUgYW4gb2JqZWN0LCB3ZSBuZWVkIGFub2JqZWN0IGFuZCBhIGtleS5cbiAgICAgICAqIEBwYXJhbSBpbnNpZGUgVGhlIGtleSAob3IgbGFuZ3VhZ2UgaWQpIG9mIHRoZSBwYXJlbnRcbiAgICAgICAqIEBwYXJhbSBiZWZvcmUgVGhlIGtleSB0byBpbnNlcnQgYmVmb3JlLiBJZiBub3QgcHJvdmlkZWQsIHRoZSBmdW5jdGlvbiBhcHBlbmRzIGluc3RlYWQuXG4gICAgICAgKiBAcGFyYW0gaW5zZXJ0IE9iamVjdCB3aXRoIHRoZSBrZXkvdmFsdWUgcGFpcnMgdG8gaW5zZXJ0XG4gICAgICAgKiBAcGFyYW0gcm9vdCBUaGUgb2JqZWN0IHRoYXQgY29udGFpbnMgYGluc2lkZWAuIElmIGVxdWFsIHRvIFByaXNtLmxhbmd1YWdlcywgaXQgY2FuIGJlIG9taXR0ZWQuXG4gICAgICAgKi9cbiAgICAgIGluc2VydEJlZm9yZTogZnVuY3Rpb24gKGluc2lkZSwgYmVmb3JlLCBpbnNlcnQsIHJvb3QpIHtcbiAgICAgICAgcm9vdCA9IHJvb3QgfHwgXy5sYW5ndWFnZXM7XG4gICAgICAgIHZhciBncmFtbWFyID0gcm9vdFtpbnNpZGVdO1xuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICBpbnNlcnQgPSBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgICBmb3IgKHZhciBuZXdUb2tlbiBpbiBpbnNlcnQpIHtcbiAgICAgICAgICAgIGlmIChpbnNlcnQuaGFzT3duUHJvcGVydHkobmV3VG9rZW4pKSB7XG4gICAgICAgICAgICAgIGdyYW1tYXJbbmV3VG9rZW5dID0gaW5zZXJ0W25ld1Rva2VuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZ3JhbW1hcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXQgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciB0b2tlbiBpbiBncmFtbWFyKSB7XG4gICAgICAgICAgaWYgKGdyYW1tYXIuaGFzT3duUHJvcGVydHkodG9rZW4pKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4gPT0gYmVmb3JlKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIG5ld1Rva2VuIGluIGluc2VydCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnNlcnQuaGFzT3duUHJvcGVydHkobmV3VG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICByZXRbbmV3VG9rZW5dID0gaW5zZXJ0W25ld1Rva2VuXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0W3Rva2VuXSA9IGdyYW1tYXJbdG9rZW5dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSByZWZlcmVuY2VzIGluIG90aGVyIGxhbmd1YWdlIGRlZmluaXRpb25zXG4gICAgICAgIF8ubGFuZ3VhZ2VzLkRGUyhfLmxhbmd1YWdlcywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPT09IHJvb3RbaW5zaWRlXSAmJiBrZXkgIT0gaW5zaWRlKSB7XG4gICAgICAgICAgICB0aGlzW2tleV0gPSByZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gKHJvb3RbaW5zaWRlXSA9IHJldCk7XG4gICAgICB9LFxuXG4gICAgICAvLyBUcmF2ZXJzZSBhIGxhbmd1YWdlIGRlZmluaXRpb24gd2l0aCBEZXB0aCBGaXJzdCBTZWFyY2hcbiAgICAgIERGUzogZnVuY3Rpb24gKG8sIGNhbGxiYWNrLCB0eXBlKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gbykge1xuICAgICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKG8sIGksIG9baV0sIHR5cGUgfHwgaSk7XG5cbiAgICAgICAgICAgIGlmIChfLnV0aWwudHlwZShvW2ldKSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgICAgXy5sYW5ndWFnZXMuREZTKG9baV0sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXy51dGlsLnR5cGUob1tpXSkgPT09ICdBcnJheScpIHtcbiAgICAgICAgICAgICAgXy5sYW5ndWFnZXMuREZTKG9baV0sIGNhbGxiYWNrLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSxcblxuICAgIGhpZ2hsaWdodEFsbDogZnVuY3Rpb24gKGFzeW5jLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgJ2NvZGVbY2xhc3MqPVwibGFuZ3VhZ2UtXCJdLCBbY2xhc3MqPVwibGFuZ3VhZ2UtXCJdIGNvZGUsIGNvZGVbY2xhc3MqPVwibGFuZy1cIl0sIFtjbGFzcyo9XCJsYW5nLVwiXSBjb2RlJ1xuICAgICAgKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGVsZW1lbnQ7IChlbGVtZW50ID0gZWxlbWVudHNbaSsrXSk7ICkge1xuICAgICAgICBfLmhpZ2hsaWdodEVsZW1lbnQoZWxlbWVudCwgYXN5bmMgPT09IHRydWUsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaGlnaGxpZ2h0RWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQsIGFzeW5jLCBjYWxsYmFjaykge1xuICAgICAgLy8gRmluZCBsYW5ndWFnZVxuICAgICAgdmFyIGxhbmd1YWdlLFxuICAgICAgICBncmFtbWFyLFxuICAgICAgICBwYXJlbnQgPSBlbGVtZW50O1xuXG4gICAgICB3aGlsZSAocGFyZW50ICYmICFsYW5nLnRlc3QocGFyZW50LmNsYXNzTmFtZSkpIHtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgbGFuZ3VhZ2UgPSAocGFyZW50LmNsYXNzTmFtZS5tYXRjaChsYW5nKSB8fCBbLCAnJ10pWzFdO1xuICAgICAgICBncmFtbWFyID0gXy5sYW5ndWFnZXNbbGFuZ3VhZ2VdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWdyYW1tYXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgbGFuZ3VhZ2Ugb24gdGhlIGVsZW1lbnQsIGlmIG5vdCBwcmVzZW50XG4gICAgICBlbGVtZW50LmNsYXNzTmFtZSA9XG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UobGFuZywgJycpLnJlcGxhY2UoL1xccysvZywgJyAnKSArXG4gICAgICAgICcgbGFuZ3VhZ2UtJyArXG4gICAgICAgIGxhbmd1YWdlO1xuXG4gICAgICAvLyBTZXQgbGFuZ3VhZ2Ugb24gdGhlIHBhcmVudCwgZm9yIHN0eWxpbmdcbiAgICAgIHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblxuICAgICAgaWYgKC9wcmUvaS50ZXN0KHBhcmVudC5ub2RlTmFtZSkpIHtcbiAgICAgICAgcGFyZW50LmNsYXNzTmFtZSA9XG4gICAgICAgICAgcGFyZW50LmNsYXNzTmFtZS5yZXBsYWNlKGxhbmcsICcnKS5yZXBsYWNlKC9cXHMrL2csICcgJykgK1xuICAgICAgICAgICcgbGFuZ3VhZ2UtJyArXG4gICAgICAgICAgbGFuZ3VhZ2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb2RlID0gZWxlbWVudC50ZXh0Q29udGVudDtcblxuICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGVudiA9IHtcbiAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgbGFuZ3VhZ2U6IGxhbmd1YWdlLFxuICAgICAgICBncmFtbWFyOiBncmFtbWFyLFxuICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgfTtcblxuICAgICAgXy5ob29rcy5ydW4oJ2JlZm9yZS1oaWdobGlnaHQnLCBlbnYpO1xuXG4gICAgICBpZiAoYXN5bmMgJiYgc2VsZi5Xb3JrZXIpIHtcbiAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIoXy5maWxlbmFtZSk7XG5cbiAgICAgICAgd29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICBlbnYuaGlnaGxpZ2h0ZWRDb2RlID0gVG9rZW4uc3RyaW5naWZ5KEpTT04ucGFyc2UoZXZ0LmRhdGEpLCBsYW5ndWFnZSk7XG5cbiAgICAgICAgICBfLmhvb2tzLnJ1bignYmVmb3JlLWluc2VydCcsIGVudik7XG5cbiAgICAgICAgICBlbnYuZWxlbWVudC5pbm5lckhUTUwgPSBlbnYuaGlnaGxpZ2h0ZWRDb2RlO1xuXG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbChlbnYuZWxlbWVudCk7XG4gICAgICAgICAgXy5ob29rcy5ydW4oJ2FmdGVyLWhpZ2hsaWdodCcsIGVudik7XG4gICAgICAgIH07XG5cbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKFxuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGxhbmd1YWdlOiBlbnYubGFuZ3VhZ2UsXG4gICAgICAgICAgICBjb2RlOiBlbnYuY29kZSxcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW52LmhpZ2hsaWdodGVkQ29kZSA9IF8uaGlnaGxpZ2h0KGVudi5jb2RlLCBlbnYuZ3JhbW1hciwgZW52Lmxhbmd1YWdlKTtcblxuICAgICAgICBfLmhvb2tzLnJ1bignYmVmb3JlLWluc2VydCcsIGVudik7XG5cbiAgICAgICAgZW52LmVsZW1lbnQuaW5uZXJIVE1MID0gZW52LmhpZ2hsaWdodGVkQ29kZTtcblxuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGVsZW1lbnQpO1xuXG4gICAgICAgIF8uaG9va3MucnVuKCdhZnRlci1oaWdobGlnaHQnLCBlbnYpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBoaWdobGlnaHQ6IGZ1bmN0aW9uICh0ZXh0LCBncmFtbWFyLCBsYW5ndWFnZSkge1xuICAgICAgdmFyIHRva2VucyA9IF8udG9rZW5pemUodGV4dCwgZ3JhbW1hcik7XG4gICAgICByZXR1cm4gVG9rZW4uc3RyaW5naWZ5KF8udXRpbC5lbmNvZGUodG9rZW5zKSwgbGFuZ3VhZ2UpO1xuICAgIH0sXG5cbiAgICB0b2tlbml6ZTogZnVuY3Rpb24gKHRleHQsIGdyYW1tYXIsIGxhbmd1YWdlKSB7XG4gICAgICB2YXIgVG9rZW4gPSBfLlRva2VuO1xuXG4gICAgICB2YXIgc3RyYXJyID0gW3RleHRdO1xuXG4gICAgICB2YXIgcmVzdCA9IGdyYW1tYXIucmVzdDtcblxuICAgICAgaWYgKHJlc3QpIHtcbiAgICAgICAgZm9yICh2YXIgdG9rZW4gaW4gcmVzdCkge1xuICAgICAgICAgIGdyYW1tYXJbdG9rZW5dID0gcmVzdFt0b2tlbl07XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgZ3JhbW1hci5yZXN0O1xuICAgICAgfVxuXG4gICAgICB0b2tlbmxvb3A6IGZvciAodmFyIHRva2VuIGluIGdyYW1tYXIpIHtcbiAgICAgICAgaWYgKCFncmFtbWFyLmhhc093blByb3BlcnR5KHRva2VuKSB8fCAhZ3JhbW1hclt0b2tlbl0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXR0ZXJucyA9IGdyYW1tYXJbdG9rZW5dO1xuICAgICAgICBwYXR0ZXJucyA9IF8udXRpbC50eXBlKHBhdHRlcm5zKSA9PT0gJ0FycmF5JyA/IHBhdHRlcm5zIDogW3BhdHRlcm5zXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhdHRlcm5zLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgdmFyIHBhdHRlcm4gPSBwYXR0ZXJuc1tqXSxcbiAgICAgICAgICAgIGluc2lkZSA9IHBhdHRlcm4uaW5zaWRlLFxuICAgICAgICAgICAgbG9va2JlaGluZCA9ICEhcGF0dGVybi5sb29rYmVoaW5kLFxuICAgICAgICAgICAgbG9va2JlaGluZExlbmd0aCA9IDAsXG4gICAgICAgICAgICBhbGlhcyA9IHBhdHRlcm4uYWxpYXM7XG5cbiAgICAgICAgICBwYXR0ZXJuID0gcGF0dGVybi5wYXR0ZXJuIHx8IHBhdHRlcm47XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gRG9u4oCZdCBjYWNoZSBsZW5ndGggYXMgaXQgY2hhbmdlcyBkdXJpbmcgdGhlIGxvb3BcblxuICAgICAgICAgICAgdmFyIHN0ciA9IHN0cmFycltpXTtcblxuICAgICAgICAgICAgaWYgKHN0cmFyci5sZW5ndGggPiB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgd2VudCB0ZXJyaWJseSB3cm9uZywgQUJPUlQsIEFCT1JUIVxuICAgICAgICAgICAgICBicmVhayB0b2tlbmxvb3A7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdHIgaW5zdGFuY2VvZiBUb2tlbikge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGF0dGVybi5sYXN0SW5kZXggPSAwO1xuXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc3RyKTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgIGlmIChsb29rYmVoaW5kKSB7XG4gICAgICAgICAgICAgICAgbG9va2JlaGluZExlbmd0aCA9IG1hdGNoWzFdLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBmcm9tID0gbWF0Y2guaW5kZXggLSAxICsgbG9va2JlaGluZExlbmd0aCxcbiAgICAgICAgICAgICAgICBtYXRjaCA9IG1hdGNoWzBdLnNsaWNlKGxvb2tiZWhpbmRMZW5ndGgpLFxuICAgICAgICAgICAgICAgIGxlbiA9IG1hdGNoLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB0byA9IGZyb20gKyBsZW4sXG4gICAgICAgICAgICAgICAgYmVmb3JlID0gc3RyLnNsaWNlKDAsIGZyb20gKyAxKSxcbiAgICAgICAgICAgICAgICBhZnRlciA9IHN0ci5zbGljZSh0byArIDEpO1xuXG4gICAgICAgICAgICAgIHZhciBhcmdzID0gW2ksIDFdO1xuXG4gICAgICAgICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goYmVmb3JlKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciB3cmFwcGVkID0gbmV3IFRva2VuKFxuICAgICAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgICAgIGluc2lkZSA/IF8udG9rZW5pemUobWF0Y2gsIGluc2lkZSkgOiBtYXRjaCxcbiAgICAgICAgICAgICAgICBhbGlhc1xuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIGFyZ3MucHVzaCh3cmFwcGVkKTtcblxuICAgICAgICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goYWZ0ZXIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5hcHBseShzdHJhcnIsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyYXJyO1xuICAgIH0sXG5cbiAgICBob29rczoge1xuICAgICAgYWxsOiB7fSxcblxuICAgICAgYWRkOiBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGhvb2tzID0gXy5ob29rcy5hbGw7XG5cbiAgICAgICAgaG9va3NbbmFtZV0gPSBob29rc1tuYW1lXSB8fCBbXTtcblxuICAgICAgICBob29rc1tuYW1lXS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgIH0sXG5cbiAgICAgIHJ1bjogZnVuY3Rpb24gKG5hbWUsIGVudikge1xuICAgICAgICB2YXIgY2FsbGJhY2tzID0gXy5ob29rcy5hbGxbbmFtZV07XG5cbiAgICAgICAgaWYgKCFjYWxsYmFja3MgfHwgIWNhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgY2FsbGJhY2s7IChjYWxsYmFjayA9IGNhbGxiYWNrc1tpKytdKTsgKSB7XG4gICAgICAgICAgY2FsbGJhY2soZW52KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9LFxuICB9KTtcblxuICB2YXIgVG9rZW4gPSAoXy5Ub2tlbiA9IGZ1bmN0aW9uICh0eXBlLCBjb250ZW50LCBhbGlhcykge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB0aGlzLmFsaWFzID0gYWxpYXM7XG4gIH0pO1xuXG4gIFRva2VuLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChvLCBsYW5ndWFnZSwgcGFyZW50KSB7XG4gICAgaWYgKHR5cGVvZiBvID09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbztcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHJldHVybiBvXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gVG9rZW4uc3RyaW5naWZ5KGVsZW1lbnQsIGxhbmd1YWdlLCBvKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oJycpO1xuICAgIH1cblxuICAgIHZhciBlbnYgPSB7XG4gICAgICB0eXBlOiBvLnR5cGUsXG4gICAgICBjb250ZW50OiBUb2tlbi5zdHJpbmdpZnkoby5jb250ZW50LCBsYW5ndWFnZSwgcGFyZW50KSxcbiAgICAgIHRhZzogJ3NwYW4nLFxuICAgICAgY2xhc3NlczogWyd0b2tlbicsIG8udHlwZV0sXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZSxcbiAgICAgIHBhcmVudDogcGFyZW50LFxuICAgIH07XG5cbiAgICBpZiAoZW52LnR5cGUgPT0gJ2NvbW1lbnQnKSB7XG4gICAgICBlbnYuYXR0cmlidXRlc1snc3BlbGxjaGVjayddID0gJ3RydWUnO1xuICAgIH1cblxuICAgIGlmIChvLmFsaWFzKSB7XG4gICAgICB2YXIgYWxpYXNlcyA9IF8udXRpbC50eXBlKG8uYWxpYXMpID09PSAnQXJyYXknID8gby5hbGlhcyA6IFtvLmFsaWFzXTtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGVudi5jbGFzc2VzLCBhbGlhc2VzKTtcbiAgICB9XG5cbiAgICBfLmhvb2tzLnJ1bignd3JhcCcsIGVudik7XG5cbiAgICB2YXIgYXR0cmlidXRlcyA9ICcnO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBlbnYuYXR0cmlidXRlcykge1xuICAgICAgYXR0cmlidXRlcyArPSBuYW1lICsgJz1cIicgKyAoZW52LmF0dHJpYnV0ZXNbbmFtZV0gfHwgJycpICsgJ1wiJztcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgJzwnICtcbiAgICAgIGVudi50YWcgK1xuICAgICAgJyBjbGFzcz1cIicgK1xuICAgICAgZW52LmNsYXNzZXMuam9pbignICcpICtcbiAgICAgICdcIiAnICtcbiAgICAgIGF0dHJpYnV0ZXMgK1xuICAgICAgJz4nICtcbiAgICAgIGVudi5jb250ZW50ICtcbiAgICAgICc8LycgK1xuICAgICAgZW52LnRhZyArXG4gICAgICAnPidcbiAgICApO1xuICB9O1xuXG4gIGlmICghc2VsZi5kb2N1bWVudCkge1xuICAgIGlmICghc2VsZi5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAvLyBpbiBOb2RlLmpzXG4gICAgICByZXR1cm4gc2VsZi5QcmlzbTtcbiAgICB9XG4gICAgLy8gSW4gd29ya2VyXG4gICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgJ21lc3NhZ2UnLFxuICAgICAgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IEpTT04ucGFyc2UoZXZ0LmRhdGEpLFxuICAgICAgICAgIGxhbmcgPSBtZXNzYWdlLmxhbmd1YWdlLFxuICAgICAgICAgIGNvZGUgPSBtZXNzYWdlLmNvZGU7XG5cbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZShcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShfLnV0aWwuZW5jb2RlKF8udG9rZW5pemUoY29kZSwgXy5sYW5ndWFnZXNbbGFuZ10pKSlcbiAgICAgICAgKTtcbiAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgfSxcbiAgICAgIGZhbHNlXG4gICAgKTtcblxuICAgIHJldHVybiBzZWxmLlByaXNtO1xuICB9XG5cbiAgLy8gR2V0IGN1cnJlbnQgc2NyaXB0IGFuZCBoaWdobGlnaHRcbiAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcblxuICBzY3JpcHQgPSBzY3JpcHRbc2NyaXB0Lmxlbmd0aCAtIDFdO1xuXG4gIGlmIChzY3JpcHQpIHtcbiAgICBfLmZpbGVuYW1lID0gc2NyaXB0LnNyYztcblxuICAgIGlmIChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyICYmICFzY3JpcHQuaGFzQXR0cmlidXRlKCdkYXRhLW1hbnVhbCcpKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgXy5oaWdobGlnaHRBbGwpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmLlByaXNtO1xufSkoKTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gUHJpc207XG59XG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tbWFya3VwLmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cblByaXNtLmxhbmd1YWdlcy5tYXJrdXAgPSB7XG4gIGNvbW1lbnQ6IC88IS0tW1xcd1xcV10qPy0tPi9nLFxuICBwcm9sb2c6IC88XFw/Lis/XFw/Pi8sXG4gIGRvY3R5cGU6IC88IURPQ1RZUEUuKz8+LyxcbiAgY2RhdGE6IC88IVxcW0NEQVRBXFxbW1xcd1xcV10qP11dPi9pLFxuICB0YWc6IHtcbiAgICBwYXR0ZXJuOlxuICAgICAgLzxcXC8/W1xcdzotXStcXHMqKD86XFxzK1tcXHc6LV0rKD86PSg/OihcInwnKShcXFxcP1tcXHdcXFddKSo/XFwxfFteXFxzJ1wiPj1dKykpP1xccyopKlxcLz8+L2dpLFxuICAgIGluc2lkZToge1xuICAgICAgdGFnOiB7XG4gICAgICAgIHBhdHRlcm46IC9ePFxcLz9bXFx3Oi1dKy9pLFxuICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICBwdW5jdHVhdGlvbjogL148XFwvPy8sXG4gICAgICAgICAgbmFtZXNwYWNlOiAvXltcXHctXSs/Oi8sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgJ2F0dHItdmFsdWUnOiB7XG4gICAgICAgIHBhdHRlcm46IC89KD86KCd8XCIpW1xcd1xcV10qPyhcXDEpfFteXFxzPl0rKS9naSxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgcHVuY3R1YXRpb246IC89fD58XCIvZyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBwdW5jdHVhdGlvbjogL1xcLz8+L2csXG4gICAgICAnYXR0ci1uYW1lJzoge1xuICAgICAgICBwYXR0ZXJuOiAvW1xcdzotXSsvZyxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgbmFtZXNwYWNlOiAvXltcXHctXSs/Oi8sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gIH0sXG4gIGVudGl0eTogL1xcJiM/W1xcZGEtel17MSw4fTsvZ2ksXG59O1xuXG4vLyBQbHVnaW4gdG8gbWFrZSBlbnRpdHkgdGl0bGUgc2hvdyB0aGUgcmVhbCBlbnRpdHksIGlkZWEgYnkgUm9tYW4gS29tYXJvdlxuUHJpc20uaG9va3MuYWRkKCd3cmFwJywgZnVuY3Rpb24gKGVudikge1xuICBpZiAoZW52LnR5cGUgPT09ICdlbnRpdHknKSB7XG4gICAgZW52LmF0dHJpYnV0ZXNbJ3RpdGxlJ10gPSBlbnYuY29udGVudC5yZXBsYWNlKC8mYW1wOy8sICcmJyk7XG4gIH1cbn0pO1xuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLWNzcy5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5QcmlzbS5sYW5ndWFnZXMuY3NzID0ge1xuICBjb21tZW50OiAvXFwvXFwqW1xcd1xcV10qP1xcKlxcLy9nLFxuICBhdHJ1bGU6IHtcbiAgICBwYXR0ZXJuOiAvQFtcXHctXSs/Lio/KDt8KD89XFxzKnspKS9naSxcbiAgICBpbnNpZGU6IHtcbiAgICAgIHB1bmN0dWF0aW9uOiAvWzs6XS9nLFxuICAgIH0sXG4gIH0sXG4gIHVybDogL3VybFxcKChbXCInXT8pLio/XFwxXFwpL2dpLFxuICBzZWxlY3RvcjogL1teXFx7XFx9XFxzXVteXFx7XFx9O10qKD89XFxzKlxceykvZyxcbiAgcHJvcGVydHk6IC8oXFxifFxcQilbXFx3LV0rKD89XFxzKjopL2dpLFxuICBzdHJpbmc6IC8oXCJ8JykoXFxcXD8uKSo/XFwxL2csXG4gIGltcG9ydGFudDogL1xcQiFpbXBvcnRhbnRcXGIvZ2ksXG4gIHB1bmN0dWF0aW9uOiAvW1xce1xcfTs6XS9nLFxuICBmdW5jdGlvbjogL1stYS16MC05XSsoPz1cXCgpL2dpLFxufTtcblxuaWYgKFByaXNtLmxhbmd1YWdlcy5tYXJrdXApIHtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya3VwJywgJ3RhZycsIHtcbiAgICBzdHlsZToge1xuICAgICAgcGF0dGVybjogLzxzdHlsZVtcXHdcXFddKj8+W1xcd1xcV10qPzxcXC9zdHlsZT4vZ2ksXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgdGFnOiB7XG4gICAgICAgICAgcGF0dGVybjogLzxzdHlsZVtcXHdcXFddKj8+fDxcXC9zdHlsZT4vZ2ksXG4gICAgICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZy5pbnNpZGUsXG4gICAgICAgIH0sXG4gICAgICAgIHJlc3Q6IFByaXNtLmxhbmd1YWdlcy5jc3MsXG4gICAgICB9LFxuICAgICAgYWxpYXM6ICdsYW5ndWFnZS1jc3MnLFxuICAgIH0sXG4gIH0pO1xuXG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoXG4gICAgJ2luc2lkZScsXG4gICAgJ2F0dHItdmFsdWUnLFxuICAgIHtcbiAgICAgICdzdHlsZS1hdHRyJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXFxzKnN0eWxlPShcInwnKS4rP1xcMS9naSxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgJ2F0dHItbmFtZSc6IHtcbiAgICAgICAgICAgIHBhdHRlcm46IC9eXFxzKnN0eWxlL2dpLFxuICAgICAgICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZy5pbnNpZGUsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwdW5jdHVhdGlvbjogL15cXHMqPVxccypbJ1wiXXxbJ1wiXVxccyokLyxcbiAgICAgICAgICAnYXR0ci12YWx1ZSc6IHtcbiAgICAgICAgICAgIHBhdHRlcm46IC8uKy9naSxcbiAgICAgICAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmNzcyxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBhbGlhczogJ2xhbmd1YWdlLWNzcycsXG4gICAgICB9LFxuICAgIH0sXG4gICAgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWdcbiAgKTtcbn1cblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1jbGlrZS5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5QcmlzbS5sYW5ndWFnZXMuY2xpa2UgPSB7XG4gIGNvbW1lbnQ6IFtcbiAgICB7XG4gICAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSlcXC9cXCpbXFx3XFxXXSo/XFwqXFwvL2csXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIH0sXG4gICAge1xuICAgICAgcGF0dGVybjogLyhefFteXFxcXDpdKVxcL1xcLy4qPyhcXHI/XFxufCQpL2csXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIH0sXG4gIF0sXG4gIHN0cmluZzogLyhcInwnKShcXFxcPy4pKj9cXDEvZyxcbiAgJ2NsYXNzLW5hbWUnOiB7XG4gICAgcGF0dGVybjpcbiAgICAgIC8oKD86KD86Y2xhc3N8aW50ZXJmYWNlfGV4dGVuZHN8aW1wbGVtZW50c3x0cmFpdHxpbnN0YW5jZW9mfG5ldylcXHMrKXwoPzpjYXRjaFxccytcXCgpKVthLXowLTlfXFwuXFxcXF0rL2dpLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICBwdW5jdHVhdGlvbjogLyhcXC58XFxcXCkvLFxuICAgIH0sXG4gIH0sXG4gIGtleXdvcmQ6XG4gICAgL1xcYihpZnxlbHNlfHdoaWxlfGRvfGZvcnxyZXR1cm58aW58aW5zdGFuY2VvZnxmdW5jdGlvbnxuZXd8dHJ5fHRocm93fGNhdGNofGZpbmFsbHl8bnVsbHxicmVha3xjb250aW51ZSlcXGIvZyxcbiAgYm9vbGVhbjogL1xcYih0cnVlfGZhbHNlKVxcYi9nLFxuICBmdW5jdGlvbjoge1xuICAgIHBhdHRlcm46IC9bYS16MC05X10rXFwoL2dpLFxuICAgIGluc2lkZToge1xuICAgICAgcHVuY3R1YXRpb246IC9cXCgvLFxuICAgIH0sXG4gIH0sXG4gIG51bWJlcjogL1xcYi0/KDB4W1xcZEEtRmEtZl0rfFxcZCpcXC4/XFxkKyhbRWVdLT9cXGQrKT8pXFxiL2csXG4gIG9wZXJhdG9yOiAvWy0rXXsxLDJ9fCF8PD0/fD49P3w9ezEsM318JnsxLDJ9fFxcfD9cXHx8XFw/fFxcKnxcXC98XFx+fFxcXnxcXCUvZyxcbiAgaWdub3JlOiAvJihsdHxndHxhbXApOy9naSxcbiAgcHVuY3R1YXRpb246IC9be31bXFxdOygpLC46XS9nLFxufTtcblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1qYXZhc2NyaXB0LmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cblByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0ID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY2xpa2UnLCB7XG4gIGtleXdvcmQ6XG4gICAgL1xcYihicmVha3xjYXNlfGNhdGNofGNsYXNzfGNvbnN0fGNvbnRpbnVlfGRlYnVnZ2VyfGRlZmF1bHR8ZGVsZXRlfGRvfGVsc2V8ZW51bXxleHBvcnR8ZXh0ZW5kc3xmYWxzZXxmaW5hbGx5fGZvcnxmdW5jdGlvbnxnZXR8aWZ8aW1wbGVtZW50c3xpbXBvcnR8aW58aW5zdGFuY2VvZnxpbnRlcmZhY2V8bGV0fG5ld3xudWxsfHBhY2thZ2V8cHJpdmF0ZXxwcm90ZWN0ZWR8cHVibGljfHJldHVybnxzZXR8c3RhdGljfHN1cGVyfHN3aXRjaHx0aGlzfHRocm93fHRydWV8dHJ5fHR5cGVvZnx2YXJ8dm9pZHx3aGlsZXx3aXRofHlpZWxkKVxcYi9nLFxuICBudW1iZXI6IC9cXGItPygweFtcXGRBLUZhLWZdK3xcXGQqXFwuP1xcZCsoW0VlXS0/XFxkKyk/fE5hTnwtP0luZmluaXR5KVxcYi9nLFxufSk7XG5cblByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAna2V5d29yZCcsIHtcbiAgcmVnZXg6IHtcbiAgICBwYXR0ZXJuOlxuICAgICAgLyhefFteL10pXFwvKD8hXFwvKShcXFsuKz9dfFxcXFwufFteL1xcclxcbl0pK1xcL1tnaW1dezAsM30oPz1cXHMqKCR8W1xcclxcbiwuO30pXSkpL2csXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgfSxcbn0pO1xuXG5pZiAoUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cCkge1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdtYXJrdXAnLCAndGFnJywge1xuICAgIHNjcmlwdDoge1xuICAgICAgcGF0dGVybjogLzxzY3JpcHRbXFx3XFxXXSo/PltcXHdcXFddKj88XFwvc2NyaXB0Pi9naSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICB0YWc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvPHNjcmlwdFtcXHdcXFddKj8+fDxcXC9zY3JpcHQ+L2dpLFxuICAgICAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuaW5zaWRlLFxuICAgICAgICB9LFxuICAgICAgICByZXN0OiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCxcbiAgICAgIH0sXG4gICAgICBhbGlhczogJ2xhbmd1YWdlLWphdmFzY3JpcHQnLFxuICAgIH0sXG4gIH0pO1xufVxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLWZpbGUtaGlnaGxpZ2h0LmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbihmdW5jdGlvbiAoKSB7XG4gIGlmICghc2VsZi5QcmlzbSB8fCAhc2VsZi5kb2N1bWVudCB8fCAhZG9jdW1lbnQucXVlcnlTZWxlY3Rvcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBFeHRlbnNpb25zID0ge1xuICAgIGpzOiAnamF2YXNjcmlwdCcsXG4gICAgaHRtbDogJ21hcmt1cCcsXG4gICAgc3ZnOiAnbWFya3VwJyxcbiAgICB4bWw6ICdtYXJrdXAnLFxuICAgIHB5OiAncHl0aG9uJyxcbiAgICByYjogJ3J1YnknLFxuICB9O1xuXG4gIEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgIC5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3ByZVtkYXRhLXNyY10nKSlcbiAgICAuZm9yRWFjaChmdW5jdGlvbiAocHJlKSB7XG4gICAgICB2YXIgc3JjID0gcHJlLmdldEF0dHJpYnV0ZSgnZGF0YS1zcmMnKTtcbiAgICAgIHZhciBleHRlbnNpb24gPSAoc3JjLm1hdGNoKC9cXC4oXFx3KykkLykgfHwgWywgJyddKVsxXTtcbiAgICAgIHZhciBsYW5ndWFnZSA9IEV4dGVuc2lvbnNbZXh0ZW5zaW9uXSB8fCBleHRlbnNpb247XG5cbiAgICAgIHZhciBjb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29kZScpO1xuICAgICAgY29kZS5jbGFzc05hbWUgPSAnbGFuZ3VhZ2UtJyArIGxhbmd1YWdlO1xuXG4gICAgICBwcmUudGV4dENvbnRlbnQgPSAnJztcblxuICAgICAgY29kZS50ZXh0Q29udGVudCA9ICdMb2FkaW5n4oCmJztcblxuICAgICAgcHJlLmFwcGVuZENoaWxkKGNvZGUpO1xuXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIHhoci5vcGVuKCdHRVQnLCBzcmMsIHRydWUpO1xuXG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgIGlmICh4aHIuc3RhdHVzIDwgNDAwICYmIHhoci5yZXNwb25zZVRleHQpIHtcbiAgICAgICAgICAgIGNvZGUudGV4dENvbnRlbnQgPSB4aHIucmVzcG9uc2VUZXh0O1xuXG4gICAgICAgICAgICBQcmlzbS5oaWdobGlnaHRFbGVtZW50KGNvZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoeGhyLnN0YXR1cyA+PSA0MDApIHtcbiAgICAgICAgICAgIGNvZGUudGV4dENvbnRlbnQgPVxuICAgICAgICAgICAgICAn4pyWIEVycm9yICcgK1xuICAgICAgICAgICAgICB4aHIuc3RhdHVzICtcbiAgICAgICAgICAgICAgJyB3aGlsZSBmZXRjaGluZyBmaWxlOiAnICtcbiAgICAgICAgICAgICAgeGhyLnN0YXR1c1RleHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvZGUudGV4dENvbnRlbnQgPSAn4pyWIEVycm9yOiBGaWxlIGRvZXMgbm90IGV4aXN0IG9yIGlzIGVtcHR5JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgIH0pO1xufSkoKTtcbiIsImdsb2JhbC5ydW5JdCA9IGZ1bmN0aW9uIHJ1bkl0KGJ1dHRvbikge1xuICBpZiAoIWdsb2JhbC5SdW5LaXQpIHJldHVybjtcblxuICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZhciBjb2RlRWxlbWVudCA9IGJ1dHRvbi5wYXJlbnROb2RlO1xuICB2YXIgcGFyZW50ID0gY29kZUVsZW1lbnQucGFyZW50Tm9kZTtcblxuICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNvbnRhaW5lciwgY29kZUVsZW1lbnQpO1xuICBwYXJlbnQucmVtb3ZlQ2hpbGQoY29kZUVsZW1lbnQpO1xuICBjb2RlRWxlbWVudC5yZW1vdmVDaGlsZChidXR0b24pO1xuXG4gIGNvbnN0IG9wdGlvbnMgPSBKU09OLnBhcnNlKHVuZXNjYXBlKGJ1dHRvbi5kYXRhc2V0Lm9wdGlvbnMpKTtcblxuICBmdW5jdGlvbiB3aXRoQ29ycmVjdFZlcnNpb24oY29kZSkge1xuICAgIHJldHVybiBjb2RlLnJlcGxhY2UoXG4gICAgICAvcmVxdWlyZVxcKCdpbW11dGFibGUnXFwpL2csXG4gICAgICBcInJlcXVpcmUoJ2ltbXV0YWJsZUA0LjAuMC1yYy45JylcIlxuICAgICk7XG4gIH1cblxuICBnbG9iYWwuUnVuS2l0LmNyZWF0ZU5vdGVib29rKHtcbiAgICBlbGVtZW50OiBjb250YWluZXIsXG4gICAgbm9kZVZlcnNpb246IG9wdGlvbnMubm9kZVZlcnNpb24gfHwgJyonLFxuICAgIHByZWFtYmxlOiB3aXRoQ29ycmVjdFZlcnNpb24oXG4gICAgICAnY29uc3QgYXNzZXJ0ID0gKCcgK1xuICAgICAgICBtYWtlQXNzZXJ0ICtcbiAgICAgICAgXCIpKHJlcXVpcmUoJ2ltbXV0YWJsZScpKTtcIiArXG4gICAgICAgIChvcHRpb25zLnByZWFtYmxlIHx8ICcnKVxuICAgICksXG4gICAgc291cmNlOiB3aXRoQ29ycmVjdFZlcnNpb24oXG4gICAgICBjb2RlRWxlbWVudC50ZXh0Q29udGVudC5yZXBsYWNlKC9cXG4oPlteXFxuXSpcXG4/KSskL2csICcnKVxuICAgICksXG4gICAgbWluSGVpZ2h0OiAnNTJweCcsXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAobm90ZWJvb2spIHtcbiAgICAgIG5vdGVib29rLmV2YWx1YXRlKCk7XG4gICAgfSxcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBtYWtlQXNzZXJ0KEkpIHtcbiAgdmFyIGlzSXRlcmFibGUgPSBJLmlzSXRlcmFibGUgfHwgSS5JdGVyYWJsZS5pc0l0ZXJhYmxlO1xuICB2YXIgaHRtbCA9IChcIlxcbiAgICA8c3R5bGU+XFxuICAgICAgKiB7XFxuICAgICAgICBmb250LXNpemU6IDE0cHg7XFxuICAgICAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb2RlIHtcXG4gICAgICAgIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxuICAgICAgICBjb2xvcjogIzQxODNDNDtcXG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgICAgIGJhY2tncm91bmQ6IHJnYmEoNjUsIDEzMSwgMTk2LCAwLjEpO1xcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMnB4O1xcbiAgICAgICAgcGFkZGluZzogMnB4O1xcbiAgICB9XFxuXFxuICAgICAgLnN1Y2Nlc3Mge1xcbiAgICAgICAgY29sb3I6IHJnYmEoODQsMTg0LDU0LDEuMCk7XFxuICAgICAgfVxcblxcbiAgICAgIC5zdWNjZXNzOmJlZm9yZSB7XFxuICAgICAgICBjb250ZW50OiBcXFwi4pyFXFxcIjtcXG4gICAgICB9XFxuXFxuICAgICAgLmZhaWx1cmUge1xcbiAgICAgICAgY29sb3I6IHJnYmEoMjIwLDQ3LDMzLDEuMCk7XFxuICAgICAgfVxcblxcbiAgICAgIC5mYWlsdXJlIGkge1xcbiAgICAgICAgY29sb3I6IHJnYmEoMjEwLDQ0LDMxLDEuMCk7XFxuICAgICAgfVxcblxcbiAgICAgIC5mYWlsdXJlOmJlZm9yZSB7XFxuICAgICAgICBjb250ZW50OiBcXFwi4p2MXFxcIjtcXG4gICAgICB9XFxuICAgIDwvc3R5bGU+XCJcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4pO1xuXG4gIGZ1bmN0aW9uIGNvbXBhcmUobGhzLCByaHMsIHNhbWUsIGlkZW50aWNhbCkge1xuICAgIHZhciBib3RoID0gIWlkZW50aWNhbCAmJiBpc0l0ZXJhYmxlKGxocykgJiYgaXNJdGVyYWJsZShyaHMpO1xuXG4gICAgaWYgKGJvdGgpIHJldHVybiBsaHMuZXF1YWxzKHJocyk7XG5cbiAgICByZXR1cm4gbGhzID09PSByaHM7XG4gIH1cblxuICBmdW5jdGlvbiBtZXNzYWdlKGxocywgcmhzLCBzYW1lLCBpZGVudGljYWwpIHtcbiAgICB2YXIgcmVzdWx0ID0gY29tcGFyZShsaHMsIHJocywgc2FtZSwgaWRlbnRpY2FsKTtcbiAgICB2YXIgY29tcGFyaXNvbiA9IHJlc3VsdFxuICAgICAgPyBpZGVudGljYWxcbiAgICAgICAgPyAnc3RyaWN0IGVxdWFsIHRvJ1xuICAgICAgICA6ICdkb2VzIGVxdWFsJ1xuICAgICAgOiBpZGVudGljYWxcbiAgICAgID8gJ25vdCBzdHJpY3QgZXF1YWwgdG8nXG4gICAgICA6ICdkb2VzIG5vdCBlcXVhbCc7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHJlc3VsdCA9PT0gc2FtZSA/ICdzdWNjZXNzJyA6ICdmYWlsdXJlJztcbiAgICB2YXIgbGhzU3RyaW5nID0gaXNJdGVyYWJsZShsaHMpID8gbGhzICsgJycgOiBKU09OLnN0cmluZ2lmeShsaHMpO1xuICAgIHZhciByaHNTdHJpbmcgPSBpc0l0ZXJhYmxlKHJocykgPyByaHMgKyAnJyA6IEpTT04uc3RyaW5naWZ5KHJocyk7XG5cbiAgICByZXR1cm4gKGh0bWwgKz0gKFwiXFxuICAgICAgPHNwYW4gY2xhc3M9XFxcIlwiICsgXG5jbGFzc05hbWUgKyBcIlxcXCI+XFxuICAgICAgICA8Y29kZT5cIiArIFxubGhzU3RyaW5nICsgXCI8L2NvZGU+XFxuICAgICAgICBcIiArIFxuY29tcGFyaXNvbiArIFwiXFxuICAgICAgICA8Y29kZT5cIiArIFxucmhzU3RyaW5nICsgXCI8L2NvZGU+XFxuICAgICAgPC9zcGFuPjxici8+XCJcbikpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXF1YWwobGhzLCByaHMpIHtcbiAgICByZXR1cm4gbWVzc2FnZShsaHMsIHJocywgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBub3RFcXVhbChsaHMsIHJocykge1xuICAgIHJldHVybiBtZXNzYWdlKGxocywgcmhzLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpY3RFcXVhbChsaHMsIHJocykge1xuICAgIHJldHVybiBtZXNzYWdlKGxocywgcmhzLCB0cnVlLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGxocywgcmhzKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UobGhzLCByaHMsIGZhbHNlLCB0cnVlKTtcbiAgfVxuXG4gIHJldHVybiB7IGVxdWFsOmVxdWFsLCBub3RFcXVhbDpub3RFcXVhbCwgc3RyaWN0RXF1YWw6c3RyaWN0RXF1YWwsIG5vdFN0cmljdEVxdWFsOm5vdFN0cmljdEVxdWFsIH07XG59XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIENTU0NvcmUgPSByZXF1aXJlKCdyZWFjdC9saWIvQ1NTQ29yZScpO1xudmFyIFJvdXRlciA9IHJlcXVpcmUoJ3JlYWN0LXJvdXRlcicpO1xudmFyICRfXzA9ICAgIHJlcXVpcmUoJy4uLy4uLy4uLy4uLycpLFNlcT0kX18wLlNlcTtcbnZhciBUeXBlS2luZCA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9UeXBlS2luZCcpO1xudmFyIGRlZnMgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvZ2V0VHlwZURlZnMnKTtcblxudmFyIEludGVyZmFjZURlZiA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJJbnRlcmZhY2VEZWZcIixcbiAgcmVuZGVyOmZ1bmN0aW9uKCkge1xuICAgIHZhciBuYW1lID0gdGhpcy5wcm9wcy5uYW1lO1xuICAgIHZhciBkZWYgPSB0aGlzLnByb3BzLmRlZjtcbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogXCJ0IGludGVyZmFjZURlZlwifSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCBrZXl3b3JkXCJ9LCBcInR5cGUgXCIpLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogXCJ0IHR5cGVOYW1lXCJ9LCBuYW1lKSwgXG4gICAgICAgIGRlZi50eXBlUGFyYW1zICYmIFtcbiAgICAgICAgICAnPCcsXG4gICAgICAgICAgU2VxKGRlZi50eXBlUGFyYW1zKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbih0LCBrKSAgXG4gICAgICAgICAgICAgIHtyZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogXCJ0IHR5cGVQYXJhbVwiLCBrZXk6IGt9LCBcbiAgICAgICAgICAgICAgICB0XG4gICAgICAgICAgICAgICk7fVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmludGVycG9zZSgnLCAnKVxuICAgICAgICAgICAgLnRvQXJyYXkoKSxcbiAgICAgICAgICAnPicsXG4gICAgICAgIF0sIFxuICAgICAgICBkZWYuZXh0ZW5kcyAmJiBbXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogXCJ0IGtleXdvcmRcIn0sIFwiIGV4dGVuZHMgXCIpLFxuICAgICAgICAgIFNlcShkZWYuZXh0ZW5kcylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oZSwgaSkgIHtyZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChUeXBlRGVmLCB7a2V5OiBpLCB0eXBlOiBlfSk7fSlcbiAgICAgICAgICAgIC5pbnRlcnBvc2UoJywgJylcbiAgICAgICAgICAgIC50b0FycmF5KCksXG4gICAgICAgIF0sIFxuICAgICAgICBkZWYuaW1wbGVtZW50cyAmJiBbXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogXCJ0IGtleXdvcmRcIn0sIFwiIGltcGxlbWVudHMgXCIpLFxuICAgICAgICAgIFNlcShkZWYuaW1wbGVtZW50cylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oZSwgaSkgIHtyZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChUeXBlRGVmLCB7a2V5OiBpLCB0eXBlOiBlfSk7fSlcbiAgICAgICAgICAgIC5pbnRlcnBvc2UoJywgJylcbiAgICAgICAgICAgIC50b0FycmF5KCksXG4gICAgICAgIF1cbiAgICAgIClcbiAgICApO1xuICB9LFxufSk7XG5cbmV4cG9ydHMuSW50ZXJmYWNlRGVmID0gSW50ZXJmYWNlRGVmO1xuXG52YXIgQ2FsbFNpZ0RlZiA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJDYWxsU2lnRGVmXCIsXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5mbyA9IHRoaXMucHJvcHMuaW5mbztcbiAgICB2YXIgbW9kdWxlID0gdGhpcy5wcm9wcy5tb2R1bGU7XG4gICAgdmFyIG5hbWUgPSB0aGlzLnByb3BzLm5hbWU7XG4gICAgdmFyIGNhbGxTaWcgPSB0aGlzLnByb3BzLmNhbGxTaWcgfHwge307XG5cbiAgICB2YXIgc2hvdWxkV3JhcCA9IGNhbGxTaWdMZW5ndGgoaW5mbywgbW9kdWxlLCBuYW1lLCBjYWxsU2lnKSA+IDgwO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCBjYWxsU2lnXCJ9LCBcbiAgICAgICAgbW9kdWxlICYmIFtSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7Y2xhc3NOYW1lOiBcInQgZm5RdWFsaWZpZXJcIn0sIG1vZHVsZSksICcuJ10sIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7Y2xhc3NOYW1lOiBcInQgZm5OYW1lXCJ9LCBuYW1lKSwgXG4gICAgICAgIGNhbGxTaWcudHlwZVBhcmFtcyAmJiBbXG4gICAgICAgICAgJzwnLFxuICAgICAgICAgIFNlcShjYWxsU2lnLnR5cGVQYXJhbXMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHQpICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCB0eXBlUGFyYW1cIn0sIHQpO30pXG4gICAgICAgICAgICAuaW50ZXJwb3NlKCcsICcpXG4gICAgICAgICAgICAudG9BcnJheSgpLFxuICAgICAgICAgICc+JyxcbiAgICAgICAgXSwgXG4gICAgICAgICcoJywgXG4gICAgICAgIGNhbGxTaWcgJiYgZnVuY3Rpb25QYXJhbXMoaW5mbywgY2FsbFNpZy5wYXJhbXMsIHNob3VsZFdyYXApLCBcbiAgICAgICAgJyknLCBcbiAgICAgICAgY2FsbFNpZy50eXBlICYmIFsnOiAnLCBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEZWYsIHtpbmZvOiBpbmZvLCB0eXBlOiBjYWxsU2lnLnR5cGV9KV1cbiAgICAgIClcbiAgICApO1xuICB9LFxufSk7XG5cbmV4cG9ydHMuQ2FsbFNpZ0RlZiA9IENhbGxTaWdEZWY7XG5cbnZhciBUeXBlRGVmID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiBcIlR5cGVEZWZcIixcbiAgcmVuZGVyOmZ1bmN0aW9uKCkge1xuICAgIHZhciBpbmZvID0gdGhpcy5wcm9wcy5pbmZvO1xuICAgIHZhciB0eXBlID0gdGhpcy5wcm9wcy50eXBlO1xuICAgIHZhciBwcmVmaXggPSB0aGlzLnByb3BzLnByZWZpeDtcbiAgICBzd2l0Y2ggKHR5cGUuaykge1xuICAgICAgY2FzZSBUeXBlS2luZC5OZXZlcjpcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCgncHJpbWl0aXZlJywgJ25ldmVyJyk7XG4gICAgICBjYXNlIFR5cGVLaW5kLkFueTpcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCgncHJpbWl0aXZlJywgJ2FueScpO1xuICAgICAgY2FzZSBUeXBlS2luZC5Vbmtub3duOlxuICAgICAgICByZXR1cm4gdGhpcy53cmFwKCdwcmltaXRpdmUnLCAndW5rbm93bicpO1xuICAgICAgY2FzZSBUeXBlS2luZC5UaGlzOlxuICAgICAgICByZXR1cm4gdGhpcy53cmFwKCdwcmltaXRpdmUnLCAndGhpcycpO1xuICAgICAgY2FzZSBUeXBlS2luZC5VbmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB0aGlzLndyYXAoJ3ByaW1pdGl2ZScsICd1bmRlZmluZWQnKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuQm9vbGVhbjpcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCgncHJpbWl0aXZlJywgJ2Jvb2xlYW4nKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuTnVtYmVyOlxuICAgICAgICByZXR1cm4gdGhpcy53cmFwKCdwcmltaXRpdmUnLCAnbnVtYmVyJyk7XG4gICAgICBjYXNlIFR5cGVLaW5kLlN0cmluZzpcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCgncHJpbWl0aXZlJywgJ3N0cmluZycpO1xuICAgICAgY2FzZSBUeXBlS2luZC5VbmlvbjpcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCgndW5pb24nLCBbXG4gICAgICAgICAgU2VxKHR5cGUudHlwZXMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHQpICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVHlwZURlZiwge2luZm86IGluZm8sIHR5cGU6IHR9KTt9KVxuICAgICAgICAgICAgLmludGVycG9zZSgnIHwgJylcbiAgICAgICAgICAgIC50b0FycmF5KCksXG4gICAgICAgIF0pO1xuICAgICAgY2FzZSBUeXBlS2luZC5JbnRlcnNlY3Rpb246XG4gICAgICAgIHJldHVybiB0aGlzLndyYXAoJ2ludGVyc2VjdGlvbicsIFtcbiAgICAgICAgICBTZXEodHlwZS50eXBlcylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24odCkgIHtyZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChUeXBlRGVmLCB7aW5mbzogaW5mbywgdHlwZTogdH0pO30pXG4gICAgICAgICAgICAuaW50ZXJwb3NlKCcgJiAnKVxuICAgICAgICAgICAgLnRvQXJyYXkoKSxcbiAgICAgICAgXSk7XG4gICAgICBjYXNlIFR5cGVLaW5kLlR1cGxlOlxuICAgICAgICByZXR1cm4gdGhpcy53cmFwKCd0dXBsZScsIFtcbiAgICAgICAgICAnWycsXG4gICAgICAgICAgU2VxKHR5cGUudHlwZXMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHQpICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVHlwZURlZiwge2luZm86IGluZm8sIHR5cGU6IHR9KTt9KVxuICAgICAgICAgICAgLmludGVycG9zZSgnLCAnKVxuICAgICAgICAgICAgLnRvQXJyYXkoKSxcbiAgICAgICAgICAnXScsXG4gICAgICAgIF0pO1xuICAgICAgY2FzZSBUeXBlS2luZC5PYmplY3Q6XG4gICAgICAgIHJldHVybiB0aGlzLndyYXAoJ29iamVjdCcsIFtcbiAgICAgICAgICAneycsXG4gICAgICAgICAgU2VxKHR5cGUubWVtYmVycylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24odCkgIHtyZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChNZW1iZXJEZWYsIHttZW1iZXI6IHR9KTt9KVxuICAgICAgICAgICAgLmludGVycG9zZSgnLCAnKVxuICAgICAgICAgICAgLnRvQXJyYXkoKSxcbiAgICAgICAgICAnfScsXG4gICAgICAgIF0pO1xuICAgICAgY2FzZSBUeXBlS2luZC5JbmRleGVkOlxuICAgICAgICByZXR1cm4gdGhpcy53cmFwKCdpbmRleGVkJywgW1xuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVHlwZURlZiwge2luZm86IGluZm8sIHR5cGU6IHR5cGUudHlwZX0pLFxuICAgICAgICAgICdbJyxcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEZWYsIHtpbmZvOiBpbmZvLCB0eXBlOiB0eXBlLmluZGV4fSksXG4gICAgICAgICAgJ10nLFxuICAgICAgICBdKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuT3BlcmF0b3I6XG4gICAgICAgIHJldHVybiB0aGlzLndyYXAoJ29wZXJhdG9yJywgW1xuICAgICAgICAgIHRoaXMud3JhcCgncHJpbWl0aXZlJywgdHlwZS5vcGVyYXRvciksXG4gICAgICAgICAgJyAnLFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVHlwZURlZiwge2luZm86IGluZm8sIHR5cGU6IHR5cGUudHlwZX0pLFxuICAgICAgICBdKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuQXJyYXk6XG4gICAgICAgIHJldHVybiB0aGlzLndyYXAoJ2FycmF5JywgW1xuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVHlwZURlZiwge2luZm86IGluZm8sIHR5cGU6IHR5cGUudHlwZX0pLFxuICAgICAgICAgICdbXScsXG4gICAgICAgIF0pO1xuICAgICAgY2FzZSBUeXBlS2luZC5GdW5jdGlvbjpcbiAgICAgICAgdmFyIHNob3VsZFdyYXAgPSAocHJlZml4IHx8IDApICsgZnVuY0xlbmd0aChpbmZvLCB0eXBlKSA+IDc4O1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwKCdmdW5jdGlvbicsIFtcbiAgICAgICAgICB0eXBlLnR5cGVQYXJhbXMgJiYgW1xuICAgICAgICAgICAgJzwnLFxuICAgICAgICAgICAgU2VxKHR5cGUudHlwZVBhcmFtcylcbiAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbih0LCBrKSAgXG4gICAgICAgICAgICAgICAge3JldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7Y2xhc3NOYW1lOiBcInQgdHlwZVBhcmFtXCIsIGtleToga30sIFxuICAgICAgICAgICAgICAgICAgdFxuICAgICAgICAgICAgICAgICk7fVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIC5pbnRlcnBvc2UoJywgJylcbiAgICAgICAgICAgICAgLnRvQXJyYXkoKSxcbiAgICAgICAgICAgICc+JyxcbiAgICAgICAgICBdLFxuICAgICAgICAgICcoJyxcbiAgICAgICAgICBmdW5jdGlvblBhcmFtcyhpbmZvLCB0eXBlLnBhcmFtcywgc2hvdWxkV3JhcCksXG4gICAgICAgICAgJykgPT4gJyxcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEZWYsIHtpbmZvOiBpbmZvLCB0eXBlOiB0eXBlLnR5cGV9KSxcbiAgICAgICAgXSk7XG4gICAgICBjYXNlIFR5cGVLaW5kLlBhcmFtOlxuICAgICAgICByZXR1cm4gaW5mbyAmJiBpbmZvLnByb3BNYXBbaW5mby5kZWZpbmluZyArICc8JyArIHR5cGUucGFyYW1dID8gKFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVHlwZURlZiwge3R5cGU6IGluZm8ucHJvcE1hcFtpbmZvLmRlZmluaW5nICsgJzwnICsgdHlwZS5wYXJhbV19KVxuICAgICAgICApIDogKFxuICAgICAgICAgIHRoaXMud3JhcCgndHlwZVBhcmFtJywgdHlwZS5wYXJhbSlcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuVHlwZTpcbiAgICAgICAgdmFyIHF1YWxpZmllZFR5cGUgPSAodHlwZS5xdWFsaWZpZXIgfHwgW10pLmNvbmNhdChbdHlwZS5uYW1lXSk7XG4gICAgICAgIHZhciBxdWFsaWZpZWRUeXBlTmFtZSA9IHF1YWxpZmllZFR5cGUuam9pbignLicpO1xuICAgICAgICB2YXIgZGVmID0gcXVhbGlmaWVkVHlwZU5hbWVcbiAgICAgICAgICAuc3BsaXQoJy4nKVxuICAgICAgICAgIC5yZWR1Y2UoXG4gICAgICAgICAgICBmdW5jdGlvbihkZWYsIG5hbWUpICB7cmV0dXJuIGRlZiAmJiBkZWYubW9kdWxlICYmIGRlZi5tb2R1bGVbbmFtZV07fSxcbiAgICAgICAgICAgIGRlZnMuSW1tdXRhYmxlXG4gICAgICAgICAgKTtcbiAgICAgICAgdmFyIHR5cGVOYW1lRWxlbWVudCA9IFtcbiAgICAgICAgICB0eXBlLnF1YWxpZmllciAmJiBbXG4gICAgICAgICAgICBTZXEodHlwZS5xdWFsaWZpZXIpXG4gICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24ocSkgIHtyZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogXCJ0IHR5cGVRdWFsaWZpZXJcIn0sIHEpO30pXG4gICAgICAgICAgICAgIC5pbnRlcnBvc2UoJy4nKVxuICAgICAgICAgICAgICAudG9BcnJheSgpLFxuICAgICAgICAgICAgJy4nLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogXCJ0IHR5cGVOYW1lXCJ9LCB0eXBlLm5hbWUpLFxuICAgICAgICBdO1xuICAgICAgICBpZiAoZGVmKSB7XG4gICAgICAgICAgdHlwZU5hbWVFbGVtZW50ID0gKFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIuTGluaywge3RvOiAnLycgKyBxdWFsaWZpZWRUeXBlTmFtZX0sIFxuICAgICAgICAgICAgICB0eXBlTmFtZUVsZW1lbnRcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndyYXAoJ3R5cGUnLCBbXG4gICAgICAgICAgdHlwZU5hbWVFbGVtZW50LFxuICAgICAgICAgIHR5cGUuYXJncyAmJiBbXG4gICAgICAgICAgICAnPCcsXG4gICAgICAgICAgICBTZXEodHlwZS5hcmdzKVxuICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGEpICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVHlwZURlZiwge2luZm86IGluZm8sIHR5cGU6IGF9KTt9KVxuICAgICAgICAgICAgICAuaW50ZXJwb3NlKCcsICcpXG4gICAgICAgICAgICAgIC50b0FycmF5KCksXG4gICAgICAgICAgICAnPicsXG4gICAgICAgICAgXSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBraW5kICcgKyB0eXBlLmspO1xuICB9LFxuXG4gIG1vdXNlT3ZlcjpmdW5jdGlvbihldmVudCkge1xuICAgIENTU0NvcmUuYWRkQ2xhc3ModGhpcy5nZXRET01Ob2RlKCksICdvdmVyJyk7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0sXG5cbiAgbW91c2VPdXQ6ZnVuY3Rpb24oKSB7XG4gICAgQ1NTQ29yZS5yZW1vdmVDbGFzcyh0aGlzLmdldERPTU5vZGUoKSwgJ292ZXInKTtcbiAgfSxcblxuICB3cmFwOmZ1bmN0aW9uKGNsYXNzTmFtZSwgY2hpbGQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICBjbGFzc05hbWU6ICd0ICcgKyBjbGFzc05hbWUsIFxuICAgICAgICBvbk1vdXNlT3ZlcjogdGhpcy5tb3VzZU92ZXIsIFxuICAgICAgICBvbkZvY3VzOiB0aGlzLm1vdXNlT3ZlciwgXG4gICAgICAgIG9uTW91c2VPdXQ6IHRoaXMubW91c2VPdXQsIFxuICAgICAgICBvbkJsdXI6IHRoaXMubW91c2VPdXRcbiAgICAgIH0sIFxuICAgICAgICBjaGlsZFxuICAgICAgKVxuICAgICk7XG4gIH0sXG59KTtcblxuZXhwb3J0cy5UeXBlRGVmID0gVHlwZURlZjtcblxudmFyIE1lbWJlckRlZiA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJNZW1iZXJEZWZcIixcbiAgcmVuZGVyOmZ1bmN0aW9uKCkge1xuICAgIHZhciBtb2R1bGUgPSB0aGlzLnByb3BzLm1vZHVsZTtcbiAgICB2YXIgbWVtYmVyID0gdGhpcy5wcm9wcy5tZW1iZXI7XG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCBtZW1iZXJcIn0sIFxuICAgICAgICBtb2R1bGUgJiYgW1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCBmblF1YWxpZmllclwifSwgbW9kdWxlKSwgJy4nXSwgXG4gICAgICAgIG1lbWJlci5pbmRleCA/IChcbiAgICAgICAgICBbJ1snLCBmdW5jdGlvblBhcmFtcyhudWxsLCBtZW1iZXIucGFyYW1zKSwgJ10nXVxuICAgICAgICApIDogKFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCBtZW1iZXJOYW1lXCJ9LCBtZW1iZXIubmFtZSlcbiAgICAgICAgKSwgXG4gICAgICAgIG1lbWJlci50eXBlICYmIFsnOiAnLCBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEZWYsIHt0eXBlOiBtZW1iZXIudHlwZX0pXVxuICAgICAgKVxuICAgICk7XG4gIH0sXG59KTtcblxuZXhwb3J0cy5NZW1iZXJEZWYgPSBNZW1iZXJEZWY7XG5cbmZ1bmN0aW9uIGZ1bmN0aW9uUGFyYW1zKGluZm8sIHBhcmFtcywgc2hvdWxkV3JhcCkge1xuICB2YXIgZWxlbWVudHMgPSBTZXEocGFyYW1zKVxuICAgIC5tYXAoZnVuY3Rpb24odCkgIHtyZXR1cm4gW1xuICAgICAgdC52YXJBcmdzID8gJy4uLicgOiBudWxsLFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogXCJ0IHBhcmFtXCJ9LCB0Lm5hbWUpLFxuICAgICAgdC5vcHRpb25hbCA/ICc/OiAnIDogJzogJyxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVHlwZURlZiwge1xuICAgICAgICBwcmVmaXg6IHQubmFtZS5sZW5ndGggKyAodC52YXJBcmdzID8gMyA6IDApICsgKHQub3B0aW9uYWwgPyAzIDogMiksIFxuICAgICAgICBpbmZvOiBpbmZvLCBcbiAgICAgICAgdHlwZTogdC50eXBlfVxuICAgICAgKSxcbiAgICBdO30pXG4gICAgLmludGVycG9zZShzaG91bGRXcmFwID8gWycsJywgUmVhY3QuY3JlYXRlRWxlbWVudChcImJyXCIsIG51bGwpXSA6ICcsICcpXG4gICAgLnRvQXJyYXkoKTtcbiAgcmV0dXJuIHNob3VsZFdyYXAgPyAoXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7Y2xhc3NOYW1lOiBcInQgYmxvY2tQYXJhbXNcIn0sIGVsZW1lbnRzKVxuICApIDogKFxuICAgIGVsZW1lbnRzXG4gICk7XG59XG5cbmZ1bmN0aW9uIGNhbGxTaWdMZW5ndGgoaW5mbywgbW9kdWxlLCBuYW1lLCBzaWcpIHtcbiAgcmV0dXJuIChtb2R1bGUgPyBtb2R1bGUubGVuZ3RoICsgMSA6IDApICsgbmFtZS5sZW5ndGggKyBmdW5jTGVuZ3RoKGluZm8sIHNpZyk7XG59XG5cbmZ1bmN0aW9uIGZ1bmNMZW5ndGgoaW5mbywgc2lnKSB7XG4gIHJldHVybiAoXG4gICAgKHNpZy50eXBlUGFyYW1zID8gMiArIHNpZy50eXBlUGFyYW1zLmpvaW4oJywgJykubGVuZ3RoIDogMCkgK1xuICAgIDIgK1xuICAgIChzaWcucGFyYW1zID8gcGFyYW1MZW5ndGgoaW5mbywgc2lnLnBhcmFtcykgOiAwKSArXG4gICAgKHNpZy50eXBlID8gMiArIHR5cGVMZW5ndGgoaW5mbywgc2lnLnR5cGUpIDogMClcbiAgKTtcbn1cblxuZnVuY3Rpb24gcGFyYW1MZW5ndGgoaW5mbywgcGFyYW1zKSB7XG4gIHJldHVybiBwYXJhbXMucmVkdWNlKFxuICAgIGZ1bmN0aW9uKHMsIHApIFxuICAgICAge3JldHVybiBzICtcbiAgICAgIChwLnZhckFyZ3MgPyAzIDogMCkgK1xuICAgICAgcC5uYW1lLmxlbmd0aCArXG4gICAgICAocC5vcHRpb25hbCA/IDMgOiAyKSArXG4gICAgICB0eXBlTGVuZ3RoKGluZm8sIHAudHlwZSk7fSxcbiAgICAocGFyYW1zLmxlbmd0aCAtIDEpICogMlxuICApO1xufVxuXG5mdW5jdGlvbiBtZW1iZXJMZW5ndGgoaW5mbywgbWVtYmVycykge1xuICByZXR1cm4gbWVtYmVycy5yZWR1Y2UoXG4gICAgZnVuY3Rpb24ocywgbSkgXG4gICAgICB7cmV0dXJuIHMgK1xuICAgICAgKG0uaW5kZXggPyBwYXJhbUxlbmd0aChpbmZvLCBtLnBhcmFtcykgKyA0IDogbS5uYW1lICsgMikgK1xuICAgICAgdHlwZUxlbmd0aChpbmZvLCBtLnR5cGUpO30sXG4gICAgKG1lbWJlcnMubGVuZ3RoIC0gMSkgKiAyXG4gICk7XG59XG5cbmZ1bmN0aW9uIHR5cGVMZW5ndGgoaW5mbywgdHlwZSkge1xuICBpZiAoIXR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHR5cGUnKTtcbiAgfVxuICBzd2l0Y2ggKHR5cGUuaykge1xuICAgIGNhc2UgVHlwZUtpbmQuTmV2ZXI6XG4gICAgICByZXR1cm4gNTtcbiAgICBjYXNlIFR5cGVLaW5kLkFueTpcbiAgICAgIHJldHVybiAzO1xuICAgIGNhc2UgVHlwZUtpbmQuVW5rbm93bjpcbiAgICAgIHJldHVybiA3O1xuICAgIGNhc2UgVHlwZUtpbmQuVGhpczpcbiAgICAgIHJldHVybiA0O1xuICAgIGNhc2UgVHlwZUtpbmQuVW5kZWZpbmVkOlxuICAgICAgcmV0dXJuIDk7XG4gICAgY2FzZSBUeXBlS2luZC5Cb29sZWFuOlxuICAgICAgcmV0dXJuIDc7XG4gICAgY2FzZSBUeXBlS2luZC5OdW1iZXI6XG4gICAgICByZXR1cm4gNjtcbiAgICBjYXNlIFR5cGVLaW5kLlN0cmluZzpcbiAgICAgIHJldHVybiA2O1xuICAgIGNhc2UgVHlwZUtpbmQuVW5pb246XG4gICAgY2FzZSBUeXBlS2luZC5JbnRlcnNlY3Rpb246XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0eXBlLnR5cGVzLnJlZHVjZShmdW5jdGlvbihzLCB0KSAge3JldHVybiBzICsgdHlwZUxlbmd0aChpbmZvLCB0KTt9LCAwKSArXG4gICAgICAgICh0eXBlLnR5cGVzLmxlbmd0aCAtIDEpICogM1xuICAgICAgKTtcbiAgICBjYXNlIFR5cGVLaW5kLlR1cGxlOlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgMiArXG4gICAgICAgIHR5cGUudHlwZXMucmVkdWNlKGZ1bmN0aW9uKHMsIHQpICB7cmV0dXJuIHMgKyB0eXBlTGVuZ3RoKGluZm8sIHQpO30sIDApICtcbiAgICAgICAgKHR5cGUudHlwZXMubGVuZ3RoIC0gMSkgKiAyXG4gICAgICApO1xuICAgIGNhc2UgVHlwZUtpbmQuT2JqZWN0OlxuICAgICAgcmV0dXJuIDIgKyBtZW1iZXJMZW5ndGgoaW5mbywgdHlwZS5tZW1iZXJzKTtcbiAgICBjYXNlIFR5cGVLaW5kLkluZGV4ZWQ6XG4gICAgICByZXR1cm4gMiArIHR5cGVMZW5ndGgoaW5mbywgdHlwZS50eXBlKSArIHR5cGVMZW5ndGgoaW5mbywgdHlwZS5pbmRleCk7XG4gICAgY2FzZSBUeXBlS2luZC5PcGVyYXRvcjpcbiAgICAgIHJldHVybiAxICsgdHlwZS5vcGVyYXRvci5sZW5ndGggKyB0eXBlTGVuZ3RoKGluZm8sIHR5cGUudHlwZSk7XG4gICAgY2FzZSBUeXBlS2luZC5BcnJheTpcbiAgICAgIHJldHVybiB0eXBlTGVuZ3RoKGluZm8sIHR5cGUudHlwZSkgKyAyO1xuICAgIGNhc2UgVHlwZUtpbmQuRnVuY3Rpb246XG4gICAgICByZXR1cm4gMiArIGZ1bmNMZW5ndGgoaW5mbywgdHlwZSk7XG4gICAgY2FzZSBUeXBlS2luZC5QYXJhbTpcbiAgICAgIHJldHVybiBpbmZvICYmIGluZm8ucHJvcE1hcFtpbmZvLmRlZmluaW5nICsgJzwnICsgdHlwZS5wYXJhbV1cbiAgICAgICAgPyB0eXBlTGVuZ3RoKG51bGwsIGluZm8ucHJvcE1hcFtpbmZvLmRlZmluaW5nICsgJzwnICsgdHlwZS5wYXJhbV0pXG4gICAgICAgIDogdHlwZS5wYXJhbS5sZW5ndGg7XG4gICAgY2FzZSBUeXBlS2luZC5UeXBlOlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKHR5cGUucXVhbGlmaWVyID8gMSArIHR5cGUucXVhbGlmaWVyLmpvaW4oJy4nKS5sZW5ndGggOiAwKSArXG4gICAgICAgIHR5cGUubmFtZS5sZW5ndGggK1xuICAgICAgICAoIXR5cGUuYXJnc1xuICAgICAgICAgID8gMFxuICAgICAgICAgIDogdHlwZS5hcmdzLnJlZHVjZShcbiAgICAgICAgICAgICAgZnVuY3Rpb24ocywgYSkgIHtyZXR1cm4gcyArIHR5cGVMZW5ndGgoaW5mbywgYSk7fSxcbiAgICAgICAgICAgICAgdHlwZS5hcmdzLmxlbmd0aCAqIDJcbiAgICAgICAgICAgICkpXG4gICAgICApO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVHlwZSB3aXRoIHVua25vd24ga2luZCAnICsgSlNPTi5zdHJpbmdpZnkodHlwZSkpO1xufVxuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBTVkdTZXQgPSByZXF1aXJlKCcuLi8uLi9zcmMvU1ZHU2V0Jyk7XG52YXIgTG9nbyA9IHJlcXVpcmUoJy4uLy4uL3NyYy9Mb2dvJyk7XG52YXIgcGFja2FnZUpzb24gPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9wYWNrYWdlLmpzb24nKTtcblxudmFyIERvY0hlYWRlciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJEb2NIZWFkZXJcIixcbiAgcmVuZGVyOmZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtjbGFzc05hbWU6IFwiaGVhZGVyXCJ9LCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7Y2xhc3NOYW1lOiBcIm1pbmlIZWFkZXJcIn0sIFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2NsYXNzTmFtZTogXCJtaW5pSGVhZGVyQ29udGVudHNcIn0sIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwge2hyZWY6IFwiLi4vXCIsIHRhcmdldDogXCJfc2VsZlwiLCBjbGFzc05hbWU6IFwibWluaUxvZ29cIn0sIFxuICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFNWR1NldCwgbnVsbCwgXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChMb2dvLCB7Y29sb3I6IFwiI0ZDNDM0OVwifSksIFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTG9nbywge2NvbG9yOiBcIiMyQzNFNTBcIiwgaW5saW5lOiB0cnVlfSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7aHJlZjogXCIuL1wiLCB0YXJnZXQ6IFwiX3NlbGZcIn0sIFxuICAgICAgICAgICAgICBcIkRvY3MgKHZcIiwgXG4gICAgICAgICAgICAgIHBhY2thZ2VKc29uLnZlcnNpb24sIFwiKVwiXG4gICAgICAgICAgICApLCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHtocmVmOiBcImh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zL3RhZ2dlZC9pbW11dGFibGUuanM/c29ydD12b3Rlc1wifSwgXG4gICAgICAgICAgICAgIFwiUXVlc3Rpb25zXCJcbiAgICAgICAgICAgICksIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwge2hyZWY6IFwiaHR0cHM6Ly9naXRodWIuY29tL2ltbXV0YWJsZS1qcy9pbW11dGFibGUtanMvXCJ9LCBcIkdpdGh1YlwiKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gIH0sXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEb2NIZWFkZXI7XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJvdXRlciA9IHJlcXVpcmUoJ3JlYWN0LXJvdXRlcicpO1xudmFyICRfXzA9ICAgIHJlcXVpcmUoJy4uLy4uLy4uLy4uLycpLFNlcT0kX18wLlNlcTtcbnZhciBNYXJrZG93biA9IHJlcXVpcmUoJy4vTWFya0Rvd24nKTtcblxudmFyIERvY092ZXJ2aWV3ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiBcIkRvY092ZXJ2aWV3XCIsXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICB2YXIgZGVmID0gdGhpcy5wcm9wcy5kZWY7XG4gICAgdmFyIGRvYyA9IGRlZi5kb2M7XG5cbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCBcbiAgICAgICAgZG9jICYmIChcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiLCBudWxsLCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFya2Rvd24sIHtjb250ZW50czogZG9jLnN5bm9wc2lzfSksIFxuICAgICAgICAgICAgZG9jLmRlc2NyaXB0aW9uICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFya2Rvd24sIHtjb250ZW50czogZG9jLmRlc2NyaXB0aW9ufSlcbiAgICAgICAgICApXG4gICAgICAgICksIFxuXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImdyb3VwVGl0bGVcIn0sIFwiQVBJXCIpLCBcblxuICAgICAgICBTZXEoZGVmLm1vZHVsZSlcbiAgICAgICAgICAubWFwKGZ1bmN0aW9uKHQsIG5hbWUpICB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9ICF0LmludGVyZmFjZSAmJiAhdC5tb2R1bGU7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbikge1xuICAgICAgICAgICAgICB0ID0gdC5jYWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwge2tleTogbmFtZSwgY2xhc3NOYW1lOiBcImludGVyZmFjZU1lbWJlclwifSwgXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImgzXCIsIHtjbGFzc05hbWU6IFwibWVtYmVyTGFiZWxcIn0sIFxuICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIuTGluaywge3RvOiAnLycgKyBuYW1lfSwgXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgKyAoaXNGdW5jdGlvbiA/ICcoKScgOiAnJylcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLCBcbiAgICAgICAgICAgICAgICB0LmRvYyAmJiAoXG4gICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1hcmtkb3duLCB7Y2xhc3NOYW1lOiBcImRldGFpbFwiLCBjb250ZW50czogdC5kb2Muc3lub3BzaXN9KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC52YWx1ZVNlcSgpXG4gICAgICAgICAgLnRvQXJyYXkoKVxuICAgICAgKVxuICAgICk7XG4gIH0sXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEb2NPdmVydmlldztcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBEb2NTZWFyY2ggPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiRG9jU2VhcmNoXCIsXG4gIGdldEluaXRpYWxTdGF0ZTpmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geyBlbmFibGVkOiB0cnVlIH07XG4gIH0sXG4gIGNvbXBvbmVudERpZE1vdW50OmZ1bmN0aW9uKCkge1xuICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICB2YXIgZmlyc3RTY3JpcHQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF07XG4gICAgc2NyaXB0LnNyYyA9XG4gICAgICAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9kb2NzZWFyY2guanNAMi41LjIvZGlzdC9jZG4vZG9jc2VhcmNoLm1pbi5qcyc7XG4gICAgc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAnbG9hZCcsXG4gICAgICBmdW5jdGlvbigpICB7XG4gICAgICAgIC8vIEluaXRpYWxpemUgQWxnb2xpYSBzZWFyY2guXG4gICAgICAgIGlmICh3aW5kb3cuZG9jc2VhcmNoKSB7XG4gICAgICAgICAgd2luZG93LmRvY3NlYXJjaCh7XG4gICAgICAgICAgICBhcGlLZXk6ICc4M2Y2MWY4NjVlZjRjYjY4MmUwNDMyNDEwYzJmNzgwOScsXG4gICAgICAgICAgICBpbmRleE5hbWU6ICdpbW11dGFibGVfanMnLFxuICAgICAgICAgICAgaW5wdXRTZWxlY3RvcjogJyNhbGdvbGlhLWRvY3NlYXJjaCcsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGVuYWJsZWQ6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcyksXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgZmlyc3RTY3JpcHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2NyaXB0LCBmaXJzdFNjcmlwdCk7XG5cbiAgICB2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcbiAgICB2YXIgZmlyc3RMaW5rID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2xpbmsnKVswXTtcbiAgICBsaW5rLnJlbCA9ICdzdHlsZXNoZWV0JztcbiAgICBsaW5rLmhyZWYgPVxuICAgICAgJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vZG9jc2VhcmNoLmpzQDIuNS4yL2Rpc3QvY2RuL2RvY3NlYXJjaC5taW4uY3NzJztcbiAgICBmaXJzdExpbmsucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobGluaywgZmlyc3RMaW5rKTtcbiAgfSxcbiAgcmVuZGVyOmZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmVuYWJsZWQgPyAoXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwge1xuICAgICAgICBpZDogXCJhbGdvbGlhLWRvY3NlYXJjaFwiLCBcbiAgICAgICAgY2xhc3NOYW1lOiBcImRvY1NlYXJjaFwiLCBcbiAgICAgICAgdHlwZTogXCJzZWFyY2hcIiwgXG4gICAgICAgIHBsYWNlaG9sZGVyOiBcIlNlYXJjaCBJbW11dGFibGUuanMgRG9jdW1lbnRhdGlvblwifVxuICAgICAgKVxuICAgICkgOiBudWxsO1xuICB9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRG9jU2VhcmNoO1xuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIE1hcmtEb3duID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiBcIk1hcmtEb3duXCIsXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZTpmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgcmVuZGVyOmZ1bmN0aW9uKCkge1xuICAgIHZhciBodG1sID0gdGhpcy5wcm9wcy5jb250ZW50cztcbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogdGhpcy5wcm9wcy5jbGFzc05hbWUsIFxuICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogeyBfX2h0bWw6IGh0bWx9fVxuICAgICAgKVxuICAgICk7XG4gIH0sXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXJrRG93bjtcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUmVhY3RUcmFuc2l0aW9uRXZlbnRzID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0VHJhbnNpdGlvbkV2ZW50cycpO1xudmFyIFJvdXRlciA9IHJlcXVpcmUoJ3JlYWN0LXJvdXRlcicpO1xudmFyICRfXzA9ICAgICByZXF1aXJlKCcuL0RlZnMnKSxDYWxsU2lnRGVmPSRfXzAuQ2FsbFNpZ0RlZixNZW1iZXJEZWY9JF9fMC5NZW1iZXJEZWY7XG52YXIgUGFnZURhdGFNaXhpbiA9IHJlcXVpcmUoJy4vUGFnZURhdGFNaXhpbicpO1xudmFyIGlzTW9iaWxlID0gcmVxdWlyZSgnLi9pc01vYmlsZScpO1xudmFyIE1hcmtEb3duID0gcmVxdWlyZSgnLi9NYXJrRG93bicpO1xuXG52YXIgJF9fMT0gICAgUmVhY3QuYWRkb25zLFRyYW5zaXRpb25Hcm91cD0kX18xLlRyYW5zaXRpb25Hcm91cDtcblxudmFyIE1lbWJlckRvYyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJNZW1iZXJEb2NcIixcbiAgbWl4aW5zOiBbUGFnZURhdGFNaXhpbiwgUm91dGVyLk5hdmlnYXRpb25dLFxuXG4gIGdldEluaXRpYWxTdGF0ZTpmdW5jdGlvbigpIHtcbiAgICB2YXIgc2hvd0RldGFpbCA9IHRoaXMucHJvcHMuc2hvd0RldGFpbDtcbiAgICByZXR1cm4geyBkZXRhaWw6IHNob3dEZXRhaWwgfTtcbiAgfSxcblxuICBjb21wb25lbnREaWRNb3VudDpmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5zaG93RGV0YWlsKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0RE9NTm9kZSgpO1xuICAgICAgdmFyIG5hdlR5cGUgPSB0aGlzLmdldFBhZ2VEYXRhKCkudHlwZTtcbiAgICAgIGlmIChuYXZUeXBlID09PSAnaW5pdCcgfHwgbmF2VHlwZSA9PT0gJ3B1c2gnKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbyh3aW5kb3cuc2Nyb2xsWCwgb2Zmc2V0VG9wKG5vZGUpIC0gRklYRURfSEVBREVSX0hFSUdIVCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6ZnVuY3Rpb24obmV4dFByb3BzKSB7XG4gICAgaWYgKG5leHRQcm9wcy5zaG93RGV0YWlsICYmICF0aGlzLnByb3BzLnNob3dEZXRhaWwpIHtcbiAgICAgIHRoaXMuc2Nyb2xsVG8gPSB0cnVlO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGRldGFpbDogdHJ1ZSB9KTtcbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkVXBkYXRlOmZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnNjcm9sbFRvKSB7XG4gICAgICB0aGlzLnNjcm9sbFRvID0gZmFsc2U7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0RE9NTm9kZSgpO1xuICAgICAgdmFyIG5hdlR5cGUgPSB0aGlzLmdldFBhZ2VEYXRhKCkudHlwZTtcbiAgICAgIGlmIChuYXZUeXBlID09PSAnaW5pdCcgfHwgbmF2VHlwZSA9PT0gJ3B1c2gnKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbyh3aW5kb3cuc2Nyb2xsWCwgb2Zmc2V0VG9wKG5vZGUpIC0gRklYRURfSEVBREVSX0hFSUdIVCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHRvZ2dsZURldGFpbDpmdW5jdGlvbigpIHtcbiAgICAvLyBOb3RlOiByZW1vdmVkIHRoaXMgYmVjYXVzZSBpdCBkcm9wcyB0aGUgVVJMIGJhciBvbiBtb2JpbGUsIGFuZCB0aGF0J3NcbiAgICAvLyB0aGUgb25seSBwbGFjZSBpdCdzIGN1cnJlbnRseSBiZWluZyB1c2VkLlxuICAgIC8vIHZhciBtZW1iZXIgPSB0aGlzLnByb3BzLm1lbWJlcjtcbiAgICAvLyB2YXIgbmFtZSA9IG1lbWJlci5tZW1iZXJOYW1lO1xuICAgIC8vIHZhciB0eXBlTmFtZSA9IHRoaXMucHJvcHMucGFyZW50TmFtZTtcbiAgICAvLyB2YXIgc2hvd0RldGFpbCA9IHRoaXMucHJvcHMuc2hvd0RldGFpbDtcbiAgICAvLyBpZiAoIXRoaXMuc3RhdGUuZGV0YWlsKSB7XG4gICAgLy8gICB0aGlzLnJlcGxhY2VXaXRoKCcvJyArICh0eXBlTmFtZSA/IHR5cGVOYW1lICsgJy8nIDogJycpICsgbmFtZSApO1xuICAgIC8vIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5kZXRhaWwgJiYgc2hvd0RldGFpbCkge1xuICAgIC8vICAgdGhpcy5yZXBsYWNlV2l0aCgnLycgKyAodHlwZU5hbWUgfHwgJycpICk7XG4gICAgLy8gfVxuICAgIHRoaXMuc2V0U3RhdGUoeyBkZXRhaWw6ICF0aGlzLnN0YXRlLmRldGFpbCB9KTtcbiAgfSxcblxuICByZW5kZXI6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIHR5cGVQcm9wTWFwID0gdGhpcy5wcm9wcy50eXBlUHJvcE1hcDtcbiAgICB2YXIgbWVtYmVyID0gdGhpcy5wcm9wcy5tZW1iZXI7XG4gICAgdmFyIG1vZHVsZSA9IG1lbWJlci5pc1N0YXRpYyA/IHRoaXMucHJvcHMucGFyZW50TmFtZSA6IG51bGw7XG4gICAgdmFyIG5hbWUgPSBtZW1iZXIubWVtYmVyTmFtZTtcbiAgICB2YXIgZGVmID0gbWVtYmVyLm1lbWJlckRlZjtcbiAgICB2YXIgZG9jID0gZGVmLmRvYyB8fCB7fTtcbiAgICB2YXIgaXNQcm9wID0gIWRlZi5zaWduYXR1cmVzO1xuXG4gICAgdmFyIHR5cGVJbmZvID0gbWVtYmVyLmluaGVyaXRlZCAmJiB7XG4gICAgICBwcm9wTWFwOiB0eXBlUHJvcE1hcCxcbiAgICAgIGRlZmluaW5nOiBtZW1iZXIuaW5oZXJpdGVkLm5hbWUsXG4gICAgfTtcblxuICAgIHZhciBzaG93RGV0YWlsID0gaXNNb2JpbGUgPyB0aGlzLnN0YXRlLmRldGFpbCA6IHRydWU7XG5cbiAgICB2YXIgbWVtYmVyQW5jaG9yTGluayA9IHRoaXMucHJvcHMucGFyZW50TmFtZSArICcvJyArIG5hbWU7XG5cbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7Y2xhc3NOYW1lOiBcImludGVyZmFjZU1lbWJlclwifSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoM1wiLCB7Y2xhc3NOYW1lOiBcIm1lbWJlckxhYmVsXCJ9LCBcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlci5MaW5rLCB7XG4gICAgICAgICAgICB0bzogJy8nICsgbWVtYmVyQW5jaG9yTGluaywgXG4gICAgICAgICAgICBvbkNsaWNrOiBpc01vYmlsZSA/IHRoaXMudG9nZ2xlRGV0YWlsIDogbnVsbFxuICAgICAgICAgIH0sIFxuICAgICAgICAgICAgKG1vZHVsZSA/IG1vZHVsZSArICcuJyA6ICcnKSArIG5hbWUgKyAoaXNQcm9wID8gJycgOiAnKCknKVxuICAgICAgICAgIClcbiAgICAgICAgKSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVHJhbnNpdGlvbkdyb3VwLCB7Y2hpbGRGYWN0b3J5OiBtYWtlU2xpZGVEb3dufSwgXG4gICAgICAgICAgc2hvd0RldGFpbCAmJiAoXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtrZXk6IFwiZGV0YWlsXCIsIGNsYXNzTmFtZTogXCJkZXRhaWxcIn0sIFxuICAgICAgICAgICAgICBkb2Muc3lub3BzaXMgJiYgKFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFya0Rvd24sIHtjbGFzc05hbWU6IFwic3lub3BzaXNcIiwgY29udGVudHM6IGRvYy5zeW5vcHNpc30pXG4gICAgICAgICAgICAgICksIFxuICAgICAgICAgICAgICBpc1Byb3AgPyAoXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImNvZGVcIiwge2NsYXNzTmFtZTogXCJjb2RlQmxvY2sgbWVtYmVyU2lnbmF0dXJlXCJ9LCBcbiAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtYmVyRGVmLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZTogbW9kdWxlLCBcbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyOiB7IG5hbWU6bmFtZSwgdHlwZTogZGVmLnR5cGV9fVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCB7Y2xhc3NOYW1lOiBcImNvZGVCbG9jayBtZW1iZXJTaWduYXR1cmVcIn0sIFxuICAgICAgICAgICAgICAgICAgZGVmLnNpZ25hdHVyZXMubWFwKGZ1bmN0aW9uKGNhbGxTaWcsIGkpICB7cmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDYWxsU2lnRGVmLCB7XG4gICAgICAgICAgICAgICAgICAgICAga2V5OiBpLCBcbiAgICAgICAgICAgICAgICAgICAgICBpbmZvOiB0eXBlSW5mbywgXG4gICAgICAgICAgICAgICAgICAgICAgbW9kdWxlOiBtb2R1bGUsIFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsIFxuICAgICAgICAgICAgICAgICAgICAgIGNhbGxTaWc6IGNhbGxTaWd9XG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICdcXG4nLFxuICAgICAgICAgICAgICAgICAgXTt9KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKSwgXG4gICAgICAgICAgICAgIG1lbWJlci5pbmhlcml0ZWQgJiYgKFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIsIG51bGwsIFxuICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg0XCIsIHtjbGFzc05hbWU6IFwiaW5mb0hlYWRlclwifSwgXCJJbmhlcml0ZWQgZnJvbVwiKSwgXG4gICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCBudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIuTGluaywge3RvOiAnLycgKyBtZW1iZXIuaW5oZXJpdGVkLm5hbWUgKyAnLycgKyBuYW1lfSwgXG4gICAgICAgICAgICAgICAgICAgICAgbWVtYmVyLmluaGVyaXRlZC5uYW1lICsgJyMnICsgbmFtZVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApLCBcbiAgICAgICAgICAgICAgbWVtYmVyLm92ZXJyaWRlcyAmJiAoXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwgbnVsbCwgXG4gICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDRcIiwge2NsYXNzTmFtZTogXCJpbmZvSGVhZGVyXCJ9LCBcIk92ZXJyaWRlc1wiKSwgXG4gICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCBudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIuTGluaywge3RvOiAnLycgKyBtZW1iZXIub3ZlcnJpZGVzLm5hbWUgKyAnLycgKyBuYW1lfSwgXG4gICAgICAgICAgICAgICAgICAgICAgbWVtYmVyLm92ZXJyaWRlcy5uYW1lICsgJyMnICsgbmFtZVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApLCBcbiAgICAgICAgICAgICAgZG9jLm5vdGVzICYmXG4gICAgICAgICAgICAgICAgZG9jLm5vdGVzLm1hcChmdW5jdGlvbihub3RlLCBpKSAgXG4gICAgICAgICAgICAgICAgICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIsIHtrZXk6IGl9LCBcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg0XCIsIHtjbGFzc05hbWU6IFwiaW5mb0hlYWRlclwifSwgbm90ZS5uYW1lKSwgXG4gICAgICAgICAgICAgICAgICAgIG5vdGUubmFtZSA9PT0gJ2FsaWFzJyA/IChcbiAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCBudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FsbFNpZ0RlZiwge25hbWU6IG5vdGUuYm9keX0pXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFya0Rvd24sIHtjbGFzc05hbWU6IFwiZGlzY3Vzc2lvblwiLCBjb250ZW50czogbm90ZS5ib2R5fSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKTt9XG4gICAgICAgICAgICAgICAgKSwgXG4gICAgICAgICAgICAgIGRvYy5kZXNjcmlwdGlvbiAmJiAoXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwgbnVsbCwgXG4gICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDRcIiwge2NsYXNzTmFtZTogXCJpbmZvSGVhZGVyXCJ9LCBcbiAgICAgICAgICAgICAgICAgICAgZG9jLmRlc2NyaXB0aW9uLnN1YnN0cigwLCA1KSA9PT0gJzxjb2RlJ1xuICAgICAgICAgICAgICAgICAgICAgID8gJ0V4YW1wbGUnXG4gICAgICAgICAgICAgICAgICAgICAgOiAnRGlzY3Vzc2lvbidcbiAgICAgICAgICAgICAgICAgICksIFxuICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChNYXJrRG93biwge2NsYXNzTmFtZTogXCJkaXNjdXNzaW9uXCIsIGNvbnRlbnRzOiBkb2MuZGVzY3JpcHRpb259KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gIH0sXG59KTtcblxuZnVuY3Rpb24gbWFrZVNsaWRlRG93bihjaGlsZCkge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChTbGlkZURvd24sIG51bGwsIGNoaWxkKTtcbn1cblxudmFyIFNsaWRlRG93biA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJTbGlkZURvd25cIixcbiAgY29tcG9uZW50V2lsbEVudGVyOmZ1bmN0aW9uKGRvbmUpIHtcbiAgICB0aGlzLnNsaWRlKGZhbHNlLCBkb25lKTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsTGVhdmU6ZnVuY3Rpb24oZG9uZSkge1xuICAgIHRoaXMuc2xpZGUodHJ1ZSwgZG9uZSk7XG4gIH0sXG5cbiAgc2xpZGU6ZnVuY3Rpb24oc2xpZGluZ1VwLCBkb25lKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLmdldERPTU5vZGUoKTtcbiAgICBub2RlLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICB2YXIgaGVpZ2h0ID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5oZWlnaHQ7XG4gICAgdmFyIHN0YXJ0ID0gc2xpZGluZ1VwID8gaGVpZ2h0IDogMDtcbiAgICB2YXIgZW5kID0gc2xpZGluZ1VwID8gMCA6IGhlaWdodDtcbiAgICBub2RlLnN0eWxlLnRyYW5zaXRpb24gPSAnJztcbiAgICBub2RlLnN0eWxlLmhlaWdodCA9IHN0YXJ0O1xuICAgIG5vZGUuc3R5bGUudHJhbnNpdGlvbiA9ICdoZWlnaHQgMC4zNXMgZWFzZS1pbi1vdXQnO1xuICAgIHZhciBlbmRMaXN0ZW5lciA9IGZ1bmN0aW9uKCkgIHtcbiAgICAgIFJlYWN0VHJhbnNpdGlvbkV2ZW50cy5yZW1vdmVFbmRFdmVudExpc3RlbmVyKG5vZGUsIGVuZExpc3RlbmVyKTtcbiAgICAgIGRvbmUoKTtcbiAgICB9O1xuICAgIFJlYWN0VHJhbnNpdGlvbkV2ZW50cy5hZGRFbmRFdmVudExpc3RlbmVyKG5vZGUsIGVuZExpc3RlbmVyKTtcbiAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgIHtcbiAgICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gZW5kO1xuICAgIH0sIDE3KTtcbiAgfSxcblxuICByZW5kZXI6ZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gIH0sXG59KTtcblxudmFyIEZJWEVEX0hFQURFUl9IRUlHSFQgPSA3NTtcblxuZnVuY3Rpb24gb2Zmc2V0VG9wKG5vZGUpIHtcbiAgdmFyIHRvcCA9IDA7XG4gIGRvIHtcbiAgICB0b3AgKz0gbm9kZS5vZmZzZXRUb3A7XG4gIH0gd2hpbGUgKChub2RlID0gbm9kZS5vZmZzZXRQYXJlbnQpKTtcbiAgcmV0dXJuIHRvcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNZW1iZXJEb2M7XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29udGV4dFR5cGVzOiB7XG4gICAgZ2V0UGFnZURhdGE6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG1vc3QgcmVjZW50IGNoYW5nZSBldmVudC5cbiAgICovXG4gIGdldFBhZ2VEYXRhOmZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuZ2V0UGFnZURhdGEoKTtcbiAgfSxcbn07XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJvdXRlciA9IHJlcXVpcmUoJ3JlYWN0LXJvdXRlcicpO1xudmFyICRfXzA9ICAgICByZXF1aXJlKCcuLi8uLi8uLi8uLi8nKSxNYXA9JF9fMC5NYXAsU2VxPSRfXzAuU2VxO1xudmFyIGRlZnMgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvZ2V0VHlwZURlZnMnKTtcblxudmFyIFNpZGVCYXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiU2lkZUJhclwiLFxuICByZW5kZXI6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIHR5cGUgPSBkZWZzLkltbXV0YWJsZTtcblxuICAgIHJldHVybiAoXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtjbGFzc05hbWU6IFwic2lkZUJhclwifSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2NsYXNzTmFtZTogXCJ0b29sQmFyXCJ9LCBcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMucHJvcHMudG9nZ2xlU2hvd0luR3JvdXBzLCBcbiAgICAgICAgICAgIG9uS2V5UHJlc3M6IHRoaXMucHJvcHMudG9nZ2xlU2hvd0luR3JvdXBzXG4gICAgICAgICAgfSwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7Y2xhc3NOYW1lOiB0aGlzLnByb3BzLnNob3dJbkdyb3VwcyAmJiAnc2VsZWN0ZWQnfSwgXG4gICAgICAgICAgICAgIFwiR3JvdXBlZFwiXG4gICAgICAgICAgICApLCBcbiAgICAgICAgICAgICcg4oCiICcsIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogdGhpcy5wcm9wcy5zaG93SW5Hcm91cHMgfHwgJ3NlbGVjdGVkJ30sIFxuICAgICAgICAgICAgICBcIkFscGhhYmV0aXplZFwiXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSwgXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgICBvbkNsaWNrOiB0aGlzLnByb3BzLnRvZ2dsZVNob3dJbmhlcml0ZWQsIFxuICAgICAgICAgICAgb25LZXlQcmVzczogdGhpcy5wcm9wcy50b2dnbGVTaG93SW5oZXJpdGVkXG4gICAgICAgICAgfSwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7Y2xhc3NOYW1lOiB0aGlzLnByb3BzLnNob3dJbmhlcml0ZWQgJiYgJ3NlbGVjdGVkJ30sIFxuICAgICAgICAgICAgICBcIkluaGVyaXRlZFwiXG4gICAgICAgICAgICApLCBcbiAgICAgICAgICAgICcg4oCiICcsIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogdGhpcy5wcm9wcy5zaG93SW5oZXJpdGVkIHx8ICdzZWxlY3RlZCd9LCBcbiAgICAgICAgICAgICAgXCJEZWZpbmVkXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgICksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtjbGFzc05hbWU6IFwic2Nyb2xsQ29udGVudFwifSwgXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg0XCIsIHtjbGFzc05hbWU6IFwiZ3JvdXBUaXRsZVwifSwgXCJBUElcIiksIFxuICAgICAgICAgIFNlcSh0eXBlLm1vZHVsZSlcbiAgICAgICAgICAgIC5mbGF0TWFwKGZ1bmN0aW9uKHQsIG5hbWUpICB7cmV0dXJuIGZsYXR0ZW5TdWJtb2R1bGVzKE1hcCgpLCB0LCBuYW1lKTt9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbih0LCBuYW1lKSAge3JldHVybiB0aGlzLnJlbmRlclNpZGVCYXJUeXBlKG5hbWUsIHQpO30uYmluZCh0aGlzKSlcbiAgICAgICAgICAgIC52YWx1ZVNlcSgpXG4gICAgICAgICAgICAudG9BcnJheSgpXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9LFxuXG4gIHJlbmRlclNpZGVCYXJUeXBlOmZ1bmN0aW9uKHR5cGVOYW1lLCB0eXBlKSB7XG4gICAgdmFyIGlzRm9jdXMgPSB0aGlzLnByb3BzLmZvY3VzID09PSB0eXBlTmFtZTtcbiAgICB2YXIgaXNGdW5jdGlvbiA9ICF0eXBlLmludGVyZmFjZSAmJiAhdHlwZS5tb2R1bGU7XG4gICAgdmFyIGNhbGwgPSB0eXBlLmNhbGw7XG4gICAgdmFyIGZ1bmN0aW9ucyA9IFNlcSh0eXBlLm1vZHVsZSkuZmlsdGVyKGZ1bmN0aW9uKHQpICB7cmV0dXJuICF0LmludGVyZmFjZSAmJiAhdC5tb2R1bGU7fSk7XG5cbiAgICB2YXIgbGFiZWwgPSB0eXBlTmFtZSArIChpc0Z1bmN0aW9uID8gJygpJyA6ICcnKTtcblxuICAgIGlmICghaXNGb2N1cykge1xuICAgICAgbGFiZWwgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlci5MaW5rLCB7dG86ICcvJyArIHR5cGVOYW1lfSwgbGFiZWwpO1xuICAgIH1cblxuICAgIHZhciBtZW1iZXJHcm91cHMgPSB0aGlzLnByb3BzLm1lbWJlckdyb3VwcztcblxuICAgIHZhciBtZW1iZXJzID1cbiAgICAgICFpc0ZvY3VzIHx8IGlzRnVuY3Rpb24gPyBudWxsIDogKFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtjbGFzc05hbWU6IFwibWVtYmVyc1wifSwgXG4gICAgICAgICAgY2FsbCAmJiAoXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiLCBudWxsLCBcbiAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg0XCIsIHtjbGFzc05hbWU6IFwiZ3JvdXBUaXRsZVwifSwgXCJDb25zdHJ1Y3Rpb25cIiksIFxuICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwsIFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLkxpbmssIHt0bzogJy8nICsgdHlwZU5hbWUgKyAnLycgKyB0eXBlTmFtZX0sIFxuICAgICAgICAgICAgICAgICAgdHlwZU5hbWUgKyAnKCknXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSwgXG5cbiAgICAgICAgICBmdW5jdGlvbnMuY291bnQoKSA+IDAgJiYgKFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwgbnVsbCwgXG4gICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImdyb3VwVGl0bGVcIn0sIFwiU3RhdGljIE1ldGhvZHNcIiksIFxuICAgICAgICAgICAgICBmdW5jdGlvbnNcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHQsIG5hbWUpICBcbiAgICAgICAgICAgICAgICAgIHtyZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7a2V5OiBuYW1lfSwgXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLkxpbmssIHt0bzogJy8nICsgdHlwZU5hbWUgKyAnLycgKyBuYW1lfSwgXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZU5hbWUgKyAnLicgKyBuYW1lICsgJygpJ1xuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICApO31cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgLnZhbHVlU2VxKClcbiAgICAgICAgICAgICAgICAudG9BcnJheSgpXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSwgXG5cbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiLCBudWxsLCBcbiAgICAgICAgICAgIFNlcShtZW1iZXJHcm91cHMpXG4gICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24obWVtYmVycywgdGl0bGUpIFxuICAgICAgICAgICAgICAgIHtyZXR1cm4gbWVtYmVycy5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgOiBTZXEoW1xuICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7a2V5OiB0aXRsZSB8fCAnTWVtYmVycycsIGNsYXNzTmFtZTogXCJncm91cFRpdGxlXCJ9LCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlIHx8ICdNZW1iZXJzJ1xuICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgU2VxKG1lbWJlcnMpLm1hcChmdW5jdGlvbihtZW1iZXIpICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHtyZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7a2V5OiBtZW1iZXIubWVtYmVyTmFtZX0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlci5MaW5rLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86ICcvJyArIHR5cGVOYW1lICsgJy8nICsgbWVtYmVyLm1lbWJlck5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVtYmVyLm1lbWJlck5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1lbWJlci5tZW1iZXJEZWYuc2lnbmF0dXJlcyA/ICcoKScgOiAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTt9XG4gICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgXSk7fVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIC5mbGF0dGVuKClcbiAgICAgICAgICAgICAgLnZhbHVlU2VxKClcbiAgICAgICAgICAgICAgLnRvQXJyYXkoKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtrZXk6IHR5cGVOYW1lfSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoMlwiLCBudWxsLCBsYWJlbCksIFxuICAgICAgICBtZW1iZXJzXG4gICAgICApXG4gICAgKTtcbiAgfSxcbn0pO1xuXG5mdW5jdGlvbiBmbGF0dGVuU3VibW9kdWxlcyhtb2R1bGVzLCB0eXBlLCBuYW1lKSB7XG4gIG1vZHVsZXMgPSBtb2R1bGVzLnNldChuYW1lLCB0eXBlKTtcbiAgcmV0dXJuIHR5cGUubW9kdWxlXG4gICAgPyBTZXEodHlwZS5tb2R1bGUpXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24odCkgIHtyZXR1cm4gdC5pbnRlcmZhY2UgfHwgdC5tb2R1bGU7fSlcbiAgICAgICAgLnJlZHVjZShcbiAgICAgICAgICBmdW5jdGlvbihtb2R1bGVzLCBzdWJULCBzdWJOYW1lKSBcbiAgICAgICAgICAgIHtyZXR1cm4gZmxhdHRlblN1Ym1vZHVsZXMobW9kdWxlcywgc3ViVCwgbmFtZSArICcuJyArIHN1Yk5hbWUpO30sXG4gICAgICAgICAgbW9kdWxlc1xuICAgICAgICApXG4gICAgOiBtb2R1bGVzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNpZGVCYXI7XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJvdXRlciA9IHJlcXVpcmUoJ3JlYWN0LXJvdXRlcicpO1xudmFyICRfXzA9ICAgIHJlcXVpcmUoJy4uLy4uLy4uLy4uLycpLFNlcT0kX18wLlNlcTtcbnZhciAkX18xPSAgICAgcmVxdWlyZSgnLi9EZWZzJyksSW50ZXJmYWNlRGVmPSRfXzEuSW50ZXJmYWNlRGVmLENhbGxTaWdEZWY9JF9fMS5DYWxsU2lnRGVmO1xudmFyIE1lbWJlckRvYyA9IHJlcXVpcmUoJy4vTWVtYmVyRG9jJyk7XG52YXIgaXNNb2JpbGUgPSByZXF1aXJlKCcuL2lzTW9iaWxlJyk7XG52YXIgU2lkZUJhciA9IHJlcXVpcmUoJy4vU2lkZUJhcicpO1xudmFyIE1hcmtEb3duID0gcmVxdWlyZSgnLi9NYXJrRG93bicpO1xudmFyIERvY092ZXJ2aWV3ID0gcmVxdWlyZSgnLi9Eb2NPdmVydmlldycpO1xudmFyIGNvbGxlY3RNZW1iZXJHcm91cHMgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvY29sbGVjdE1lbWJlckdyb3VwcycpO1xudmFyIFR5cGVLaW5kID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL1R5cGVLaW5kJyk7XG52YXIgZGVmcyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9nZXRUeXBlRGVmcycpO1xuXG52YXIgdHlwZURlZlVSTCA9XG4gICdodHRwczovL2dpdGh1Yi5jb20vaW1tdXRhYmxlLWpzL2ltbXV0YWJsZS1qcy9ibG9iL21haW4vdHlwZS1kZWZpbml0aW9ucy9JbW11dGFibGUuZC50cyc7XG52YXIgaXNzdWVzVVJMID0gJ2h0dHBzOi8vZ2l0aHViLmNvbS9pbW11dGFibGUtanMvaW1tdXRhYmxlLWpzL2lzc3Vlcyc7XG5cbnZhciBEaXNjbGFpbWVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIsIHtjbGFzc05hbWU6IFwiZGlzY2xhaW1lclwifSwgXG4gICAgICBcIlRoaXMgZG9jdW1lbnRhdGlvbiBpcyBnZW5lcmF0ZWQgZnJvbVwiLCAnICcsIFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwge2hyZWY6IHR5cGVEZWZVUkx9LCBcIkltbXV0YWJsZS5kLnRzXCIpLCBcIi4gUHVsbCByZXF1ZXN0cyBhbmRcIiwgJyAnLCBcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHtocmVmOiBpc3N1ZXNVUkx9LCBcIklzc3Vlc1wiKSwgXCIgd2VsY29tZS5cIlxuICAgIClcbiAgKTtcbn07XG5cbnZhciBUeXBlRG9jdW1lbnRhdGlvbiA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJUeXBlRG9jdW1lbnRhdGlvblwiLFxuICBnZXRJbml0aWFsU3RhdGU6ZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNob3dJbmhlcml0ZWQ6IHRydWUsXG4gICAgICBzaG93SW5Hcm91cHM6IHRydWUsXG4gICAgfTtcbiAgfSxcblxuICB0b2dnbGVTaG93SW5Hcm91cHM6ZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IHNob3dJbkdyb3VwczogIXRoaXMuc3RhdGUuc2hvd0luR3JvdXBzIH0pO1xuICB9LFxuXG4gIHRvZ2dsZVNob3dJbmhlcml0ZWQ6ZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IHNob3dJbmhlcml0ZWQ6ICF0aGlzLnN0YXRlLnNob3dJbmhlcml0ZWQgfSk7XG4gIH0sXG5cbiAgcmVuZGVyOmZ1bmN0aW9uKCkge1xuICAgIHZhciBuYW1lID0gdGhpcy5wcm9wcy5uYW1lO1xuICAgIHZhciBtZW1iZXJOYW1lID0gdGhpcy5wcm9wcy5tZW1iZXJOYW1lO1xuICAgIHZhciBkZWYgPSB0aGlzLnByb3BzLmRlZjtcblxuICAgIHZhciBtZW1iZXJHcm91cHMgPSBjb2xsZWN0TWVtYmVyR3JvdXBzKGRlZiAmJiBkZWYuaW50ZXJmYWNlLCB7XG4gICAgICBzaG93SW5Hcm91cHM6IHRoaXMuc3RhdGUuc2hvd0luR3JvdXBzLFxuICAgICAgc2hvd0luaGVyaXRlZDogdGhpcy5zdGF0ZS5zaG93SW5oZXJpdGVkLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgXG4gICAgICAgIGlzTW9iaWxlIHx8IChcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFNpZGVCYXIsIHtcbiAgICAgICAgICAgIGZvY3VzOiBuYW1lLCBcbiAgICAgICAgICAgIG1lbWJlckdyb3VwczogbWVtYmVyR3JvdXBzLCBcbiAgICAgICAgICAgIHRvZ2dsZVNob3dJbmhlcml0ZWQ6IHRoaXMudG9nZ2xlU2hvd0luaGVyaXRlZCwgXG4gICAgICAgICAgICB0b2dnbGVTaG93SW5Hcm91cHM6IHRoaXMudG9nZ2xlU2hvd0luR3JvdXBzLCBcbiAgICAgICAgICAgIHNob3dJbkdyb3VwczogdGhpcy5zdGF0ZS5zaG93SW5Hcm91cHMsIFxuICAgICAgICAgICAgc2hvd0luaGVyaXRlZDogdGhpcy5zdGF0ZS5zaG93SW5oZXJpdGVkfVxuICAgICAgICAgIClcbiAgICAgICAgKSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2tleTogbmFtZSwgY2xhc3NOYW1lOiBcImRvY0NvbnRlbnRzXCJ9LCBcbiAgICAgICAgICAhZGVmID8gKFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChOb3RGb3VuZCwgbnVsbClcbiAgICAgICAgICApIDogIW5hbWUgPyAoXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERvY092ZXJ2aWV3LCB7ZGVmOiBkZWZ9KVxuICAgICAgICAgICkgOiAhZGVmLmludGVyZmFjZSAmJiAhZGVmLm1vZHVsZSA/IChcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRnVuY3Rpb25Eb2MsIHtuYW1lOiBuYW1lLCBkZWY6IGRlZi5jYWxsfSlcbiAgICAgICAgICApIDogKFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChUeXBlRG9jLCB7XG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUsIFxuICAgICAgICAgICAgICBkZWY6IGRlZiwgXG4gICAgICAgICAgICAgIG1lbWJlck5hbWU6IG1lbWJlck5hbWUsIFxuICAgICAgICAgICAgICBtZW1iZXJHcm91cHM6IG1lbWJlckdyb3Vwc31cbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9LFxufSk7XG5cbmZ1bmN0aW9uIE5vdEZvdW5kKCkge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCBcIk5vdCBmb3VuZFwiKTtcbn1cblxudmFyIEZ1bmN0aW9uRG9jID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiBcIkZ1bmN0aW9uRG9jXCIsXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcbiAgICB2YXIgZGVmID0gdGhpcy5wcm9wcy5kZWY7XG4gICAgdmFyIGRvYyA9IGRlZi5kb2MgfHwge307XG5cbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImgxXCIsIHtjbGFzc05hbWU6IFwidHlwZUhlYWRlclwifSwgbmFtZSArICcoKScpLCBcbiAgICAgICAgZG9jLnN5bm9wc2lzICYmIChcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1hcmtEb3duLCB7Y2xhc3NOYW1lOiBcInN5bm9wc2lzXCIsIGNvbnRlbnRzOiBkb2Muc3lub3BzaXN9KVxuICAgICAgICApLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImNvZGVcIiwge2NsYXNzTmFtZTogXCJjb2RlQmxvY2sgbWVtYmVyU2lnbmF0dXJlXCJ9LCBcbiAgICAgICAgICBkZWYuc2lnbmF0dXJlcy5tYXAoZnVuY3Rpb24oY2FsbFNpZywgaSkgIHtyZXR1cm4gW1xuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDYWxsU2lnRGVmLCB7a2V5OiBpLCBuYW1lOiBuYW1lLCBjYWxsU2lnOiBjYWxsU2lnfSksXG4gICAgICAgICAgICAnXFxuJyxcbiAgICAgICAgICBdO30pXG4gICAgICAgICksIFxuICAgICAgICBkb2Mubm90ZXMgJiZcbiAgICAgICAgICBkb2Mubm90ZXMubWFwKGZ1bmN0aW9uKG5vdGUsIGkpICBcbiAgICAgICAgICAgIHtyZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwge2tleTogaX0sIFxuICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDRcIiwge2NsYXNzTmFtZTogXCJpbmZvSGVhZGVyXCJ9LCBub3RlLm5hbWUpLCBcbiAgICAgICAgICAgICAgbm90ZS5uYW1lID09PSAnYWxpYXMnID8gKFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FsbFNpZ0RlZiwge25hbWU6IG5vdGUuYm9keX0pXG4gICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgbm90ZS5ib2R5XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7fVxuICAgICAgICAgICksIFxuICAgICAgICBkb2MuZGVzY3JpcHRpb24gJiYgKFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIsIG51bGwsIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg0XCIsIHtjbGFzc05hbWU6IFwiaW5mb0hlYWRlclwifSwgXG4gICAgICAgICAgICAgIGRvYy5kZXNjcmlwdGlvbi5zdWJzdHIoMCwgNSkgPT09ICc8Y29kZSdcbiAgICAgICAgICAgICAgICA/ICdFeGFtcGxlJ1xuICAgICAgICAgICAgICAgIDogJ0Rpc2N1c3Npb24nXG4gICAgICAgICAgICApLCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFya0Rvd24sIHtjbGFzc05hbWU6IFwiZGlzY3Vzc2lvblwiLCBjb250ZW50czogZG9jLmRlc2NyaXB0aW9ufSlcbiAgICAgICAgICApXG4gICAgICAgICksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERpc2NsYWltZXIsIG51bGwpXG4gICAgICApXG4gICAgKTtcbiAgfSxcbn0pO1xuXG52YXIgVHlwZURvYyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJUeXBlRG9jXCIsXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcbiAgICB2YXIgZGVmID0gdGhpcy5wcm9wcy5kZWY7XG4gICAgdmFyIG1lbWJlck5hbWUgPSB0aGlzLnByb3BzLm1lbWJlck5hbWU7XG4gICAgdmFyIG1lbWJlckdyb3VwcyA9IHRoaXMucHJvcHMubWVtYmVyR3JvdXBzO1xuXG4gICAgdmFyIGRvYyA9IGRlZi5kb2MgfHwge307XG4gICAgdmFyIGNhbGwgPSBkZWYuY2FsbDtcbiAgICB2YXIgZnVuY3Rpb25zID0gU2VxKGRlZi5tb2R1bGUpLmZpbHRlcihmdW5jdGlvbih0KSAge3JldHVybiAhdC5pbnRlcmZhY2UgJiYgIXQubW9kdWxlO30pO1xuICAgIHZhciB0eXBlcyA9IFNlcShkZWYubW9kdWxlKS5maWx0ZXIoZnVuY3Rpb24odCkgIHtyZXR1cm4gdC5pbnRlcmZhY2UgfHwgdC5tb2R1bGU7fSk7XG4gICAgdmFyIGludGVyZmFjZURlZiA9IGRlZi5pbnRlcmZhY2U7XG4gICAgdmFyIHR5cGVQcm9wTWFwID0gZ2V0VHlwZVByb3BNYXAoaW50ZXJmYWNlRGVmKTtcblxuICAgIHJldHVybiAoXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwsIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDFcIiwge2NsYXNzTmFtZTogXCJ0eXBlSGVhZGVyXCJ9LCBuYW1lKSwgXG4gICAgICAgIGRvYy5zeW5vcHNpcyAmJiAoXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChNYXJrRG93biwge2NsYXNzTmFtZTogXCJzeW5vcHNpc1wiLCBjb250ZW50czogZG9jLnN5bm9wc2lzfSlcbiAgICAgICAgKSwgXG4gICAgICAgIGludGVyZmFjZURlZiAmJiAoXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImNvZGVcIiwge2NsYXNzTmFtZTogXCJjb2RlQmxvY2sgbWVtYmVyU2lnbmF0dXJlXCJ9LCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW50ZXJmYWNlRGVmLCB7bmFtZTogbmFtZSwgZGVmOiBpbnRlcmZhY2VEZWZ9KVxuICAgICAgICAgIClcbiAgICAgICAgKSwgXG5cbiAgICAgICAgZG9jLm5vdGVzICYmXG4gICAgICAgICAgZG9jLm5vdGVzLm1hcChmdW5jdGlvbihub3RlLCBpKSAgXG4gICAgICAgICAgICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIsIHtrZXk6IGl9LCBcbiAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg0XCIsIHtjbGFzc05hbWU6IFwiaW5mb0hlYWRlclwifSwgbm90ZS5uYW1lKSwgXG4gICAgICAgICAgICAgIG5vdGUubmFtZSA9PT0gJ2FsaWFzJyA/IChcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENhbGxTaWdEZWYsIHtuYW1lOiBub3RlLmJvZHl9KVxuICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgIG5vdGUuYm9keVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO31cbiAgICAgICAgICApLCBcblxuICAgICAgICBkb2MuZGVzY3JpcHRpb24gJiYgKFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIsIG51bGwsIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg0XCIsIHtjbGFzc05hbWU6IFwiaW5mb0hlYWRlclwifSwgXG4gICAgICAgICAgICAgIGRvYy5kZXNjcmlwdGlvbi5zdWJzdHIoMCwgNSkgPT09ICc8Y29kZSdcbiAgICAgICAgICAgICAgICA/ICdFeGFtcGxlJ1xuICAgICAgICAgICAgICAgIDogJ0Rpc2N1c3Npb24nXG4gICAgICAgICAgICApLCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFya0Rvd24sIHtjbGFzc05hbWU6IFwiZGlzY3Vzc2lvblwiLCBjb250ZW50czogZG9jLmRlc2NyaXB0aW9ufSlcbiAgICAgICAgICApXG4gICAgICAgICksIFxuXG4gICAgICAgIHR5cGVzLmNvdW50KCkgPiAwICYmIChcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiLCBudWxsLCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImdyb3VwVGl0bGVcIn0sIFwiU3ViLXR5cGVzXCIpLCBcbiAgICAgICAgICAgIHR5cGVzXG4gICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24odCwgdHlwZU5hbWUpICBcbiAgICAgICAgICAgICAgICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2tleTogdHlwZU5hbWV9LCBcbiAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLkxpbmssIHtcbiAgICAgICAgICAgICAgICAgICAgdG86ICcvJyArIChuYW1lID8gbmFtZSArICcuJyArIHR5cGVOYW1lIDogdHlwZU5hbWUpXG4gICAgICAgICAgICAgICAgICB9LCBcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA/IG5hbWUgKyAnLicgKyB0eXBlTmFtZSA6IHR5cGVOYW1lXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTt9XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgLnZhbHVlU2VxKClcbiAgICAgICAgICAgICAgLnRvQXJyYXkoKVxuICAgICAgICAgIClcbiAgICAgICAgKSwgXG5cbiAgICAgICAgY2FsbCAmJiAoXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwgbnVsbCwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDRcIiwge2NsYXNzTmFtZTogXCJncm91cFRpdGxlXCJ9LCBcIkNvbnN0cnVjdGlvblwiKSwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1lbWJlckRvYywge1xuICAgICAgICAgICAgICBzaG93RGV0YWlsOiBuYW1lID09PSBtZW1iZXJOYW1lLCBcbiAgICAgICAgICAgICAgcGFyZW50TmFtZTogbmFtZSwgXG4gICAgICAgICAgICAgIG1lbWJlcjoge1xuICAgICAgICAgICAgICAgIG1lbWJlck5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgbWVtYmVyRGVmOiBjYWxsLFxuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgKSwgXG5cbiAgICAgICAgZnVuY3Rpb25zLmNvdW50KCkgPiAwICYmIChcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiLCBudWxsLCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImdyb3VwVGl0bGVcIn0sIFwiU3RhdGljIG1ldGhvZHNcIiksIFxuICAgICAgICAgICAgZnVuY3Rpb25zXG4gICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24odCwgZm5OYW1lKSAgXG4gICAgICAgICAgICAgICAge3JldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE1lbWJlckRvYywge1xuICAgICAgICAgICAgICAgICAga2V5OiBmbk5hbWUsIFxuICAgICAgICAgICAgICAgICAgc2hvd0RldGFpbDogZm5OYW1lID09PSBtZW1iZXJOYW1lLCBcbiAgICAgICAgICAgICAgICAgIHBhcmVudE5hbWU6IG5hbWUsIFxuICAgICAgICAgICAgICAgICAgbWVtYmVyOiB7XG4gICAgICAgICAgICAgICAgICAgIG1lbWJlck5hbWU6IGZuTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyRGVmOiB0LmNhbGwsXG4gICAgICAgICAgICAgICAgICAgIGlzU3RhdGljOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICApO31cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAudmFsdWVTZXEoKVxuICAgICAgICAgICAgICAudG9BcnJheSgpXG4gICAgICAgICAgKVxuICAgICAgICApLCBcblxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiLCBudWxsLCBcbiAgICAgICAgICBTZXEobWVtYmVyR3JvdXBzKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihtZW1iZXJzLCB0aXRsZSkgXG4gICAgICAgICAgICAgIHtyZXR1cm4gbWVtYmVycy5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICA6IFNlcShbXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7a2V5OiB0aXRsZSB8fCAnTWVtYmVycycsIGNsYXNzTmFtZTogXCJncm91cFRpdGxlXCJ9LCBcbiAgICAgICAgICAgICAgICAgICAgICB0aXRsZSB8fCAnTWVtYmVycydcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgU2VxKG1lbWJlcnMpLm1hcChmdW5jdGlvbihtZW1iZXIpICBcbiAgICAgICAgICAgICAgICAgICAgICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtYmVyRG9jLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlUHJvcE1hcDogdHlwZVByb3BNYXAsIFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBtZW1iZXIubWVtYmVyTmFtZSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93RGV0YWlsOiBtZW1iZXIubWVtYmVyTmFtZSA9PT0gbWVtYmVyTmFtZSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROYW1lOiBuYW1lLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbWJlcjogbWVtYmVyfVxuICAgICAgICAgICAgICAgICAgICAgICk7fVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgXSk7fVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmZsYXR0ZW4oKVxuICAgICAgICAgICAgLnZhbHVlU2VxKClcbiAgICAgICAgICAgIC50b0FycmF5KClcbiAgICAgICAgKSwgXG5cbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEaXNjbGFpbWVyLCBudWxsKVxuICAgICAgKVxuICAgICk7XG4gIH0sXG59KTtcblxuLyoqXG4gKiBHZXQgYSBtYXAgZnJvbSBzdXBlciB0eXBlIHBhcmFtZXRlciB0byBjb25jcmV0ZSB0eXBlIGRlZmluaXRpb24uIFRoaXMgaXNcbiAqIHVzZWQgd2hlbiByZW5kZXJpbmcgaW5oZXJpdGVkIHR5cGUgZGVmaW5pdGlvbnMgdG8gZW5zdXJlIGNvbnRleHR1YWxseVxuICogcmVsZXZhbnQgaW5mb3JtYXRpb24uXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgIHR5cGUgQTxUPiBpbXBsZW1lbnRzIEI8bnVtYmVyLCBUPlxuICogICB0eXBlIEI8SywgVj4gaW1wbGVtZW50cyBDPEssIFYsIFY+XG4gKiAgIHR5cGUgQzxYLCBZLCBaPlxuICpcbiAqIHBhcnNlIEM6XG4gKiAgIHt9XG4gKlxuICogcGFyc2UgQjpcbiAqICAgeyBDPFg6IEtcbiAqICAgICBDPFk6IFZcbiAqICAgICBDPFo6IFYgfVxuICpcbiAqIHBhcnNlIEE6XG4gKiAgIHsgQjxLOiBudW1iZXJcbiAqICAgICBCPFY6IFRcbiAqICAgICBDPFg6IG51bWJlclxuICogICAgIEM8WTogVFxuICogICAgIEM8WjogVCB9XG4gKi9cbmZ1bmN0aW9uIGdldFR5cGVQcm9wTWFwKGRlZikge1xuICB2YXIgbWFwID0ge307XG4gIGRlZiAmJlxuICAgIGRlZi5leHRlbmRzICYmXG4gICAgZGVmLmV4dGVuZHMuZm9yRWFjaChmdW5jdGlvbihlKSAge1xuICAgICAgdmFyIHN1cGVyTW9kdWxlID0gZGVmcy5JbW11dGFibGU7XG4gICAgICBlLm5hbWUuc3BsaXQoJy4nKS5mb3JFYWNoKGZ1bmN0aW9uKHBhcnQpICB7XG4gICAgICAgIHN1cGVyTW9kdWxlID1cbiAgICAgICAgICBzdXBlck1vZHVsZSAmJiBzdXBlck1vZHVsZS5tb2R1bGUgJiYgc3VwZXJNb2R1bGUubW9kdWxlW3BhcnRdO1xuICAgICAgfSk7XG4gICAgICB2YXIgc3VwZXJJbnRlcmZhY2UgPSBzdXBlck1vZHVsZSAmJiBzdXBlck1vZHVsZS5pbnRlcmZhY2U7XG4gICAgICBpZiAoc3VwZXJJbnRlcmZhY2UpIHtcbiAgICAgICAgdmFyIGludGVyZmFjZU1hcCA9IFNlcShzdXBlckludGVyZmFjZS50eXBlUGFyYW1zKVxuICAgICAgICAgIC50b0tleWVkU2VxKClcbiAgICAgICAgICAuZmxpcCgpXG4gICAgICAgICAgLm1hcChmdW5jdGlvbihpKSAge3JldHVybiBlLmFyZ3NbaV07fSlcbiAgICAgICAgICAudG9PYmplY3QoKTtcbiAgICAgICAgU2VxKGludGVyZmFjZU1hcCkuZm9yRWFjaChmdW5jdGlvbih2LCBrKSAge1xuICAgICAgICAgIG1hcFtlLm5hbWUgKyAnPCcgKyBrXSA9IHY7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc3VwZXJNYXAgPSBnZXRUeXBlUHJvcE1hcChzdXBlckludGVyZmFjZSk7XG4gICAgICAgIFNlcShzdXBlck1hcCkuZm9yRWFjaChmdW5jdGlvbih2LCBrKSAge1xuICAgICAgICAgIG1hcFtrXSA9IHYuayA9PT0gVHlwZUtpbmQuUGFyYW0gPyBpbnRlcmZhY2VNYXBbdi5wYXJhbV0gOiB2O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgcmV0dXJuIG1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUeXBlRG9jdW1lbnRhdGlvbjtcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgncmVhY3QvbGliL09iamVjdC5hc3NpZ24nKTtcbnZhciBSb3V0ZXIgPSByZXF1aXJlKCdyZWFjdC1yb3V0ZXInKTtcbnZhciBEb2NIZWFkZXIgPSByZXF1aXJlKCcuL0RvY0hlYWRlcicpO1xudmFyIERvY1NlYXJjaCA9IHJlcXVpcmUoJy4vRG9jU2VhcmNoJyk7XG52YXIgVHlwZURvY3VtZW50YXRpb24gPSByZXF1aXJlKCcuL1R5cGVEb2N1bWVudGF0aW9uJyk7XG52YXIgZGVmcyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9nZXRUeXBlRGVmcycpO1xuXG52YXIgJF9fMD0gICAgICBSb3V0ZXIsUm91dGU9JF9fMC5Sb3V0ZSxEZWZhdWx0Um91dGU9JF9fMC5EZWZhdWx0Um91dGUsUm91dGVIYW5kbGVyPSRfXzAuUm91dGVIYW5kbGVyO1xuXG5yZXF1aXJlKCcuLi8uLi8uLi9saWIvcnVua2l0LWVtYmVkJyk7XG5cbnZhciBEb2N1bWVudGF0aW9uID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiBcIkRvY3VtZW50YXRpb25cIixcbiAgcmVuZGVyOmZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwsIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERvY0hlYWRlciwgbnVsbCksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtjbGFzc05hbWU6IFwicGFnZUJvZHlcIiwgaWQ6IFwiYm9keVwifSwgXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7Y2xhc3NOYW1lOiBcImNvbnRlbnRzXCJ9LCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRG9jU2VhcmNoLCBudWxsKSwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlSGFuZGxlciwgbnVsbClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9LFxufSk7XG5cbnZhciBEb2NEZXRlcm1pbmVyID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiBcIkRvY0RldGVybWluZXJcIixcbiAgbWl4aW5zOiBbUm91dGVyLlN0YXRlXSxcblxuICByZW5kZXI6ZnVuY3Rpb24oKSB7XG4gICAgdmFyICRfXzA9ICAgICAgZGV0ZXJtaW5lRG9jKHRoaXMuZ2V0UGF0aCgpKSxkZWY9JF9fMC5kZWYsbmFtZT0kX18wLm5hbWUsbWVtYmVyTmFtZT0kX18wLm1lbWJlck5hbWU7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVHlwZURvY3VtZW50YXRpb24sIHtkZWY6IGRlZiwgbmFtZTogbmFtZSwgbWVtYmVyTmFtZTogbWVtYmVyTmFtZX0pO1xuICB9LFxufSk7XG5cbmZ1bmN0aW9uIGRldGVybWluZURvYyhwYXRoKSB7XG4gIHZhciAkX18wPSAgICBwYXRoLnNwbGl0KCcvJyksbmFtZT0kX18wWzFdLG1lbWJlck5hbWU9JF9fMFsyXTtcblxuICB2YXIgbmFtZVBhdGggPSBuYW1lID8gbmFtZS5zcGxpdCgnLicpIDogW107XG4gIHZhciBkZWYgPSBuYW1lUGF0aC5yZWR1Y2UoXG4gICAgZnVuY3Rpb24oZGVmLCBzdWJOYW1lKSAge3JldHVybiBkZWYgJiYgZGVmLm1vZHVsZSAmJiBkZWYubW9kdWxlW3N1Yk5hbWVdO30sXG4gICAgZGVmcy5JbW11dGFibGVcbiAgKTtcblxuICByZXR1cm4geyBkZWY6ZGVmLCBuYW1lOm5hbWUsIG1lbWJlck5hbWU6bWVtYmVyTmFtZSB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJleHBvcnRzXCIsXG4gIGNoaWxkQ29udGV4dFR5cGVzOiB7XG4gICAgZ2V0UGFnZURhdGE6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIH0sXG5cbiAgZ2V0Q2hpbGRDb250ZXh0OmZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBnZXRQYWdlRGF0YTogdGhpcy5nZXRQYWdlRGF0YSxcbiAgICB9O1xuICB9LFxuXG4gIGdldFBhZ2VEYXRhOmZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBhZ2VEYXRhO1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxNb3VudDpmdW5jdGlvbigpIHtcbiAgICB2YXIgbG9jYXRpb247XG4gICAgdmFyIHNjcm9sbEJlaGF2aW9yO1xuXG4gICAgaWYgKHdpbmRvdy5kb2N1bWVudCkge1xuICAgICAgbG9jYXRpb24gPSBSb3V0ZXIuSGFzaExvY2F0aW9uO1xuICAgICAgbG9jYXRpb24uYWRkQ2hhbmdlTGlzdGVuZXIoZnVuY3Rpb24oY2hhbmdlKSAge1xuICAgICAgICB0aGlzLnBhZ2VEYXRhID0gYXNzaWduKHt9LCBjaGFuZ2UsIGRldGVybWluZURvYyhjaGFuZ2UucGF0aCkpO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgdGhpcy5wYWdlRGF0YSA9ICF3aW5kb3cuZG9jdW1lbnRcbiAgICAgICAgPyB7fVxuICAgICAgICA6IGFzc2lnbihcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcGF0aDogbG9jYXRpb24uZ2V0Q3VycmVudFBhdGgoKSxcbiAgICAgICAgICAgICAgdHlwZTogJ2luaXQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRldGVybWluZURvYyhsb2NhdGlvbi5nZXRDdXJyZW50UGF0aCgpKVxuICAgICAgICAgICk7XG5cbiAgICAgIHNjcm9sbEJlaGF2aW9yID0ge1xuICAgICAgICB1cGRhdGVTY3JvbGxQb3NpdGlvbjogZnVuY3Rpb24ocG9zaXRpb24sIGFjdGlvblR5cGUpICB7XG4gICAgICAgICAgc3dpdGNoIChhY3Rpb25UeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdwdXNoJzpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFnZURhdGEoKS5tZW1iZXJOYW1lXG4gICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgOiB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gICAgICAgICAgICBjYXNlICdwb3AnOlxuICAgICAgICAgICAgICByZXR1cm4gd2luZG93LnNjcm9sbFRvKFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID8gcG9zaXRpb24ueCA6IDAsXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPyBwb3NpdGlvbi55IDogMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBSb3V0ZXIuY3JlYXRlKHtcbiAgICAgIHJvdXRlczogKFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlLCB7aGFuZGxlcjogRG9jdW1lbnRhdGlvbiwgcGF0aDogXCIvXCJ9LCBcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERlZmF1bHRSb3V0ZSwge2hhbmRsZXI6IERvY0RldGVybWluZXJ9KSwgXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZSwge25hbWU6IFwidHlwZVwiLCBwYXRoOiBcIi86bmFtZVwiLCBoYW5kbGVyOiBEb2NEZXRlcm1pbmVyfSksIFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGUsIHtcbiAgICAgICAgICAgIG5hbWU6IFwibWV0aG9kXCIsIFxuICAgICAgICAgICAgcGF0aDogXCIvOm5hbWUvOm1lbWJlck5hbWVcIiwgXG4gICAgICAgICAgICBoYW5kbGVyOiBEb2NEZXRlcm1pbmVyfVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgIHNjcm9sbEJlaGF2aW9yOiBzY3JvbGxCZWhhdmlvcixcbiAgICB9KS5ydW4oZnVuY3Rpb24oSGFuZGxlcikgIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBoYW5kbGVyOiBIYW5kbGVyIH0pO1xuICAgICAgaWYgKHdpbmRvdy5kb2N1bWVudCkge1xuICAgICAgICB3aW5kb3cuZG9jdW1lbnQudGl0bGUgPSAodGhpcy5wYWdlRGF0YS5uYW1lICsgXCIg4oCUIEltbXV0YWJsZS5qc1wiKTtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuICB9LFxuXG4gIC8vIFRPRE86IHJlcGxhY2UgdGhpcy4gdGhpcyBpcyBoYWNreSBhbmQgcHJvYmFibHkgd3JvbmdcblxuICBjb21wb25lbnREaWRNb3VudDpmdW5jdGlvbigpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgIHtcbiAgICAgIHRoaXMucGFnZURhdGEudHlwZSA9ICcnO1xuICAgIH0uYmluZCh0aGlzKSwgMCk7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkVXBkYXRlOmZ1bmN0aW9uKCkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSAge1xuICAgICAgdGhpcy5wYWdlRGF0YS50eXBlID0gJyc7XG4gICAgfS5iaW5kKHRoaXMpLCAwKTtcbiAgfSxcblxuICByZW5kZXI6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIEhhbmRsZXIgPSB0aGlzLnN0YXRlLmhhbmRsZXI7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSGFuZGxlciwgbnVsbCk7XG4gIH0sXG59KTtcbiIsInZhciBpc01vYmlsZSA9XG4gIHdpbmRvdy5tYXRjaE1lZGlhICYmIHdpbmRvdy5tYXRjaE1lZGlhKCcobWF4LWRldmljZS13aWR0aDogNjgwcHgpJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZhbHNlICYmICEhKGlzTW9iaWxlICYmIGlzTW9iaWxlLm1hdGNoZXMpO1xuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIExvZ28gPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiTG9nb1wiLFxuICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uIChuZXh0UHJvcHMpIHtcbiAgICByZXR1cm4gbmV4dFByb3BzLm9wYWNpdHkgIT09IHRoaXMucHJvcHMub3BhY2l0eTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3BhY2l0eSA9IHRoaXMucHJvcHMub3BhY2l0eTtcbiAgICBpZiAob3BhY2l0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcGFjaXR5ID0gMTtcbiAgICB9XG4gICAgcmV0dXJuICF0aGlzLnByb3BzLmlubGluZSA/IChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHtmaWxsOiB0aGlzLnByb3BzLmNvbG9yLCBzdHlsZTogeyBvcGFjaXR5OiB0aGlzLnByb3BzLm9wYWNpdHl9fSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtkOiBcIk0wLDBsMTMuOSwwdjQxLjFIMEwwLDB6XCJ9KSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtkOiBcIk0xOC4yLDBMMjksMGwxMC43LDE1LjhMNTAuNCwwbDEwLjksMHY0MS4xSDQ4LjFWMjYuM2wtOC40LDEyLjNsLTguNC0xMi4zdjE0LjhIMTguMlYwelwifSksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7ZDogXCJNNjUuNSwwbDEwLjksMEw4NywxNS44TDk3LjcsMGwxMC45LDB2NDEuMUg5NS40VjI2LjNMODcsMzguN2wtOC40LTEyLjN2MTQuOEg2NS41VjB6XCJ9KSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgICAgICBkOiBcIk0xMjguNiw0Mi4yYy0yLjYsMC00LjktMC4zLTctMWMtMi4xLTAuNy0zLjktMS42LTUuNC0zYy0xLjUtMS4zLTIuNi0zLTMuNC01Yy0wLjgtMi0xLjItNC40LTEuMi03LjFWMFwiICsgJyAnICtcbiAgICAgICAgICBcImwxMy4xLDB2MjUuNmMwLDEuNCwwLjMsMi41LDAuOSwzLjNjMC42LDAuOCwxLjYsMS4xLDMsMS4xYzEuNCwwLDIuNC0wLjQsMy0xLjFjMC42LTAuOCwwLjktMS45LDAuOS0zLjNWMGwxMy4yLDB2MjYuMVwiICsgJyAnICtcbiAgICAgICAgICBcImMwLDIuNy0wLjQsNS4xLTEuMiw3LjFjLTAuOCwyLTIsMy43LTMuNSw1Yy0xLjUsMS4zLTMuMywyLjMtNS40LDNDMTMzLjUsNDEuOCwxMzEuMiw0Mi4yLDEyOC42LDQyLjJ6XCJ9XG4gICAgICAgICksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7ZDogXCJNMTU1LjQsMTAuOGgtNy42VjBsMjguNywwdjEwLjhoLTcuNnYzMC4zaC0xMy42VjEwLjh6XCJ9KSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgICAgICBkOiBcIk0xODYuNCwwbDkuOSwwbDE1LjYsNDEuMWgtMTIuOWwtMS40LTMuN2gtMTIuNWwtMS40LDMuN2gtMTIuOUwxODYuNCwweiBNMTk0LjEsMjguNGwtMi44LTcuMmwtMi44LDcuMlwiICsgJyAnICtcbiAgICAgICAgICBcIkgxOTQuMXpcIn1cbiAgICAgICAgKSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgICAgICBkOiBcIk0yMTIuOSwwTDIyOSwwYzIuMSwwLDMuOSwwLjIsNS42LDAuN2MxLjcsMC41LDMuMiwxLjIsNC40LDIuMXMyLjIsMi4xLDIuOCwzLjVjMC43LDEuNCwxLDMsMSw0LjhcIiArICcgJyArXG4gICAgICAgICAgXCJjMCwxLjMtMC4yLDIuNC0wLjUsMy40Yy0wLjMsMC45LTAuNywxLjctMSwyLjNjLTAuNSwwLjctMSwxLjQtMS41LDEuOGMwLjksMC42LDEuNywxLjMsMi41LDIuMmMwLjYsMC44LDEuMiwxLjgsMS43LDNcIiArICcgJyArXG4gICAgICAgICAgXCJjMC41LDEuMiwwLjgsMi43LDAuOCw0LjRjMCwyLTAuMywzLjgtMSw1LjRjLTAuNywxLjYtMS43LDMtMyw0LjFjLTEuMywxLjEtMi45LDItNC43LDIuNmMtMS45LDAuNi00LDAuOS02LjMsMC45aC0xNi44VjB6XCIgKyAnICcgK1xuICAgICAgICAgICBcIk0yMzAuMiwxMi41YzAtMS45LTEtMi44LTMuMS0yLjhoLTEuNXY1LjdoMS41QzIyOS4yLDE1LjQsMjMwLjIsMTQuNCwyMzAuMiwxMi41eiBNMjI3LjEsMzEuNGMzLjEsMCw0LjctMS4yLDQuNy0zLjZcIiArICcgJyArXG4gICAgICAgICAgXCJjMC0yLjQtMS42LTMuNi00LjctMy42aC0xLjV2Ny4ySDIyNy4xelwifVxuICAgICAgICApLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge2Q6IFwiTTI0OC4zLDBMMjYyLDB2MzAuM2gxMS4zdjEwLjhoLTI1VjB6XCJ9KSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtkOiBcIk0yNzUuMywwbDI0LjIsMHYxMC44aC0xMS4xdjQuNmgxMC45djEwLjJoLTEwLjl2NC43SDMwMHYxMC44aC0yNC43VjB6XCJ9KVxuICAgICAgKVxuICAgICkgOiAoXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7ZmlsbDogdGhpcy5wcm9wcy5jb2xvciwgc3R5bGU6IHsgb3BhY2l0eTogdGhpcy5wcm9wcy5vcGFjaXR5fX0sIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7ZDogXCJNMCwwbDEzLjksMHY0MS4xSDBMMCwweiBNNy44LDM2LjJWNC45SDYuMnYzMS4zSDcuOHpcIn0pLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgICAgICAgIGQ6IFwiTTE4LjIsMEwyOSwwbDEwLjcsMTUuOEw1MC40LDBsMTAuOSwwdjQxLjFINDguMVYyNi4zbC04LjQsMTIuM2wtOC40LTEyLjN2MTQuOEgxOC4yVjB6IE0yNS45LDM2LjJWNy45XCIgKyAnICcgK1xuICAgICAgICAgIFwiTDM5LjcsMjhMNTMuNSw3Ljl2MjguM2gxLjZWNC45aC0xLjZMMzkuNywyNS4yTDI1LjksNC45aC0xLjZ2MzEuM0gyNS45elwifVxuICAgICAgICApLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgICAgICAgIGQ6IFwiTTY1LjUsMGwxMC45LDBMODcsMTUuOEw5Ny43LDBsMTAuOSwwdjQxLjFIOTUuNFYyNi4zTDg3LDM4LjdsLTguNC0xMi4zdjE0LjhINjUuNVYweiBNNzMuMiwzNi4yVjcuOVwiICsgJyAnICtcbiAgICAgICAgICBcIkw4NywyOGwxMy43LTIwLjF2MjguM2gxLjZWNC45aC0xLjZMODcsMjUuMkw3My4yLDQuOWgtMS42djMxLjNINzMuMnpcIn1cbiAgICAgICAgKSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgICAgICBkOiBcIk0xMjguNiw0Mi4yYy0yLjYsMC00LjktMC4zLTctMWMtMi4xLTAuNy0zLjktMS42LTUuNC0zYy0xLjUtMS4zLTIuNi0zLTMuNC01Yy0wLjgtMi0xLjItNC40LTEuMi03LjFWMFwiICsgJyAnICtcbiAgICAgICAgICBcImwxMy4xLDB2MjUuNmMwLDEuNCwwLjMsMi41LDAuOSwzLjNjMC42LDAuOCwxLjYsMS4xLDMsMS4xYzEuNCwwLDIuNC0wLjQsMy0xLjFjMC42LTAuOCwwLjktMS45LDAuOS0zLjNWMGwxMy4yLDB2MjYuMVwiICsgJyAnICtcbiAgICAgICAgICBcImMwLDIuNy0wLjQsNS4xLTEuMiw3LjFjLTAuOCwyLTIsMy43LTMuNSw1Yy0xLjUsMS4zLTMuMywyLjMtNS40LDNDMTMzLjUsNDEuOCwxMzEuMiw0Mi4yLDEyOC42LDQyLjJ6IE0xMjguNiwzNC44XCIgKyAnICcgK1xuICAgICAgICAgIFwiYy02LjIsMC05LjItMy05LjItOS4xVjQuOWgtMS42djIwLjhjMCwzLjUsMC45LDYuMSwyLjgsNy45YzEuOSwxLjgsNC42LDIuNyw4LDIuN2MzLjUsMCw2LjItMC45LDguMS0yLjdjMS45LTEuOCwyLjgtNC41LDIuOC03LjlcIiArICcgJyArXG4gICAgICAgICAgXCJWNC45aC0xLjd2MjAuOEMxMzcuOCwzMS43LDEzNC44LDM0LjgsMTI4LjYsMzQuOHpcIn1cbiAgICAgICAgKSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtkOiBcIk0xNTUuNCwxMC44aC03LjZWMGwyOC43LDB2MTAuOGgtNy42djMwLjNoLTEzLjZWMTAuOHogTTE2MywzNi4yVjYuNGg4LjhWNC45aC0xOS4ydjEuNWg4Ljh2MjkuOEgxNjN6XCJ9KSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgICAgICBkOiBcIk0xODYuNCwwbDkuOSwwbDE1LjYsNDEuMWgtMTIuOWwtMS40LTMuN2gtMTIuNWwtMS40LDMuN2gtMTIuOUwxODYuNCwweiBNMTgwLDM2LjJsMS4yLTMuMWgyMC4zbDEuMiwzLjFcIiArICcgJyArXG4gICAgICAgICAgXCJoMS43TDE5Mi41LDQuOWgtMi4zbC0xMS45LDMxLjNIMTgweiBNMTkxLjMsNi40bDkuNiwyNS4yaC0xOS4yTDE5MS4zLDYuNHogTTE5NC4xLDI4LjRsLTIuOC03LjJsLTIuOCw3LjJIMTk0LjF6XCJ9XG4gICAgICAgICksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgICAgZDogXCJNMjEyLjksMEwyMjksMGMyLjEsMCwzLjksMC4yLDUuNiwwLjdjMS43LDAuNSwzLjIsMS4yLDQuNCwyLjFzMi4yLDIuMSwyLjgsMy41YzAuNywxLjQsMSwzLDEsNC44XCIgKyAnICcgK1xuICAgICAgICAgIFwiYzAsMS4zLTAuMiwyLjQtMC41LDMuNGMtMC4zLDAuOS0wLjcsMS43LTEsMi4zYy0wLjUsMC43LTEsMS40LTEuNSwxLjhjMC45LDAuNiwxLjcsMS4zLDIuNSwyLjJjMC42LDAuOCwxLjIsMS44LDEuNywzXCIgKyAnICcgK1xuICAgICAgICAgIFwiYzAuNSwxLjIsMC44LDIuNywwLjgsNC40YzAsMi0wLjMsMy44LTEsNS40Yy0wLjcsMS42LTEuNywzLTMsNC4xYy0xLjMsMS4xLTIuOSwyLTQuNywyLjZjLTEuOSwwLjYtNCwwLjktNi4zLDAuOWgtMTYuOFYwelwiICsgJyAnICtcbiAgICAgICAgICAgXCJNMjI4LDM2LjJjMy42LDAsNi4zLTAuOCw4LTIuM2MxLjctMS42LDIuNi0zLjYsMi42LTYuMmMwLTEuNy0wLjQtMy0xLjEtNGMtMC43LTEtMS41LTEuOC0yLjMtMi40Yy0xLTAuNy0yLjItMS4xLTMuNC0xLjRcIiArICcgJyArXG4gICAgICAgICAgXCJjMS0wLjMsMS45LTAuNywyLjctMS40YzAuNy0wLjUsMS4zLTEuMywxLjktMi4yczAuOC0yLjEsMC44LTMuNWMwLTIuNi0wLjgtNC41LTIuNS01LjljLTEuNi0xLjMtMy45LTItNi43LTJoLTguOXYzMS4zSDIyOHpcIiArICcgJyArXG4gICAgICAgICAgIFwiTTIyMC43LDE5LjFWNi40bDcuMywwYzIuNywwLDQuNiwwLjYsNS44LDEuOGMxLjIsMS4yLDEuOCwyLjcsMS44LDQuNmMwLDEuOS0wLjYsMy40LTEuOCw0LjZjLTEuMiwxLjItMy4xLDEuOC01LjgsMS44SDIyMC43elwiICsgJyAnICtcbiAgICAgICAgICAgXCJNMjIwLjcsMzQuN1YyMC42aDcuMmMxLjMsMCwyLjUsMC4xLDMuNSwwLjRjMS4xLDAuMywyLDAuNywyLjksMS4yYzAuOCwwLjYsMS41LDEuMywxLjksMi4yYzAuNSwwLjksMC43LDIsMC43LDMuMlwiICsgJyAnICtcbiAgICAgICAgICBcImMwLDIuNS0wLjgsNC4zLTIuNSw1LjRjLTEuNywxLjEtMy45LDEuNy02LjYsMS43SDIyMC43eiBNMjMwLjIsMTIuNWMwLTEuOS0xLTIuOC0zLjEtMi44aC0xLjV2NS43aDEuNVwiICsgJyAnICtcbiAgICAgICAgICBcIkMyMjkuMiwxNS40LDIzMC4yLDE0LjQsMjMwLjIsMTIuNXogTTIyNy4xLDMxLjRjMy4xLDAsNC43LTEuMiw0LjctMy42YzAtMi40LTEuNi0zLjYtNC43LTMuNmgtMS41djcuMkgyMjcuMXpcIn1cbiAgICAgICAgKSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtkOiBcIk0yNDguMywwTDI2MiwwdjMwLjNoMTEuM3YxMC44aC0yNVYweiBNMjY5LjksMzYuMnYtMS41aC0xMy44VjQuOWgtMS42djMxLjNIMjY5Ljl6XCJ9KSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgICAgICBkOiBcIk0yNzUuMywwbDI0LjIsMHYxMC44aC0xMS4xdjQuNmgxMC45djEwLjJoLTEwLjl2NC43SDMwMHYxMC44aC0yNC43VjB6IE0yOTUuNCwzNi4ydi0xLjVoLTEyLjNWMjEuMmgxMS43XCIgKyAnICcgK1xuICAgICAgICAgIFwidi0xLjVoLTExLjdWNi40aDEyLjNWNC45aC0xMy45djMxLjNIMjk1LjR6XCJ9XG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTG9nbztcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBTVkdTZXQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiU1ZHU2V0XCIsXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHtjbGFzc05hbWU6IFwic3ZnXCIsIHN0eWxlOiB0aGlzLnByb3BzLnN0eWxlLCB2aWV3Qm94OiBcIjAgMCAzMDAgNDIuMlwifSwgXG4gICAgICAgIHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgICAgIClcbiAgICApO1xuICB9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU1ZHU2V0O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuSW1tdXRhYmxlO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuUmVhY3Q7XG4iXX0="}