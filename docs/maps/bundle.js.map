{"version":3,"sources":["../../../node_modules/browser-pack/_prelude.js","../../../dist/immutable.js","../../../node_modules/base64-js/index.js","../../../node_modules/buffer/index.js","../../../node_modules/ieee754/index.js","../../../node_modules/marked/lib/marked.js","../../../node_modules/process/browser.js","../../../node_modules/react-router/modules/actions/LocationActions.js","../../../node_modules/react-router/modules/behaviors/ImitateBrowserBehavior.js","../../../node_modules/react-router/modules/behaviors/ScrollToTopBehavior.js","../../../node_modules/react-router/modules/components/DefaultRoute.js","../../../node_modules/react-router/modules/components/Link.js","../../../node_modules/react-router/modules/components/NotFoundRoute.js","../../../node_modules/react-router/modules/components/Redirect.js","../../../node_modules/react-router/modules/components/Route.js","../../../node_modules/react-router/modules/components/RouteHandler.js","../../../node_modules/react-router/modules/index.js","../../../node_modules/react-router/modules/locations/HashLocation.js","../../../node_modules/react-router/modules/locations/HistoryLocation.js","../../../node_modules/react-router/modules/locations/RefreshLocation.js","../../../node_modules/react-router/modules/mixins/FakeNode.js","../../../node_modules/react-router/modules/mixins/Navigation.js","../../../node_modules/react-router/modules/mixins/NavigationContext.js","../../../node_modules/react-router/modules/mixins/RouteHandler.js","../../../node_modules/react-router/modules/mixins/Scrolling.js","../../../node_modules/react-router/modules/mixins/State.js","../../../node_modules/react-router/modules/mixins/StateContext.js","../../../node_modules/react-router/modules/utils/Cancellation.js","../../../node_modules/react-router/modules/utils/History.js","../../../node_modules/react-router/modules/utils/Path.js","../../../node_modules/react-router/modules/utils/Promise.js","../../../node_modules/react-router/modules/utils/PropTypes.js","../../../node_modules/react-router/modules/utils/Redirect.js","../../../node_modules/react-router/modules/utils/Transition.js","../../../node_modules/react-router/modules/utils/createRouter.js","../../../node_modules/react-router/modules/utils/createRoutesFromChildren.js","../../../node_modules/react-router/modules/utils/getWindowScrollPosition.js","../../../node_modules/react-router/modules/utils/reversedArray.js","../../../node_modules/react-router/modules/utils/runRouter.js","../../../node_modules/react-router/modules/utils/supportsHistory.js","../../../node_modules/react-router/node_modules/qs/index.js","../../../node_modules/react-router/node_modules/qs/lib/index.js","../../../node_modules/react-router/node_modules/qs/lib/parse.js","../../../node_modules/react-router/node_modules/qs/lib/stringify.js","../../../node_modules/react-router/node_modules/qs/lib/utils.js","../../../node_modules/react-router/node_modules/when/lib/Promise.js","../../../node_modules/react-router/node_modules/when/lib/Queue.js","../../../node_modules/react-router/node_modules/when/lib/Scheduler.js","../../../node_modules/react-router/node_modules/when/lib/async.js","../../../node_modules/react-router/node_modules/when/lib/makePromise.js","../../../node_modules/react/lib/CSSCore.js","../../../node_modules/react/lib/ExecutionEnvironment.js","../../../node_modules/react/lib/Object.assign.js","../../../node_modules/react/lib/ReactTransitionEvents.js","../../../node_modules/react/lib/cx.js","../../../node_modules/react/lib/emptyFunction.js","../../../node_modules/react/lib/invariant.js","../../../node_modules/react/lib/warning.js","../../../package.json","../../generated/immutable.d.json","../../lib/TypeKind.js","../../lib/collectMemberGroups.js","../../lib/getTypeDefs.js","../../lib/markdown.js","../../lib/markdownDocs.js","../../lib/prism.js","../../lib/runkit-embed.js","src/Defs.js","src/DocHeader.js","src/DocOverview.js","src/DocSearch.js","src/MarkDown.js","src/MemberDoc.js","src/PageDataMixin.js","src/SideBar.js","src/TypeDocumentation.js","src/index.js","src/isMobile.js","../src/Logo.js","../src/SVGSet.js","../../../resources/immutable-global.js","../../../resources/react-global.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/tLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5xBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtIA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/rBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9XA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9IA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACbA;AACA;;;;;ACDA;AACA","file":"../bundle.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/**\n * MIT License\n * \n * Copyright (c) 2014-present, Lee Byron and other contributors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Immutable = {}));\n}(this, (function (exports) { 'use strict';\n\n  var DELETE = 'delete';\n\n  // Constants describing the size of trie nodes.\n  var SHIFT = 5; // Resulted in best performance after ______?\n  var SIZE = 1 << SHIFT;\n  var MASK = SIZE - 1;\n\n  // A consistent shared value representing \"not set\" which equals nothing other\n  // than itself, and nothing that could be provided externally.\n  var NOT_SET = {};\n\n  // Boolean references, Rough equivalent of `bool &`.\n  function MakeRef() {\n    return { value: false };\n  }\n\n  function SetRef(ref) {\n    if (ref) {\n      ref.value = true;\n    }\n  }\n\n  // A function which returns a value representing an \"owner\" for transient writes\n  // to tries. The return value will only ever equal itself, and will not equal\n  // the return of any subsequent call of this function.\n  function OwnerID() {}\n\n  function ensureSize(iter) {\n    if (iter.size === undefined) {\n      iter.size = iter.__iterate(returnTrue);\n    }\n    return iter.size;\n  }\n\n  function wrapIndex(iter, index) {\n    // This implements \"is array index\" which the ECMAString spec defines as:\n    //\n    //     A String property name P is an array index if and only if\n    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n    //     to 2^321.\n    //\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n    if (typeof index !== 'number') {\n      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n      if ('' + uint32Index !== index || uint32Index === 4294967295) {\n        return NaN;\n      }\n      index = uint32Index;\n    }\n    return index < 0 ? ensureSize(iter) + index : index;\n  }\n\n  function returnTrue() {\n    return true;\n  }\n\n  function wholeSlice(begin, end, size) {\n    return (\n      ((begin === 0 && !isNeg(begin)) ||\n        (size !== undefined && begin <= -size)) &&\n      (end === undefined || (size !== undefined && end >= size))\n    );\n  }\n\n  function resolveBegin(begin, size) {\n    return resolveIndex(begin, size, 0);\n  }\n\n  function resolveEnd(end, size) {\n    return resolveIndex(end, size, size);\n  }\n\n  function resolveIndex(index, size, defaultIndex) {\n    // Sanitize indices using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    return index === undefined\n      ? defaultIndex\n      : isNeg(index)\n      ? size === Infinity\n        ? size\n        : Math.max(0, size + index) | 0\n      : size === undefined || size === index\n      ? index\n      : Math.min(size, index) | 0;\n  }\n\n  function isNeg(value) {\n    // Account for -0 which is negative, but not less than 0.\n    return value < 0 || (value === 0 && 1 / value === -Infinity);\n  }\n\n  var IS_COLLECTION_SYMBOL = '@@__IMMUTABLE_ITERABLE__@@';\n\n  function isCollection(maybeCollection) {\n    return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);\n  }\n\n  var IS_KEYED_SYMBOL = '@@__IMMUTABLE_KEYED__@@';\n\n  function isKeyed(maybeKeyed) {\n    return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);\n  }\n\n  var IS_INDEXED_SYMBOL = '@@__IMMUTABLE_INDEXED__@@';\n\n  function isIndexed(maybeIndexed) {\n    return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);\n  }\n\n  function isAssociative(maybeAssociative) {\n    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n  }\n\n  var Collection = function Collection(value) {\n    return isCollection(value) ? value : Seq(value);\n  };\n\n  var KeyedCollection = /*@__PURE__*/(function (Collection) {\n    function KeyedCollection(value) {\n      return isKeyed(value) ? value : KeyedSeq(value);\n    }\n\n    if ( Collection ) KeyedCollection.__proto__ = Collection;\n    KeyedCollection.prototype = Object.create( Collection && Collection.prototype );\n    KeyedCollection.prototype.constructor = KeyedCollection;\n\n    return KeyedCollection;\n  }(Collection));\n\n  var IndexedCollection = /*@__PURE__*/(function (Collection) {\n    function IndexedCollection(value) {\n      return isIndexed(value) ? value : IndexedSeq(value);\n    }\n\n    if ( Collection ) IndexedCollection.__proto__ = Collection;\n    IndexedCollection.prototype = Object.create( Collection && Collection.prototype );\n    IndexedCollection.prototype.constructor = IndexedCollection;\n\n    return IndexedCollection;\n  }(Collection));\n\n  var SetCollection = /*@__PURE__*/(function (Collection) {\n    function SetCollection(value) {\n      return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);\n    }\n\n    if ( Collection ) SetCollection.__proto__ = Collection;\n    SetCollection.prototype = Object.create( Collection && Collection.prototype );\n    SetCollection.prototype.constructor = SetCollection;\n\n    return SetCollection;\n  }(Collection));\n\n  Collection.Keyed = KeyedCollection;\n  Collection.Indexed = IndexedCollection;\n  Collection.Set = SetCollection;\n\n  var IS_SEQ_SYMBOL = '@@__IMMUTABLE_SEQ__@@';\n\n  function isSeq(maybeSeq) {\n    return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);\n  }\n\n  var IS_RECORD_SYMBOL = '@@__IMMUTABLE_RECORD__@@';\n\n  function isRecord(maybeRecord) {\n    return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);\n  }\n\n  function isImmutable(maybeImmutable) {\n    return isCollection(maybeImmutable) || isRecord(maybeImmutable);\n  }\n\n  var IS_ORDERED_SYMBOL = '@@__IMMUTABLE_ORDERED__@@';\n\n  function isOrdered(maybeOrdered) {\n    return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);\n  }\n\n  var ITERATE_KEYS = 0;\n  var ITERATE_VALUES = 1;\n  var ITERATE_ENTRIES = 2;\n\n  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\n  var Iterator = function Iterator(next) {\n    this.next = next;\n  };\n\n  Iterator.prototype.toString = function toString () {\n    return '[Iterator]';\n  };\n\n  Iterator.KEYS = ITERATE_KEYS;\n  Iterator.VALUES = ITERATE_VALUES;\n  Iterator.ENTRIES = ITERATE_ENTRIES;\n\n  Iterator.prototype.inspect = Iterator.prototype.toSource = function () {\n    return this.toString();\n  };\n  Iterator.prototype[ITERATOR_SYMBOL] = function () {\n    return this;\n  };\n\n  function iteratorValue(type, k, v, iteratorResult) {\n    var value = type === 0 ? k : type === 1 ? v : [k, v];\n    iteratorResult\n      ? (iteratorResult.value = value)\n      : (iteratorResult = {\n          value: value,\n          done: false,\n        });\n    return iteratorResult;\n  }\n\n  function iteratorDone() {\n    return { value: undefined, done: true };\n  }\n\n  function hasIterator(maybeIterable) {\n    return !!getIteratorFn(maybeIterable);\n  }\n\n  function isIterator(maybeIterator) {\n    return maybeIterator && typeof maybeIterator.next === 'function';\n  }\n\n  function getIterator(iterable) {\n    var iteratorFn = getIteratorFn(iterable);\n    return iteratorFn && iteratorFn.call(iterable);\n  }\n\n  function getIteratorFn(iterable) {\n    var iteratorFn =\n      iterable &&\n      ((REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n        iterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  function isArrayLike(value) {\n    if (Array.isArray(value) || typeof value === 'string') {\n      return true;\n    }\n\n    return (\n      value &&\n      typeof value === 'object' &&\n      Number.isInteger(value.length) &&\n      value.length >= 0 &&\n      (value.length === 0\n        ? // Only {length: 0} is considered Array-like.\n          Object.keys(value).length === 1\n        : // An object is only Array-like if it has a property where the last value\n          // in the array-like may be found (which could be undefined).\n          value.hasOwnProperty(value.length - 1))\n    );\n  }\n\n  var Seq = /*@__PURE__*/(function (Collection) {\n    function Seq(value) {\n      return value === null || value === undefined\n        ? emptySequence()\n        : isImmutable(value)\n        ? value.toSeq()\n        : seqFromValue(value);\n    }\n\n    if ( Collection ) Seq.__proto__ = Collection;\n    Seq.prototype = Object.create( Collection && Collection.prototype );\n    Seq.prototype.constructor = Seq;\n\n    Seq.prototype.toSeq = function toSeq () {\n      return this;\n    };\n\n    Seq.prototype.toString = function toString () {\n      return this.__toString('Seq {', '}');\n    };\n\n    Seq.prototype.cacheResult = function cacheResult () {\n      if (!this._cache && this.__iterateUncached) {\n        this._cache = this.entrySeq().toArray();\n        this.size = this._cache.length;\n      }\n      return this;\n    };\n\n    // abstract __iterateUncached(fn, reverse)\n\n    Seq.prototype.__iterate = function __iterate (fn, reverse) {\n      var cache = this._cache;\n      if (cache) {\n        var size = cache.length;\n        var i = 0;\n        while (i !== size) {\n          var entry = cache[reverse ? size - ++i : i++];\n          if (fn(entry[1], entry[0], this) === false) {\n            break;\n          }\n        }\n        return i;\n      }\n      return this.__iterateUncached(fn, reverse);\n    };\n\n    // abstract __iteratorUncached(type, reverse)\n\n    Seq.prototype.__iterator = function __iterator (type, reverse) {\n      var cache = this._cache;\n      if (cache) {\n        var size = cache.length;\n        var i = 0;\n        return new Iterator(function () {\n          if (i === size) {\n            return iteratorDone();\n          }\n          var entry = cache[reverse ? size - ++i : i++];\n          return iteratorValue(type, entry[0], entry[1]);\n        });\n      }\n      return this.__iteratorUncached(type, reverse);\n    };\n\n    return Seq;\n  }(Collection));\n\n  var KeyedSeq = /*@__PURE__*/(function (Seq) {\n    function KeyedSeq(value) {\n      return value === null || value === undefined\n        ? emptySequence().toKeyedSeq()\n        : isCollection(value)\n        ? isKeyed(value)\n          ? value.toSeq()\n          : value.fromEntrySeq()\n        : isRecord(value)\n        ? value.toSeq()\n        : keyedSeqFromValue(value);\n    }\n\n    if ( Seq ) KeyedSeq.__proto__ = Seq;\n    KeyedSeq.prototype = Object.create( Seq && Seq.prototype );\n    KeyedSeq.prototype.constructor = KeyedSeq;\n\n    KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq () {\n      return this;\n    };\n\n    return KeyedSeq;\n  }(Seq));\n\n  var IndexedSeq = /*@__PURE__*/(function (Seq) {\n    function IndexedSeq(value) {\n      return value === null || value === undefined\n        ? emptySequence()\n        : isCollection(value)\n        ? isKeyed(value)\n          ? value.entrySeq()\n          : value.toIndexedSeq()\n        : isRecord(value)\n        ? value.toSeq().entrySeq()\n        : indexedSeqFromValue(value);\n    }\n\n    if ( Seq ) IndexedSeq.__proto__ = Seq;\n    IndexedSeq.prototype = Object.create( Seq && Seq.prototype );\n    IndexedSeq.prototype.constructor = IndexedSeq;\n\n    IndexedSeq.of = function of (/*...values*/) {\n      return IndexedSeq(arguments);\n    };\n\n    IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq () {\n      return this;\n    };\n\n    IndexedSeq.prototype.toString = function toString () {\n      return this.__toString('Seq [', ']');\n    };\n\n    return IndexedSeq;\n  }(Seq));\n\n  var SetSeq = /*@__PURE__*/(function (Seq) {\n    function SetSeq(value) {\n      return (\n        isCollection(value) && !isAssociative(value) ? value : IndexedSeq(value)\n      ).toSetSeq();\n    }\n\n    if ( Seq ) SetSeq.__proto__ = Seq;\n    SetSeq.prototype = Object.create( Seq && Seq.prototype );\n    SetSeq.prototype.constructor = SetSeq;\n\n    SetSeq.of = function of (/*...values*/) {\n      return SetSeq(arguments);\n    };\n\n    SetSeq.prototype.toSetSeq = function toSetSeq () {\n      return this;\n    };\n\n    return SetSeq;\n  }(Seq));\n\n  Seq.isSeq = isSeq;\n  Seq.Keyed = KeyedSeq;\n  Seq.Set = SetSeq;\n  Seq.Indexed = IndexedSeq;\n\n  Seq.prototype[IS_SEQ_SYMBOL] = true;\n\n  // #pragma Root Sequences\n\n  var ArraySeq = /*@__PURE__*/(function (IndexedSeq) {\n    function ArraySeq(array) {\n      this._array = array;\n      this.size = array.length;\n    }\n\n    if ( IndexedSeq ) ArraySeq.__proto__ = IndexedSeq;\n    ArraySeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n    ArraySeq.prototype.constructor = ArraySeq;\n\n    ArraySeq.prototype.get = function get (index, notSetValue) {\n      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n    };\n\n    ArraySeq.prototype.__iterate = function __iterate (fn, reverse) {\n      var array = this._array;\n      var size = array.length;\n      var i = 0;\n      while (i !== size) {\n        var ii = reverse ? size - ++i : i++;\n        if (fn(array[ii], ii, this) === false) {\n          break;\n        }\n      }\n      return i;\n    };\n\n    ArraySeq.prototype.__iterator = function __iterator (type, reverse) {\n      var array = this._array;\n      var size = array.length;\n      var i = 0;\n      return new Iterator(function () {\n        if (i === size) {\n          return iteratorDone();\n        }\n        var ii = reverse ? size - ++i : i++;\n        return iteratorValue(type, ii, array[ii]);\n      });\n    };\n\n    return ArraySeq;\n  }(IndexedSeq));\n\n  var ObjectSeq = /*@__PURE__*/(function (KeyedSeq) {\n    function ObjectSeq(object) {\n      var keys = Object.keys(object);\n      this._object = object;\n      this._keys = keys;\n      this.size = keys.length;\n    }\n\n    if ( KeyedSeq ) ObjectSeq.__proto__ = KeyedSeq;\n    ObjectSeq.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );\n    ObjectSeq.prototype.constructor = ObjectSeq;\n\n    ObjectSeq.prototype.get = function get (key, notSetValue) {\n      if (notSetValue !== undefined && !this.has(key)) {\n        return notSetValue;\n      }\n      return this._object[key];\n    };\n\n    ObjectSeq.prototype.has = function has (key) {\n      return hasOwnProperty.call(this._object, key);\n    };\n\n    ObjectSeq.prototype.__iterate = function __iterate (fn, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var size = keys.length;\n      var i = 0;\n      while (i !== size) {\n        var key = keys[reverse ? size - ++i : i++];\n        if (fn(object[key], key, this) === false) {\n          break;\n        }\n      }\n      return i;\n    };\n\n    ObjectSeq.prototype.__iterator = function __iterator (type, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var size = keys.length;\n      var i = 0;\n      return new Iterator(function () {\n        if (i === size) {\n          return iteratorDone();\n        }\n        var key = keys[reverse ? size - ++i : i++];\n        return iteratorValue(type, key, object[key]);\n      });\n    };\n\n    return ObjectSeq;\n  }(KeyedSeq));\n  ObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;\n\n  var CollectionSeq = /*@__PURE__*/(function (IndexedSeq) {\n    function CollectionSeq(collection) {\n      this._collection = collection;\n      this.size = collection.length || collection.size;\n    }\n\n    if ( IndexedSeq ) CollectionSeq.__proto__ = IndexedSeq;\n    CollectionSeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n    CollectionSeq.prototype.constructor = CollectionSeq;\n\n    CollectionSeq.prototype.__iterateUncached = function __iterateUncached (fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var collection = this._collection;\n      var iterator = getIterator(collection);\n      var iterations = 0;\n      if (isIterator(iterator)) {\n        var step;\n        while (!(step = iterator.next()).done) {\n          if (fn(step.value, iterations++, this) === false) {\n            break;\n          }\n        }\n      }\n      return iterations;\n    };\n\n    CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached (type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var collection = this._collection;\n      var iterator = getIterator(collection);\n      if (!isIterator(iterator)) {\n        return new Iterator(iteratorDone);\n      }\n      var iterations = 0;\n      return new Iterator(function () {\n        var step = iterator.next();\n        return step.done ? step : iteratorValue(type, iterations++, step.value);\n      });\n    };\n\n    return CollectionSeq;\n  }(IndexedSeq));\n\n  // # pragma Helper functions\n\n  var EMPTY_SEQ;\n\n  function emptySequence() {\n    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n  }\n\n  function keyedSeqFromValue(value) {\n    var seq = Array.isArray(value)\n      ? new ArraySeq(value)\n      : hasIterator(value)\n      ? new CollectionSeq(value)\n      : undefined;\n    if (seq) {\n      return seq.fromEntrySeq();\n    }\n    if (typeof value === 'object') {\n      return new ObjectSeq(value);\n    }\n    throw new TypeError(\n      'Expected Array or collection object of [k, v] entries, or keyed object: ' +\n        value\n    );\n  }\n\n  function indexedSeqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n    if (seq) {\n      return seq;\n    }\n    throw new TypeError(\n      'Expected Array or collection object of values: ' + value\n    );\n  }\n\n  function seqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n    if (seq) {\n      return seq;\n    }\n    if (typeof value === 'object') {\n      return new ObjectSeq(value);\n    }\n    throw new TypeError(\n      'Expected Array or collection object of values, or keyed object: ' + value\n    );\n  }\n\n  function maybeIndexedSeqFromValue(value) {\n    return isArrayLike(value)\n      ? new ArraySeq(value)\n      : hasIterator(value)\n      ? new CollectionSeq(value)\n      : undefined;\n  }\n\n  var IS_MAP_SYMBOL = '@@__IMMUTABLE_MAP__@@';\n\n  function isMap(maybeMap) {\n    return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);\n  }\n\n  function isOrderedMap(maybeOrderedMap) {\n    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n  }\n\n  function isValueObject(maybeValue) {\n    return Boolean(\n      maybeValue &&\n        typeof maybeValue.equals === 'function' &&\n        typeof maybeValue.hashCode === 'function'\n    );\n  }\n\n  /**\n   * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n   *\n   * NaN is considered the same as NaN, however -0 and 0 are considered the same\n   * value, which is different from the algorithm described by\n   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n   *\n   * This is extended further to allow Objects to describe the values they\n   * represent, by way of `valueOf` or `equals` (and `hashCode`).\n   *\n   * Note: because of this extension, the key equality of Immutable.Map and the\n   * value equality of Immutable.Set will differ from ES6 Map and Set.\n   *\n   * ### Defining custom values\n   *\n   * The easiest way to describe the value an object represents is by implementing\n   * `valueOf`. For example, `Date` represents a value by returning a unix\n   * timestamp for `valueOf`:\n   *\n   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n   *     var date2 = new Date(1234567890000);\n   *     date1.valueOf(); // 1234567890000\n   *     assert( date1 !== date2 );\n   *     assert( Immutable.is( date1, date2 ) );\n   *\n   * Note: overriding `valueOf` may have other implications if you use this object\n   * where JavaScript expects a primitive, such as implicit string coercion.\n   *\n   * For more complex types, especially collections, implementing `valueOf` may\n   * not be performant. An alternative is to implement `equals` and `hashCode`.\n   *\n   * `equals` takes another object, presumably of similar type, and returns true\n   * if it is equal. Equality is symmetrical, so the same result should be\n   * returned if this and the argument are flipped.\n   *\n   *     assert( a.equals(b) === b.equals(a) );\n   *\n   * `hashCode` returns a 32bit integer number representing the object which will\n   * be used to determine how to store the value object in a Map or Set. You must\n   * provide both or neither methods, one must not exist without the other.\n   *\n   * Also, an important relationship between these methods must be upheld: if two\n   * values are equal, they *must* return the same hashCode. If the values are not\n   * equal, they might have the same hashCode; this is called a hash collision,\n   * and while undesirable for performance reasons, it is acceptable.\n   *\n   *     if (a.equals(b)) {\n   *       assert( a.hashCode() === b.hashCode() );\n   *     }\n   *\n   * All Immutable collections are Value Objects: they implement `equals()`\n   * and `hashCode()`.\n   */\n  function is(valueA, valueB) {\n    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n      return true;\n    }\n    if (!valueA || !valueB) {\n      return false;\n    }\n    if (\n      typeof valueA.valueOf === 'function' &&\n      typeof valueB.valueOf === 'function'\n    ) {\n      valueA = valueA.valueOf();\n      valueB = valueB.valueOf();\n      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n        return true;\n      }\n      if (!valueA || !valueB) {\n        return false;\n      }\n    }\n    return !!(\n      isValueObject(valueA) &&\n      isValueObject(valueB) &&\n      valueA.equals(valueB)\n    );\n  }\n\n  var imul =\n    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2\n      ? Math.imul\n      : function imul(a, b) {\n          a |= 0; // int\n          b |= 0; // int\n          var c = a & 0xffff;\n          var d = b & 0xffff;\n          // Shift by 0 fixes the sign on the high part.\n          return (c * d + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0)) | 0; // int\n        };\n\n  // v8 has an optimization for storing 31-bit signed numbers.\n  // Values which have either 00 or 11 as the high order bits qualify.\n  // This function drops the highest order bit in a signed number, maintaining\n  // the sign bit.\n  function smi(i32) {\n    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xbfffffff);\n  }\n\n  var defaultValueOf = Object.prototype.valueOf;\n\n  function hash(o) {\n    switch (typeof o) {\n      case 'boolean':\n        // The hash values for built-in constants are a 1 value for each 5-byte\n        // shift region expect for the first, which encodes the value. This\n        // reduces the odds of a hash collision for these common values.\n        return o ? 0x42108421 : 0x42108420;\n      case 'number':\n        return hashNumber(o);\n      case 'string':\n        return o.length > STRING_HASH_CACHE_MIN_STRLEN\n          ? cachedHashString(o)\n          : hashString(o);\n      case 'object':\n      case 'function':\n        if (o === null) {\n          return 0x42108422;\n        }\n        if (typeof o.hashCode === 'function') {\n          // Drop any high bits from accidentally long hash codes.\n          return smi(o.hashCode(o));\n        }\n        if (o.valueOf !== defaultValueOf && typeof o.valueOf === 'function') {\n          o = o.valueOf(o);\n        }\n        return hashJSObj(o);\n      case 'undefined':\n        return 0x42108423;\n      default:\n        if (typeof o.toString === 'function') {\n          return hashString(o.toString());\n        }\n        throw new Error('Value type ' + typeof o + ' cannot be hashed.');\n    }\n  }\n\n  // Compress arbitrarily large numbers into smi hashes.\n  function hashNumber(n) {\n    if (n !== n || n === Infinity) {\n      return 0;\n    }\n    var hash = n | 0;\n    if (hash !== n) {\n      hash ^= n * 0xffffffff;\n    }\n    while (n > 0xffffffff) {\n      n /= 0xffffffff;\n      hash ^= n;\n    }\n    return smi(hash);\n  }\n\n  function cachedHashString(string) {\n    var hashed = stringHashCache[string];\n    if (hashed === undefined) {\n      hashed = hashString(string);\n      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n        STRING_HASH_CACHE_SIZE = 0;\n        stringHashCache = {};\n      }\n      STRING_HASH_CACHE_SIZE++;\n      stringHashCache[string] = hashed;\n    }\n    return hashed;\n  }\n\n  // http://jsperf.com/hashing-strings\n  function hashString(string) {\n    // This is the hash from JVM\n    // The hash code for a string is computed as\n    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n    // where s[i] is the ith character of the string and n is the length of\n    // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n    // (exclusive) by dropping high bits.\n    var hashed = 0;\n    for (var ii = 0; ii < string.length; ii++) {\n      hashed = (31 * hashed + string.charCodeAt(ii)) | 0;\n    }\n    return smi(hashed);\n  }\n\n  function hashJSObj(obj) {\n    var hashed;\n    if (usingWeakMap) {\n      hashed = weakMap.get(obj);\n      if (hashed !== undefined) {\n        return hashed;\n      }\n    }\n\n    hashed = obj[UID_HASH_KEY];\n    if (hashed !== undefined) {\n      return hashed;\n    }\n\n    if (!canDefineProperty) {\n      hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n      if (hashed !== undefined) {\n        return hashed;\n      }\n\n      hashed = getIENodeHash(obj);\n      if (hashed !== undefined) {\n        return hashed;\n      }\n    }\n\n    hashed = ++objHashUID;\n    if (objHashUID & 0x40000000) {\n      objHashUID = 0;\n    }\n\n    if (usingWeakMap) {\n      weakMap.set(obj, hashed);\n    } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n      throw new Error('Non-extensible objects are not allowed as keys.');\n    } else if (canDefineProperty) {\n      Object.defineProperty(obj, UID_HASH_KEY, {\n        enumerable: false,\n        configurable: false,\n        writable: false,\n        value: hashed,\n      });\n    } else if (\n      obj.propertyIsEnumerable !== undefined &&\n      obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable\n    ) {\n      // Since we can't define a non-enumerable property on the object\n      // we'll hijack one of the less-used non-enumerable properties to\n      // save our hash on it. Since this is a function it will not show up in\n      // `JSON.stringify` which is what we want.\n      obj.propertyIsEnumerable = function () {\n        return this.constructor.prototype.propertyIsEnumerable.apply(\n          this,\n          arguments\n        );\n      };\n      obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;\n    } else if (obj.nodeType !== undefined) {\n      // At this point we couldn't get the IE `uniqueID` to use as a hash\n      // and we couldn't use a non-enumerable property to exploit the\n      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n      // itself.\n      obj[UID_HASH_KEY] = hashed;\n    } else {\n      throw new Error('Unable to set a non-enumerable property on object.');\n    }\n\n    return hashed;\n  }\n\n  // Get references to ES5 object methods.\n  var isExtensible = Object.isExtensible;\n\n  // True if Object.defineProperty works as expected. IE8 fails this test.\n  var canDefineProperty = (function () {\n    try {\n      Object.defineProperty({}, '@', {});\n      return true;\n    } catch (e) {\n      return false;\n    }\n  })();\n\n  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n  // and avoid memory leaks from the IE cloneNode bug.\n  function getIENodeHash(node) {\n    if (node && node.nodeType > 0) {\n      switch (node.nodeType) {\n        case 1: // Element\n          return node.uniqueID;\n        case 9: // Document\n          return node.documentElement && node.documentElement.uniqueID;\n      }\n    }\n  }\n\n  // If possible, use a WeakMap.\n  var usingWeakMap = typeof WeakMap === 'function';\n  var weakMap;\n  if (usingWeakMap) {\n    weakMap = new WeakMap();\n  }\n\n  var objHashUID = 0;\n\n  var UID_HASH_KEY = '__immutablehash__';\n  if (typeof Symbol === 'function') {\n    UID_HASH_KEY = Symbol(UID_HASH_KEY);\n  }\n\n  var STRING_HASH_CACHE_MIN_STRLEN = 16;\n  var STRING_HASH_CACHE_MAX_SIZE = 255;\n  var STRING_HASH_CACHE_SIZE = 0;\n  var stringHashCache = {};\n\n  var ToKeyedSequence = /*@__PURE__*/(function (KeyedSeq) {\n    function ToKeyedSequence(indexed, useKeys) {\n      this._iter = indexed;\n      this._useKeys = useKeys;\n      this.size = indexed.size;\n    }\n\n    if ( KeyedSeq ) ToKeyedSequence.__proto__ = KeyedSeq;\n    ToKeyedSequence.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );\n    ToKeyedSequence.prototype.constructor = ToKeyedSequence;\n\n    ToKeyedSequence.prototype.get = function get (key, notSetValue) {\n      return this._iter.get(key, notSetValue);\n    };\n\n    ToKeyedSequence.prototype.has = function has (key) {\n      return this._iter.has(key);\n    };\n\n    ToKeyedSequence.prototype.valueSeq = function valueSeq () {\n      return this._iter.valueSeq();\n    };\n\n    ToKeyedSequence.prototype.reverse = function reverse () {\n      var this$1 = this;\n\n      var reversedSequence = reverseFactory(this, true);\n      if (!this._useKeys) {\n        reversedSequence.valueSeq = function () { return this$1._iter.toSeq().reverse(); };\n      }\n      return reversedSequence;\n    };\n\n    ToKeyedSequence.prototype.map = function map (mapper, context) {\n      var this$1 = this;\n\n      var mappedSequence = mapFactory(this, mapper, context);\n      if (!this._useKeys) {\n        mappedSequence.valueSeq = function () { return this$1._iter.toSeq().map(mapper, context); };\n      }\n      return mappedSequence;\n    };\n\n    ToKeyedSequence.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      return this._iter.__iterate(function (v, k) { return fn(v, k, this$1); }, reverse);\n    };\n\n    ToKeyedSequence.prototype.__iterator = function __iterator (type, reverse) {\n      return this._iter.__iterator(type, reverse);\n    };\n\n    return ToKeyedSequence;\n  }(KeyedSeq));\n  ToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;\n\n  var ToIndexedSequence = /*@__PURE__*/(function (IndexedSeq) {\n    function ToIndexedSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    if ( IndexedSeq ) ToIndexedSequence.__proto__ = IndexedSeq;\n    ToIndexedSequence.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n    ToIndexedSequence.prototype.constructor = ToIndexedSequence;\n\n    ToIndexedSequence.prototype.includes = function includes (value) {\n      return this._iter.includes(value);\n    };\n\n    ToIndexedSequence.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      var i = 0;\n      reverse && ensureSize(this);\n      return this._iter.__iterate(\n        function (v) { return fn(v, reverse ? this$1.size - ++i : i++, this$1); },\n        reverse\n      );\n    };\n\n    ToIndexedSequence.prototype.__iterator = function __iterator (type, reverse) {\n      var this$1 = this;\n\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var i = 0;\n      reverse && ensureSize(this);\n      return new Iterator(function () {\n        var step = iterator.next();\n        return step.done\n          ? step\n          : iteratorValue(\n              type,\n              reverse ? this$1.size - ++i : i++,\n              step.value,\n              step\n            );\n      });\n    };\n\n    return ToIndexedSequence;\n  }(IndexedSeq));\n\n  var ToSetSequence = /*@__PURE__*/(function (SetSeq) {\n    function ToSetSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    if ( SetSeq ) ToSetSequence.__proto__ = SetSeq;\n    ToSetSequence.prototype = Object.create( SetSeq && SetSeq.prototype );\n    ToSetSequence.prototype.constructor = ToSetSequence;\n\n    ToSetSequence.prototype.has = function has (key) {\n      return this._iter.includes(key);\n    };\n\n    ToSetSequence.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      return this._iter.__iterate(function (v) { return fn(v, v, this$1); }, reverse);\n    };\n\n    ToSetSequence.prototype.__iterator = function __iterator (type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function () {\n        var step = iterator.next();\n        return step.done\n          ? step\n          : iteratorValue(type, step.value, step.value, step);\n      });\n    };\n\n    return ToSetSequence;\n  }(SetSeq));\n\n  var FromEntriesSequence = /*@__PURE__*/(function (KeyedSeq) {\n    function FromEntriesSequence(entries) {\n      this._iter = entries;\n      this.size = entries.size;\n    }\n\n    if ( KeyedSeq ) FromEntriesSequence.__proto__ = KeyedSeq;\n    FromEntriesSequence.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );\n    FromEntriesSequence.prototype.constructor = FromEntriesSequence;\n\n    FromEntriesSequence.prototype.entrySeq = function entrySeq () {\n      return this._iter.toSeq();\n    };\n\n    FromEntriesSequence.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      return this._iter.__iterate(function (entry) {\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedCollection = isCollection(entry);\n          return fn(\n            indexedCollection ? entry.get(1) : entry[1],\n            indexedCollection ? entry.get(0) : entry[0],\n            this$1\n          );\n        }\n      }, reverse);\n    };\n\n    FromEntriesSequence.prototype.__iterator = function __iterator (type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function () {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          // Check if entry exists first so array access doesn't throw for holes\n          // in the parent iteration.\n          if (entry) {\n            validateEntry(entry);\n            var indexedCollection = isCollection(entry);\n            return iteratorValue(\n              type,\n              indexedCollection ? entry.get(0) : entry[0],\n              indexedCollection ? entry.get(1) : entry[1],\n              step\n            );\n          }\n        }\n      });\n    };\n\n    return FromEntriesSequence;\n  }(KeyedSeq));\n\n  ToIndexedSequence.prototype.cacheResult =\n    ToKeyedSequence.prototype.cacheResult =\n    ToSetSequence.prototype.cacheResult =\n    FromEntriesSequence.prototype.cacheResult =\n      cacheResultThrough;\n\n  function flipFactory(collection) {\n    var flipSequence = makeSequence(collection);\n    flipSequence._iter = collection;\n    flipSequence.size = collection.size;\n    flipSequence.flip = function () { return collection; };\n    flipSequence.reverse = function () {\n      var reversedSequence = collection.reverse.apply(this); // super.reverse()\n      reversedSequence.flip = function () { return collection.reverse(); };\n      return reversedSequence;\n    };\n    flipSequence.has = function (key) { return collection.includes(key); };\n    flipSequence.includes = function (key) { return collection.has(key); };\n    flipSequence.cacheResult = cacheResultThrough;\n    flipSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      return collection.__iterate(function (v, k) { return fn(k, v, this$1) !== false; }, reverse);\n    };\n    flipSequence.__iteratorUncached = function (type, reverse) {\n      if (type === ITERATE_ENTRIES) {\n        var iterator = collection.__iterator(type, reverse);\n        return new Iterator(function () {\n          var step = iterator.next();\n          if (!step.done) {\n            var k = step.value[0];\n            step.value[0] = step.value[1];\n            step.value[1] = k;\n          }\n          return step;\n        });\n      }\n      return collection.__iterator(\n        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n        reverse\n      );\n    };\n    return flipSequence;\n  }\n\n  function mapFactory(collection, mapper, context) {\n    var mappedSequence = makeSequence(collection);\n    mappedSequence.size = collection.size;\n    mappedSequence.has = function (key) { return collection.has(key); };\n    mappedSequence.get = function (key, notSetValue) {\n      var v = collection.get(key, NOT_SET);\n      return v === NOT_SET\n        ? notSetValue\n        : mapper.call(context, v, key, collection);\n    };\n    mappedSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      return collection.__iterate(\n        function (v, k, c) { return fn(mapper.call(context, v, k, c), k, this$1) !== false; },\n        reverse\n      );\n    };\n    mappedSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n      return new Iterator(function () {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var key = entry[0];\n        return iteratorValue(\n          type,\n          key,\n          mapper.call(context, entry[1], key, collection),\n          step\n        );\n      });\n    };\n    return mappedSequence;\n  }\n\n  function reverseFactory(collection, useKeys) {\n    var this$1 = this;\n\n    var reversedSequence = makeSequence(collection);\n    reversedSequence._iter = collection;\n    reversedSequence.size = collection.size;\n    reversedSequence.reverse = function () { return collection; };\n    if (collection.flip) {\n      reversedSequence.flip = function () {\n        var flipSequence = flipFactory(collection);\n        flipSequence.reverse = function () { return collection.flip(); };\n        return flipSequence;\n      };\n    }\n    reversedSequence.get = function (key, notSetValue) { return collection.get(useKeys ? key : -1 - key, notSetValue); };\n    reversedSequence.has = function (key) { return collection.has(useKeys ? key : -1 - key); };\n    reversedSequence.includes = function (value) { return collection.includes(value); };\n    reversedSequence.cacheResult = cacheResultThrough;\n    reversedSequence.__iterate = function (fn, reverse) {\n      var this$1 = this;\n\n      var i = 0;\n      reverse && ensureSize(collection);\n      return collection.__iterate(\n        function (v, k) { return fn(v, useKeys ? k : reverse ? this$1.size - ++i : i++, this$1); },\n        !reverse\n      );\n    };\n    reversedSequence.__iterator = function (type, reverse) {\n      var i = 0;\n      reverse && ensureSize(collection);\n      var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);\n      return new Iterator(function () {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        return iteratorValue(\n          type,\n          useKeys ? entry[0] : reverse ? this$1.size - ++i : i++,\n          entry[1],\n          step\n        );\n      });\n    };\n    return reversedSequence;\n  }\n\n  function filterFactory(collection, predicate, context, useKeys) {\n    var filterSequence = makeSequence(collection);\n    if (useKeys) {\n      filterSequence.has = function (key) {\n        var v = collection.get(key, NOT_SET);\n        return v !== NOT_SET && !!predicate.call(context, v, key, collection);\n      };\n      filterSequence.get = function (key, notSetValue) {\n        var v = collection.get(key, NOT_SET);\n        return v !== NOT_SET && predicate.call(context, v, key, collection)\n          ? v\n          : notSetValue;\n      };\n    }\n    filterSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      var iterations = 0;\n      collection.__iterate(function (v, k, c) {\n        if (predicate.call(context, v, k, c)) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$1);\n        }\n      }, reverse);\n      return iterations;\n    };\n    filterSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n      var iterations = 0;\n      return new Iterator(function () {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          var key = entry[0];\n          var value = entry[1];\n          if (predicate.call(context, value, key, collection)) {\n            return iteratorValue(type, useKeys ? key : iterations++, value, step);\n          }\n        }\n      });\n    };\n    return filterSequence;\n  }\n\n  function countByFactory(collection, grouper, context) {\n    var groups = Map().asMutable();\n    collection.__iterate(function (v, k) {\n      groups.update(grouper.call(context, v, k, collection), 0, function (a) { return a + 1; });\n    });\n    return groups.asImmutable();\n  }\n\n  function groupByFactory(collection, grouper, context) {\n    var isKeyedIter = isKeyed(collection);\n    var groups = (isOrdered(collection) ? OrderedMap() : Map()).asMutable();\n    collection.__iterate(function (v, k) {\n      groups.update(\n        grouper.call(context, v, k, collection),\n        function (a) { return ((a = a || []), a.push(isKeyedIter ? [k, v] : v), a); }\n      );\n    });\n    var coerce = collectionClass(collection);\n    return groups.map(function (arr) { return reify(collection, coerce(arr)); }).asImmutable();\n  }\n\n  function sliceFactory(collection, begin, end, useKeys) {\n    var originalSize = collection.size;\n\n    if (wholeSlice(begin, end, originalSize)) {\n      return collection;\n    }\n\n    var resolvedBegin = resolveBegin(begin, originalSize);\n    var resolvedEnd = resolveEnd(end, originalSize);\n\n    // begin or end will be NaN if they were provided as negative numbers and\n    // this collection's size is unknown. In that case, cache first so there is\n    // a known size and these do not resolve to NaN.\n    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n      return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);\n    }\n\n    // Note: resolvedEnd is undefined when the original sequence's length is\n    // unknown and this slice did not supply an end and should contain all\n    // elements after resolvedBegin.\n    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n    var resolvedSize = resolvedEnd - resolvedBegin;\n    var sliceSize;\n    if (resolvedSize === resolvedSize) {\n      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n    }\n\n    var sliceSeq = makeSequence(collection);\n\n    // If collection.size is undefined, the size of the realized sliceSeq is\n    // unknown at this point unless the number of items to slice is 0\n    sliceSeq.size =\n      sliceSize === 0 ? sliceSize : (collection.size && sliceSize) || undefined;\n\n    if (!useKeys && isSeq(collection) && sliceSize >= 0) {\n      sliceSeq.get = function (index, notSetValue) {\n        index = wrapIndex(this, index);\n        return index >= 0 && index < sliceSize\n          ? collection.get(index + resolvedBegin, notSetValue)\n          : notSetValue;\n      };\n    }\n\n    sliceSeq.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      if (sliceSize === 0) {\n        return 0;\n      }\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var skipped = 0;\n      var isSkipping = true;\n      var iterations = 0;\n      collection.__iterate(function (v, k) {\n        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n          iterations++;\n          return (\n            fn(v, useKeys ? k : iterations - 1, this$1) !== false &&\n            iterations !== sliceSize\n          );\n        }\n      });\n      return iterations;\n    };\n\n    sliceSeq.__iteratorUncached = function (type, reverse) {\n      if (sliceSize !== 0 && reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      // Don't bother instantiating parent iterator if taking 0.\n      if (sliceSize === 0) {\n        return new Iterator(iteratorDone);\n      }\n      var iterator = collection.__iterator(type, reverse);\n      var skipped = 0;\n      var iterations = 0;\n      return new Iterator(function () {\n        while (skipped++ < resolvedBegin) {\n          iterator.next();\n        }\n        if (++iterations > sliceSize) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (useKeys || type === ITERATE_VALUES || step.done) {\n          return step;\n        }\n        if (type === ITERATE_KEYS) {\n          return iteratorValue(type, iterations - 1, undefined, step);\n        }\n        return iteratorValue(type, iterations - 1, step.value[1], step);\n      });\n    };\n\n    return sliceSeq;\n  }\n\n  function takeWhileFactory(collection, predicate, context) {\n    var takeSequence = makeSequence(collection);\n    takeSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterations = 0;\n      collection.__iterate(\n        function (v, k, c) { return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1); }\n      );\n      return iterations;\n    };\n    takeSequence.__iteratorUncached = function (type, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n      var iterating = true;\n      return new Iterator(function () {\n        if (!iterating) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var k = entry[0];\n        var v = entry[1];\n        if (!predicate.call(context, v, k, this$1)) {\n          iterating = false;\n          return iteratorDone();\n        }\n        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n      });\n    };\n    return takeSequence;\n  }\n\n  function skipWhileFactory(collection, predicate, context, useKeys) {\n    var skipSequence = makeSequence(collection);\n    skipSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var isSkipping = true;\n      var iterations = 0;\n      collection.__iterate(function (v, k, c) {\n        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$1);\n        }\n      });\n      return iterations;\n    };\n    skipSequence.__iteratorUncached = function (type, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n      var skipping = true;\n      var iterations = 0;\n      return new Iterator(function () {\n        var step;\n        var k;\n        var v;\n        do {\n          step = iterator.next();\n          if (step.done) {\n            if (useKeys || type === ITERATE_VALUES) {\n              return step;\n            }\n            if (type === ITERATE_KEYS) {\n              return iteratorValue(type, iterations++, undefined, step);\n            }\n            return iteratorValue(type, iterations++, step.value[1], step);\n          }\n          var entry = step.value;\n          k = entry[0];\n          v = entry[1];\n          skipping && (skipping = predicate.call(context, v, k, this$1));\n        } while (skipping);\n        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n      });\n    };\n    return skipSequence;\n  }\n\n  function concatFactory(collection, values) {\n    var isKeyedCollection = isKeyed(collection);\n    var iters = [collection]\n      .concat(values)\n      .map(function (v) {\n        if (!isCollection(v)) {\n          v = isKeyedCollection\n            ? keyedSeqFromValue(v)\n            : indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n        } else if (isKeyedCollection) {\n          v = KeyedCollection(v);\n        }\n        return v;\n      })\n      .filter(function (v) { return v.size !== 0; });\n\n    if (iters.length === 0) {\n      return collection;\n    }\n\n    if (iters.length === 1) {\n      var singleton = iters[0];\n      if (\n        singleton === collection ||\n        (isKeyedCollection && isKeyed(singleton)) ||\n        (isIndexed(collection) && isIndexed(singleton))\n      ) {\n        return singleton;\n      }\n    }\n\n    var concatSeq = new ArraySeq(iters);\n    if (isKeyedCollection) {\n      concatSeq = concatSeq.toKeyedSeq();\n    } else if (!isIndexed(collection)) {\n      concatSeq = concatSeq.toSetSeq();\n    }\n    concatSeq = concatSeq.flatten(true);\n    concatSeq.size = iters.reduce(function (sum, seq) {\n      if (sum !== undefined) {\n        var size = seq.size;\n        if (size !== undefined) {\n          return sum + size;\n        }\n      }\n    }, 0);\n    return concatSeq;\n  }\n\n  function flattenFactory(collection, depth, useKeys) {\n    var flatSequence = makeSequence(collection);\n    flatSequence.__iterateUncached = function (fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterations = 0;\n      var stopped = false;\n      function flatDeep(iter, currentDepth) {\n        iter.__iterate(function (v, k) {\n          if ((!depth || currentDepth < depth) && isCollection(v)) {\n            flatDeep(v, currentDepth + 1);\n          } else {\n            iterations++;\n            if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {\n              stopped = true;\n            }\n          }\n          return !stopped;\n        }, reverse);\n      }\n      flatDeep(collection, 0);\n      return iterations;\n    };\n    flatSequence.__iteratorUncached = function (type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = collection.__iterator(type, reverse);\n      var stack = [];\n      var iterations = 0;\n      return new Iterator(function () {\n        while (iterator) {\n          var step = iterator.next();\n          if (step.done !== false) {\n            iterator = stack.pop();\n            continue;\n          }\n          var v = step.value;\n          if (type === ITERATE_ENTRIES) {\n            v = v[1];\n          }\n          if ((!depth || stack.length < depth) && isCollection(v)) {\n            stack.push(iterator);\n            iterator = v.__iterator(type, reverse);\n          } else {\n            return useKeys ? step : iteratorValue(type, iterations++, v, step);\n          }\n        }\n        return iteratorDone();\n      });\n    };\n    return flatSequence;\n  }\n\n  function flatMapFactory(collection, mapper, context) {\n    var coerce = collectionClass(collection);\n    return collection\n      .toSeq()\n      .map(function (v, k) { return coerce(mapper.call(context, v, k, collection)); })\n      .flatten(true);\n  }\n\n  function interposeFactory(collection, separator) {\n    var interposedSequence = makeSequence(collection);\n    interposedSequence.size = collection.size && collection.size * 2 - 1;\n    interposedSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      var iterations = 0;\n      collection.__iterate(\n        function (v) { return (!iterations || fn(separator, iterations++, this$1) !== false) &&\n          fn(v, iterations++, this$1) !== false; },\n        reverse\n      );\n      return iterations;\n    };\n    interposedSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = collection.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      var step;\n      return new Iterator(function () {\n        if (!step || iterations % 2) {\n          step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n        }\n        return iterations % 2\n          ? iteratorValue(type, iterations++, separator)\n          : iteratorValue(type, iterations++, step.value, step);\n      });\n    };\n    return interposedSequence;\n  }\n\n  function sortFactory(collection, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    var isKeyedCollection = isKeyed(collection);\n    var index = 0;\n    var entries = collection\n      .toSeq()\n      .map(function (v, k) { return [k, v, index++, mapper ? mapper(v, k, collection) : v]; })\n      .valueSeq()\n      .toArray();\n    entries\n      .sort(function (a, b) { return comparator(a[3], b[3]) || a[2] - b[2]; })\n      .forEach(\n        isKeyedCollection\n          ? function (v, i) {\n              entries[i].length = 2;\n            }\n          : function (v, i) {\n              entries[i] = v[1];\n            }\n      );\n    return isKeyedCollection\n      ? KeyedSeq(entries)\n      : isIndexed(collection)\n      ? IndexedSeq(entries)\n      : SetSeq(entries);\n  }\n\n  function maxFactory(collection, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    if (mapper) {\n      var entry = collection\n        .toSeq()\n        .map(function (v, k) { return [v, mapper(v, k, collection)]; })\n        .reduce(function (a, b) { return (maxCompare(comparator, a[1], b[1]) ? b : a); });\n      return entry && entry[0];\n    }\n    return collection.reduce(function (a, b) { return (maxCompare(comparator, a, b) ? b : a); });\n  }\n\n  function maxCompare(comparator, a, b) {\n    var comp = comparator(b, a);\n    // b is considered the new max if the comparator declares them equal, but\n    // they are not equal and b is in fact a nullish value.\n    return (\n      (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) ||\n      comp > 0\n    );\n  }\n\n  function zipWithFactory(keyIter, zipper, iters, zipAll) {\n    var zipSequence = makeSequence(keyIter);\n    var sizes = new ArraySeq(iters).map(function (i) { return i.size; });\n    zipSequence.size = zipAll ? sizes.max() : sizes.min();\n    // Note: this a generic base implementation of __iterate in terms of\n    // __iterator which may be more generically useful in the future.\n    zipSequence.__iterate = function (fn, reverse) {\n      /* generic:\n      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        iterations++;\n        if (fn(step.value[1], step.value[0], this) === false) {\n          break;\n        }\n      }\n      return iterations;\n      */\n      // indexed:\n      var iterator = this.__iterator(ITERATE_VALUES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        if (fn(step.value, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n    zipSequence.__iteratorUncached = function (type, reverse) {\n      var iterators = iters.map(\n        function (i) { return ((i = Collection(i)), getIterator(reverse ? i.reverse() : i)); }\n      );\n      var iterations = 0;\n      var isDone = false;\n      return new Iterator(function () {\n        var steps;\n        if (!isDone) {\n          steps = iterators.map(function (i) { return i.next(); });\n          isDone = zipAll ? steps.every(function (s) { return s.done; }) : steps.some(function (s) { return s.done; });\n        }\n        if (isDone) {\n          return iteratorDone();\n        }\n        return iteratorValue(\n          type,\n          iterations++,\n          zipper.apply(\n            null,\n            steps.map(function (s) { return s.value; })\n          )\n        );\n      });\n    };\n    return zipSequence;\n  }\n\n  // #pragma Helper Functions\n\n  function reify(iter, seq) {\n    return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);\n  }\n\n  function validateEntry(entry) {\n    if (entry !== Object(entry)) {\n      throw new TypeError('Expected [K, V] tuple: ' + entry);\n    }\n  }\n\n  function collectionClass(collection) {\n    return isKeyed(collection)\n      ? KeyedCollection\n      : isIndexed(collection)\n      ? IndexedCollection\n      : SetCollection;\n  }\n\n  function makeSequence(collection) {\n    return Object.create(\n      (isKeyed(collection)\n        ? KeyedSeq\n        : isIndexed(collection)\n        ? IndexedSeq\n        : SetSeq\n      ).prototype\n    );\n  }\n\n  function cacheResultThrough() {\n    if (this._iter.cacheResult) {\n      this._iter.cacheResult();\n      this.size = this._iter.size;\n      return this;\n    }\n    return Seq.prototype.cacheResult.call(this);\n  }\n\n  function defaultComparator(a, b) {\n    if (a === undefined && b === undefined) {\n      return 0;\n    }\n\n    if (a === undefined) {\n      return 1;\n    }\n\n    if (b === undefined) {\n      return -1;\n    }\n\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n\n  function arrCopy(arr, offset) {\n    offset = offset || 0;\n    var len = Math.max(0, arr.length - offset);\n    var newArr = new Array(len);\n    for (var ii = 0; ii < len; ii++) {\n      newArr[ii] = arr[ii + offset];\n    }\n    return newArr;\n  }\n\n  function invariant(condition, error) {\n    if (!condition) { throw new Error(error); }\n  }\n\n  function assertNotInfinite(size) {\n    invariant(\n      size !== Infinity,\n      'Cannot perform this action with an infinite size.'\n    );\n  }\n\n  function coerceKeyPath(keyPath) {\n    if (isArrayLike(keyPath) && typeof keyPath !== 'string') {\n      return keyPath;\n    }\n    if (isOrdered(keyPath)) {\n      return keyPath.toArray();\n    }\n    throw new TypeError(\n      'Invalid keyPath: expected Ordered Collection or Array: ' + keyPath\n    );\n  }\n\n  function isPlainObj(value) {\n    return (\n      value &&\n      (typeof value.constructor !== 'function' ||\n        value.constructor.name === 'Object')\n    );\n  }\n\n  /**\n   * Returns true if the value is a potentially-persistent data structure, either\n   * provided by Immutable.js or a plain Array or Object.\n   */\n  function isDataStructure(value) {\n    return (\n      typeof value === 'object' &&\n      (isImmutable(value) || Array.isArray(value) || isPlainObj(value))\n    );\n  }\n\n  function quoteString(value) {\n    try {\n      return typeof value === 'string' ? JSON.stringify(value) : String(value);\n    } catch (_ignoreError) {\n      return JSON.stringify(value);\n    }\n  }\n\n  function has(collection, key) {\n    return isImmutable(collection)\n      ? collection.has(key)\n      : isDataStructure(collection) && hasOwnProperty.call(collection, key);\n  }\n\n  function get(collection, key, notSetValue) {\n    return isImmutable(collection)\n      ? collection.get(key, notSetValue)\n      : !has(collection, key)\n      ? notSetValue\n      : typeof collection.get === 'function'\n      ? collection.get(key)\n      : collection[key];\n  }\n\n  function shallowCopy(from) {\n    if (Array.isArray(from)) {\n      return arrCopy(from);\n    }\n    var to = {};\n    for (var key in from) {\n      if (hasOwnProperty.call(from, key)) {\n        to[key] = from[key];\n      }\n    }\n    return to;\n  }\n\n  function remove(collection, key) {\n    if (!isDataStructure(collection)) {\n      throw new TypeError(\n        'Cannot update non-data-structure value: ' + collection\n      );\n    }\n    if (isImmutable(collection)) {\n      if (!collection.remove) {\n        throw new TypeError(\n          'Cannot update immutable value without .remove() method: ' + collection\n        );\n      }\n      return collection.remove(key);\n    }\n    if (!hasOwnProperty.call(collection, key)) {\n      return collection;\n    }\n    var collectionCopy = shallowCopy(collection);\n    if (Array.isArray(collectionCopy)) {\n      collectionCopy.splice(key, 1);\n    } else {\n      delete collectionCopy[key];\n    }\n    return collectionCopy;\n  }\n\n  function set(collection, key, value) {\n    if (!isDataStructure(collection)) {\n      throw new TypeError(\n        'Cannot update non-data-structure value: ' + collection\n      );\n    }\n    if (isImmutable(collection)) {\n      if (!collection.set) {\n        throw new TypeError(\n          'Cannot update immutable value without .set() method: ' + collection\n        );\n      }\n      return collection.set(key, value);\n    }\n    if (hasOwnProperty.call(collection, key) && value === collection[key]) {\n      return collection;\n    }\n    var collectionCopy = shallowCopy(collection);\n    collectionCopy[key] = value;\n    return collectionCopy;\n  }\n\n  function updateIn(collection, keyPath, notSetValue, updater) {\n    if (!updater) {\n      updater = notSetValue;\n      notSetValue = undefined;\n    }\n    var updatedValue = updateInDeeply(\n      isImmutable(collection),\n      collection,\n      coerceKeyPath(keyPath),\n      0,\n      notSetValue,\n      updater\n    );\n    return updatedValue === NOT_SET ? notSetValue : updatedValue;\n  }\n\n  function updateInDeeply(\n    inImmutable,\n    existing,\n    keyPath,\n    i,\n    notSetValue,\n    updater\n  ) {\n    var wasNotSet = existing === NOT_SET;\n    if (i === keyPath.length) {\n      var existingValue = wasNotSet ? notSetValue : existing;\n      var newValue = updater(existingValue);\n      return newValue === existingValue ? existing : newValue;\n    }\n    if (!wasNotSet && !isDataStructure(existing)) {\n      throw new TypeError(\n        'Cannot update within non-data-structure value in path [' +\n          keyPath.slice(0, i).map(quoteString) +\n          ']: ' +\n          existing\n      );\n    }\n    var key = keyPath[i];\n    var nextExisting = wasNotSet ? NOT_SET : get(existing, key, NOT_SET);\n    var nextUpdated = updateInDeeply(\n      nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting),\n      nextExisting,\n      keyPath,\n      i + 1,\n      notSetValue,\n      updater\n    );\n    return nextUpdated === nextExisting\n      ? existing\n      : nextUpdated === NOT_SET\n      ? remove(existing, key)\n      : set(\n          wasNotSet ? (inImmutable ? emptyMap() : {}) : existing,\n          key,\n          nextUpdated\n        );\n  }\n\n  function setIn(collection, keyPath, value) {\n    return updateIn(collection, keyPath, NOT_SET, function () { return value; });\n  }\n\n  function setIn$1(keyPath, v) {\n    return setIn(this, keyPath, v);\n  }\n\n  function removeIn(collection, keyPath) {\n    return updateIn(collection, keyPath, function () { return NOT_SET; });\n  }\n\n  function deleteIn(keyPath) {\n    return removeIn(this, keyPath);\n  }\n\n  function update(collection, key, notSetValue, updater) {\n    return updateIn(collection, [key], notSetValue, updater);\n  }\n\n  function update$1(key, notSetValue, updater) {\n    return arguments.length === 1\n      ? key(this)\n      : update(this, key, notSetValue, updater);\n  }\n\n  function updateIn$1(keyPath, notSetValue, updater) {\n    return updateIn(this, keyPath, notSetValue, updater);\n  }\n\n  function merge() {\n    var iters = [], len = arguments.length;\n    while ( len-- ) iters[ len ] = arguments[ len ];\n\n    return mergeIntoKeyedWith(this, iters);\n  }\n\n  function mergeWith(merger) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    if (typeof merger !== 'function') {\n      throw new TypeError('Invalid merger function: ' + merger);\n    }\n    return mergeIntoKeyedWith(this, iters, merger);\n  }\n\n  function mergeIntoKeyedWith(collection, collections, merger) {\n    var iters = [];\n    for (var ii = 0; ii < collections.length; ii++) {\n      var collection$1 = KeyedCollection(collections[ii]);\n      if (collection$1.size !== 0) {\n        iters.push(collection$1);\n      }\n    }\n    if (iters.length === 0) {\n      return collection;\n    }\n    if (\n      collection.toSeq().size === 0 &&\n      !collection.__ownerID &&\n      iters.length === 1\n    ) {\n      return collection.constructor(iters[0]);\n    }\n    return collection.withMutations(function (collection) {\n      var mergeIntoCollection = merger\n        ? function (value, key) {\n            update(collection, key, NOT_SET, function (oldVal) { return oldVal === NOT_SET ? value : merger(oldVal, value, key); }\n            );\n          }\n        : function (value, key) {\n            collection.set(key, value);\n          };\n      for (var ii = 0; ii < iters.length; ii++) {\n        iters[ii].forEach(mergeIntoCollection);\n      }\n    });\n  }\n\n  function merge$1(collection) {\n    var sources = [], len = arguments.length - 1;\n    while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n    return mergeWithSources(collection, sources);\n  }\n\n  function mergeWith$1(merger, collection) {\n    var sources = [], len = arguments.length - 2;\n    while ( len-- > 0 ) sources[ len ] = arguments[ len + 2 ];\n\n    return mergeWithSources(collection, sources, merger);\n  }\n\n  function mergeDeep(collection) {\n    var sources = [], len = arguments.length - 1;\n    while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n    return mergeDeepWithSources(collection, sources);\n  }\n\n  function mergeDeepWith(merger, collection) {\n    var sources = [], len = arguments.length - 2;\n    while ( len-- > 0 ) sources[ len ] = arguments[ len + 2 ];\n\n    return mergeDeepWithSources(collection, sources, merger);\n  }\n\n  function mergeDeepWithSources(collection, sources, merger) {\n    return mergeWithSources(collection, sources, deepMergerWith(merger));\n  }\n\n  function mergeWithSources(collection, sources, merger) {\n    if (!isDataStructure(collection)) {\n      throw new TypeError(\n        'Cannot merge into non-data-structure value: ' + collection\n      );\n    }\n    if (isImmutable(collection)) {\n      return typeof merger === 'function' && collection.mergeWith\n        ? collection.mergeWith.apply(collection, [ merger ].concat( sources ))\n        : collection.merge\n        ? collection.merge.apply(collection, sources)\n        : collection.concat.apply(collection, sources);\n    }\n    var isArray = Array.isArray(collection);\n    var merged = collection;\n    var Collection = isArray ? IndexedCollection : KeyedCollection;\n    var mergeItem = isArray\n      ? function (value) {\n          // Copy on write\n          if (merged === collection) {\n            merged = shallowCopy(merged);\n          }\n          merged.push(value);\n        }\n      : function (value, key) {\n          var hasVal = hasOwnProperty.call(merged, key);\n          var nextVal =\n            hasVal && merger ? merger(merged[key], value, key) : value;\n          if (!hasVal || nextVal !== merged[key]) {\n            // Copy on write\n            if (merged === collection) {\n              merged = shallowCopy(merged);\n            }\n            merged[key] = nextVal;\n          }\n        };\n    for (var i = 0; i < sources.length; i++) {\n      Collection(sources[i]).forEach(mergeItem);\n    }\n    return merged;\n  }\n\n  function deepMergerWith(merger) {\n    function deepMerger(oldValue, newValue, key) {\n      return isDataStructure(oldValue) && isDataStructure(newValue)\n        ? mergeWithSources(oldValue, [newValue], deepMerger)\n        : merger\n        ? merger(oldValue, newValue, key)\n        : newValue;\n    }\n    return deepMerger;\n  }\n\n  function mergeDeep$1() {\n    var iters = [], len = arguments.length;\n    while ( len-- ) iters[ len ] = arguments[ len ];\n\n    return mergeDeepWithSources(this, iters);\n  }\n\n  function mergeDeepWith$1(merger) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return mergeDeepWithSources(this, iters, merger);\n  }\n\n  function mergeIn(keyPath) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return updateIn(this, keyPath, emptyMap(), function (m) { return mergeWithSources(m, iters); });\n  }\n\n  function mergeDeepIn(keyPath) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return updateIn(this, keyPath, emptyMap(), function (m) { return mergeDeepWithSources(m, iters); }\n    );\n  }\n\n  function withMutations(fn) {\n    var mutable = this.asMutable();\n    fn(mutable);\n    return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n  }\n\n  function asMutable() {\n    return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n  }\n\n  function asImmutable() {\n    return this.__ensureOwner();\n  }\n\n  function wasAltered() {\n    return this.__altered;\n  }\n\n  var Map = /*@__PURE__*/(function (KeyedCollection) {\n    function Map(value) {\n      return value === null || value === undefined\n        ? emptyMap()\n        : isMap(value) && !isOrdered(value)\n        ? value\n        : emptyMap().withMutations(function (map) {\n            var iter = KeyedCollection(value);\n            assertNotInfinite(iter.size);\n            iter.forEach(function (v, k) { return map.set(k, v); });\n          });\n    }\n\n    if ( KeyedCollection ) Map.__proto__ = KeyedCollection;\n    Map.prototype = Object.create( KeyedCollection && KeyedCollection.prototype );\n    Map.prototype.constructor = Map;\n\n    Map.of = function of () {\n      var keyValues = [], len = arguments.length;\n      while ( len-- ) keyValues[ len ] = arguments[ len ];\n\n      return emptyMap().withMutations(function (map) {\n        for (var i = 0; i < keyValues.length; i += 2) {\n          if (i + 1 >= keyValues.length) {\n            throw new Error('Missing value for key: ' + keyValues[i]);\n          }\n          map.set(keyValues[i], keyValues[i + 1]);\n        }\n      });\n    };\n\n    Map.prototype.toString = function toString () {\n      return this.__toString('Map {', '}');\n    };\n\n    // @pragma Access\n\n    Map.prototype.get = function get (k, notSetValue) {\n      return this._root\n        ? this._root.get(0, undefined, k, notSetValue)\n        : notSetValue;\n    };\n\n    // @pragma Modification\n\n    Map.prototype.set = function set (k, v) {\n      return updateMap(this, k, v);\n    };\n\n    Map.prototype.remove = function remove (k) {\n      return updateMap(this, k, NOT_SET);\n    };\n\n    Map.prototype.deleteAll = function deleteAll (keys) {\n      var collection = Collection(keys);\n\n      if (collection.size === 0) {\n        return this;\n      }\n\n      return this.withMutations(function (map) {\n        collection.forEach(function (key) { return map.remove(key); });\n      });\n    };\n\n    Map.prototype.clear = function clear () {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._root = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyMap();\n    };\n\n    // @pragma Composition\n\n    Map.prototype.sort = function sort (comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator));\n    };\n\n    Map.prototype.sortBy = function sortBy (mapper, comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator, mapper));\n    };\n\n    Map.prototype.map = function map (mapper, context) {\n      return this.withMutations(function (map) {\n        map.forEach(function (value, key) {\n          map.set(key, mapper.call(context, value, key, map));\n        });\n      });\n    };\n\n    // @pragma Mutability\n\n    Map.prototype.__iterator = function __iterator (type, reverse) {\n      return new MapIterator(this, type, reverse);\n    };\n\n    Map.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      var iterations = 0;\n      this._root &&\n        this._root.iterate(function (entry) {\n          iterations++;\n          return fn(entry[1], entry[0], this$1);\n        }, reverse);\n      return iterations;\n    };\n\n    Map.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        if (this.size === 0) {\n          return emptyMap();\n        }\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeMap(this.size, this._root, ownerID, this.__hash);\n    };\n\n    return Map;\n  }(KeyedCollection));\n\n  Map.isMap = isMap;\n\n  var MapPrototype = Map.prototype;\n  MapPrototype[IS_MAP_SYMBOL] = true;\n  MapPrototype[DELETE] = MapPrototype.remove;\n  MapPrototype.removeAll = MapPrototype.deleteAll;\n  MapPrototype.setIn = setIn$1;\n  MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;\n  MapPrototype.update = update$1;\n  MapPrototype.updateIn = updateIn$1;\n  MapPrototype.merge = MapPrototype.concat = merge;\n  MapPrototype.mergeWith = mergeWith;\n  MapPrototype.mergeDeep = mergeDeep$1;\n  MapPrototype.mergeDeepWith = mergeDeepWith$1;\n  MapPrototype.mergeIn = mergeIn;\n  MapPrototype.mergeDeepIn = mergeDeepIn;\n  MapPrototype.withMutations = withMutations;\n  MapPrototype.wasAltered = wasAltered;\n  MapPrototype.asImmutable = asImmutable;\n  MapPrototype['@@transducer/init'] = MapPrototype.asMutable = asMutable;\n  MapPrototype['@@transducer/step'] = function (result, arr) {\n    return result.set(arr[0], arr[1]);\n  };\n  MapPrototype['@@transducer/result'] = function (obj) {\n    return obj.asImmutable();\n  };\n\n  // #pragma Trie Nodes\n\n  var ArrayMapNode = function ArrayMapNode(ownerID, entries) {\n    this.ownerID = ownerID;\n    this.entries = entries;\n  };\n\n  ArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n    var entries = this.entries;\n    for (var ii = 0, len = entries.length; ii < len; ii++) {\n      if (is(key, entries[ii][0])) {\n        return entries[ii][1];\n      }\n    }\n    return notSetValue;\n  };\n\n  ArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    var removed = value === NOT_SET;\n\n    var entries = this.entries;\n    var idx = 0;\n    var len = entries.length;\n    for (; idx < len; idx++) {\n      if (is(key, entries[idx][0])) {\n        break;\n      }\n    }\n    var exists = idx < len;\n\n    if (exists ? entries[idx][1] === value : removed) {\n      return this;\n    }\n\n    SetRef(didAlter);\n    (removed || !exists) && SetRef(didChangeSize);\n\n    if (removed && entries.length === 1) {\n      return; // undefined\n    }\n\n    if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n      return createNodes(ownerID, entries, key, value);\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newEntries = isEditable ? entries : arrCopy(entries);\n\n    if (exists) {\n      if (removed) {\n        idx === len - 1\n          ? newEntries.pop()\n          : (newEntries[idx] = newEntries.pop());\n      } else {\n        newEntries[idx] = [key, value];\n      }\n    } else {\n      newEntries.push([key, value]);\n    }\n\n    if (isEditable) {\n      this.entries = newEntries;\n      return this;\n    }\n\n    return new ArrayMapNode(ownerID, newEntries);\n  };\n\n  var BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {\n    this.ownerID = ownerID;\n    this.bitmap = bitmap;\n    this.nodes = nodes;\n  };\n\n  BitmapIndexedNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n    var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);\n    var bitmap = this.bitmap;\n    return (bitmap & bit) === 0\n      ? notSetValue\n      : this.nodes[popCount(bitmap & (bit - 1))].get(\n          shift + SHIFT,\n          keyHash,\n          key,\n          notSetValue\n        );\n  };\n\n  BitmapIndexedNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n    var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n    var bit = 1 << keyHashFrag;\n    var bitmap = this.bitmap;\n    var exists = (bitmap & bit) !== 0;\n\n    if (!exists && value === NOT_SET) {\n      return this;\n    }\n\n    var idx = popCount(bitmap & (bit - 1));\n    var nodes = this.nodes;\n    var node = exists ? nodes[idx] : undefined;\n    var newNode = updateNode(\n      node,\n      ownerID,\n      shift + SHIFT,\n      keyHash,\n      key,\n      value,\n      didChangeSize,\n      didAlter\n    );\n\n    if (newNode === node) {\n      return this;\n    }\n\n    if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n      return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n    }\n\n    if (\n      exists &&\n      !newNode &&\n      nodes.length === 2 &&\n      isLeafNode(nodes[idx ^ 1])\n    ) {\n      return nodes[idx ^ 1];\n    }\n\n    if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n      return newNode;\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newBitmap = exists ? (newNode ? bitmap : bitmap ^ bit) : bitmap | bit;\n    var newNodes = exists\n      ? newNode\n        ? setAt(nodes, idx, newNode, isEditable)\n        : spliceOut(nodes, idx, isEditable)\n      : spliceIn(nodes, idx, newNode, isEditable);\n\n    if (isEditable) {\n      this.bitmap = newBitmap;\n      this.nodes = newNodes;\n      return this;\n    }\n\n    return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n  };\n\n  var HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {\n    this.ownerID = ownerID;\n    this.count = count;\n    this.nodes = nodes;\n  };\n\n  HashArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n    var node = this.nodes[idx];\n    return node\n      ? node.get(shift + SHIFT, keyHash, key, notSetValue)\n      : notSetValue;\n  };\n\n  HashArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n    var removed = value === NOT_SET;\n    var nodes = this.nodes;\n    var node = nodes[idx];\n\n    if (removed && !node) {\n      return this;\n    }\n\n    var newNode = updateNode(\n      node,\n      ownerID,\n      shift + SHIFT,\n      keyHash,\n      key,\n      value,\n      didChangeSize,\n      didAlter\n    );\n    if (newNode === node) {\n      return this;\n    }\n\n    var newCount = this.count;\n    if (!node) {\n      newCount++;\n    } else if (!newNode) {\n      newCount--;\n      if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n        return packNodes(ownerID, nodes, newCount, idx);\n      }\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newNodes = setAt(nodes, idx, newNode, isEditable);\n\n    if (isEditable) {\n      this.count = newCount;\n      this.nodes = newNodes;\n      return this;\n    }\n\n    return new HashArrayMapNode(ownerID, newCount, newNodes);\n  };\n\n  var HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {\n    this.ownerID = ownerID;\n    this.keyHash = keyHash;\n    this.entries = entries;\n  };\n\n  HashCollisionNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n    var entries = this.entries;\n    for (var ii = 0, len = entries.length; ii < len; ii++) {\n      if (is(key, entries[ii][0])) {\n        return entries[ii][1];\n      }\n    }\n    return notSetValue;\n  };\n\n  HashCollisionNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n\n    var removed = value === NOT_SET;\n\n    if (keyHash !== this.keyHash) {\n      if (removed) {\n        return this;\n      }\n      SetRef(didAlter);\n      SetRef(didChangeSize);\n      return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n    }\n\n    var entries = this.entries;\n    var idx = 0;\n    var len = entries.length;\n    for (; idx < len; idx++) {\n      if (is(key, entries[idx][0])) {\n        break;\n      }\n    }\n    var exists = idx < len;\n\n    if (exists ? entries[idx][1] === value : removed) {\n      return this;\n    }\n\n    SetRef(didAlter);\n    (removed || !exists) && SetRef(didChangeSize);\n\n    if (removed && len === 2) {\n      return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newEntries = isEditable ? entries : arrCopy(entries);\n\n    if (exists) {\n      if (removed) {\n        idx === len - 1\n          ? newEntries.pop()\n          : (newEntries[idx] = newEntries.pop());\n      } else {\n        newEntries[idx] = [key, value];\n      }\n    } else {\n      newEntries.push([key, value]);\n    }\n\n    if (isEditable) {\n      this.entries = newEntries;\n      return this;\n    }\n\n    return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n  };\n\n  var ValueNode = function ValueNode(ownerID, keyHash, entry) {\n    this.ownerID = ownerID;\n    this.keyHash = keyHash;\n    this.entry = entry;\n  };\n\n  ValueNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n    return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n  };\n\n  ValueNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    var removed = value === NOT_SET;\n    var keyMatch = is(key, this.entry[0]);\n    if (keyMatch ? value === this.entry[1] : removed) {\n      return this;\n    }\n\n    SetRef(didAlter);\n\n    if (removed) {\n      SetRef(didChangeSize);\n      return; // undefined\n    }\n\n    if (keyMatch) {\n      if (ownerID && ownerID === this.ownerID) {\n        this.entry[1] = value;\n        return this;\n      }\n      return new ValueNode(ownerID, this.keyHash, [key, value]);\n    }\n\n    SetRef(didChangeSize);\n    return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n  };\n\n  // #pragma Iterators\n\n  ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate =\n    function (fn, reverse) {\n      var entries = this.entries;\n      for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n        if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n          return false;\n        }\n      }\n    };\n\n  BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate =\n    function (fn, reverse) {\n      var nodes = this.nodes;\n      for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n        var node = nodes[reverse ? maxIndex - ii : ii];\n        if (node && node.iterate(fn, reverse) === false) {\n          return false;\n        }\n      }\n    };\n\n  // eslint-disable-next-line no-unused-vars\n  ValueNode.prototype.iterate = function (fn, reverse) {\n    return fn(this.entry);\n  };\n\n  var MapIterator = /*@__PURE__*/(function (Iterator) {\n    function MapIterator(map, type, reverse) {\n      this._type = type;\n      this._reverse = reverse;\n      this._stack = map._root && mapIteratorFrame(map._root);\n    }\n\n    if ( Iterator ) MapIterator.__proto__ = Iterator;\n    MapIterator.prototype = Object.create( Iterator && Iterator.prototype );\n    MapIterator.prototype.constructor = MapIterator;\n\n    MapIterator.prototype.next = function next () {\n      var type = this._type;\n      var stack = this._stack;\n      while (stack) {\n        var node = stack.node;\n        var index = stack.index++;\n        var maxIndex = (void 0);\n        if (node.entry) {\n          if (index === 0) {\n            return mapIteratorValue(type, node.entry);\n          }\n        } else if (node.entries) {\n          maxIndex = node.entries.length - 1;\n          if (index <= maxIndex) {\n            return mapIteratorValue(\n              type,\n              node.entries[this._reverse ? maxIndex - index : index]\n            );\n          }\n        } else {\n          maxIndex = node.nodes.length - 1;\n          if (index <= maxIndex) {\n            var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n            if (subNode) {\n              if (subNode.entry) {\n                return mapIteratorValue(type, subNode.entry);\n              }\n              stack = this._stack = mapIteratorFrame(subNode, stack);\n            }\n            continue;\n          }\n        }\n        stack = this._stack = this._stack.__prev;\n      }\n      return iteratorDone();\n    };\n\n    return MapIterator;\n  }(Iterator));\n\n  function mapIteratorValue(type, entry) {\n    return iteratorValue(type, entry[0], entry[1]);\n  }\n\n  function mapIteratorFrame(node, prev) {\n    return {\n      node: node,\n      index: 0,\n      __prev: prev,\n    };\n  }\n\n  function makeMap(size, root, ownerID, hash) {\n    var map = Object.create(MapPrototype);\n    map.size = size;\n    map._root = root;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_MAP;\n  function emptyMap() {\n    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n  }\n\n  function updateMap(map, k, v) {\n    var newRoot;\n    var newSize;\n    if (!map._root) {\n      if (v === NOT_SET) {\n        return map;\n      }\n      newSize = 1;\n      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n    } else {\n      var didChangeSize = MakeRef();\n      var didAlter = MakeRef();\n      newRoot = updateNode(\n        map._root,\n        map.__ownerID,\n        0,\n        undefined,\n        k,\n        v,\n        didChangeSize,\n        didAlter\n      );\n      if (!didAlter.value) {\n        return map;\n      }\n      newSize = map.size + (didChangeSize.value ? (v === NOT_SET ? -1 : 1) : 0);\n    }\n    if (map.__ownerID) {\n      map.size = newSize;\n      map._root = newRoot;\n      map.__hash = undefined;\n      map.__altered = true;\n      return map;\n    }\n    return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n  }\n\n  function updateNode(\n    node,\n    ownerID,\n    shift,\n    keyHash,\n    key,\n    value,\n    didChangeSize,\n    didAlter\n  ) {\n    if (!node) {\n      if (value === NOT_SET) {\n        return node;\n      }\n      SetRef(didAlter);\n      SetRef(didChangeSize);\n      return new ValueNode(ownerID, keyHash, [key, value]);\n    }\n    return node.update(\n      ownerID,\n      shift,\n      keyHash,\n      key,\n      value,\n      didChangeSize,\n      didAlter\n    );\n  }\n\n  function isLeafNode(node) {\n    return (\n      node.constructor === ValueNode || node.constructor === HashCollisionNode\n    );\n  }\n\n  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n    if (node.keyHash === keyHash) {\n      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n    }\n\n    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\n    var newNode;\n    var nodes =\n      idx1 === idx2\n        ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)]\n        : ((newNode = new ValueNode(ownerID, keyHash, entry)),\n          idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\n    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n  }\n\n  function createNodes(ownerID, entries, key, value) {\n    if (!ownerID) {\n      ownerID = new OwnerID();\n    }\n    var node = new ValueNode(ownerID, hash(key), [key, value]);\n    for (var ii = 0; ii < entries.length; ii++) {\n      var entry = entries[ii];\n      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n    }\n    return node;\n  }\n\n  function packNodes(ownerID, nodes, count, excluding) {\n    var bitmap = 0;\n    var packedII = 0;\n    var packedNodes = new Array(count);\n    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n      var node = nodes[ii];\n      if (node !== undefined && ii !== excluding) {\n        bitmap |= bit;\n        packedNodes[packedII++] = node;\n      }\n    }\n    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n  }\n\n  function expandNodes(ownerID, nodes, bitmap, including, node) {\n    var count = 0;\n    var expandedNodes = new Array(SIZE);\n    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n    }\n    expandedNodes[including] = node;\n    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n  }\n\n  function popCount(x) {\n    x -= (x >> 1) & 0x55555555;\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    x = (x + (x >> 4)) & 0x0f0f0f0f;\n    x += x >> 8;\n    x += x >> 16;\n    return x & 0x7f;\n  }\n\n  function setAt(array, idx, val, canEdit) {\n    var newArray = canEdit ? array : arrCopy(array);\n    newArray[idx] = val;\n    return newArray;\n  }\n\n  function spliceIn(array, idx, val, canEdit) {\n    var newLen = array.length + 1;\n    if (canEdit && idx + 1 === newLen) {\n      array[idx] = val;\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        newArray[ii] = val;\n        after = -1;\n      } else {\n        newArray[ii] = array[ii + after];\n      }\n    }\n    return newArray;\n  }\n\n  function spliceOut(array, idx, canEdit) {\n    var newLen = array.length - 1;\n    if (canEdit && idx === newLen) {\n      array.pop();\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        after = 1;\n      }\n      newArray[ii] = array[ii + after];\n    }\n    return newArray;\n  }\n\n  var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\n  var IS_LIST_SYMBOL = '@@__IMMUTABLE_LIST__@@';\n\n  function isList(maybeList) {\n    return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);\n  }\n\n  var List = /*@__PURE__*/(function (IndexedCollection) {\n    function List(value) {\n      var empty = emptyList();\n      if (value === null || value === undefined) {\n        return empty;\n      }\n      if (isList(value)) {\n        return value;\n      }\n      var iter = IndexedCollection(value);\n      var size = iter.size;\n      if (size === 0) {\n        return empty;\n      }\n      assertNotInfinite(size);\n      if (size > 0 && size < SIZE) {\n        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n      }\n      return empty.withMutations(function (list) {\n        list.setSize(size);\n        iter.forEach(function (v, i) { return list.set(i, v); });\n      });\n    }\n\n    if ( IndexedCollection ) List.__proto__ = IndexedCollection;\n    List.prototype = Object.create( IndexedCollection && IndexedCollection.prototype );\n    List.prototype.constructor = List;\n\n    List.of = function of (/*...values*/) {\n      return this(arguments);\n    };\n\n    List.prototype.toString = function toString () {\n      return this.__toString('List [', ']');\n    };\n\n    // @pragma Access\n\n    List.prototype.get = function get (index, notSetValue) {\n      index = wrapIndex(this, index);\n      if (index >= 0 && index < this.size) {\n        index += this._origin;\n        var node = listNodeFor(this, index);\n        return node && node.array[index & MASK];\n      }\n      return notSetValue;\n    };\n\n    // @pragma Modification\n\n    List.prototype.set = function set (index, value) {\n      return updateList(this, index, value);\n    };\n\n    List.prototype.remove = function remove (index) {\n      return !this.has(index)\n        ? this\n        : index === 0\n        ? this.shift()\n        : index === this.size - 1\n        ? this.pop()\n        : this.splice(index, 1);\n    };\n\n    List.prototype.insert = function insert (index, value) {\n      return this.splice(index, 0, value);\n    };\n\n    List.prototype.clear = function clear () {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = this._origin = this._capacity = 0;\n        this._level = SHIFT;\n        this._root = this._tail = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyList();\n    };\n\n    List.prototype.push = function push (/*...values*/) {\n      var values = arguments;\n      var oldSize = this.size;\n      return this.withMutations(function (list) {\n        setListBounds(list, 0, oldSize + values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(oldSize + ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.pop = function pop () {\n      return setListBounds(this, 0, -1);\n    };\n\n    List.prototype.unshift = function unshift (/*...values*/) {\n      var values = arguments;\n      return this.withMutations(function (list) {\n        setListBounds(list, -values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.shift = function shift () {\n      return setListBounds(this, 1);\n    };\n\n    // @pragma Composition\n\n    List.prototype.concat = function concat (/*...collections*/) {\n      var arguments$1 = arguments;\n\n      var seqs = [];\n      for (var i = 0; i < arguments.length; i++) {\n        var argument = arguments$1[i];\n        var seq = IndexedCollection(\n          typeof argument !== 'string' && hasIterator(argument)\n            ? argument\n            : [argument]\n        );\n        if (seq.size !== 0) {\n          seqs.push(seq);\n        }\n      }\n      if (seqs.length === 0) {\n        return this;\n      }\n      if (this.size === 0 && !this.__ownerID && seqs.length === 1) {\n        return this.constructor(seqs[0]);\n      }\n      return this.withMutations(function (list) {\n        seqs.forEach(function (seq) { return seq.forEach(function (value) { return list.push(value); }); });\n      });\n    };\n\n    List.prototype.setSize = function setSize (size) {\n      return setListBounds(this, 0, size);\n    };\n\n    List.prototype.map = function map (mapper, context) {\n      var this$1 = this;\n\n      return this.withMutations(function (list) {\n        for (var i = 0; i < this$1.size; i++) {\n          list.set(i, mapper.call(context, list.get(i), i, list));\n        }\n      });\n    };\n\n    // @pragma Iteration\n\n    List.prototype.slice = function slice (begin, end) {\n      var size = this.size;\n      if (wholeSlice(begin, end, size)) {\n        return this;\n      }\n      return setListBounds(\n        this,\n        resolveBegin(begin, size),\n        resolveEnd(end, size)\n      );\n    };\n\n    List.prototype.__iterator = function __iterator (type, reverse) {\n      var index = reverse ? this.size : 0;\n      var values = iterateList(this, reverse);\n      return new Iterator(function () {\n        var value = values();\n        return value === DONE\n          ? iteratorDone()\n          : iteratorValue(type, reverse ? --index : index++, value);\n      });\n    };\n\n    List.prototype.__iterate = function __iterate (fn, reverse) {\n      var index = reverse ? this.size : 0;\n      var values = iterateList(this, reverse);\n      var value;\n      while ((value = values()) !== DONE) {\n        if (fn(value, reverse ? --index : index++, this) === false) {\n          break;\n        }\n      }\n      return index;\n    };\n\n    List.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        if (this.size === 0) {\n          return emptyList();\n        }\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeList(\n        this._origin,\n        this._capacity,\n        this._level,\n        this._root,\n        this._tail,\n        ownerID,\n        this.__hash\n      );\n    };\n\n    return List;\n  }(IndexedCollection));\n\n  List.isList = isList;\n\n  var ListPrototype = List.prototype;\n  ListPrototype[IS_LIST_SYMBOL] = true;\n  ListPrototype[DELETE] = ListPrototype.remove;\n  ListPrototype.merge = ListPrototype.concat;\n  ListPrototype.setIn = setIn$1;\n  ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;\n  ListPrototype.update = update$1;\n  ListPrototype.updateIn = updateIn$1;\n  ListPrototype.mergeIn = mergeIn;\n  ListPrototype.mergeDeepIn = mergeDeepIn;\n  ListPrototype.withMutations = withMutations;\n  ListPrototype.wasAltered = wasAltered;\n  ListPrototype.asImmutable = asImmutable;\n  ListPrototype['@@transducer/init'] = ListPrototype.asMutable = asMutable;\n  ListPrototype['@@transducer/step'] = function (result, arr) {\n    return result.push(arr);\n  };\n  ListPrototype['@@transducer/result'] = function (obj) {\n    return obj.asImmutable();\n  };\n\n  var VNode = function VNode(array, ownerID) {\n    this.array = array;\n    this.ownerID = ownerID;\n  };\n\n  // TODO: seems like these methods are very similar\n\n  VNode.prototype.removeBefore = function removeBefore (ownerID, level, index) {\n    if (index === level ? 1 << level :  this.array.length === 0) {\n      return this;\n    }\n    var originIndex = (index >>> level) & MASK;\n    if (originIndex >= this.array.length) {\n      return new VNode([], ownerID);\n    }\n    var removingFirst = originIndex === 0;\n    var newChild;\n    if (level > 0) {\n      var oldChild = this.array[originIndex];\n      newChild =\n        oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n      if (newChild === oldChild && removingFirst) {\n        return this;\n      }\n    }\n    if (removingFirst && !newChild) {\n      return this;\n    }\n    var editable = editableVNode(this, ownerID);\n    if (!removingFirst) {\n      for (var ii = 0; ii < originIndex; ii++) {\n        editable.array[ii] = undefined;\n      }\n    }\n    if (newChild) {\n      editable.array[originIndex] = newChild;\n    }\n    return editable;\n  };\n\n  VNode.prototype.removeAfter = function removeAfter (ownerID, level, index) {\n    if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n      return this;\n    }\n    var sizeIndex = ((index - 1) >>> level) & MASK;\n    if (sizeIndex >= this.array.length) {\n      return this;\n    }\n\n    var newChild;\n    if (level > 0) {\n      var oldChild = this.array[sizeIndex];\n      newChild =\n        oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n      if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n        return this;\n      }\n    }\n\n    var editable = editableVNode(this, ownerID);\n    editable.array.splice(sizeIndex + 1);\n    if (newChild) {\n      editable.array[sizeIndex] = newChild;\n    }\n    return editable;\n  };\n\n  var DONE = {};\n\n  function iterateList(list, reverse) {\n    var left = list._origin;\n    var right = list._capacity;\n    var tailPos = getTailOffset(right);\n    var tail = list._tail;\n\n    return iterateNodeOrLeaf(list._root, list._level, 0);\n\n    function iterateNodeOrLeaf(node, level, offset) {\n      return level === 0\n        ? iterateLeaf(node, offset)\n        : iterateNode(node, level, offset);\n    }\n\n    function iterateLeaf(node, offset) {\n      var array = offset === tailPos ? tail && tail.array : node && node.array;\n      var from = offset > left ? 0 : left - offset;\n      var to = right - offset;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function () {\n        if (from === to) {\n          return DONE;\n        }\n        var idx = reverse ? --to : from++;\n        return array && array[idx];\n      };\n    }\n\n    function iterateNode(node, level, offset) {\n      var values;\n      var array = node && node.array;\n      var from = offset > left ? 0 : (left - offset) >> level;\n      var to = ((right - offset) >> level) + 1;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function () {\n        while (true) {\n          if (values) {\n            var value = values();\n            if (value !== DONE) {\n              return value;\n            }\n            values = null;\n          }\n          if (from === to) {\n            return DONE;\n          }\n          var idx = reverse ? --to : from++;\n          values = iterateNodeOrLeaf(\n            array && array[idx],\n            level - SHIFT,\n            offset + (idx << level)\n          );\n        }\n      };\n    }\n  }\n\n  function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n    var list = Object.create(ListPrototype);\n    list.size = capacity - origin;\n    list._origin = origin;\n    list._capacity = capacity;\n    list._level = level;\n    list._root = root;\n    list._tail = tail;\n    list.__ownerID = ownerID;\n    list.__hash = hash;\n    list.__altered = false;\n    return list;\n  }\n\n  var EMPTY_LIST;\n  function emptyList() {\n    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n  }\n\n  function updateList(list, index, value) {\n    index = wrapIndex(list, index);\n\n    if (index !== index) {\n      return list;\n    }\n\n    if (index >= list.size || index < 0) {\n      return list.withMutations(function (list) {\n        index < 0\n          ? setListBounds(list, index).set(0, value)\n          : setListBounds(list, 0, index + 1).set(index, value);\n      });\n    }\n\n    index += list._origin;\n\n    var newTail = list._tail;\n    var newRoot = list._root;\n    var didAlter = MakeRef();\n    if (index >= getTailOffset(list._capacity)) {\n      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n    } else {\n      newRoot = updateVNode(\n        newRoot,\n        list.__ownerID,\n        list._level,\n        index,\n        value,\n        didAlter\n      );\n    }\n\n    if (!didAlter.value) {\n      return list;\n    }\n\n    if (list.__ownerID) {\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n  }\n\n  function updateVNode(node, ownerID, level, index, value, didAlter) {\n    var idx = (index >>> level) & MASK;\n    var nodeHas = node && idx < node.array.length;\n    if (!nodeHas && value === undefined) {\n      return node;\n    }\n\n    var newNode;\n\n    if (level > 0) {\n      var lowerNode = node && node.array[idx];\n      var newLowerNode = updateVNode(\n        lowerNode,\n        ownerID,\n        level - SHIFT,\n        index,\n        value,\n        didAlter\n      );\n      if (newLowerNode === lowerNode) {\n        return node;\n      }\n      newNode = editableVNode(node, ownerID);\n      newNode.array[idx] = newLowerNode;\n      return newNode;\n    }\n\n    if (nodeHas && node.array[idx] === value) {\n      return node;\n    }\n\n    if (didAlter) {\n      SetRef(didAlter);\n    }\n\n    newNode = editableVNode(node, ownerID);\n    if (value === undefined && idx === newNode.array.length - 1) {\n      newNode.array.pop();\n    } else {\n      newNode.array[idx] = value;\n    }\n    return newNode;\n  }\n\n  function editableVNode(node, ownerID) {\n    if (ownerID && node && ownerID === node.ownerID) {\n      return node;\n    }\n    return new VNode(node ? node.array.slice() : [], ownerID);\n  }\n\n  function listNodeFor(list, rawIndex) {\n    if (rawIndex >= getTailOffset(list._capacity)) {\n      return list._tail;\n    }\n    if (rawIndex < 1 << (list._level + SHIFT)) {\n      var node = list._root;\n      var level = list._level;\n      while (node && level > 0) {\n        node = node.array[(rawIndex >>> level) & MASK];\n        level -= SHIFT;\n      }\n      return node;\n    }\n  }\n\n  function setListBounds(list, begin, end) {\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin |= 0;\n    }\n    if (end !== undefined) {\n      end |= 0;\n    }\n    var owner = list.__ownerID || new OwnerID();\n    var oldOrigin = list._origin;\n    var oldCapacity = list._capacity;\n    var newOrigin = oldOrigin + begin;\n    var newCapacity =\n      end === undefined\n        ? oldCapacity\n        : end < 0\n        ? oldCapacity + end\n        : oldOrigin + end;\n    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n      return list;\n    }\n\n    // If it's going to end after it starts, it's empty.\n    if (newOrigin >= newCapacity) {\n      return list.clear();\n    }\n\n    var newLevel = list._level;\n    var newRoot = list._root;\n\n    // New origin might need creating a higher root.\n    var offsetShift = 0;\n    while (newOrigin + offsetShift < 0) {\n      newRoot = new VNode(\n        newRoot && newRoot.array.length ? [undefined, newRoot] : [],\n        owner\n      );\n      newLevel += SHIFT;\n      offsetShift += 1 << newLevel;\n    }\n    if (offsetShift) {\n      newOrigin += offsetShift;\n      oldOrigin += offsetShift;\n      newCapacity += offsetShift;\n      oldCapacity += offsetShift;\n    }\n\n    var oldTailOffset = getTailOffset(oldCapacity);\n    var newTailOffset = getTailOffset(newCapacity);\n\n    // New size might need creating a higher root.\n    while (newTailOffset >= 1 << (newLevel + SHIFT)) {\n      newRoot = new VNode(\n        newRoot && newRoot.array.length ? [newRoot] : [],\n        owner\n      );\n      newLevel += SHIFT;\n    }\n\n    // Locate or create the new tail.\n    var oldTail = list._tail;\n    var newTail =\n      newTailOffset < oldTailOffset\n        ? listNodeFor(list, newCapacity - 1)\n        : newTailOffset > oldTailOffset\n        ? new VNode([], owner)\n        : oldTail;\n\n    // Merge Tail into tree.\n    if (\n      oldTail &&\n      newTailOffset > oldTailOffset &&\n      newOrigin < oldCapacity &&\n      oldTail.array.length\n    ) {\n      newRoot = editableVNode(newRoot, owner);\n      var node = newRoot;\n      for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n        var idx = (oldTailOffset >>> level) & MASK;\n        node = node.array[idx] = editableVNode(node.array[idx], owner);\n      }\n      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n    }\n\n    // If the size has been reduced, there's a chance the tail needs to be trimmed.\n    if (newCapacity < oldCapacity) {\n      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n    }\n\n    // If the new origin is within the tail, then we do not need a root.\n    if (newOrigin >= newTailOffset) {\n      newOrigin -= newTailOffset;\n      newCapacity -= newTailOffset;\n      newLevel = SHIFT;\n      newRoot = null;\n      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n      // Otherwise, if the root has been trimmed, garbage collect.\n    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n      offsetShift = 0;\n\n      // Identify the new top root node of the subtree of the old root.\n      while (newRoot) {\n        var beginIndex = (newOrigin >>> newLevel) & MASK;\n        if ((beginIndex !== newTailOffset >>> newLevel) & MASK) {\n          break;\n        }\n        if (beginIndex) {\n          offsetShift += (1 << newLevel) * beginIndex;\n        }\n        newLevel -= SHIFT;\n        newRoot = newRoot.array[beginIndex];\n      }\n\n      // Trim the new sides of the new root.\n      if (newRoot && newOrigin > oldOrigin) {\n        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n      }\n      if (newRoot && newTailOffset < oldTailOffset) {\n        newRoot = newRoot.removeAfter(\n          owner,\n          newLevel,\n          newTailOffset - offsetShift\n        );\n      }\n      if (offsetShift) {\n        newOrigin -= offsetShift;\n        newCapacity -= offsetShift;\n      }\n    }\n\n    if (list.__ownerID) {\n      list.size = newCapacity - newOrigin;\n      list._origin = newOrigin;\n      list._capacity = newCapacity;\n      list._level = newLevel;\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n  }\n\n  function getTailOffset(size) {\n    return size < SIZE ? 0 : ((size - 1) >>> SHIFT) << SHIFT;\n  }\n\n  var OrderedMap = /*@__PURE__*/(function (Map) {\n    function OrderedMap(value) {\n      return value === null || value === undefined\n        ? emptyOrderedMap()\n        : isOrderedMap(value)\n        ? value\n        : emptyOrderedMap().withMutations(function (map) {\n            var iter = KeyedCollection(value);\n            assertNotInfinite(iter.size);\n            iter.forEach(function (v, k) { return map.set(k, v); });\n          });\n    }\n\n    if ( Map ) OrderedMap.__proto__ = Map;\n    OrderedMap.prototype = Object.create( Map && Map.prototype );\n    OrderedMap.prototype.constructor = OrderedMap;\n\n    OrderedMap.of = function of (/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedMap.prototype.toString = function toString () {\n      return this.__toString('OrderedMap {', '}');\n    };\n\n    // @pragma Access\n\n    OrderedMap.prototype.get = function get (k, notSetValue) {\n      var index = this._map.get(k);\n      return index !== undefined ? this._list.get(index)[1] : notSetValue;\n    };\n\n    // @pragma Modification\n\n    OrderedMap.prototype.clear = function clear () {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._map.clear();\n        this._list.clear();\n        return this;\n      }\n      return emptyOrderedMap();\n    };\n\n    OrderedMap.prototype.set = function set (k, v) {\n      return updateOrderedMap(this, k, v);\n    };\n\n    OrderedMap.prototype.remove = function remove (k) {\n      return updateOrderedMap(this, k, NOT_SET);\n    };\n\n    OrderedMap.prototype.wasAltered = function wasAltered () {\n      return this._map.wasAltered() || this._list.wasAltered();\n    };\n\n    OrderedMap.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      return this._list.__iterate(\n        function (entry) { return entry && fn(entry[1], entry[0], this$1); },\n        reverse\n      );\n    };\n\n    OrderedMap.prototype.__iterator = function __iterator (type, reverse) {\n      return this._list.fromEntrySeq().__iterator(type, reverse);\n    };\n\n    OrderedMap.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      var newList = this._list.__ensureOwner(ownerID);\n      if (!ownerID) {\n        if (this.size === 0) {\n          return emptyOrderedMap();\n        }\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        this._list = newList;\n        return this;\n      }\n      return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n    };\n\n    return OrderedMap;\n  }(Map));\n\n  OrderedMap.isOrderedMap = isOrderedMap;\n\n  OrderedMap.prototype[IS_ORDERED_SYMBOL] = true;\n  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\n  function makeOrderedMap(map, list, ownerID, hash) {\n    var omap = Object.create(OrderedMap.prototype);\n    omap.size = map ? map.size : 0;\n    omap._map = map;\n    omap._list = list;\n    omap.__ownerID = ownerID;\n    omap.__hash = hash;\n    return omap;\n  }\n\n  var EMPTY_ORDERED_MAP;\n  function emptyOrderedMap() {\n    return (\n      EMPTY_ORDERED_MAP ||\n      (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()))\n    );\n  }\n\n  function updateOrderedMap(omap, k, v) {\n    var map = omap._map;\n    var list = omap._list;\n    var i = map.get(k);\n    var has = i !== undefined;\n    var newMap;\n    var newList;\n    if (v === NOT_SET) {\n      // removed\n      if (!has) {\n        return omap;\n      }\n      if (list.size >= SIZE && list.size >= map.size * 2) {\n        newList = list.filter(function (entry, idx) { return entry !== undefined && i !== idx; });\n        newMap = newList\n          .toKeyedSeq()\n          .map(function (entry) { return entry[0]; })\n          .flip()\n          .toMap();\n        if (omap.__ownerID) {\n          newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n        }\n      } else {\n        newMap = map.remove(k);\n        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n      }\n    } else if (has) {\n      if (v === list.get(i)[1]) {\n        return omap;\n      }\n      newMap = map;\n      newList = list.set(i, [k, v]);\n    } else {\n      newMap = map.set(k, list.size);\n      newList = list.set(list.size, [k, v]);\n    }\n    if (omap.__ownerID) {\n      omap.size = newMap.size;\n      omap._map = newMap;\n      omap._list = newList;\n      omap.__hash = undefined;\n      return omap;\n    }\n    return makeOrderedMap(newMap, newList);\n  }\n\n  var IS_STACK_SYMBOL = '@@__IMMUTABLE_STACK__@@';\n\n  function isStack(maybeStack) {\n    return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);\n  }\n\n  var Stack = /*@__PURE__*/(function (IndexedCollection) {\n    function Stack(value) {\n      return value === null || value === undefined\n        ? emptyStack()\n        : isStack(value)\n        ? value\n        : emptyStack().pushAll(value);\n    }\n\n    if ( IndexedCollection ) Stack.__proto__ = IndexedCollection;\n    Stack.prototype = Object.create( IndexedCollection && IndexedCollection.prototype );\n    Stack.prototype.constructor = Stack;\n\n    Stack.of = function of (/*...values*/) {\n      return this(arguments);\n    };\n\n    Stack.prototype.toString = function toString () {\n      return this.__toString('Stack [', ']');\n    };\n\n    // @pragma Access\n\n    Stack.prototype.get = function get (index, notSetValue) {\n      var head = this._head;\n      index = wrapIndex(this, index);\n      while (head && index--) {\n        head = head.next;\n      }\n      return head ? head.value : notSetValue;\n    };\n\n    Stack.prototype.peek = function peek () {\n      return this._head && this._head.value;\n    };\n\n    // @pragma Modification\n\n    Stack.prototype.push = function push (/*...values*/) {\n      var arguments$1 = arguments;\n\n      if (arguments.length === 0) {\n        return this;\n      }\n      var newSize = this.size + arguments.length;\n      var head = this._head;\n      for (var ii = arguments.length - 1; ii >= 0; ii--) {\n        head = {\n          value: arguments$1[ii],\n          next: head,\n        };\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pushAll = function pushAll (iter) {\n      iter = IndexedCollection(iter);\n      if (iter.size === 0) {\n        return this;\n      }\n      if (this.size === 0 && isStack(iter)) {\n        return iter;\n      }\n      assertNotInfinite(iter.size);\n      var newSize = this.size;\n      var head = this._head;\n      iter.__iterate(function (value) {\n        newSize++;\n        head = {\n          value: value,\n          next: head,\n        };\n      }, /* reverse */ true);\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pop = function pop () {\n      return this.slice(1);\n    };\n\n    Stack.prototype.clear = function clear () {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._head = undefined;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyStack();\n    };\n\n    Stack.prototype.slice = function slice (begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      var resolvedBegin = resolveBegin(begin, this.size);\n      var resolvedEnd = resolveEnd(end, this.size);\n      if (resolvedEnd !== this.size) {\n        // super.slice(begin, end);\n        return IndexedCollection.prototype.slice.call(this, begin, end);\n      }\n      var newSize = this.size - resolvedBegin;\n      var head = this._head;\n      while (resolvedBegin--) {\n        head = head.next;\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    // @pragma Mutability\n\n    Stack.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        if (this.size === 0) {\n          return emptyStack();\n        }\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeStack(this.size, this._head, ownerID, this.__hash);\n    };\n\n    // @pragma Iteration\n\n    Stack.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return new ArraySeq(this.toArray()).__iterate(\n          function (v, k) { return fn(v, k, this$1); },\n          reverse\n        );\n      }\n      var iterations = 0;\n      var node = this._head;\n      while (node) {\n        if (fn(node.value, iterations++, this) === false) {\n          break;\n        }\n        node = node.next;\n      }\n      return iterations;\n    };\n\n    Stack.prototype.__iterator = function __iterator (type, reverse) {\n      if (reverse) {\n        return new ArraySeq(this.toArray()).__iterator(type, reverse);\n      }\n      var iterations = 0;\n      var node = this._head;\n      return new Iterator(function () {\n        if (node) {\n          var value = node.value;\n          node = node.next;\n          return iteratorValue(type, iterations++, value);\n        }\n        return iteratorDone();\n      });\n    };\n\n    return Stack;\n  }(IndexedCollection));\n\n  Stack.isStack = isStack;\n\n  var StackPrototype = Stack.prototype;\n  StackPrototype[IS_STACK_SYMBOL] = true;\n  StackPrototype.shift = StackPrototype.pop;\n  StackPrototype.unshift = StackPrototype.push;\n  StackPrototype.unshiftAll = StackPrototype.pushAll;\n  StackPrototype.withMutations = withMutations;\n  StackPrototype.wasAltered = wasAltered;\n  StackPrototype.asImmutable = asImmutable;\n  StackPrototype['@@transducer/init'] = StackPrototype.asMutable = asMutable;\n  StackPrototype['@@transducer/step'] = function (result, arr) {\n    return result.unshift(arr);\n  };\n  StackPrototype['@@transducer/result'] = function (obj) {\n    return obj.asImmutable();\n  };\n\n  function makeStack(size, head, ownerID, hash) {\n    var map = Object.create(StackPrototype);\n    map.size = size;\n    map._head = head;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_STACK;\n  function emptyStack() {\n    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n  }\n\n  var IS_SET_SYMBOL = '@@__IMMUTABLE_SET__@@';\n\n  function isSet(maybeSet) {\n    return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);\n  }\n\n  function isOrderedSet(maybeOrderedSet) {\n    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n  }\n\n  function deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    if (\n      !isCollection(b) ||\n      (a.size !== undefined && b.size !== undefined && a.size !== b.size) ||\n      (a.__hash !== undefined &&\n        b.__hash !== undefined &&\n        a.__hash !== b.__hash) ||\n      isKeyed(a) !== isKeyed(b) ||\n      isIndexed(a) !== isIndexed(b) ||\n      isOrdered(a) !== isOrdered(b)\n    ) {\n      return false;\n    }\n\n    if (a.size === 0 && b.size === 0) {\n      return true;\n    }\n\n    var notAssociative = !isAssociative(a);\n\n    if (isOrdered(a)) {\n      var entries = a.entries();\n      return (\n        b.every(function (v, k) {\n          var entry = entries.next().value;\n          return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n        }) && entries.next().done\n      );\n    }\n\n    var flipped = false;\n\n    if (a.size === undefined) {\n      if (b.size === undefined) {\n        if (typeof a.cacheResult === 'function') {\n          a.cacheResult();\n        }\n      } else {\n        flipped = true;\n        var _ = a;\n        a = b;\n        b = _;\n      }\n    }\n\n    var allEqual = true;\n    var bSize = b.__iterate(function (v, k) {\n      if (\n        notAssociative\n          ? !a.has(v)\n          : flipped\n          ? !is(v, a.get(k, NOT_SET))\n          : !is(a.get(k, NOT_SET), v)\n      ) {\n        allEqual = false;\n        return false;\n      }\n    });\n\n    return allEqual && a.size === bSize;\n  }\n\n  function mixin(ctor, methods) {\n    var keyCopier = function (key) {\n      ctor.prototype[key] = methods[key];\n    };\n    Object.keys(methods).forEach(keyCopier);\n    Object.getOwnPropertySymbols &&\n      Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n    return ctor;\n  }\n\n  function toJS(value) {\n    if (!value || typeof value !== 'object') {\n      return value;\n    }\n    if (!isCollection(value)) {\n      if (!isDataStructure(value)) {\n        return value;\n      }\n      value = Seq(value);\n    }\n    if (isKeyed(value)) {\n      var result$1 = {};\n      value.__iterate(function (v, k) {\n        result$1[k] = toJS(v);\n      });\n      return result$1;\n    }\n    var result = [];\n    value.__iterate(function (v) {\n      result.push(toJS(v));\n    });\n    return result;\n  }\n\n  var Set = /*@__PURE__*/(function (SetCollection) {\n    function Set(value) {\n      return value === null || value === undefined\n        ? emptySet()\n        : isSet(value) && !isOrdered(value)\n        ? value\n        : emptySet().withMutations(function (set) {\n            var iter = SetCollection(value);\n            assertNotInfinite(iter.size);\n            iter.forEach(function (v) { return set.add(v); });\n          });\n    }\n\n    if ( SetCollection ) Set.__proto__ = SetCollection;\n    Set.prototype = Object.create( SetCollection && SetCollection.prototype );\n    Set.prototype.constructor = Set;\n\n    Set.of = function of (/*...values*/) {\n      return this(arguments);\n    };\n\n    Set.fromKeys = function fromKeys (value) {\n      return this(KeyedCollection(value).keySeq());\n    };\n\n    Set.intersect = function intersect (sets) {\n      sets = Collection(sets).toArray();\n      return sets.length\n        ? SetPrototype.intersect.apply(Set(sets.pop()), sets)\n        : emptySet();\n    };\n\n    Set.union = function union (sets) {\n      sets = Collection(sets).toArray();\n      return sets.length\n        ? SetPrototype.union.apply(Set(sets.pop()), sets)\n        : emptySet();\n    };\n\n    Set.prototype.toString = function toString () {\n      return this.__toString('Set {', '}');\n    };\n\n    // @pragma Access\n\n    Set.prototype.has = function has (value) {\n      return this._map.has(value);\n    };\n\n    // @pragma Modification\n\n    Set.prototype.add = function add (value) {\n      return updateSet(this, this._map.set(value, value));\n    };\n\n    Set.prototype.remove = function remove (value) {\n      return updateSet(this, this._map.remove(value));\n    };\n\n    Set.prototype.clear = function clear () {\n      return updateSet(this, this._map.clear());\n    };\n\n    // @pragma Composition\n\n    Set.prototype.map = function map (mapper, context) {\n      var this$1 = this;\n\n      var removes = [];\n      var adds = [];\n      this.forEach(function (value) {\n        var mapped = mapper.call(context, value, value, this$1);\n        if (mapped !== value) {\n          removes.push(value);\n          adds.push(mapped);\n        }\n      });\n      return this.withMutations(function (set) {\n        removes.forEach(function (value) { return set.remove(value); });\n        adds.forEach(function (value) { return set.add(value); });\n      });\n    };\n\n    Set.prototype.union = function union () {\n      var iters = [], len = arguments.length;\n      while ( len-- ) iters[ len ] = arguments[ len ];\n\n      iters = iters.filter(function (x) { return x.size !== 0; });\n      if (iters.length === 0) {\n        return this;\n      }\n      if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n        return this.constructor(iters[0]);\n      }\n      return this.withMutations(function (set) {\n        for (var ii = 0; ii < iters.length; ii++) {\n          SetCollection(iters[ii]).forEach(function (value) { return set.add(value); });\n        }\n      });\n    };\n\n    Set.prototype.intersect = function intersect () {\n      var iters = [], len = arguments.length;\n      while ( len-- ) iters[ len ] = arguments[ len ];\n\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function (iter) { return SetCollection(iter); });\n      var toRemove = [];\n      this.forEach(function (value) {\n        if (!iters.every(function (iter) { return iter.includes(value); })) {\n          toRemove.push(value);\n        }\n      });\n      return this.withMutations(function (set) {\n        toRemove.forEach(function (value) {\n          set.remove(value);\n        });\n      });\n    };\n\n    Set.prototype.subtract = function subtract () {\n      var iters = [], len = arguments.length;\n      while ( len-- ) iters[ len ] = arguments[ len ];\n\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function (iter) { return SetCollection(iter); });\n      var toRemove = [];\n      this.forEach(function (value) {\n        if (iters.some(function (iter) { return iter.includes(value); })) {\n          toRemove.push(value);\n        }\n      });\n      return this.withMutations(function (set) {\n        toRemove.forEach(function (value) {\n          set.remove(value);\n        });\n      });\n    };\n\n    Set.prototype.sort = function sort (comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator));\n    };\n\n    Set.prototype.sortBy = function sortBy (mapper, comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator, mapper));\n    };\n\n    Set.prototype.wasAltered = function wasAltered () {\n      return this._map.wasAltered();\n    };\n\n    Set.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      return this._map.__iterate(function (k) { return fn(k, k, this$1); }, reverse);\n    };\n\n    Set.prototype.__iterator = function __iterator (type, reverse) {\n      return this._map.__iterator(type, reverse);\n    };\n\n    Set.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        if (this.size === 0) {\n          return this.__empty();\n        }\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return this.__make(newMap, ownerID);\n    };\n\n    return Set;\n  }(SetCollection));\n\n  Set.isSet = isSet;\n\n  var SetPrototype = Set.prototype;\n  SetPrototype[IS_SET_SYMBOL] = true;\n  SetPrototype[DELETE] = SetPrototype.remove;\n  SetPrototype.merge = SetPrototype.concat = SetPrototype.union;\n  SetPrototype.withMutations = withMutations;\n  SetPrototype.asImmutable = asImmutable;\n  SetPrototype['@@transducer/init'] = SetPrototype.asMutable = asMutable;\n  SetPrototype['@@transducer/step'] = function (result, arr) {\n    return result.add(arr);\n  };\n  SetPrototype['@@transducer/result'] = function (obj) {\n    return obj.asImmutable();\n  };\n\n  SetPrototype.__empty = emptySet;\n  SetPrototype.__make = makeSet;\n\n  function updateSet(set, newMap) {\n    if (set.__ownerID) {\n      set.size = newMap.size;\n      set._map = newMap;\n      return set;\n    }\n    return newMap === set._map\n      ? set\n      : newMap.size === 0\n      ? set.__empty()\n      : set.__make(newMap);\n  }\n\n  function makeSet(map, ownerID) {\n    var set = Object.create(SetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_SET;\n  function emptySet() {\n    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n  }\n\n  /**\n   * Returns a lazy seq of nums from start (inclusive) to end\n   * (exclusive), by step, where start defaults to 0, step to 1, and end to\n   * infinity. When start is equal to end, returns empty list.\n   */\n  var Range = /*@__PURE__*/(function (IndexedSeq) {\n    function Range(start, end, step) {\n      if (!(this instanceof Range)) {\n        return new Range(start, end, step);\n      }\n      invariant(step !== 0, 'Cannot step a Range by 0');\n      start = start || 0;\n      if (end === undefined) {\n        end = Infinity;\n      }\n      step = step === undefined ? 1 : Math.abs(step);\n      if (end < start) {\n        step = -step;\n      }\n      this._start = start;\n      this._end = end;\n      this._step = step;\n      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n      if (this.size === 0) {\n        if (EMPTY_RANGE) {\n          return EMPTY_RANGE;\n        }\n        EMPTY_RANGE = this;\n      }\n    }\n\n    if ( IndexedSeq ) Range.__proto__ = IndexedSeq;\n    Range.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n    Range.prototype.constructor = Range;\n\n    Range.prototype.toString = function toString () {\n      if (this.size === 0) {\n        return 'Range []';\n      }\n      return (\n        'Range [ ' +\n        this._start +\n        '...' +\n        this._end +\n        (this._step !== 1 ? ' by ' + this._step : '') +\n        ' ]'\n      );\n    };\n\n    Range.prototype.get = function get (index, notSetValue) {\n      return this.has(index)\n        ? this._start + wrapIndex(this, index) * this._step\n        : notSetValue;\n    };\n\n    Range.prototype.includes = function includes (searchValue) {\n      var possibleIndex = (searchValue - this._start) / this._step;\n      return (\n        possibleIndex >= 0 &&\n        possibleIndex < this.size &&\n        possibleIndex === Math.floor(possibleIndex)\n      );\n    };\n\n    Range.prototype.slice = function slice (begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      begin = resolveBegin(begin, this.size);\n      end = resolveEnd(end, this.size);\n      if (end <= begin) {\n        return new Range(0, 0);\n      }\n      return new Range(\n        this.get(begin, this._end),\n        this.get(end, this._end),\n        this._step\n      );\n    };\n\n    Range.prototype.indexOf = function indexOf (searchValue) {\n      var offsetValue = searchValue - this._start;\n      if (offsetValue % this._step === 0) {\n        var index = offsetValue / this._step;\n        if (index >= 0 && index < this.size) {\n          return index;\n        }\n      }\n      return -1;\n    };\n\n    Range.prototype.lastIndexOf = function lastIndexOf (searchValue) {\n      return this.indexOf(searchValue);\n    };\n\n    Range.prototype.__iterate = function __iterate (fn, reverse) {\n      var size = this.size;\n      var step = this._step;\n      var value = reverse ? this._start + (size - 1) * step : this._start;\n      var i = 0;\n      while (i !== size) {\n        if (fn(value, reverse ? size - ++i : i++, this) === false) {\n          break;\n        }\n        value += reverse ? -step : step;\n      }\n      return i;\n    };\n\n    Range.prototype.__iterator = function __iterator (type, reverse) {\n      var size = this.size;\n      var step = this._step;\n      var value = reverse ? this._start + (size - 1) * step : this._start;\n      var i = 0;\n      return new Iterator(function () {\n        if (i === size) {\n          return iteratorDone();\n        }\n        var v = value;\n        value += reverse ? -step : step;\n        return iteratorValue(type, reverse ? size - ++i : i++, v);\n      });\n    };\n\n    Range.prototype.equals = function equals (other) {\n      return other instanceof Range\n        ? this._start === other._start &&\n            this._end === other._end &&\n            this._step === other._step\n        : deepEqual(this, other);\n    };\n\n    return Range;\n  }(IndexedSeq));\n\n  var EMPTY_RANGE;\n\n  function getIn(collection, searchKeyPath, notSetValue) {\n    var keyPath = coerceKeyPath(searchKeyPath);\n    var i = 0;\n    while (i !== keyPath.length) {\n      collection = get(collection, keyPath[i++], NOT_SET);\n      if (collection === NOT_SET) {\n        return notSetValue;\n      }\n    }\n    return collection;\n  }\n\n  function getIn$1(searchKeyPath, notSetValue) {\n    return getIn(this, searchKeyPath, notSetValue);\n  }\n\n  function hasIn(collection, keyPath) {\n    return getIn(collection, keyPath, NOT_SET) !== NOT_SET;\n  }\n\n  function hasIn$1(searchKeyPath) {\n    return hasIn(this, searchKeyPath);\n  }\n\n  function toObject() {\n    assertNotInfinite(this.size);\n    var object = {};\n    this.__iterate(function (v, k) {\n      object[k] = v;\n    });\n    return object;\n  }\n\n  // Note: all of these methods are deprecated.\n  Collection.isIterable = isCollection;\n  Collection.isKeyed = isKeyed;\n  Collection.isIndexed = isIndexed;\n  Collection.isAssociative = isAssociative;\n  Collection.isOrdered = isOrdered;\n\n  Collection.Iterator = Iterator;\n\n  mixin(Collection, {\n    // ### Conversion to other types\n\n    toArray: function toArray() {\n      assertNotInfinite(this.size);\n      var array = new Array(this.size || 0);\n      var useTuples = isKeyed(this);\n      var i = 0;\n      this.__iterate(function (v, k) {\n        // Keyed collections produce an array of tuples.\n        array[i++] = useTuples ? [k, v] : v;\n      });\n      return array;\n    },\n\n    toIndexedSeq: function toIndexedSeq() {\n      return new ToIndexedSequence(this);\n    },\n\n    toJS: function toJS$1() {\n      return toJS(this);\n    },\n\n    toKeyedSeq: function toKeyedSeq() {\n      return new ToKeyedSequence(this, true);\n    },\n\n    toMap: function toMap() {\n      // Use Late Binding here to solve the circular dependency.\n      return Map(this.toKeyedSeq());\n    },\n\n    toObject: toObject,\n\n    toOrderedMap: function toOrderedMap() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedMap(this.toKeyedSeq());\n    },\n\n    toOrderedSet: function toOrderedSet() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSet: function toSet() {\n      // Use Late Binding here to solve the circular dependency.\n      return Set(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSetSeq: function toSetSeq() {\n      return new ToSetSequence(this);\n    },\n\n    toSeq: function toSeq() {\n      return isIndexed(this)\n        ? this.toIndexedSeq()\n        : isKeyed(this)\n        ? this.toKeyedSeq()\n        : this.toSetSeq();\n    },\n\n    toStack: function toStack() {\n      // Use Late Binding here to solve the circular dependency.\n      return Stack(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toList: function toList() {\n      // Use Late Binding here to solve the circular dependency.\n      return List(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    // ### Common JavaScript methods and properties\n\n    toString: function toString() {\n      return '[Collection]';\n    },\n\n    __toString: function __toString(head, tail) {\n      if (this.size === 0) {\n        return head + tail;\n      }\n      return (\n        head +\n        ' ' +\n        this.toSeq().map(this.__toStringMapper).join(', ') +\n        ' ' +\n        tail\n      );\n    },\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    concat: function concat() {\n      var values = [], len = arguments.length;\n      while ( len-- ) values[ len ] = arguments[ len ];\n\n      return reify(this, concatFactory(this, values));\n    },\n\n    includes: function includes(searchValue) {\n      return this.some(function (value) { return is(value, searchValue); });\n    },\n\n    entries: function entries() {\n      return this.__iterator(ITERATE_ENTRIES);\n    },\n\n    every: function every(predicate, context) {\n      assertNotInfinite(this.size);\n      var returnValue = true;\n      this.__iterate(function (v, k, c) {\n        if (!predicate.call(context, v, k, c)) {\n          returnValue = false;\n          return false;\n        }\n      });\n      return returnValue;\n    },\n\n    filter: function filter(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, true));\n    },\n\n    find: function find(predicate, context, notSetValue) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[1] : notSetValue;\n    },\n\n    forEach: function forEach(sideEffect, context) {\n      assertNotInfinite(this.size);\n      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n    },\n\n    join: function join(separator) {\n      assertNotInfinite(this.size);\n      separator = separator !== undefined ? '' + separator : ',';\n      var joined = '';\n      var isFirst = true;\n      this.__iterate(function (v) {\n        isFirst ? (isFirst = false) : (joined += separator);\n        joined += v !== null && v !== undefined ? v.toString() : '';\n      });\n      return joined;\n    },\n\n    keys: function keys() {\n      return this.__iterator(ITERATE_KEYS);\n    },\n\n    map: function map(mapper, context) {\n      return reify(this, mapFactory(this, mapper, context));\n    },\n\n    reduce: function reduce$1(reducer, initialReduction, context) {\n      return reduce(\n        this,\n        reducer,\n        initialReduction,\n        context,\n        arguments.length < 2,\n        false\n      );\n    },\n\n    reduceRight: function reduceRight(reducer, initialReduction, context) {\n      return reduce(\n        this,\n        reducer,\n        initialReduction,\n        context,\n        arguments.length < 2,\n        true\n      );\n    },\n\n    reverse: function reverse() {\n      return reify(this, reverseFactory(this, true));\n    },\n\n    slice: function slice(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, true));\n    },\n\n    some: function some(predicate, context) {\n      return !this.every(not(predicate), context);\n    },\n\n    sort: function sort(comparator) {\n      return reify(this, sortFactory(this, comparator));\n    },\n\n    values: function values() {\n      return this.__iterator(ITERATE_VALUES);\n    },\n\n    // ### More sequential methods\n\n    butLast: function butLast() {\n      return this.slice(0, -1);\n    },\n\n    isEmpty: function isEmpty() {\n      return this.size !== undefined ? this.size === 0 : !this.some(function () { return true; });\n    },\n\n    count: function count(predicate, context) {\n      return ensureSize(\n        predicate ? this.toSeq().filter(predicate, context) : this\n      );\n    },\n\n    countBy: function countBy(grouper, context) {\n      return countByFactory(this, grouper, context);\n    },\n\n    equals: function equals(other) {\n      return deepEqual(this, other);\n    },\n\n    entrySeq: function entrySeq() {\n      var collection = this;\n      if (collection._cache) {\n        // We cache as an entries array, so we can just return the cache!\n        return new ArraySeq(collection._cache);\n      }\n      var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();\n      entriesSequence.fromEntrySeq = function () { return collection.toSeq(); };\n      return entriesSequence;\n    },\n\n    filterNot: function filterNot(predicate, context) {\n      return this.filter(not(predicate), context);\n    },\n\n    findEntry: function findEntry(predicate, context, notSetValue) {\n      var found = notSetValue;\n      this.__iterate(function (v, k, c) {\n        if (predicate.call(context, v, k, c)) {\n          found = [k, v];\n          return false;\n        }\n      });\n      return found;\n    },\n\n    findKey: function findKey(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry && entry[0];\n    },\n\n    findLast: function findLast(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n    },\n\n    findLastEntry: function findLastEntry(predicate, context, notSetValue) {\n      return this.toKeyedSeq()\n        .reverse()\n        .findEntry(predicate, context, notSetValue);\n    },\n\n    findLastKey: function findLastKey(predicate, context) {\n      return this.toKeyedSeq().reverse().findKey(predicate, context);\n    },\n\n    first: function first(notSetValue) {\n      return this.find(returnTrue, null, notSetValue);\n    },\n\n    flatMap: function flatMap(mapper, context) {\n      return reify(this, flatMapFactory(this, mapper, context));\n    },\n\n    flatten: function flatten(depth) {\n      return reify(this, flattenFactory(this, depth, true));\n    },\n\n    fromEntrySeq: function fromEntrySeq() {\n      return new FromEntriesSequence(this);\n    },\n\n    get: function get(searchKey, notSetValue) {\n      return this.find(function (_, key) { return is(key, searchKey); }, undefined, notSetValue);\n    },\n\n    getIn: getIn$1,\n\n    groupBy: function groupBy(grouper, context) {\n      return groupByFactory(this, grouper, context);\n    },\n\n    has: function has(searchKey) {\n      return this.get(searchKey, NOT_SET) !== NOT_SET;\n    },\n\n    hasIn: hasIn$1,\n\n    isSubset: function isSubset(iter) {\n      iter = typeof iter.includes === 'function' ? iter : Collection(iter);\n      return this.every(function (value) { return iter.includes(value); });\n    },\n\n    isSuperset: function isSuperset(iter) {\n      iter = typeof iter.isSubset === 'function' ? iter : Collection(iter);\n      return iter.isSubset(this);\n    },\n\n    keyOf: function keyOf(searchValue) {\n      return this.findKey(function (value) { return is(value, searchValue); });\n    },\n\n    keySeq: function keySeq() {\n      return this.toSeq().map(keyMapper).toIndexedSeq();\n    },\n\n    last: function last(notSetValue) {\n      return this.toSeq().reverse().first(notSetValue);\n    },\n\n    lastKeyOf: function lastKeyOf(searchValue) {\n      return this.toKeyedSeq().reverse().keyOf(searchValue);\n    },\n\n    max: function max(comparator) {\n      return maxFactory(this, comparator);\n    },\n\n    maxBy: function maxBy(mapper, comparator) {\n      return maxFactory(this, comparator, mapper);\n    },\n\n    min: function min(comparator) {\n      return maxFactory(\n        this,\n        comparator ? neg(comparator) : defaultNegComparator\n      );\n    },\n\n    minBy: function minBy(mapper, comparator) {\n      return maxFactory(\n        this,\n        comparator ? neg(comparator) : defaultNegComparator,\n        mapper\n      );\n    },\n\n    rest: function rest() {\n      return this.slice(1);\n    },\n\n    skip: function skip(amount) {\n      return amount === 0 ? this : this.slice(Math.max(0, amount));\n    },\n\n    skipLast: function skipLast(amount) {\n      return amount === 0 ? this : this.slice(0, -Math.max(0, amount));\n    },\n\n    skipWhile: function skipWhile(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, true));\n    },\n\n    skipUntil: function skipUntil(predicate, context) {\n      return this.skipWhile(not(predicate), context);\n    },\n\n    sortBy: function sortBy(mapper, comparator) {\n      return reify(this, sortFactory(this, comparator, mapper));\n    },\n\n    take: function take(amount) {\n      return this.slice(0, Math.max(0, amount));\n    },\n\n    takeLast: function takeLast(amount) {\n      return this.slice(-Math.max(0, amount));\n    },\n\n    takeWhile: function takeWhile(predicate, context) {\n      return reify(this, takeWhileFactory(this, predicate, context));\n    },\n\n    takeUntil: function takeUntil(predicate, context) {\n      return this.takeWhile(not(predicate), context);\n    },\n\n    update: function update(fn) {\n      return fn(this);\n    },\n\n    valueSeq: function valueSeq() {\n      return this.toIndexedSeq();\n    },\n\n    // ### Hashable Object\n\n    hashCode: function hashCode() {\n      return this.__hash || (this.__hash = hashCollection(this));\n    },\n\n    // ### Internal\n\n    // abstract __iterate(fn, reverse)\n\n    // abstract __iterator(type, reverse)\n  });\n\n  var CollectionPrototype = Collection.prototype;\n  CollectionPrototype[IS_COLLECTION_SYMBOL] = true;\n  CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;\n  CollectionPrototype.toJSON = CollectionPrototype.toArray;\n  CollectionPrototype.__toStringMapper = quoteString;\n  CollectionPrototype.inspect = CollectionPrototype.toSource = function () {\n    return this.toString();\n  };\n  CollectionPrototype.chain = CollectionPrototype.flatMap;\n  CollectionPrototype.contains = CollectionPrototype.includes;\n\n  mixin(KeyedCollection, {\n    // ### More sequential methods\n\n    flip: function flip() {\n      return reify(this, flipFactory(this));\n    },\n\n    mapEntries: function mapEntries(mapper, context) {\n      var this$1 = this;\n\n      var iterations = 0;\n      return reify(\n        this,\n        this.toSeq()\n          .map(function (v, k) { return mapper.call(context, [k, v], iterations++, this$1); })\n          .fromEntrySeq()\n      );\n    },\n\n    mapKeys: function mapKeys(mapper, context) {\n      var this$1 = this;\n\n      return reify(\n        this,\n        this.toSeq()\n          .flip()\n          .map(function (k, v) { return mapper.call(context, k, v, this$1); })\n          .flip()\n      );\n    },\n  });\n\n  var KeyedCollectionPrototype = KeyedCollection.prototype;\n  KeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;\n  KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;\n  KeyedCollectionPrototype.toJSON = toObject;\n  KeyedCollectionPrototype.__toStringMapper = function (v, k) { return quoteString(k) + ': ' + quoteString(v); };\n\n  mixin(IndexedCollection, {\n    // ### Conversion to other types\n\n    toKeyedSeq: function toKeyedSeq() {\n      return new ToKeyedSequence(this, false);\n    },\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    filter: function filter(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, false));\n    },\n\n    findIndex: function findIndex(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    indexOf: function indexOf(searchValue) {\n      var key = this.keyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    lastIndexOf: function lastIndexOf(searchValue) {\n      var key = this.lastKeyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    reverse: function reverse() {\n      return reify(this, reverseFactory(this, false));\n    },\n\n    slice: function slice(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, false));\n    },\n\n    splice: function splice(index, removeNum /*, ...values*/) {\n      var numArgs = arguments.length;\n      removeNum = Math.max(removeNum || 0, 0);\n      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n        return this;\n      }\n      // If index is negative, it should resolve relative to the size of the\n      // collection. However size may be expensive to compute if not cached, so\n      // only call count() if the number is in fact negative.\n      index = resolveBegin(index, index < 0 ? this.count() : this.size);\n      var spliced = this.slice(0, index);\n      return reify(\n        this,\n        numArgs === 1\n          ? spliced\n          : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n      );\n    },\n\n    // ### More collection methods\n\n    findLastIndex: function findLastIndex(predicate, context) {\n      var entry = this.findLastEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    first: function first(notSetValue) {\n      return this.get(0, notSetValue);\n    },\n\n    flatten: function flatten(depth) {\n      return reify(this, flattenFactory(this, depth, false));\n    },\n\n    get: function get(index, notSetValue) {\n      index = wrapIndex(this, index);\n      return index < 0 ||\n        this.size === Infinity ||\n        (this.size !== undefined && index > this.size)\n        ? notSetValue\n        : this.find(function (_, key) { return key === index; }, undefined, notSetValue);\n    },\n\n    has: function has(index) {\n      index = wrapIndex(this, index);\n      return (\n        index >= 0 &&\n        (this.size !== undefined\n          ? this.size === Infinity || index < this.size\n          : this.indexOf(index) !== -1)\n      );\n    },\n\n    interpose: function interpose(separator) {\n      return reify(this, interposeFactory(this, separator));\n    },\n\n    interleave: function interleave(/*...collections*/) {\n      var collections = [this].concat(arrCopy(arguments));\n      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);\n      var interleaved = zipped.flatten(true);\n      if (zipped.size) {\n        interleaved.size = zipped.size * collections.length;\n      }\n      return reify(this, interleaved);\n    },\n\n    keySeq: function keySeq() {\n      return Range(0, this.size);\n    },\n\n    last: function last(notSetValue) {\n      return this.get(-1, notSetValue);\n    },\n\n    skipWhile: function skipWhile(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, false));\n    },\n\n    zip: function zip(/*, ...collections */) {\n      var collections = [this].concat(arrCopy(arguments));\n      return reify(this, zipWithFactory(this, defaultZipper, collections));\n    },\n\n    zipAll: function zipAll(/*, ...collections */) {\n      var collections = [this].concat(arrCopy(arguments));\n      return reify(this, zipWithFactory(this, defaultZipper, collections, true));\n    },\n\n    zipWith: function zipWith(zipper /*, ...collections */) {\n      var collections = arrCopy(arguments);\n      collections[0] = this;\n      return reify(this, zipWithFactory(this, zipper, collections));\n    },\n  });\n\n  var IndexedCollectionPrototype = IndexedCollection.prototype;\n  IndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;\n  IndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;\n\n  mixin(SetCollection, {\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    get: function get(value, notSetValue) {\n      return this.has(value) ? value : notSetValue;\n    },\n\n    includes: function includes(value) {\n      return this.has(value);\n    },\n\n    // ### More sequential methods\n\n    keySeq: function keySeq() {\n      return this.valueSeq();\n    },\n  });\n\n  SetCollection.prototype.has = CollectionPrototype.includes;\n  SetCollection.prototype.contains = SetCollection.prototype.includes;\n\n  // Mixin subclasses\n\n  mixin(KeyedSeq, KeyedCollection.prototype);\n  mixin(IndexedSeq, IndexedCollection.prototype);\n  mixin(SetSeq, SetCollection.prototype);\n\n  // #pragma Helper functions\n\n  function reduce(collection, reducer, reduction, context, useFirst, reverse) {\n    assertNotInfinite(collection.size);\n    collection.__iterate(function (v, k, c) {\n      if (useFirst) {\n        useFirst = false;\n        reduction = v;\n      } else {\n        reduction = reducer.call(context, reduction, v, k, c);\n      }\n    }, reverse);\n    return reduction;\n  }\n\n  function keyMapper(v, k) {\n    return k;\n  }\n\n  function entryMapper(v, k) {\n    return [k, v];\n  }\n\n  function not(predicate) {\n    return function () {\n      return !predicate.apply(this, arguments);\n    };\n  }\n\n  function neg(predicate) {\n    return function () {\n      return -predicate.apply(this, arguments);\n    };\n  }\n\n  function defaultZipper() {\n    return arrCopy(arguments);\n  }\n\n  function defaultNegComparator(a, b) {\n    return a < b ? 1 : a > b ? -1 : 0;\n  }\n\n  function hashCollection(collection) {\n    if (collection.size === Infinity) {\n      return 0;\n    }\n    var ordered = isOrdered(collection);\n    var keyed = isKeyed(collection);\n    var h = ordered ? 1 : 0;\n    var size = collection.__iterate(\n      keyed\n        ? ordered\n          ? function (v, k) {\n              h = (31 * h + hashMerge(hash(v), hash(k))) | 0;\n            }\n          : function (v, k) {\n              h = (h + hashMerge(hash(v), hash(k))) | 0;\n            }\n        : ordered\n        ? function (v) {\n            h = (31 * h + hash(v)) | 0;\n          }\n        : function (v) {\n            h = (h + hash(v)) | 0;\n          }\n    );\n    return murmurHashOfSize(size, h);\n  }\n\n  function murmurHashOfSize(size, h) {\n    h = imul(h, 0xcc9e2d51);\n    h = imul((h << 15) | (h >>> -15), 0x1b873593);\n    h = imul((h << 13) | (h >>> -13), 5);\n    h = ((h + 0xe6546b64) | 0) ^ size;\n    h = imul(h ^ (h >>> 16), 0x85ebca6b);\n    h = imul(h ^ (h >>> 13), 0xc2b2ae35);\n    h = smi(h ^ (h >>> 16));\n    return h;\n  }\n\n  function hashMerge(a, b) {\n    return (a ^ (b + 0x9e3779b9 + (a << 6) + (a >> 2))) | 0; // int\n  }\n\n  var OrderedSet = /*@__PURE__*/(function (Set) {\n    function OrderedSet(value) {\n      return value === null || value === undefined\n        ? emptyOrderedSet()\n        : isOrderedSet(value)\n        ? value\n        : emptyOrderedSet().withMutations(function (set) {\n            var iter = SetCollection(value);\n            assertNotInfinite(iter.size);\n            iter.forEach(function (v) { return set.add(v); });\n          });\n    }\n\n    if ( Set ) OrderedSet.__proto__ = Set;\n    OrderedSet.prototype = Object.create( Set && Set.prototype );\n    OrderedSet.prototype.constructor = OrderedSet;\n\n    OrderedSet.of = function of (/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedSet.fromKeys = function fromKeys (value) {\n      return this(KeyedCollection(value).keySeq());\n    };\n\n    OrderedSet.prototype.toString = function toString () {\n      return this.__toString('OrderedSet {', '}');\n    };\n\n    return OrderedSet;\n  }(Set));\n\n  OrderedSet.isOrderedSet = isOrderedSet;\n\n  var OrderedSetPrototype = OrderedSet.prototype;\n  OrderedSetPrototype[IS_ORDERED_SYMBOL] = true;\n  OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;\n  OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;\n\n  OrderedSetPrototype.__empty = emptyOrderedSet;\n  OrderedSetPrototype.__make = makeOrderedSet;\n\n  function makeOrderedSet(map, ownerID) {\n    var set = Object.create(OrderedSetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_ORDERED_SET;\n  function emptyOrderedSet() {\n    return (\n      EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()))\n    );\n  }\n\n  var Record = function Record(defaultValues, name) {\n    var hasInitialized;\n\n    var RecordType = function Record(values) {\n      var this$1 = this;\n\n      if (values instanceof RecordType) {\n        return values;\n      }\n      if (!(this instanceof RecordType)) {\n        return new RecordType(values);\n      }\n      if (!hasInitialized) {\n        hasInitialized = true;\n        var keys = Object.keys(defaultValues);\n        var indices = (RecordTypePrototype._indices = {});\n        // Deprecated: left to attempt not to break any external code which\n        // relies on a ._name property existing on record instances.\n        // Use Record.getDescriptiveName() instead\n        RecordTypePrototype._name = name;\n        RecordTypePrototype._keys = keys;\n        RecordTypePrototype._defaultValues = defaultValues;\n        for (var i = 0; i < keys.length; i++) {\n          var propName = keys[i];\n          indices[propName] = i;\n          if (RecordTypePrototype[propName]) {\n            /* eslint-disable no-console */\n            typeof console === 'object' &&\n              console.warn &&\n              console.warn(\n                'Cannot define ' +\n                  recordName(this) +\n                  ' with property \"' +\n                  propName +\n                  '\" since that property name is part of the Record API.'\n              );\n            /* eslint-enable no-console */\n          } else {\n            setProp(RecordTypePrototype, propName);\n          }\n        }\n      }\n      this.__ownerID = undefined;\n      this._values = List().withMutations(function (l) {\n        l.setSize(this$1._keys.length);\n        KeyedCollection(values).forEach(function (v, k) {\n          l.set(this$1._indices[k], v === this$1._defaultValues[k] ? undefined : v);\n        });\n      });\n    };\n\n    var RecordTypePrototype = (RecordType.prototype =\n      Object.create(RecordPrototype));\n    RecordTypePrototype.constructor = RecordType;\n\n    if (name) {\n      RecordType.displayName = name;\n    }\n\n    return RecordType;\n  };\n\n  Record.prototype.toString = function toString () {\n    var str = recordName(this) + ' { ';\n    var keys = this._keys;\n    var k;\n    for (var i = 0, l = keys.length; i !== l; i++) {\n      k = keys[i];\n      str += (i ? ', ' : '') + k + ': ' + quoteString(this.get(k));\n    }\n    return str + ' }';\n  };\n\n  Record.prototype.equals = function equals (other) {\n    return (\n      this === other ||\n      (other &&\n        this._keys === other._keys &&\n        recordSeq(this).equals(recordSeq(other)))\n    );\n  };\n\n  Record.prototype.hashCode = function hashCode () {\n    return recordSeq(this).hashCode();\n  };\n\n  // @pragma Access\n\n  Record.prototype.has = function has (k) {\n    return this._indices.hasOwnProperty(k);\n  };\n\n  Record.prototype.get = function get (k, notSetValue) {\n    if (!this.has(k)) {\n      return notSetValue;\n    }\n    var index = this._indices[k];\n    var value = this._values.get(index);\n    return value === undefined ? this._defaultValues[k] : value;\n  };\n\n  // @pragma Modification\n\n  Record.prototype.set = function set (k, v) {\n    if (this.has(k)) {\n      var newValues = this._values.set(\n        this._indices[k],\n        v === this._defaultValues[k] ? undefined : v\n      );\n      if (newValues !== this._values && !this.__ownerID) {\n        return makeRecord(this, newValues);\n      }\n    }\n    return this;\n  };\n\n  Record.prototype.remove = function remove (k) {\n    return this.set(k);\n  };\n\n  Record.prototype.clear = function clear () {\n    var newValues = this._values.clear().setSize(this._keys.length);\n    return this.__ownerID ? this : makeRecord(this, newValues);\n  };\n\n  Record.prototype.wasAltered = function wasAltered () {\n    return this._values.wasAltered();\n  };\n\n  Record.prototype.toSeq = function toSeq () {\n    return recordSeq(this);\n  };\n\n  Record.prototype.toJS = function toJS$1 () {\n    return toJS(this);\n  };\n\n  Record.prototype.entries = function entries () {\n    return this.__iterator(ITERATE_ENTRIES);\n  };\n\n  Record.prototype.__iterator = function __iterator (type, reverse) {\n    return recordSeq(this).__iterator(type, reverse);\n  };\n\n  Record.prototype.__iterate = function __iterate (fn, reverse) {\n    return recordSeq(this).__iterate(fn, reverse);\n  };\n\n  Record.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    var newValues = this._values.__ensureOwner(ownerID);\n    if (!ownerID) {\n      this.__ownerID = ownerID;\n      this._values = newValues;\n      return this;\n    }\n    return makeRecord(this, newValues, ownerID);\n  };\n\n  Record.isRecord = isRecord;\n  Record.getDescriptiveName = recordName;\n  var RecordPrototype = Record.prototype;\n  RecordPrototype[IS_RECORD_SYMBOL] = true;\n  RecordPrototype[DELETE] = RecordPrototype.remove;\n  RecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;\n  RecordPrototype.getIn = getIn$1;\n  RecordPrototype.hasIn = CollectionPrototype.hasIn;\n  RecordPrototype.merge = merge;\n  RecordPrototype.mergeWith = mergeWith;\n  RecordPrototype.mergeIn = mergeIn;\n  RecordPrototype.mergeDeep = mergeDeep$1;\n  RecordPrototype.mergeDeepWith = mergeDeepWith$1;\n  RecordPrototype.mergeDeepIn = mergeDeepIn;\n  RecordPrototype.setIn = setIn$1;\n  RecordPrototype.update = update$1;\n  RecordPrototype.updateIn = updateIn$1;\n  RecordPrototype.withMutations = withMutations;\n  RecordPrototype.asMutable = asMutable;\n  RecordPrototype.asImmutable = asImmutable;\n  RecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;\n  RecordPrototype.toJSON = RecordPrototype.toObject =\n    CollectionPrototype.toObject;\n  RecordPrototype.inspect = RecordPrototype.toSource = function () {\n    return this.toString();\n  };\n\n  function makeRecord(likeRecord, values, ownerID) {\n    var record = Object.create(Object.getPrototypeOf(likeRecord));\n    record._values = values;\n    record.__ownerID = ownerID;\n    return record;\n  }\n\n  function recordName(record) {\n    return record.constructor.displayName || record.constructor.name || 'Record';\n  }\n\n  function recordSeq(record) {\n    return keyedSeqFromValue(record._keys.map(function (k) { return [k, record.get(k)]; }));\n  }\n\n  function setProp(prototype, name) {\n    try {\n      Object.defineProperty(prototype, name, {\n        get: function () {\n          return this.get(name);\n        },\n        set: function (value) {\n          invariant(this.__ownerID, 'Cannot set on an immutable record.');\n          this.set(name, value);\n        },\n      });\n    } catch (error) {\n      // Object.defineProperty failed. Probably IE8.\n    }\n  }\n\n  /**\n   * Returns a lazy Seq of `value` repeated `times` times. When `times` is\n   * undefined, returns an infinite sequence of `value`.\n   */\n  var Repeat = /*@__PURE__*/(function (IndexedSeq) {\n    function Repeat(value, times) {\n      if (!(this instanceof Repeat)) {\n        return new Repeat(value, times);\n      }\n      this._value = value;\n      this.size = times === undefined ? Infinity : Math.max(0, times);\n      if (this.size === 0) {\n        if (EMPTY_REPEAT) {\n          return EMPTY_REPEAT;\n        }\n        EMPTY_REPEAT = this;\n      }\n    }\n\n    if ( IndexedSeq ) Repeat.__proto__ = IndexedSeq;\n    Repeat.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n    Repeat.prototype.constructor = Repeat;\n\n    Repeat.prototype.toString = function toString () {\n      if (this.size === 0) {\n        return 'Repeat []';\n      }\n      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n    };\n\n    Repeat.prototype.get = function get (index, notSetValue) {\n      return this.has(index) ? this._value : notSetValue;\n    };\n\n    Repeat.prototype.includes = function includes (searchValue) {\n      return is(this._value, searchValue);\n    };\n\n    Repeat.prototype.slice = function slice (begin, end) {\n      var size = this.size;\n      return wholeSlice(begin, end, size)\n        ? this\n        : new Repeat(\n            this._value,\n            resolveEnd(end, size) - resolveBegin(begin, size)\n          );\n    };\n\n    Repeat.prototype.reverse = function reverse () {\n      return this;\n    };\n\n    Repeat.prototype.indexOf = function indexOf (searchValue) {\n      if (is(this._value, searchValue)) {\n        return 0;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.lastIndexOf = function lastIndexOf (searchValue) {\n      if (is(this._value, searchValue)) {\n        return this.size;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.__iterate = function __iterate (fn, reverse) {\n      var size = this.size;\n      var i = 0;\n      while (i !== size) {\n        if (fn(this._value, reverse ? size - ++i : i++, this) === false) {\n          break;\n        }\n      }\n      return i;\n    };\n\n    Repeat.prototype.__iterator = function __iterator (type, reverse) {\n      var this$1 = this;\n\n      var size = this.size;\n      var i = 0;\n      return new Iterator(function () { return i === size\n          ? iteratorDone()\n          : iteratorValue(type, reverse ? size - ++i : i++, this$1._value); }\n      );\n    };\n\n    Repeat.prototype.equals = function equals (other) {\n      return other instanceof Repeat\n        ? is(this._value, other._value)\n        : deepEqual(other);\n    };\n\n    return Repeat;\n  }(IndexedSeq));\n\n  var EMPTY_REPEAT;\n\n  function fromJS(value, converter) {\n    return fromJSWith(\n      [],\n      converter || defaultConverter,\n      value,\n      '',\n      converter && converter.length > 2 ? [] : undefined,\n      { '': value }\n    );\n  }\n\n  function fromJSWith(stack, converter, value, key, keyPath, parentValue) {\n    var toSeq = Array.isArray(value)\n      ? IndexedSeq\n      : isPlainObj(value)\n      ? KeyedSeq\n      : null;\n    if (toSeq) {\n      if (~stack.indexOf(value)) {\n        throw new TypeError('Cannot convert circular structure to Immutable');\n      }\n      stack.push(value);\n      keyPath && key !== '' && keyPath.push(key);\n      var converted = converter.call(\n        parentValue,\n        key,\n        toSeq(value).map(function (v, k) { return fromJSWith(stack, converter, v, k, keyPath, value); }\n        ),\n        keyPath && keyPath.slice()\n      );\n      stack.pop();\n      keyPath && keyPath.pop();\n      return converted;\n    }\n    return value;\n  }\n\n  function defaultConverter(k, v) {\n    return isKeyed(v) ? v.toMap() : v.toList();\n  }\n\n  var version = \"4.0.0-rc.12\";\n\n  var Immutable = {\n    version: version,\n\n    Collection: Collection,\n    // Note: Iterable is deprecated\n    Iterable: Collection,\n\n    Seq: Seq,\n    Map: Map,\n    OrderedMap: OrderedMap,\n    List: List,\n    Stack: Stack,\n    Set: Set,\n    OrderedSet: OrderedSet,\n\n    Record: Record,\n    Range: Range,\n    Repeat: Repeat,\n\n    is: is,\n    fromJS: fromJS,\n    hash: hash,\n\n    isImmutable: isImmutable,\n    isCollection: isCollection,\n    isKeyed: isKeyed,\n    isIndexed: isIndexed,\n    isAssociative: isAssociative,\n    isOrdered: isOrdered,\n    isValueObject: isValueObject,\n    isSeq: isSeq,\n    isList: isList,\n    isMap: isMap,\n    isOrderedMap: isOrderedMap,\n    isStack: isStack,\n    isSet: isSet,\n    isOrderedSet: isOrderedSet,\n    isRecord: isRecord,\n\n    get: get,\n    getIn: getIn,\n    has: has,\n    hasIn: hasIn,\n    merge: merge$1,\n    mergeDeep: mergeDeep,\n    mergeWith: mergeWith$1,\n    mergeDeepWith: mergeDeepWith,\n    remove: remove,\n    removeIn: removeIn,\n    set: set,\n    setIn: setIn,\n    update: update,\n    updateIn: updateIn,\n  };\n\n  // Note: Iterable is deprecated\n  var Iterable = Collection;\n\n  exports.Collection = Collection;\n  exports.Iterable = Iterable;\n  exports.List = List;\n  exports.Map = Map;\n  exports.OrderedMap = OrderedMap;\n  exports.OrderedSet = OrderedSet;\n  exports.Range = Range;\n  exports.Record = Record;\n  exports.Repeat = Repeat;\n  exports.Seq = Seq;\n  exports.Set = Set;\n  exports.Stack = Stack;\n  exports.default = Immutable;\n  exports.fromJS = fromJS;\n  exports.get = get;\n  exports.getIn = getIn;\n  exports.has = has;\n  exports.hasIn = hasIn;\n  exports.hash = hash;\n  exports.is = is;\n  exports.isAssociative = isAssociative;\n  exports.isCollection = isCollection;\n  exports.isImmutable = isImmutable;\n  exports.isIndexed = isIndexed;\n  exports.isKeyed = isKeyed;\n  exports.isOrdered = isOrdered;\n  exports.isValueObject = isValueObject;\n  exports.merge = merge$1;\n  exports.mergeDeep = mergeDeep;\n  exports.mergeDeepWith = mergeDeepWith;\n  exports.mergeWith = mergeWith$1;\n  exports.remove = remove;\n  exports.removeIn = removeIn;\n  exports.set = set;\n  exports.setIn = setIn;\n  exports.update = update;\n  exports.updateIn = updateIn;\n  exports.version = version;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species != null &&\n    Buffer[Symbol.species] === Buffer) {\n  Object.defineProperty(Buffer, Symbol.species, {\n    value: null,\n    configurable: true,\n    enumerable: false,\n    writable: false\n  })\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayLike(value)\n  }\n\n  if (value == null) {\n    throw TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__ = Uint8Array.prototype\nBuffer.__proto__ = Uint8Array\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      buf = Buffer.from(buf)\n    }\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n        : (firstByte > 0xBF) ? 2\n          : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  newBuf.__proto__ = Buffer.prototype\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (var i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","/**\n * marked - a markdown parser\n * Copyright (c) 2011-2020, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = global || self, global.marked = factory());\n}(this, (function () { 'use strict';\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it;\n\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    it = o[Symbol.iterator]();\n    return it.next.bind(it);\n  }\n\n  function createCommonjsModule(fn, module) {\n  \treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n  }\n\n  var defaults = createCommonjsModule(function (module) {\n    function getDefaults() {\n      return {\n        baseUrl: null,\n        breaks: false,\n        gfm: true,\n        headerIds: true,\n        headerPrefix: '',\n        highlight: null,\n        langPrefix: 'language-',\n        mangle: true,\n        pedantic: false,\n        renderer: null,\n        sanitize: false,\n        sanitizer: null,\n        silent: false,\n        smartLists: false,\n        smartypants: false,\n        tokenizer: null,\n        walkTokens: null,\n        xhtml: false\n      };\n    }\n\n    function changeDefaults(newDefaults) {\n      module.exports.defaults = newDefaults;\n    }\n\n    module.exports = {\n      defaults: getDefaults(),\n      getDefaults: getDefaults,\n      changeDefaults: changeDefaults\n    };\n  });\n  var defaults_1 = defaults.defaults;\n  var defaults_2 = defaults.getDefaults;\n  var defaults_3 = defaults.changeDefaults;\n\n  /**\n   * Helpers\n   */\n  var escapeTest = /[&<>\"']/;\n  var escapeReplace = /[&<>\"']/g;\n  var escapeTestNoEncode = /[<>\"']|&(?!#?\\w+;)/;\n  var escapeReplaceNoEncode = /[<>\"']|&(?!#?\\w+;)/g;\n  var escapeReplacements = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n\n  var getEscapeReplacement = function getEscapeReplacement(ch) {\n    return escapeReplacements[ch];\n  };\n\n  function escape(html, encode) {\n    if (encode) {\n      if (escapeTest.test(html)) {\n        return html.replace(escapeReplace, getEscapeReplacement);\n      }\n    } else {\n      if (escapeTestNoEncode.test(html)) {\n        return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n      }\n    }\n\n    return html;\n  }\n\n  var unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n\n  function unescape(html) {\n    // explicitly match decimal, hex, and named HTML entities\n    return html.replace(unescapeTest, function (_, n) {\n      n = n.toLowerCase();\n      if (n === 'colon') return ':';\n\n      if (n.charAt(0) === '#') {\n        return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));\n      }\n\n      return '';\n    });\n  }\n\n  var caret = /(^|[^\\[])\\^/g;\n\n  function edit(regex, opt) {\n    regex = regex.source || regex;\n    opt = opt || '';\n    var obj = {\n      replace: function replace(name, val) {\n        val = val.source || val;\n        val = val.replace(caret, '$1');\n        regex = regex.replace(name, val);\n        return obj;\n      },\n      getRegex: function getRegex() {\n        return new RegExp(regex, opt);\n      }\n    };\n    return obj;\n  }\n\n  var nonWordAndColonTest = /[^\\w:]/g;\n  var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;\n\n  function cleanUrl(sanitize, base, href) {\n    if (sanitize) {\n      var prot;\n\n      try {\n        prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, '').toLowerCase();\n      } catch (e) {\n        return null;\n      }\n\n      if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n        return null;\n      }\n    }\n\n    if (base && !originIndependentUrl.test(href)) {\n      href = resolveUrl(base, href);\n    }\n\n    try {\n      href = encodeURI(href).replace(/%25/g, '%');\n    } catch (e) {\n      return null;\n    }\n\n    return href;\n  }\n\n  var baseUrls = {};\n  var justDomain = /^[^:]+:\\/*[^/]*$/;\n  var protocol = /^([^:]+:)[\\s\\S]*$/;\n  var domain = /^([^:]+:\\/*[^/]*)[\\s\\S]*$/;\n\n  function resolveUrl(base, href) {\n    if (!baseUrls[' ' + base]) {\n      // we can ignore everything in base after the last slash of its path component,\n      // but we might need to add _that_\n      // https://tools.ietf.org/html/rfc3986#section-3\n      if (justDomain.test(base)) {\n        baseUrls[' ' + base] = base + '/';\n      } else {\n        baseUrls[' ' + base] = rtrim(base, '/', true);\n      }\n    }\n\n    base = baseUrls[' ' + base];\n    var relativeBase = base.indexOf(':') === -1;\n\n    if (href.substring(0, 2) === '//') {\n      if (relativeBase) {\n        return href;\n      }\n\n      return base.replace(protocol, '$1') + href;\n    } else if (href.charAt(0) === '/') {\n      if (relativeBase) {\n        return href;\n      }\n\n      return base.replace(domain, '$1') + href;\n    } else {\n      return base + href;\n    }\n  }\n\n  var noopTest = {\n    exec: function noopTest() {}\n  };\n\n  function merge(obj) {\n    var i = 1,\n        target,\n        key;\n\n    for (; i < arguments.length; i++) {\n      target = arguments[i];\n\n      for (key in target) {\n        if (Object.prototype.hasOwnProperty.call(target, key)) {\n          obj[key] = target[key];\n        }\n      }\n    }\n\n    return obj;\n  }\n\n  function splitCells(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    var row = tableRow.replace(/\\|/g, function (match, offset, str) {\n      var escaped = false,\n          curr = offset;\n\n      while (--curr >= 0 && str[curr] === '\\\\') {\n        escaped = !escaped;\n      }\n\n      if (escaped) {\n        // odd number of slashes means | is escaped\n        // so we leave it alone\n        return '|';\n      } else {\n        // add space before unescaped |\n        return ' |';\n      }\n    }),\n        cells = row.split(/ \\|/);\n    var i = 0;\n\n    if (cells.length > count) {\n      cells.splice(count);\n    } else {\n      while (cells.length < count) {\n        cells.push('');\n      }\n    }\n\n    for (; i < cells.length; i++) {\n      // leading or trailing whitespace is ignored per the gfm spec\n      cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n    }\n\n    return cells;\n  } // Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n  // /c*$/ is vulnerable to REDOS.\n  // invert: Remove suffix of non-c chars instead. Default falsey.\n\n\n  function rtrim(str, c, invert) {\n    var l = str.length;\n\n    if (l === 0) {\n      return '';\n    } // Length of suffix matching the invert condition.\n\n\n    var suffLen = 0; // Step left until we fail to match the invert condition.\n\n    while (suffLen < l) {\n      var currChar = str.charAt(l - suffLen - 1);\n\n      if (currChar === c && !invert) {\n        suffLen++;\n      } else if (currChar !== c && invert) {\n        suffLen++;\n      } else {\n        break;\n      }\n    }\n\n    return str.substr(0, l - suffLen);\n  }\n\n  function findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n      return -1;\n    }\n\n    var l = str.length;\n    var level = 0,\n        i = 0;\n\n    for (; i < l; i++) {\n      if (str[i] === '\\\\') {\n        i++;\n      } else if (str[i] === b[0]) {\n        level++;\n      } else if (str[i] === b[1]) {\n        level--;\n\n        if (level < 0) {\n          return i;\n        }\n      }\n    }\n\n    return -1;\n  }\n\n  function checkSanitizeDeprecation(opt) {\n    if (opt && opt.sanitize && !opt.silent) {\n      console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');\n    }\n  }\n\n  var helpers = {\n    escape: escape,\n    unescape: unescape,\n    edit: edit,\n    cleanUrl: cleanUrl,\n    resolveUrl: resolveUrl,\n    noopTest: noopTest,\n    merge: merge,\n    splitCells: splitCells,\n    rtrim: rtrim,\n    findClosingBracket: findClosingBracket,\n    checkSanitizeDeprecation: checkSanitizeDeprecation\n  };\n\n  var defaults$1 = defaults.defaults;\n  var rtrim$1 = helpers.rtrim,\n      splitCells$1 = helpers.splitCells,\n      _escape = helpers.escape,\n      findClosingBracket$1 = helpers.findClosingBracket;\n\n  function outputLink(cap, link, raw) {\n    var href = link.href;\n    var title = link.title ? _escape(link.title) : null;\n    var text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n\n    if (cap[0].charAt(0) !== '!') {\n      return {\n        type: 'link',\n        raw: raw,\n        href: href,\n        title: title,\n        text: text\n      };\n    } else {\n      return {\n        type: 'image',\n        raw: raw,\n        href: href,\n        title: title,\n        text: _escape(text)\n      };\n    }\n  }\n\n  function indentCodeCompensation(raw, text) {\n    var matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n\n    if (matchIndentToCode === null) {\n      return text;\n    }\n\n    var indentToCode = matchIndentToCode[1];\n    return text.split('\\n').map(function (node) {\n      var matchIndentInNode = node.match(/^\\s+/);\n\n      if (matchIndentInNode === null) {\n        return node;\n      }\n\n      var indentInNode = matchIndentInNode[0];\n\n      if (indentInNode.length >= indentToCode.length) {\n        return node.slice(indentToCode.length);\n      }\n\n      return node;\n    }).join('\\n');\n  }\n  /**\n   * Tokenizer\n   */\n\n\n  var Tokenizer_1 = /*#__PURE__*/function () {\n    function Tokenizer(options) {\n      this.options = options || defaults$1;\n    }\n\n    var _proto = Tokenizer.prototype;\n\n    _proto.space = function space(src) {\n      var cap = this.rules.block.newline.exec(src);\n\n      if (cap) {\n        if (cap[0].length > 1) {\n          return {\n            type: 'space',\n            raw: cap[0]\n          };\n        }\n\n        return {\n          raw: '\\n'\n        };\n      }\n    };\n\n    _proto.code = function code(src, tokens) {\n      var cap = this.rules.block.code.exec(src);\n\n      if (cap) {\n        var lastToken = tokens[tokens.length - 1]; // An indented code block cannot interrupt a paragraph.\n\n        if (lastToken && lastToken.type === 'paragraph') {\n          return {\n            raw: cap[0],\n            text: cap[0].trimRight()\n          };\n        }\n\n        var text = cap[0].replace(/^ {4}/gm, '');\n        return {\n          type: 'code',\n          raw: cap[0],\n          codeBlockStyle: 'indented',\n          text: !this.options.pedantic ? rtrim$1(text, '\\n') : text\n        };\n      }\n    };\n\n    _proto.fences = function fences(src) {\n      var cap = this.rules.block.fences.exec(src);\n\n      if (cap) {\n        var raw = cap[0];\n        var text = indentCodeCompensation(raw, cap[3] || '');\n        return {\n          type: 'code',\n          raw: raw,\n          lang: cap[2] ? cap[2].trim() : cap[2],\n          text: text\n        };\n      }\n    };\n\n    _proto.heading = function heading(src) {\n      var cap = this.rules.block.heading.exec(src);\n\n      if (cap) {\n        return {\n          type: 'heading',\n          raw: cap[0],\n          depth: cap[1].length,\n          text: cap[2]\n        };\n      }\n    };\n\n    _proto.nptable = function nptable(src) {\n      var cap = this.rules.block.nptable.exec(src);\n\n      if (cap) {\n        var item = {\n          type: 'table',\n          header: splitCells$1(cap[1].replace(/^ *| *\\| *$/g, '')),\n          align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n          cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : [],\n          raw: cap[0]\n        };\n\n        if (item.header.length === item.align.length) {\n          var l = item.align.length;\n          var i;\n\n          for (i = 0; i < l; i++) {\n            if (/^ *-+: *$/.test(item.align[i])) {\n              item.align[i] = 'right';\n            } else if (/^ *:-+: *$/.test(item.align[i])) {\n              item.align[i] = 'center';\n            } else if (/^ *:-+ *$/.test(item.align[i])) {\n              item.align[i] = 'left';\n            } else {\n              item.align[i] = null;\n            }\n          }\n\n          l = item.cells.length;\n\n          for (i = 0; i < l; i++) {\n            item.cells[i] = splitCells$1(item.cells[i], item.header.length);\n          }\n\n          return item;\n        }\n      }\n    };\n\n    _proto.hr = function hr(src) {\n      var cap = this.rules.block.hr.exec(src);\n\n      if (cap) {\n        return {\n          type: 'hr',\n          raw: cap[0]\n        };\n      }\n    };\n\n    _proto.blockquote = function blockquote(src) {\n      var cap = this.rules.block.blockquote.exec(src);\n\n      if (cap) {\n        var text = cap[0].replace(/^ *> ?/gm, '');\n        return {\n          type: 'blockquote',\n          raw: cap[0],\n          text: text\n        };\n      }\n    };\n\n    _proto.list = function list(src) {\n      var cap = this.rules.block.list.exec(src);\n\n      if (cap) {\n        var raw = cap[0];\n        var bull = cap[2];\n        var isordered = bull.length > 1;\n        var isparen = bull[bull.length - 1] === ')';\n        var list = {\n          type: 'list',\n          raw: raw,\n          ordered: isordered,\n          start: isordered ? +bull.slice(0, -1) : '',\n          loose: false,\n          items: []\n        }; // Get each top-level item.\n\n        var itemMatch = cap[0].match(this.rules.block.item);\n        var next = false,\n            item,\n            space,\n            b,\n            addBack,\n            loose,\n            istask,\n            ischecked;\n        var l = itemMatch.length;\n\n        for (var i = 0; i < l; i++) {\n          item = itemMatch[i];\n          raw = item; // Remove the list item's bullet\n          // so it is seen as the next token.\n\n          space = item.length;\n          item = item.replace(/^ *([*+-]|\\d+[.)]) */, ''); // Outdent whatever the\n          // list item contains. Hacky.\n\n          if (~item.indexOf('\\n ')) {\n            space -= item.length;\n            item = !this.options.pedantic ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '') : item.replace(/^ {1,4}/gm, '');\n          } // Determine whether the next list item belongs here.\n          // Backpedal if it does not belong in this list.\n\n\n          if (i !== l - 1) {\n            b = this.rules.block.bullet.exec(itemMatch[i + 1])[0];\n\n            if (isordered ? b.length === 1 || !isparen && b[b.length - 1] === ')' : b.length > 1 || this.options.smartLists && b !== bull) {\n              addBack = itemMatch.slice(i + 1).join('\\n');\n              list.raw = list.raw.substring(0, list.raw.length - addBack.length);\n              i = l - 1;\n            }\n          } // Determine whether item is loose or not.\n          // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n          // for discount behavior.\n\n\n          loose = next || /\\n\\n(?!\\s*$)/.test(item);\n\n          if (i !== l - 1) {\n            next = item.charAt(item.length - 1) === '\\n';\n            if (!loose) loose = next;\n          }\n\n          if (loose) {\n            list.loose = true;\n          } // Check for task list items\n\n\n          istask = /^\\[[ xX]\\] /.test(item);\n          ischecked = undefined;\n\n          if (istask) {\n            ischecked = item[1] !== ' ';\n            item = item.replace(/^\\[[ xX]\\] +/, '');\n          }\n\n          list.items.push({\n            type: 'list_item',\n            raw: raw,\n            task: istask,\n            checked: ischecked,\n            loose: loose,\n            text: item\n          });\n        }\n\n        return list;\n      }\n    };\n\n    _proto.html = function html(src) {\n      var cap = this.rules.block.html.exec(src);\n\n      if (cap) {\n        return {\n          type: this.options.sanitize ? 'paragraph' : 'html',\n          raw: cap[0],\n          pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]\n        };\n      }\n    };\n\n    _proto.def = function def(src) {\n      var cap = this.rules.block.def.exec(src);\n\n      if (cap) {\n        if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);\n        var tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n        return {\n          tag: tag,\n          raw: cap[0],\n          href: cap[2],\n          title: cap[3]\n        };\n      }\n    };\n\n    _proto.table = function table(src) {\n      var cap = this.rules.block.table.exec(src);\n\n      if (cap) {\n        var item = {\n          type: 'table',\n          header: splitCells$1(cap[1].replace(/^ *| *\\| *$/g, '')),\n          align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n          cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n        };\n\n        if (item.header.length === item.align.length) {\n          item.raw = cap[0];\n          var l = item.align.length;\n          var i;\n\n          for (i = 0; i < l; i++) {\n            if (/^ *-+: *$/.test(item.align[i])) {\n              item.align[i] = 'right';\n            } else if (/^ *:-+: *$/.test(item.align[i])) {\n              item.align[i] = 'center';\n            } else if (/^ *:-+ *$/.test(item.align[i])) {\n              item.align[i] = 'left';\n            } else {\n              item.align[i] = null;\n            }\n          }\n\n          l = item.cells.length;\n\n          for (i = 0; i < l; i++) {\n            item.cells[i] = splitCells$1(item.cells[i].replace(/^ *\\| *| *\\| *$/g, ''), item.header.length);\n          }\n\n          return item;\n        }\n      }\n    };\n\n    _proto.lheading = function lheading(src) {\n      var cap = this.rules.block.lheading.exec(src);\n\n      if (cap) {\n        return {\n          type: 'heading',\n          raw: cap[0],\n          depth: cap[2].charAt(0) === '=' ? 1 : 2,\n          text: cap[1]\n        };\n      }\n    };\n\n    _proto.paragraph = function paragraph(src) {\n      var cap = this.rules.block.paragraph.exec(src);\n\n      if (cap) {\n        return {\n          type: 'paragraph',\n          raw: cap[0],\n          text: cap[1].charAt(cap[1].length - 1) === '\\n' ? cap[1].slice(0, -1) : cap[1]\n        };\n      }\n    };\n\n    _proto.text = function text(src, tokens) {\n      var cap = this.rules.block.text.exec(src);\n\n      if (cap) {\n        var lastToken = tokens[tokens.length - 1];\n\n        if (lastToken && lastToken.type === 'text') {\n          return {\n            raw: cap[0],\n            text: cap[0]\n          };\n        }\n\n        return {\n          type: 'text',\n          raw: cap[0],\n          text: cap[0]\n        };\n      }\n    };\n\n    _proto.escape = function escape(src) {\n      var cap = this.rules.inline.escape.exec(src);\n\n      if (cap) {\n        return {\n          type: 'escape',\n          raw: cap[0],\n          text: _escape(cap[1])\n        };\n      }\n    };\n\n    _proto.tag = function tag(src, inLink, inRawBlock) {\n      var cap = this.rules.inline.tag.exec(src);\n\n      if (cap) {\n        if (!inLink && /^<a /i.test(cap[0])) {\n          inLink = true;\n        } else if (inLink && /^<\\/a>/i.test(cap[0])) {\n          inLink = false;\n        }\n\n        if (!inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n          inRawBlock = true;\n        } else if (inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n          inRawBlock = false;\n        }\n\n        return {\n          type: this.options.sanitize ? 'text' : 'html',\n          raw: cap[0],\n          inLink: inLink,\n          inRawBlock: inRawBlock,\n          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]\n        };\n      }\n    };\n\n    _proto.link = function link(src) {\n      var cap = this.rules.inline.link.exec(src);\n\n      if (cap) {\n        var lastParenIndex = findClosingBracket$1(cap[2], '()');\n\n        if (lastParenIndex > -1) {\n          var start = cap[0].indexOf('!') === 0 ? 5 : 4;\n          var linkLen = start + cap[1].length + lastParenIndex;\n          cap[2] = cap[2].substring(0, lastParenIndex);\n          cap[0] = cap[0].substring(0, linkLen).trim();\n          cap[3] = '';\n        }\n\n        var href = cap[2];\n        var title = '';\n\n        if (this.options.pedantic) {\n          var link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n\n          if (link) {\n            href = link[1];\n            title = link[3];\n          } else {\n            title = '';\n          }\n        } else {\n          title = cap[3] ? cap[3].slice(1, -1) : '';\n        }\n\n        href = href.trim().replace(/^<([\\s\\S]*)>$/, '$1');\n        var token = outputLink(cap, {\n          href: href ? href.replace(this.rules.inline._escapes, '$1') : href,\n          title: title ? title.replace(this.rules.inline._escapes, '$1') : title\n        }, cap[0]);\n        return token;\n      }\n    };\n\n    _proto.reflink = function reflink(src, links) {\n      var cap;\n\n      if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n        var link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n        link = links[link.toLowerCase()];\n\n        if (!link || !link.href) {\n          var text = cap[0].charAt(0);\n          return {\n            type: 'text',\n            raw: text,\n            text: text\n          };\n        }\n\n        var token = outputLink(cap, link, cap[0]);\n        return token;\n      }\n    };\n\n    _proto.strong = function strong(src, maskedSrc, prevChar) {\n      if (prevChar === void 0) {\n        prevChar = '';\n      }\n\n      var match = this.rules.inline.strong.start.exec(src);\n\n      if (match && (!match[1] || match[1] && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar)))) {\n        maskedSrc = maskedSrc.slice(-1 * src.length);\n        var endReg = match[0] === '**' ? this.rules.inline.strong.endAst : this.rules.inline.strong.endUnd;\n        endReg.lastIndex = 0;\n        var cap;\n\n        while ((match = endReg.exec(maskedSrc)) != null) {\n          cap = this.rules.inline.strong.middle.exec(maskedSrc.slice(0, match.index + 3));\n\n          if (cap) {\n            return {\n              type: 'strong',\n              raw: src.slice(0, cap[0].length),\n              text: src.slice(2, cap[0].length - 2)\n            };\n          }\n        }\n      }\n    };\n\n    _proto.em = function em(src, maskedSrc, prevChar) {\n      if (prevChar === void 0) {\n        prevChar = '';\n      }\n\n      var match = this.rules.inline.em.start.exec(src);\n\n      if (match && (!match[1] || match[1] && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar)))) {\n        maskedSrc = maskedSrc.slice(-1 * src.length);\n        var endReg = match[0] === '*' ? this.rules.inline.em.endAst : this.rules.inline.em.endUnd;\n        endReg.lastIndex = 0;\n        var cap;\n\n        while ((match = endReg.exec(maskedSrc)) != null) {\n          cap = this.rules.inline.em.middle.exec(maskedSrc.slice(0, match.index + 2));\n\n          if (cap) {\n            return {\n              type: 'em',\n              raw: src.slice(0, cap[0].length),\n              text: src.slice(1, cap[0].length - 1)\n            };\n          }\n        }\n      }\n    };\n\n    _proto.codespan = function codespan(src) {\n      var cap = this.rules.inline.code.exec(src);\n\n      if (cap) {\n        var text = cap[2].replace(/\\n/g, ' ');\n        var hasNonSpaceChars = /[^ ]/.test(text);\n        var hasSpaceCharsOnBothEnds = text.startsWith(' ') && text.endsWith(' ');\n\n        if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n          text = text.substring(1, text.length - 1);\n        }\n\n        text = _escape(text, true);\n        return {\n          type: 'codespan',\n          raw: cap[0],\n          text: text\n        };\n      }\n    };\n\n    _proto.br = function br(src) {\n      var cap = this.rules.inline.br.exec(src);\n\n      if (cap) {\n        return {\n          type: 'br',\n          raw: cap[0]\n        };\n      }\n    };\n\n    _proto.del = function del(src) {\n      var cap = this.rules.inline.del.exec(src);\n\n      if (cap) {\n        return {\n          type: 'del',\n          raw: cap[0],\n          text: cap[1]\n        };\n      }\n    };\n\n    _proto.autolink = function autolink(src, mangle) {\n      var cap = this.rules.inline.autolink.exec(src);\n\n      if (cap) {\n        var text, href;\n\n        if (cap[2] === '@') {\n          text = _escape(this.options.mangle ? mangle(cap[1]) : cap[1]);\n          href = 'mailto:' + text;\n        } else {\n          text = _escape(cap[1]);\n          href = text;\n        }\n\n        return {\n          type: 'link',\n          raw: cap[0],\n          text: text,\n          href: href,\n          tokens: [{\n            type: 'text',\n            raw: text,\n            text: text\n          }]\n        };\n      }\n    };\n\n    _proto.url = function url(src, mangle) {\n      var cap;\n\n      if (cap = this.rules.inline.url.exec(src)) {\n        var text, href;\n\n        if (cap[2] === '@') {\n          text = _escape(this.options.mangle ? mangle(cap[0]) : cap[0]);\n          href = 'mailto:' + text;\n        } else {\n          // do extended autolink path validation\n          var prevCapZero;\n\n          do {\n            prevCapZero = cap[0];\n            cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];\n          } while (prevCapZero !== cap[0]);\n\n          text = _escape(cap[0]);\n\n          if (cap[1] === 'www.') {\n            href = 'http://' + text;\n          } else {\n            href = text;\n          }\n        }\n\n        return {\n          type: 'link',\n          raw: cap[0],\n          text: text,\n          href: href,\n          tokens: [{\n            type: 'text',\n            raw: text,\n            text: text\n          }]\n        };\n      }\n    };\n\n    _proto.inlineText = function inlineText(src, inRawBlock, smartypants) {\n      var cap = this.rules.inline.text.exec(src);\n\n      if (cap) {\n        var text;\n\n        if (inRawBlock) {\n          text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0];\n        } else {\n          text = _escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);\n        }\n\n        return {\n          type: 'text',\n          raw: cap[0],\n          text: text\n        };\n      }\n    };\n\n    return Tokenizer;\n  }();\n\n  var noopTest$1 = helpers.noopTest,\n      edit$1 = helpers.edit,\n      merge$1 = helpers.merge;\n  /**\n   * Block-Level Grammar\n   */\n\n  var block = {\n    newline: /^\\n+/,\n    code: /^( {4}[^\\n]+\\n*)+/,\n    fences: /^ {0,3}(`{3,}(?=[^`\\n]*\\n)|~{3,})([^\\n]*)\\n(?:|([\\s\\S]*?)\\n)(?: {0,3}\\1[~`]* *(?:\\n+|$)|$)/,\n    hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)/,\n    heading: /^ {0,3}(#{1,6}) +([^\\n]*?)(?: +#+)? *(?:\\n+|$)/,\n    blockquote: /^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/,\n    list: /^( {0,3})(bull) [\\s\\S]+?(?:hr|def|\\n{2,}(?! )(?!\\1bull )\\n*|\\s*$)/,\n    html: '^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (6)\n    + '|<(?!script|pre|style)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (7) open tag\n    + '|</(?!script|pre|style)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (7) closing tag\n    + ')',\n    def: /^ {0,3}\\[(label)\\]: *\\n? *<?([^\\s>]+)>?(?:(?: +\\n? *| *\\n *)(title))? *(?:\\n+|$)/,\n    nptable: noopTest$1,\n    table: noopTest$1,\n    lheading: /^([^\\n]+)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    // regex template, placeholders will be replaced according to different paragraph\n    // interruption rules of commonmark and the original markdown spec:\n    _paragraph: /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html)[^\\n]+)*)/,\n    text: /^[^\\n]+/\n  };\n  block._label = /(?!\\s*\\])(?:\\\\[\\[\\]]|[^\\[\\]])+/;\n  block._title = /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/;\n  block.def = edit$1(block.def).replace('label', block._label).replace('title', block._title).getRegex();\n  block.bullet = /(?:[*+-]|\\d{1,9}[.)])/;\n  block.item = /^( *)(bull) ?[^\\n]*(?:\\n(?!\\1bull ?)[^\\n]*)*/;\n  block.item = edit$1(block.item, 'gm').replace(/bull/g, block.bullet).getRegex();\n  block.list = edit$1(block.list).replace(/bull/g, block.bullet).replace('hr', '\\\\n+(?=\\\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$))').replace('def', '\\\\n+(?=' + block.def.source + ')').getRegex();\n  block._tag = 'address|article|aside|base|basefont|blockquote|body|caption' + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr' + '|track|ul';\n  block._comment = /<!--(?!-?>)[\\s\\S]*?(?:-->|$)/;\n  block.html = edit$1(block.html, 'i').replace('comment', block._comment).replace('tag', block._tag).replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\n  block.paragraph = edit$1(block._paragraph).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n  .replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|!--)').replace('tag', block._tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n  block.blockquote = edit$1(block.blockquote).replace('paragraph', block.paragraph).getRegex();\n  /**\n   * Normal Block Grammar\n   */\n\n  block.normal = merge$1({}, block);\n  /**\n   * GFM Block Grammar\n   */\n\n  block.gfm = merge$1({}, block.normal, {\n    nptable: '^ *([^|\\\\n ].*\\\\|.*)\\\\n' // Header\n    + ' {0,3}([-:]+ *\\\\|[-| :]*)' // Align\n    + '(?:\\\\n((?:(?!\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)',\n    // Cells\n    table: '^ *\\\\|(.+)\\\\n' // Header\n    + ' {0,3}\\\\|?( *[-:]+[-| :]*)' // Align\n    + '(?:\\\\n *((?:(?!\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)' // Cells\n\n  });\n  block.gfm.nptable = edit$1(block.gfm.nptable).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|!--)').replace('tag', block._tag) // tables can be interrupted by type (6) html blocks\n  .getRegex();\n  block.gfm.table = edit$1(block.gfm.table).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|!--)').replace('tag', block._tag) // tables can be interrupted by type (6) html blocks\n  .getRegex();\n  /**\n   * Pedantic grammar (original John Gruber's loose markdown specification)\n   */\n\n  block.pedantic = merge$1({}, block.normal, {\n    html: edit$1('^ *(?:comment *(?:\\\\n|\\\\s*$)' + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n    + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))').replace('comment', block._comment).replace(/tag/g, '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b').getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^ *(#{1,6}) *([^\\n]+?) *(?:#+ *)?(?:\\n+|$)/,\n    fences: noopTest$1,\n    // fences not supported\n    paragraph: edit$1(block.normal._paragraph).replace('hr', block.hr).replace('heading', ' *#{1,6} *[^\\n]').replace('lheading', block.lheading).replace('blockquote', ' {0,3}>').replace('|fences', '').replace('|list', '').replace('|html', '').getRegex()\n  });\n  /**\n   * Inline-Level Grammar\n   */\n\n  var inline = {\n    escape: /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n    autolink: /^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/,\n    url: noopTest$1,\n    tag: '^comment' + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>',\n    // CDATA section\n    link: /^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/,\n    reflink: /^!?\\[(label)\\]\\[(?!\\s*\\])((?:\\\\[\\[\\]]?|[^\\[\\]\\\\])+)\\]/,\n    nolink: /^!?\\[(?!\\s*\\])((?:\\[[^\\[\\]]*\\]|\\\\[\\[\\]]|[^\\[\\]])*)\\](?:\\[\\])?/,\n    reflinkSearch: 'reflink|nolink(?!\\\\()',\n    strong: {\n      start: /^(?:(\\*\\*(?=[*punctuation]))|\\*\\*)(?![\\s])|__/,\n      // (1) returns if starts w/ punctuation\n      middle: /^\\*\\*(?:(?:(?!overlapSkip)(?:[^*]|\\\\\\*)|overlapSkip)|\\*(?:(?!overlapSkip)(?:[^*]|\\\\\\*)|overlapSkip)*?\\*)+?\\*\\*$|^__(?![\\s])((?:(?:(?!overlapSkip)(?:[^_]|\\\\_)|overlapSkip)|_(?:(?!overlapSkip)(?:[^_]|\\\\_)|overlapSkip)*?_)+?)__$/,\n      endAst: /[^punctuation\\s]\\*\\*(?!\\*)|[punctuation]\\*\\*(?!\\*)(?:(?=[punctuation_\\s]|$))/,\n      // last char can't be punct, or final * must also be followed by punct (or endline)\n      endUnd: /[^\\s]__(?!_)(?:(?=[punctuation*\\s])|$)/ // last char can't be a space, and final _ must preceed punct or \\s (or endline)\n\n    },\n    em: {\n      start: /^(?:(\\*(?=[punctuation]))|\\*)(?![*\\s])|_/,\n      // (1) returns if starts w/ punctuation\n      middle: /^\\*(?:(?:(?!overlapSkip)(?:[^*]|\\\\\\*)|overlapSkip)|\\*(?:(?!overlapSkip)(?:[^*]|\\\\\\*)|overlapSkip)*?\\*)+?\\*$|^_(?![_\\s])(?:(?:(?!overlapSkip)(?:[^_]|\\\\_)|overlapSkip)|_(?:(?!overlapSkip)(?:[^_]|\\\\_)|overlapSkip)*?_)+?_$/,\n      endAst: /[^punctuation\\s]\\*(?!\\*)|[punctuation]\\*(?!\\*)(?:(?=[punctuation_\\s]|$))/,\n      // last char can't be punct, or final * must also be followed by punct (or endline)\n      endUnd: /[^\\s]_(?!_)(?:(?=[punctuation*\\s])|$)/ // last char can't be a space, and final _ must preceed punct or \\s (or endline)\n\n    },\n    code: /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/,\n    br: /^( {2,}|\\\\)\\n(?!\\s*$)/,\n    del: noopTest$1,\n    text: /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*]|\\b_|$)|[^ ](?= {2,}\\n)))/,\n    punctuation: /^([\\s*punctuation])/\n  }; // list of punctuation marks from common mark spec\n  // without * and _ to workaround cases with double emphasis\n\n  inline._punctuation = '!\"#$%&\\'()+\\\\-.,/:;<=>?@\\\\[\\\\]`^{|}~';\n  inline.punctuation = edit$1(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex(); // sequences em should skip over [title](link), `code`, <html>\n\n  inline._blockSkip = '\\\\[[^\\\\]]*?\\\\]\\\\([^\\\\)]*?\\\\)|`[^`]*?`|<[^>]*?>';\n  inline._overlapSkip = '__[^_]*?__|\\\\*\\\\*\\\\[^\\\\*\\\\]*?\\\\*\\\\*';\n  inline._comment = edit$1(block._comment).replace('(?:-->|$)', '-->').getRegex();\n  inline.em.start = edit$1(inline.em.start).replace(/punctuation/g, inline._punctuation).getRegex();\n  inline.em.middle = edit$1(inline.em.middle).replace(/punctuation/g, inline._punctuation).replace(/overlapSkip/g, inline._overlapSkip).getRegex();\n  inline.em.endAst = edit$1(inline.em.endAst, 'g').replace(/punctuation/g, inline._punctuation).getRegex();\n  inline.em.endUnd = edit$1(inline.em.endUnd, 'g').replace(/punctuation/g, inline._punctuation).getRegex();\n  inline.strong.start = edit$1(inline.strong.start).replace(/punctuation/g, inline._punctuation).getRegex();\n  inline.strong.middle = edit$1(inline.strong.middle).replace(/punctuation/g, inline._punctuation).replace(/overlapSkip/g, inline._overlapSkip).getRegex();\n  inline.strong.endAst = edit$1(inline.strong.endAst, 'g').replace(/punctuation/g, inline._punctuation).getRegex();\n  inline.strong.endUnd = edit$1(inline.strong.endUnd, 'g').replace(/punctuation/g, inline._punctuation).getRegex();\n  inline.blockSkip = edit$1(inline._blockSkip, 'g').getRegex();\n  inline.overlapSkip = edit$1(inline._overlapSkip, 'g').getRegex();\n  inline._escapes = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/g;\n  inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;\n  inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;\n  inline.autolink = edit$1(inline.autolink).replace('scheme', inline._scheme).replace('email', inline._email).getRegex();\n  inline._attribute = /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/;\n  inline.tag = edit$1(inline.tag).replace('comment', inline._comment).replace('attribute', inline._attribute).getRegex();\n  inline._label = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\n  inline._href = /<(?:\\\\[<>]?|[^\\s<>\\\\])*>|[^\\s\\x00-\\x1f]*/;\n  inline._title = /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/;\n  inline.link = edit$1(inline.link).replace('label', inline._label).replace('href', inline._href).replace('title', inline._title).getRegex();\n  inline.reflink = edit$1(inline.reflink).replace('label', inline._label).getRegex();\n  inline.reflinkSearch = edit$1(inline.reflinkSearch, 'g').replace('reflink', inline.reflink).replace('nolink', inline.nolink).getRegex();\n  /**\n   * Normal Inline Grammar\n   */\n\n  inline.normal = merge$1({}, inline);\n  /**\n   * Pedantic Inline Grammar\n   */\n\n  inline.pedantic = merge$1({}, inline.normal, {\n    strong: {\n      start: /^__|\\*\\*/,\n      middle: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n      endAst: /\\*\\*(?!\\*)/g,\n      endUnd: /__(?!_)/g\n    },\n    em: {\n      start: /^_|\\*/,\n      middle: /^()\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)|^_(?=\\S)([\\s\\S]*?\\S)_(?!_)/,\n      endAst: /\\*(?!\\*)/g,\n      endUnd: /_(?!_)/g\n    },\n    link: edit$1(/^!?\\[(label)\\]\\((.*?)\\)/).replace('label', inline._label).getRegex(),\n    reflink: edit$1(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace('label', inline._label).getRegex()\n  });\n  /**\n   * GFM Inline Grammar\n   */\n\n  inline.gfm = merge$1({}, inline.normal, {\n    escape: edit$1(inline.escape).replace('])', '~|])').getRegex(),\n    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,\n    url: /^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/,\n    _backpedal: /(?:[^?!.,:;*_~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,\n    del: /^~+(?=\\S)([\\s\\S]*?\\S)~+/,\n    text: /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@))|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@))/\n  });\n  inline.gfm.url = edit$1(inline.gfm.url, 'i').replace('email', inline.gfm._extended_email).getRegex();\n  /**\n   * GFM + Line Breaks Inline Grammar\n   */\n\n  inline.breaks = merge$1({}, inline.gfm, {\n    br: edit$1(inline.br).replace('{2,}', '*').getRegex(),\n    text: edit$1(inline.gfm.text).replace('\\\\b_', '\\\\b_| {2,}\\\\n').replace(/\\{2,\\}/g, '*').getRegex()\n  });\n  var rules = {\n    block: block,\n    inline: inline\n  };\n\n  var defaults$2 = defaults.defaults;\n  var block$1 = rules.block,\n      inline$1 = rules.inline;\n  /**\n   * smartypants text replacement\n   */\n\n  function smartypants(text) {\n    return text // em-dashes\n    .replace(/---/g, \"\\u2014\") // en-dashes\n    .replace(/--/g, \"\\u2013\") // opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, \"$1\\u2018\") // closing singles & apostrophes\n    .replace(/'/g, \"\\u2019\") // opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, \"$1\\u201C\") // closing doubles\n    .replace(/\"/g, \"\\u201D\") // ellipses\n    .replace(/\\.{3}/g, \"\\u2026\");\n  }\n  /**\n   * mangle email addresses\n   */\n\n\n  function mangle(text) {\n    var out = '',\n        i,\n        ch;\n    var l = text.length;\n\n    for (i = 0; i < l; i++) {\n      ch = text.charCodeAt(i);\n\n      if (Math.random() > 0.5) {\n        ch = 'x' + ch.toString(16);\n      }\n\n      out += '&#' + ch + ';';\n    }\n\n    return out;\n  }\n  /**\n   * Block Lexer\n   */\n\n\n  var Lexer_1 = /*#__PURE__*/function () {\n    function Lexer(options) {\n      this.tokens = [];\n      this.tokens.links = Object.create(null);\n      this.options = options || defaults$2;\n      this.options.tokenizer = this.options.tokenizer || new Tokenizer_1();\n      this.tokenizer = this.options.tokenizer;\n      this.tokenizer.options = this.options;\n      var rules = {\n        block: block$1.normal,\n        inline: inline$1.normal\n      };\n\n      if (this.options.pedantic) {\n        rules.block = block$1.pedantic;\n        rules.inline = inline$1.pedantic;\n      } else if (this.options.gfm) {\n        rules.block = block$1.gfm;\n\n        if (this.options.breaks) {\n          rules.inline = inline$1.breaks;\n        } else {\n          rules.inline = inline$1.gfm;\n        }\n      }\n\n      this.tokenizer.rules = rules;\n    }\n    /**\n     * Expose Rules\n     */\n\n\n    /**\n     * Static Lex Method\n     */\n    Lexer.lex = function lex(src, options) {\n      var lexer = new Lexer(options);\n      return lexer.lex(src);\n    }\n    /**\n     * Static Lex Inline Method\n     */\n    ;\n\n    Lexer.lexInline = function lexInline(src, options) {\n      var lexer = new Lexer(options);\n      return lexer.inlineTokens(src);\n    }\n    /**\n     * Preprocessing\n     */\n    ;\n\n    var _proto = Lexer.prototype;\n\n    _proto.lex = function lex(src) {\n      src = src.replace(/\\r\\n|\\r/g, '\\n').replace(/\\t/g, '    ');\n      this.blockTokens(src, this.tokens, true);\n      this.inline(this.tokens);\n      return this.tokens;\n    }\n    /**\n     * Lexing\n     */\n    ;\n\n    _proto.blockTokens = function blockTokens(src, tokens, top) {\n      if (tokens === void 0) {\n        tokens = [];\n      }\n\n      if (top === void 0) {\n        top = true;\n      }\n\n      src = src.replace(/^ +$/gm, '');\n      var token, i, l, lastToken;\n\n      while (src) {\n        // newline\n        if (token = this.tokenizer.space(src)) {\n          src = src.substring(token.raw.length);\n\n          if (token.type) {\n            tokens.push(token);\n          }\n\n          continue;\n        } // code\n\n\n        if (token = this.tokenizer.code(src, tokens)) {\n          src = src.substring(token.raw.length);\n\n          if (token.type) {\n            tokens.push(token);\n          } else {\n            lastToken = tokens[tokens.length - 1];\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.text;\n          }\n\n          continue;\n        } // fences\n\n\n        if (token = this.tokenizer.fences(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // heading\n\n\n        if (token = this.tokenizer.heading(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // table no leading pipe (gfm)\n\n\n        if (token = this.tokenizer.nptable(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // hr\n\n\n        if (token = this.tokenizer.hr(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // blockquote\n\n\n        if (token = this.tokenizer.blockquote(src)) {\n          src = src.substring(token.raw.length);\n          token.tokens = this.blockTokens(token.text, [], top);\n          tokens.push(token);\n          continue;\n        } // list\n\n\n        if (token = this.tokenizer.list(src)) {\n          src = src.substring(token.raw.length);\n          l = token.items.length;\n\n          for (i = 0; i < l; i++) {\n            token.items[i].tokens = this.blockTokens(token.items[i].text, [], false);\n          }\n\n          tokens.push(token);\n          continue;\n        } // html\n\n\n        if (token = this.tokenizer.html(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // def\n\n\n        if (top && (token = this.tokenizer.def(src))) {\n          src = src.substring(token.raw.length);\n\n          if (!this.tokens.links[token.tag]) {\n            this.tokens.links[token.tag] = {\n              href: token.href,\n              title: token.title\n            };\n          }\n\n          continue;\n        } // table (gfm)\n\n\n        if (token = this.tokenizer.table(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // lheading\n\n\n        if (token = this.tokenizer.lheading(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // top-level paragraph\n\n\n        if (top && (token = this.tokenizer.paragraph(src))) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // text\n\n\n        if (token = this.tokenizer.text(src, tokens)) {\n          src = src.substring(token.raw.length);\n\n          if (token.type) {\n            tokens.push(token);\n          } else {\n            lastToken = tokens[tokens.length - 1];\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.text;\n          }\n\n          continue;\n        }\n\n        if (src) {\n          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n\n          if (this.options.silent) {\n            console.error(errMsg);\n            break;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n\n      return tokens;\n    };\n\n    _proto.inline = function inline(tokens) {\n      var i, j, k, l2, row, token;\n      var l = tokens.length;\n\n      for (i = 0; i < l; i++) {\n        token = tokens[i];\n\n        switch (token.type) {\n          case 'paragraph':\n          case 'text':\n          case 'heading':\n            {\n              token.tokens = [];\n              this.inlineTokens(token.text, token.tokens);\n              break;\n            }\n\n          case 'table':\n            {\n              token.tokens = {\n                header: [],\n                cells: []\n              }; // header\n\n              l2 = token.header.length;\n\n              for (j = 0; j < l2; j++) {\n                token.tokens.header[j] = [];\n                this.inlineTokens(token.header[j], token.tokens.header[j]);\n              } // cells\n\n\n              l2 = token.cells.length;\n\n              for (j = 0; j < l2; j++) {\n                row = token.cells[j];\n                token.tokens.cells[j] = [];\n\n                for (k = 0; k < row.length; k++) {\n                  token.tokens.cells[j][k] = [];\n                  this.inlineTokens(row[k], token.tokens.cells[j][k]);\n                }\n              }\n\n              break;\n            }\n\n          case 'blockquote':\n            {\n              this.inline(token.tokens);\n              break;\n            }\n\n          case 'list':\n            {\n              l2 = token.items.length;\n\n              for (j = 0; j < l2; j++) {\n                this.inline(token.items[j].tokens);\n              }\n\n              break;\n            }\n        }\n      }\n\n      return tokens;\n    }\n    /**\n     * Lexing/Compiling\n     */\n    ;\n\n    _proto.inlineTokens = function inlineTokens(src, tokens, inLink, inRawBlock, prevChar) {\n      if (tokens === void 0) {\n        tokens = [];\n      }\n\n      if (inLink === void 0) {\n        inLink = false;\n      }\n\n      if (inRawBlock === void 0) {\n        inRawBlock = false;\n      }\n\n      if (prevChar === void 0) {\n        prevChar = '';\n      }\n\n      var token; // String with links masked to avoid interference with em and strong\n\n      var maskedSrc = src;\n      var match; // Mask out reflinks\n\n      if (this.tokens.links) {\n        var links = Object.keys(this.tokens.links);\n\n        if (links.length > 0) {\n          while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n            if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n              maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n            }\n          }\n        }\n      } // Mask out other blocks\n\n\n      while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n        maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n      }\n\n      while (src) {\n        // escape\n        if (token = this.tokenizer.escape(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // tag\n\n\n        if (token = this.tokenizer.tag(src, inLink, inRawBlock)) {\n          src = src.substring(token.raw.length);\n          inLink = token.inLink;\n          inRawBlock = token.inRawBlock;\n          tokens.push(token);\n          continue;\n        } // link\n\n\n        if (token = this.tokenizer.link(src)) {\n          src = src.substring(token.raw.length);\n\n          if (token.type === 'link') {\n            token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);\n          }\n\n          tokens.push(token);\n          continue;\n        } // reflink, nolink\n\n\n        if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n          src = src.substring(token.raw.length);\n\n          if (token.type === 'link') {\n            token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);\n          }\n\n          tokens.push(token);\n          continue;\n        } // strong\n\n\n        if (token = this.tokenizer.strong(src, maskedSrc, prevChar)) {\n          src = src.substring(token.raw.length);\n          token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);\n          tokens.push(token);\n          continue;\n        } // em\n\n\n        if (token = this.tokenizer.em(src, maskedSrc, prevChar)) {\n          src = src.substring(token.raw.length);\n          token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);\n          tokens.push(token);\n          continue;\n        } // code\n\n\n        if (token = this.tokenizer.codespan(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // br\n\n\n        if (token = this.tokenizer.br(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // del (gfm)\n\n\n        if (token = this.tokenizer.del(src)) {\n          src = src.substring(token.raw.length);\n          token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);\n          tokens.push(token);\n          continue;\n        } // autolink\n\n\n        if (token = this.tokenizer.autolink(src, mangle)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // url (gfm)\n\n\n        if (!inLink && (token = this.tokenizer.url(src, mangle))) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // text\n\n\n        if (token = this.tokenizer.inlineText(src, inRawBlock, smartypants)) {\n          src = src.substring(token.raw.length);\n          prevChar = token.raw.slice(-1);\n          tokens.push(token);\n          continue;\n        }\n\n        if (src) {\n          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n\n          if (this.options.silent) {\n            console.error(errMsg);\n            break;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n\n      return tokens;\n    };\n\n    _createClass(Lexer, null, [{\n      key: \"rules\",\n      get: function get() {\n        return {\n          block: block$1,\n          inline: inline$1\n        };\n      }\n    }]);\n\n    return Lexer;\n  }();\n\n  var defaults$3 = defaults.defaults;\n  var cleanUrl$1 = helpers.cleanUrl,\n      escape$1 = helpers.escape;\n  /**\n   * Renderer\n   */\n\n  var Renderer_1 = /*#__PURE__*/function () {\n    function Renderer(options) {\n      this.options = options || defaults$3;\n    }\n\n    var _proto = Renderer.prototype;\n\n    _proto.code = function code(_code, infostring, escaped) {\n      var lang = (infostring || '').match(/\\S*/)[0];\n\n      if (this.options.highlight) {\n        var out = this.options.highlight(_code, lang);\n\n        if (out != null && out !== _code) {\n          escaped = true;\n          _code = out;\n        }\n      }\n\n      if (!lang) {\n        return '<pre><code>' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\\n';\n      }\n\n      return '<pre><code class=\"' + this.options.langPrefix + escape$1(lang, true) + '\">' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\\n';\n    };\n\n    _proto.blockquote = function blockquote(quote) {\n      return '<blockquote>\\n' + quote + '</blockquote>\\n';\n    };\n\n    _proto.html = function html(_html) {\n      return _html;\n    };\n\n    _proto.heading = function heading(text, level, raw, slugger) {\n      if (this.options.headerIds) {\n        return '<h' + level + ' id=\"' + this.options.headerPrefix + slugger.slug(raw) + '\">' + text + '</h' + level + '>\\n';\n      } // ignore IDs\n\n\n      return '<h' + level + '>' + text + '</h' + level + '>\\n';\n    };\n\n    _proto.hr = function hr() {\n      return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n    };\n\n    _proto.list = function list(body, ordered, start) {\n      var type = ordered ? 'ol' : 'ul',\n          startatt = ordered && start !== 1 ? ' start=\"' + start + '\"' : '';\n      return '<' + type + startatt + '>\\n' + body + '</' + type + '>\\n';\n    };\n\n    _proto.listitem = function listitem(text) {\n      return '<li>' + text + '</li>\\n';\n    };\n\n    _proto.checkbox = function checkbox(checked) {\n      return '<input ' + (checked ? 'checked=\"\" ' : '') + 'disabled=\"\" type=\"checkbox\"' + (this.options.xhtml ? ' /' : '') + '> ';\n    };\n\n    _proto.paragraph = function paragraph(text) {\n      return '<p>' + text + '</p>\\n';\n    };\n\n    _proto.table = function table(header, body) {\n      if (body) body = '<tbody>' + body + '</tbody>';\n      return '<table>\\n' + '<thead>\\n' + header + '</thead>\\n' + body + '</table>\\n';\n    };\n\n    _proto.tablerow = function tablerow(content) {\n      return '<tr>\\n' + content + '</tr>\\n';\n    };\n\n    _proto.tablecell = function tablecell(content, flags) {\n      var type = flags.header ? 'th' : 'td';\n      var tag = flags.align ? '<' + type + ' align=\"' + flags.align + '\">' : '<' + type + '>';\n      return tag + content + '</' + type + '>\\n';\n    } // span level renderer\n    ;\n\n    _proto.strong = function strong(text) {\n      return '<strong>' + text + '</strong>';\n    };\n\n    _proto.em = function em(text) {\n      return '<em>' + text + '</em>';\n    };\n\n    _proto.codespan = function codespan(text) {\n      return '<code>' + text + '</code>';\n    };\n\n    _proto.br = function br() {\n      return this.options.xhtml ? '<br/>' : '<br>';\n    };\n\n    _proto.del = function del(text) {\n      return '<del>' + text + '</del>';\n    };\n\n    _proto.link = function link(href, title, text) {\n      href = cleanUrl$1(this.options.sanitize, this.options.baseUrl, href);\n\n      if (href === null) {\n        return text;\n      }\n\n      var out = '<a href=\"' + escape$1(href) + '\"';\n\n      if (title) {\n        out += ' title=\"' + title + '\"';\n      }\n\n      out += '>' + text + '</a>';\n      return out;\n    };\n\n    _proto.image = function image(href, title, text) {\n      href = cleanUrl$1(this.options.sanitize, this.options.baseUrl, href);\n\n      if (href === null) {\n        return text;\n      }\n\n      var out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n\n      if (title) {\n        out += ' title=\"' + title + '\"';\n      }\n\n      out += this.options.xhtml ? '/>' : '>';\n      return out;\n    };\n\n    _proto.text = function text(_text) {\n      return _text;\n    };\n\n    return Renderer;\n  }();\n\n  /**\n   * TextRenderer\n   * returns only the textual part of the token\n   */\n  var TextRenderer_1 = /*#__PURE__*/function () {\n    function TextRenderer() {}\n\n    var _proto = TextRenderer.prototype;\n\n    // no need for block level renderers\n    _proto.strong = function strong(text) {\n      return text;\n    };\n\n    _proto.em = function em(text) {\n      return text;\n    };\n\n    _proto.codespan = function codespan(text) {\n      return text;\n    };\n\n    _proto.del = function del(text) {\n      return text;\n    };\n\n    _proto.html = function html(text) {\n      return text;\n    };\n\n    _proto.text = function text(_text) {\n      return _text;\n    };\n\n    _proto.link = function link(href, title, text) {\n      return '' + text;\n    };\n\n    _proto.image = function image(href, title, text) {\n      return '' + text;\n    };\n\n    _proto.br = function br() {\n      return '';\n    };\n\n    return TextRenderer;\n  }();\n\n  /**\n   * Slugger generates header id\n   */\n  var Slugger_1 = /*#__PURE__*/function () {\n    function Slugger() {\n      this.seen = {};\n    }\n\n    var _proto = Slugger.prototype;\n\n    _proto.serialize = function serialize(value) {\n      return value.toLowerCase().trim() // remove html tags\n      .replace(/<[!\\/a-z].*?>/ig, '') // remove unwanted chars\n      .replace(/[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,./:;<=>?@[\\]^`{|}~]/g, '').replace(/\\s/g, '-');\n    }\n    /**\n     * Finds the next safe (unique) slug to use\n     */\n    ;\n\n    _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {\n      var slug = originalSlug;\n      var occurenceAccumulator = 0;\n\n      if (this.seen.hasOwnProperty(slug)) {\n        occurenceAccumulator = this.seen[originalSlug];\n\n        do {\n          occurenceAccumulator++;\n          slug = originalSlug + '-' + occurenceAccumulator;\n        } while (this.seen.hasOwnProperty(slug));\n      }\n\n      if (!isDryRun) {\n        this.seen[originalSlug] = occurenceAccumulator;\n        this.seen[slug] = 0;\n      }\n\n      return slug;\n    }\n    /**\n     * Convert string to unique id\n     * @param {object} options\n     * @param {boolean} options.dryrun Generates the next unique slug without updating the internal accumulator.\n     */\n    ;\n\n    _proto.slug = function slug(value, options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      var slug = this.serialize(value);\n      return this.getNextSafeSlug(slug, options.dryrun);\n    };\n\n    return Slugger;\n  }();\n\n  var defaults$4 = defaults.defaults;\n  var unescape$1 = helpers.unescape;\n  /**\n   * Parsing & Compiling\n   */\n\n  var Parser_1 = /*#__PURE__*/function () {\n    function Parser(options) {\n      this.options = options || defaults$4;\n      this.options.renderer = this.options.renderer || new Renderer_1();\n      this.renderer = this.options.renderer;\n      this.renderer.options = this.options;\n      this.textRenderer = new TextRenderer_1();\n      this.slugger = new Slugger_1();\n    }\n    /**\n     * Static Parse Method\n     */\n\n\n    Parser.parse = function parse(tokens, options) {\n      var parser = new Parser(options);\n      return parser.parse(tokens);\n    }\n    /**\n     * Static Parse Inline Method\n     */\n    ;\n\n    Parser.parseInline = function parseInline(tokens, options) {\n      var parser = new Parser(options);\n      return parser.parseInline(tokens);\n    }\n    /**\n     * Parse Loop\n     */\n    ;\n\n    var _proto = Parser.prototype;\n\n    _proto.parse = function parse(tokens, top) {\n      if (top === void 0) {\n        top = true;\n      }\n\n      var out = '',\n          i,\n          j,\n          k,\n          l2,\n          l3,\n          row,\n          cell,\n          header,\n          body,\n          token,\n          ordered,\n          start,\n          loose,\n          itemBody,\n          item,\n          checked,\n          task,\n          checkbox;\n      var l = tokens.length;\n\n      for (i = 0; i < l; i++) {\n        token = tokens[i];\n\n        switch (token.type) {\n          case 'space':\n            {\n              continue;\n            }\n\n          case 'hr':\n            {\n              out += this.renderer.hr();\n              continue;\n            }\n\n          case 'heading':\n            {\n              out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape$1(this.parseInline(token.tokens, this.textRenderer)), this.slugger);\n              continue;\n            }\n\n          case 'code':\n            {\n              out += this.renderer.code(token.text, token.lang, token.escaped);\n              continue;\n            }\n\n          case 'table':\n            {\n              header = ''; // header\n\n              cell = '';\n              l2 = token.header.length;\n\n              for (j = 0; j < l2; j++) {\n                cell += this.renderer.tablecell(this.parseInline(token.tokens.header[j]), {\n                  header: true,\n                  align: token.align[j]\n                });\n              }\n\n              header += this.renderer.tablerow(cell);\n              body = '';\n              l2 = token.cells.length;\n\n              for (j = 0; j < l2; j++) {\n                row = token.tokens.cells[j];\n                cell = '';\n                l3 = row.length;\n\n                for (k = 0; k < l3; k++) {\n                  cell += this.renderer.tablecell(this.parseInline(row[k]), {\n                    header: false,\n                    align: token.align[k]\n                  });\n                }\n\n                body += this.renderer.tablerow(cell);\n              }\n\n              out += this.renderer.table(header, body);\n              continue;\n            }\n\n          case 'blockquote':\n            {\n              body = this.parse(token.tokens);\n              out += this.renderer.blockquote(body);\n              continue;\n            }\n\n          case 'list':\n            {\n              ordered = token.ordered;\n              start = token.start;\n              loose = token.loose;\n              l2 = token.items.length;\n              body = '';\n\n              for (j = 0; j < l2; j++) {\n                item = token.items[j];\n                checked = item.checked;\n                task = item.task;\n                itemBody = '';\n\n                if (item.task) {\n                  checkbox = this.renderer.checkbox(checked);\n\n                  if (loose) {\n                    if (item.tokens.length > 0 && item.tokens[0].type === 'text') {\n                      item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n\n                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n                      }\n                    } else {\n                      item.tokens.unshift({\n                        type: 'text',\n                        text: checkbox\n                      });\n                    }\n                  } else {\n                    itemBody += checkbox;\n                  }\n                }\n\n                itemBody += this.parse(item.tokens, loose);\n                body += this.renderer.listitem(itemBody, task, checked);\n              }\n\n              out += this.renderer.list(body, ordered, start);\n              continue;\n            }\n\n          case 'html':\n            {\n              // TODO parse inline content if parameter markdown=1\n              out += this.renderer.html(token.text);\n              continue;\n            }\n\n          case 'paragraph':\n            {\n              out += this.renderer.paragraph(this.parseInline(token.tokens));\n              continue;\n            }\n\n          case 'text':\n            {\n              body = token.tokens ? this.parseInline(token.tokens) : token.text;\n\n              while (i + 1 < l && tokens[i + 1].type === 'text') {\n                token = tokens[++i];\n                body += '\\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);\n              }\n\n              out += top ? this.renderer.paragraph(body) : body;\n              continue;\n            }\n\n          default:\n            {\n              var errMsg = 'Token with \"' + token.type + '\" type was not found.';\n\n              if (this.options.silent) {\n                console.error(errMsg);\n                return;\n              } else {\n                throw new Error(errMsg);\n              }\n            }\n        }\n      }\n\n      return out;\n    }\n    /**\n     * Parse Inline Tokens\n     */\n    ;\n\n    _proto.parseInline = function parseInline(tokens, renderer) {\n      renderer = renderer || this.renderer;\n      var out = '',\n          i,\n          token;\n      var l = tokens.length;\n\n      for (i = 0; i < l; i++) {\n        token = tokens[i];\n\n        switch (token.type) {\n          case 'escape':\n            {\n              out += renderer.text(token.text);\n              break;\n            }\n\n          case 'html':\n            {\n              out += renderer.html(token.text);\n              break;\n            }\n\n          case 'link':\n            {\n              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'image':\n            {\n              out += renderer.image(token.href, token.title, token.text);\n              break;\n            }\n\n          case 'strong':\n            {\n              out += renderer.strong(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'em':\n            {\n              out += renderer.em(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'codespan':\n            {\n              out += renderer.codespan(token.text);\n              break;\n            }\n\n          case 'br':\n            {\n              out += renderer.br();\n              break;\n            }\n\n          case 'del':\n            {\n              out += renderer.del(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'text':\n            {\n              out += renderer.text(token.text);\n              break;\n            }\n\n          default:\n            {\n              var errMsg = 'Token with \"' + token.type + '\" type was not found.';\n\n              if (this.options.silent) {\n                console.error(errMsg);\n                return;\n              } else {\n                throw new Error(errMsg);\n              }\n            }\n        }\n      }\n\n      return out;\n    };\n\n    return Parser;\n  }();\n\n  var merge$2 = helpers.merge,\n      checkSanitizeDeprecation$1 = helpers.checkSanitizeDeprecation,\n      escape$2 = helpers.escape;\n  var getDefaults = defaults.getDefaults,\n      changeDefaults = defaults.changeDefaults,\n      defaults$5 = defaults.defaults;\n  /**\n   * Marked\n   */\n\n  function marked(src, opt, callback) {\n    // throw error in case of non string input\n    if (typeof src === 'undefined' || src === null) {\n      throw new Error('marked(): input parameter is undefined or null');\n    }\n\n    if (typeof src !== 'string') {\n      throw new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');\n    }\n\n    if (typeof opt === 'function') {\n      callback = opt;\n      opt = null;\n    }\n\n    opt = merge$2({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation$1(opt);\n\n    if (callback) {\n      var highlight = opt.highlight;\n      var tokens;\n\n      try {\n        tokens = Lexer_1.lex(src, opt);\n      } catch (e) {\n        return callback(e);\n      }\n\n      var done = function done(err) {\n        var out;\n\n        if (!err) {\n          try {\n            out = Parser_1.parse(tokens, opt);\n          } catch (e) {\n            err = e;\n          }\n        }\n\n        opt.highlight = highlight;\n        return err ? callback(err) : callback(null, out);\n      };\n\n      if (!highlight || highlight.length < 3) {\n        return done();\n      }\n\n      delete opt.highlight;\n      if (!tokens.length) return done();\n      var pending = 0;\n      marked.walkTokens(tokens, function (token) {\n        if (token.type === 'code') {\n          pending++;\n          setTimeout(function () {\n            highlight(token.text, token.lang, function (err, code) {\n              if (err) {\n                return done(err);\n              }\n\n              if (code != null && code !== token.text) {\n                token.text = code;\n                token.escaped = true;\n              }\n\n              pending--;\n\n              if (pending === 0) {\n                done();\n              }\n            });\n          }, 0);\n        }\n      });\n\n      if (pending === 0) {\n        done();\n      }\n\n      return;\n    }\n\n    try {\n      var _tokens = Lexer_1.lex(src, opt);\n\n      if (opt.walkTokens) {\n        marked.walkTokens(_tokens, opt.walkTokens);\n      }\n\n      return Parser_1.parse(_tokens, opt);\n    } catch (e) {\n      e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n      if (opt.silent) {\n        return '<p>An error occurred:</p><pre>' + escape$2(e.message + '', true) + '</pre>';\n      }\n\n      throw e;\n    }\n  }\n  /**\n   * Options\n   */\n\n\n  marked.options = marked.setOptions = function (opt) {\n    merge$2(marked.defaults, opt);\n    changeDefaults(marked.defaults);\n    return marked;\n  };\n\n  marked.getDefaults = getDefaults;\n  marked.defaults = defaults$5;\n  /**\n   * Use Extension\n   */\n\n  marked.use = function (extension) {\n    var opts = merge$2({}, extension);\n\n    if (extension.renderer) {\n      (function () {\n        var renderer = marked.defaults.renderer || new Renderer_1();\n\n        var _loop = function _loop(prop) {\n          var prevRenderer = renderer[prop];\n\n          renderer[prop] = function () {\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n\n            var ret = extension.renderer[prop].apply(renderer, args);\n\n            if (ret === false) {\n              ret = prevRenderer.apply(renderer, args);\n            }\n\n            return ret;\n          };\n        };\n\n        for (var prop in extension.renderer) {\n          _loop(prop);\n        }\n\n        opts.renderer = renderer;\n      })();\n    }\n\n    if (extension.tokenizer) {\n      (function () {\n        var tokenizer = marked.defaults.tokenizer || new Tokenizer_1();\n\n        var _loop2 = function _loop2(prop) {\n          var prevTokenizer = tokenizer[prop];\n\n          tokenizer[prop] = function () {\n            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              args[_key2] = arguments[_key2];\n            }\n\n            var ret = extension.tokenizer[prop].apply(tokenizer, args);\n\n            if (ret === false) {\n              ret = prevTokenizer.apply(tokenizer, args);\n            }\n\n            return ret;\n          };\n        };\n\n        for (var prop in extension.tokenizer) {\n          _loop2(prop);\n        }\n\n        opts.tokenizer = tokenizer;\n      })();\n    }\n\n    if (extension.walkTokens) {\n      var walkTokens = marked.defaults.walkTokens;\n\n      opts.walkTokens = function (token) {\n        extension.walkTokens(token);\n\n        if (walkTokens) {\n          walkTokens(token);\n        }\n      };\n    }\n\n    marked.setOptions(opts);\n  };\n  /**\n   * Run callback for every token\n   */\n\n\n  marked.walkTokens = function (tokens, callback) {\n    for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done;) {\n      var token = _step.value;\n      callback(token);\n\n      switch (token.type) {\n        case 'table':\n          {\n            for (var _iterator2 = _createForOfIteratorHelperLoose(token.tokens.header), _step2; !(_step2 = _iterator2()).done;) {\n              var cell = _step2.value;\n              marked.walkTokens(cell, callback);\n            }\n\n            for (var _iterator3 = _createForOfIteratorHelperLoose(token.tokens.cells), _step3; !(_step3 = _iterator3()).done;) {\n              var row = _step3.value;\n\n              for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done;) {\n                var _cell = _step4.value;\n                marked.walkTokens(_cell, callback);\n              }\n            }\n\n            break;\n          }\n\n        case 'list':\n          {\n            marked.walkTokens(token.items, callback);\n            break;\n          }\n\n        default:\n          {\n            if (token.tokens) {\n              marked.walkTokens(token.tokens, callback);\n            }\n          }\n      }\n    }\n  };\n  /**\n   * Parse Inline\n   */\n\n\n  marked.parseInline = function (src, opt) {\n    // throw error in case of non string input\n    if (typeof src === 'undefined' || src === null) {\n      throw new Error('marked.parseInline(): input parameter is undefined or null');\n    }\n\n    if (typeof src !== 'string') {\n      throw new Error('marked.parseInline(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');\n    }\n\n    opt = merge$2({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation$1(opt);\n\n    try {\n      var tokens = Lexer_1.lexInline(src, opt);\n\n      if (opt.walkTokens) {\n        marked.walkTokens(tokens, opt.walkTokens);\n      }\n\n      return Parser_1.parseInline(tokens, opt);\n    } catch (e) {\n      e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n      if (opt.silent) {\n        return '<p>An error occurred:</p><pre>' + escape$2(e.message + '', true) + '</pre>';\n      }\n\n      throw e;\n    }\n  };\n  /**\n   * Expose\n   */\n\n\n  marked.Parser = Parser_1;\n  marked.parser = Parser_1.parse;\n  marked.Renderer = Renderer_1;\n  marked.TextRenderer = TextRenderer_1;\n  marked.Lexer = Lexer_1;\n  marked.lexer = Lexer_1.lex;\n  marked.Tokenizer = Tokenizer_1;\n  marked.Slugger = Slugger_1;\n  marked.parse = marked;\n  var marked_1 = marked;\n\n  return marked_1;\n\n})));\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/**\n * Actions that modify the URL.\n */\nvar LocationActions = {\n\n  /**\n   * Indicates a new location is being pushed to the history stack.\n   */\n  PUSH: 'push',\n\n  /**\n   * Indicates the current location should be replaced.\n   */\n  REPLACE: 'replace',\n\n  /**\n   * Indicates the most recent entry should be removed from the history stack.\n   */\n  POP: 'pop'\n\n};\n\nmodule.exports = LocationActions;\n","var LocationActions = require('../actions/LocationActions');\n\n/**\n * A scroll behavior that attempts to imitate the default behavior\n * of modern browsers.\n */\nvar ImitateBrowserBehavior = {\n\n  updateScrollPosition: function (position, actionType) {\n    switch (actionType) {\n      case LocationActions.PUSH:\n      case LocationActions.REPLACE:\n        window.scrollTo(0, 0);\n        break;\n      case LocationActions.POP:\n        if (position) {\n          window.scrollTo(position.x, position.y);\n        } else {\n          window.scrollTo(0, 0);\n        }\n        break;\n    }\n  }\n\n};\n\nmodule.exports = ImitateBrowserBehavior;\n","/**\n * A scroll behavior that always scrolls to the top of the page\n * after a transition.\n */\nvar ScrollToTopBehavior = {\n\n  updateScrollPosition: function () {\n    window.scrollTo(0, 0);\n  }\n\n};\n\nmodule.exports = ScrollToTopBehavior;\n","var React = require('react');\nvar FakeNode = require('../mixins/FakeNode');\nvar PropTypes = require('../utils/PropTypes');\n\n/**\n * A <DefaultRoute> component is a special kind of <Route> that\n * renders when its parent matches but none of its siblings do.\n * Only one such route may be used at any given level in the\n * route hierarchy.\n */\nvar DefaultRoute = React.createClass({\n\n  displayName: 'DefaultRoute',\n\n  mixins: [ FakeNode ],\n\n  propTypes: {\n    name: React.PropTypes.string,\n    path: PropTypes.falsy,\n    handler: React.PropTypes.func.isRequired\n  }\n\n});\n\nmodule.exports = DefaultRoute;\n","var React = require('react');\nvar classSet = require('react/lib/cx');\nvar assign = require('react/lib/Object.assign');\nvar Navigation = require('../mixins/Navigation');\nvar State = require('../mixins/State');\n\nfunction isLeftClickEvent(event) {\n  return event.button === 0;\n}\n\nfunction isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\n\n/**\n * <Link> components are used to create an <a> element that links to a route.\n * When that route is active, the link gets an \"active\" class name (or the\n * value of its `activeClassName` prop).\n *\n * For example, assuming you have the following route:\n *\n *   <Route name=\"showPost\" path=\"/posts/:postID\" handler={Post}/>\n *\n * You could use the following component to link to that route:\n *\n *   <Link to=\"showPost\" params={{ postID: \"123\" }} />\n *\n * In addition to params, links may pass along query string parameters\n * using the `query` prop.\n *\n *   <Link to=\"showPost\" params={{ postID: \"123\" }} query={{ show:true }}/>\n */\nvar Link = React.createClass({\n\n  displayName: 'Link',\n\n  mixins: [ Navigation, State ],\n\n  propTypes: {\n    activeClassName: React.PropTypes.string.isRequired,\n    to: React.PropTypes.string.isRequired,\n    params: React.PropTypes.object,\n    query: React.PropTypes.object,\n    onClick: React.PropTypes.func\n  },\n\n  getDefaultProps: function () {\n    return {\n      activeClassName: 'active'\n    };\n  },\n\n  handleClick: function (event) {\n    var allowTransition = true;\n    var clickResult;\n\n    if (this.props.onClick)\n      clickResult = this.props.onClick(event);\n\n    if (isModifiedEvent(event) || !isLeftClickEvent(event))\n      return;\n\n    if (clickResult === false || event.defaultPrevented === true)\n      allowTransition = false;\n\n    event.preventDefault();\n\n    if (allowTransition)\n      this.transitionTo(this.props.to, this.props.params, this.props.query);\n  },\n\n  /**\n   * Returns the value of the \"href\" attribute to use on the DOM element.\n   */\n  getHref: function () {\n    return this.makeHref(this.props.to, this.props.params, this.props.query);\n  },\n\n  /**\n   * Returns the value of the \"class\" attribute to use on the DOM element, which contains\n   * the value of the activeClassName property when this <Link> is active.\n   */\n  getClassName: function () {\n    var classNames = {};\n\n    if (this.props.className)\n      classNames[this.props.className] = true;\n\n    if (this.isActive(this.props.to, this.props.params, this.props.query))\n      classNames[this.props.activeClassName] = true;\n\n    return classSet(classNames);\n  },\n\n  render: function () {\n    var props = assign({}, this.props, {\n      href: this.getHref(),\n      className: this.getClassName(),\n      onClick: this.handleClick\n    });\n\n    return React.DOM.a(props, this.props.children);\n  }\n\n});\n\nmodule.exports = Link;\n","var React = require('react');\nvar FakeNode = require('../mixins/FakeNode');\nvar PropTypes = require('../utils/PropTypes');\n\n/**\n * A <NotFoundRoute> is a special kind of <Route> that\n * renders when the beginning of its parent's path matches\n * but none of its siblings do, including any <DefaultRoute>.\n * Only one such route may be used at any given level in the\n * route hierarchy.\n */\nvar NotFoundRoute = React.createClass({\n\n  displayName: 'NotFoundRoute',\n\n  mixins: [ FakeNode ],\n\n  propTypes: {\n    name: React.PropTypes.string,\n    path: PropTypes.falsy,\n    handler: React.PropTypes.func.isRequired\n  }\n\n});\n\nmodule.exports = NotFoundRoute;\n","var React = require('react');\nvar FakeNode = require('../mixins/FakeNode');\nvar PropTypes = require('../utils/PropTypes');\n\n/**\n * A <Redirect> component is a special kind of <Route> that always\n * redirects to another route when it matches.\n */\nvar Redirect = React.createClass({\n\n  displayName: 'Redirect',\n\n  mixins: [ FakeNode ],\n\n  propTypes: {\n    path: React.PropTypes.string,\n    from: React.PropTypes.string, // Alias for path.\n    to: React.PropTypes.string,\n    handler: PropTypes.falsy\n  }\n\n});\n\nmodule.exports = Redirect;\n","var React = require('react');\nvar FakeNode = require('../mixins/FakeNode');\n\n/**\n * <Route> components specify components that are rendered to the page when the\n * URL matches a given pattern.\n *\n * Routes are arranged in a nested tree structure. When a new URL is requested,\n * the tree is searched depth-first to find a route whose path matches the URL.\n * When one is found, all routes in the tree that lead to it are considered\n * \"active\" and their components are rendered into the DOM, nested in the same\n * order as they are in the tree.\n *\n * The preferred way to configure a router is using JSX. The XML-like syntax is\n * a great way to visualize how routes are laid out in an application.\n *\n *   var routes = [\n *     <Route handler={App}>\n *       <Route name=\"login\" handler={Login}/>\n *       <Route name=\"logout\" handler={Logout}/>\n *       <Route name=\"about\" handler={About}/>\n *     </Route>\n *   ];\n *   \n *   Router.run(routes, function (Handler) {\n *     React.render(<Handler/>, document.body);\n *   });\n *\n * Handlers for Route components that contain children can render their active\n * child route using a <RouteHandler> element.\n *\n *   var App = React.createClass({\n *     render: function () {\n *       return (\n *         <div class=\"application\">\n *           <RouteHandler/>\n *         </div>\n *       );\n *     }\n *   });\n */\nvar Route = React.createClass({\n\n  displayName: 'Route',\n\n  mixins: [ FakeNode ],\n\n  propTypes: {\n    name: React.PropTypes.string,\n    path: React.PropTypes.string,\n    handler: React.PropTypes.func.isRequired,\n    ignoreScrollBehavior: React.PropTypes.bool\n  }\n\n});\n\nmodule.exports = Route;\n","var React = require('react');\nvar RouteHandlerMixin = require('../mixins/RouteHandler');\n\n/**\n * A <RouteHandler> component renders the active child route handler\n * when routes are nested.\n */\nvar RouteHandler = React.createClass({\n\n  displayName: 'RouteHandler',\n\n  mixins: [RouteHandlerMixin],\n\n  getDefaultProps: function () {\n    return {\n      ref: '__routeHandler__'\n    };\n  },\n\n  render: function () {\n    return this.getRouteHandler();\n  }\n\n});\n\nmodule.exports = RouteHandler;\n","exports.DefaultRoute = require('./components/DefaultRoute');\nexports.Link = require('./components/Link');\nexports.NotFoundRoute = require('./components/NotFoundRoute');\nexports.Redirect = require('./components/Redirect');\nexports.Route = require('./components/Route');\nexports.RouteHandler = require('./components/RouteHandler');\n\nexports.HashLocation = require('./locations/HashLocation');\nexports.HistoryLocation = require('./locations/HistoryLocation');\nexports.RefreshLocation = require('./locations/RefreshLocation');\n\nexports.ImitateBrowserBehavior = require('./behaviors/ImitateBrowserBehavior');\nexports.ScrollToTopBehavior = require('./behaviors/ScrollToTopBehavior');\n\nexports.Navigation = require('./mixins/Navigation');\nexports.State = require('./mixins/State');\n\nexports.create = require('./utils/createRouter');\nexports.run = require('./utils/runRouter');\n\nexports.History = require('./utils/History');\n","var LocationActions = require('../actions/LocationActions');\nvar History = require('../utils/History');\nvar Path = require('../utils/Path');\n\n/**\n * Returns the current URL path from the `hash` portion of the URL, including\n * query string.\n */\nfunction getHashPath() {\n  return Path.decode(\n    // We can't use window.location.hash here because it's not\n    // consistent across browsers - Firefox will pre-decode it!\n    window.location.href.split('#')[1] || ''\n  );\n}\n\nvar _actionType;\n\nfunction ensureSlash() {\n  var path = getHashPath();\n\n  if (path.charAt(0) === '/')\n    return true;\n\n  HashLocation.replace('/' + path);\n\n  return false;\n}\n\nvar _changeListeners = [];\n\nfunction notifyChange(type) {\n  if (type === LocationActions.PUSH)\n    History.length += 1;\n\n  var change = {\n    path: getHashPath(),\n    type: type\n  };\n\n  _changeListeners.forEach(function (listener) {\n    listener(change);\n  });\n}\n\nvar _isListening = false;\n\nfunction onHashChange() {\n  if (ensureSlash()) {\n    // If we don't have an _actionType then all we know is the hash\n    // changed. It was probably caused by the user clicking the Back\n    // button, but may have also been the Forward button or manual\n    // manipulation. So just guess 'pop'.\n    notifyChange(_actionType || LocationActions.POP);\n    _actionType = null;\n  }\n}\n\n/**\n * A Location that uses `window.location.hash`.\n */\nvar HashLocation = {\n\n  addChangeListener: function (listener) {\n    _changeListeners.push(listener);\n\n    // Do this BEFORE listening for hashchange.\n    ensureSlash();\n\n    if (_isListening)\n      return;\n\n    if (window.addEventListener) {\n      window.addEventListener('hashchange', onHashChange, false);\n    } else {\n      window.attachEvent('onhashchange', onHashChange);\n    }\n\n    _isListening = true;\n  },\n\n  removeChangeListener: function(listener) {\n    for (var i = 0, l = _changeListeners.length; i < l; i ++) {\n      if (_changeListeners[i] === listener) {\n        _changeListeners.splice(i, 1);\n        break;\n      }\n    }\n\n    if (window.removeEventListener) {\n      window.removeEventListener('hashchange', onHashChange, false);\n    } else {\n      window.removeEvent('onhashchange', onHashChange);\n    }\n\n    if (_changeListeners.length === 0)\n      _isListening = false;\n  },\n\n\n\n  push: function (path) {\n    _actionType = LocationActions.PUSH;\n    window.location.hash = Path.encode(path);\n  },\n\n  replace: function (path) {\n    _actionType = LocationActions.REPLACE;\n    window.location.replace(window.location.pathname + '#' + Path.encode(path));\n  },\n\n  pop: function () {\n    _actionType = LocationActions.POP;\n    History.back();\n  },\n\n  getCurrentPath: getHashPath,\n\n  toString: function () {\n    return '<HashLocation>';\n  }\n\n};\n\nmodule.exports = HashLocation;\n","var LocationActions = require('../actions/LocationActions');\nvar History = require('../utils/History');\nvar Path = require('../utils/Path');\n\n/**\n * Returns the current URL path from `window.location`, including query string.\n */\nfunction getWindowPath() {\n  return Path.decode(\n    window.location.pathname + window.location.search\n  );\n}\n\nvar _changeListeners = [];\n\nfunction notifyChange(type) {\n  var change = {\n    path: getWindowPath(),\n    type: type\n  };\n\n  _changeListeners.forEach(function (listener) {\n    listener(change);\n  });\n}\n\nvar _isListening = false;\n\nfunction onPopState() {\n  notifyChange(LocationActions.POP);\n}\n\n/**\n * A Location that uses HTML5 history.\n */\nvar HistoryLocation = {\n\n  addChangeListener: function (listener) {\n    _changeListeners.push(listener);\n\n    if (_isListening)\n      return;\n\n    if (window.addEventListener) {\n      window.addEventListener('popstate', onPopState, false);\n    } else {\n      window.attachEvent('popstate', onPopState);\n    }\n\n    _isListening = true;\n  },\n\n  removeChangeListener: function(listener) {\n    for (var i = 0, l = _changeListeners.length; i < l; i ++) {\n      if (_changeListeners[i] === listener) {\n        _changeListeners.splice(i, 1);\n        break;\n      }\n    }\n\n    if (window.addEventListener) {\n      window.removeEventListener('popstate', onPopState);\n    } else {\n      window.removeEvent('popstate', onPopState);\n    }\n\n    if (_changeListeners.length === 0)\n      _isListening = false;\n  },\n\n\n\n  push: function (path) {\n    window.history.pushState({ path: path }, '', Path.encode(path));\n    History.length += 1;\n    notifyChange(LocationActions.PUSH);\n  },\n\n  replace: function (path) {\n    window.history.replaceState({ path: path }, '', Path.encode(path));\n    notifyChange(LocationActions.REPLACE);\n  },\n\n  pop: History.back,\n\n  getCurrentPath: getWindowPath,\n\n  toString: function () {\n    return '<HistoryLocation>';\n  }\n\n};\n\nmodule.exports = HistoryLocation;\n","var HistoryLocation = require('./HistoryLocation');\nvar History = require('../utils/History');\nvar Path = require('../utils/Path');\n\n/**\n * A Location that uses full page refreshes. This is used as\n * the fallback for HistoryLocation in browsers that do not\n * support the HTML5 history API.\n */\nvar RefreshLocation = {\n\n  push: function (path) {\n    window.location = Path.encode(path);\n  },\n\n  replace: function (path) {\n    window.location.replace(Path.encode(path));\n  },\n\n  pop: History.back,\n\n  getCurrentPath: HistoryLocation.getCurrentPath,\n\n  toString: function () {\n    return '<RefreshLocation>';\n  }\n\n};\n\nmodule.exports = RefreshLocation;\n","var invariant = require('react/lib/invariant');\n\nvar FakeNode = {\n\n  render: function () {\n    invariant(\n      false,\n      '%s elements should not be rendered',\n      this.constructor.displayName\n    );\n  }\n\n};\n\nmodule.exports = FakeNode;\n","var React = require('react');\n\n/**\n * A mixin for components that modify the URL.\n *\n * Example:\n *\n *   var MyLink = React.createClass({\n *     mixins: [ Router.Navigation ],\n *     handleClick: function (event) {\n *       event.preventDefault();\n *       this.transitionTo('aRoute', { the: 'params' }, { the: 'query' });\n *     },\n *     render: function () {\n *       return (\n *         <a onClick={this.handleClick}>Click me!</a>\n *       );\n *     }\n *   });\n */\nvar Navigation = {\n\n  contextTypes: {\n    makePath: React.PropTypes.func.isRequired,\n    makeHref: React.PropTypes.func.isRequired,\n    transitionTo: React.PropTypes.func.isRequired,\n    replaceWith: React.PropTypes.func.isRequired,\n    goBack: React.PropTypes.func.isRequired\n  },\n\n  /**\n   * Returns an absolute URL path created from the given route\n   * name, URL parameters, and query values.\n   */\n  makePath: function (to, params, query) {\n    return this.context.makePath(to, params, query);\n  },\n\n  /**\n   * Returns a string that may safely be used as the href of a\n   * link to the route with the given name.\n   */\n  makeHref: function (to, params, query) {\n    return this.context.makeHref(to, params, query);\n  },\n\n  /**\n   * Transitions to the URL specified in the arguments by pushing\n   * a new URL onto the history stack.\n   */\n  transitionTo: function (to, params, query) {\n    this.context.transitionTo(to, params, query);\n  },\n\n  /**\n   * Transitions to the URL specified in the arguments by replacing\n   * the current URL in the history stack.\n   */\n  replaceWith: function (to, params, query) {\n    this.context.replaceWith(to, params, query);\n  },\n\n  /**\n   * Transitions to the previous URL.\n   */\n  goBack: function () {\n    this.context.goBack();\n  }\n\n};\n\nmodule.exports = Navigation;\n","var React = require('react');\n\n/**\n * Provides the router with context for Router.Navigation.\n */\nvar NavigationContext = {\n\n  childContextTypes: {\n    makePath: React.PropTypes.func.isRequired,\n    makeHref: React.PropTypes.func.isRequired,\n    transitionTo: React.PropTypes.func.isRequired,\n    replaceWith: React.PropTypes.func.isRequired,\n    goBack: React.PropTypes.func.isRequired\n  },\n\n  getChildContext: function () {\n    return {\n      makePath: this.constructor.makePath,\n      makeHref: this.constructor.makeHref,\n      transitionTo: this.constructor.transitionTo,\n      replaceWith: this.constructor.replaceWith,\n      goBack: this.constructor.goBack\n    };\n  }\n\n};\n\nmodule.exports = NavigationContext;\n","var React = require('react');\n\nmodule.exports = {\n  contextTypes: {\n    getRouteAtDepth: React.PropTypes.func.isRequired,\n    getRouteComponents: React.PropTypes.func.isRequired,\n    routeHandlers: React.PropTypes.array.isRequired\n  },\n\n  childContextTypes: {\n    routeHandlers: React.PropTypes.array.isRequired\n  },\n\n  getChildContext: function () {\n    return {\n      routeHandlers: this.context.routeHandlers.concat([ this ])\n    };\n  },\n\n  getRouteDepth: function () {\n    return this.context.routeHandlers.length - 1;\n  },\n\n  componentDidMount: function () {\n    this._updateRouteComponent();\n  },\n\n  componentDidUpdate: function () {\n    this._updateRouteComponent();\n  },\n\n  _updateRouteComponent: function () {\n    var depth = this.getRouteDepth();\n    var components = this.context.getRouteComponents();\n    components[depth] = this.refs[this.props.ref || '__routeHandler__'];\n  },\n\n  getRouteHandler: function (props) {\n    var route = this.context.getRouteAtDepth(this.getRouteDepth());\n    return route ? React.createElement(route.handler, props || this.props) : null;\n  }\n};","var invariant = require('react/lib/invariant');\nvar canUseDOM = require('react/lib/ExecutionEnvironment').canUseDOM;\nvar getWindowScrollPosition = require('../utils/getWindowScrollPosition');\n\nfunction shouldUpdateScroll(state, prevState) {\n  if (!prevState)\n    return true;\n\n  // Don't update scroll position when only the query has changed.\n  if (state.pathname === prevState.pathname)\n    return false;\n\n  var routes = state.routes;\n  var prevRoutes = prevState.routes;\n\n  var sharedAncestorRoutes = routes.filter(function (route) {\n    return prevRoutes.indexOf(route) !== -1;\n  });\n\n  return !sharedAncestorRoutes.some(function (route) {\n    return route.ignoreScrollBehavior;\n  });\n}\n\n/**\n * Provides the router with the ability to manage window scroll position\n * according to its scroll behavior.\n */\nvar Scrolling = {\n\n  statics: {\n    /**\n     * Records curent scroll position as the last known position for the given URL path.\n     */\n    recordScrollPosition: function (path) {\n      if (!this.scrollHistory)\n        this.scrollHistory = {};\n\n      this.scrollHistory[path] = getWindowScrollPosition();\n    },\n\n    /**\n     * Returns the last known scroll position for the given URL path.\n     */\n    getScrollPosition: function (path) {\n      if (!this.scrollHistory)\n        this.scrollHistory = {};\n\n      return this.scrollHistory[path] || null;\n    }\n  },\n\n  componentWillMount: function () {\n    invariant(\n      this.getScrollBehavior() == null || canUseDOM,\n      'Cannot use scroll behavior without a DOM'\n    );\n  },\n\n  componentDidMount: function () {\n    this._updateScroll();\n  },\n\n  componentDidUpdate: function (prevProps, prevState) {\n    this._updateScroll(prevState);\n  },\n\n  _updateScroll: function (prevState) {\n    if (!shouldUpdateScroll(this.state, prevState))\n      return;\n\n    var scrollBehavior = this.getScrollBehavior();\n\n    if (scrollBehavior)\n      scrollBehavior.updateScrollPosition(\n        this.constructor.getScrollPosition(this.state.path),\n        this.state.action\n      );\n  }\n\n};\n\nmodule.exports = Scrolling;\n","var React = require('react');\n\n/**\n * A mixin for components that need to know the path, routes, URL\n * params and query that are currently active.\n *\n * Example:\n *\n *   var AboutLink = React.createClass({\n *     mixins: [ Router.State ],\n *     render: function () {\n *       var className = this.props.className;\n *   \n *       if (this.isActive('about'))\n *         className += ' is-active';\n *   \n *       return React.DOM.a({ className: className }, this.props.children);\n *     }\n *   });\n */\nvar State = {\n\n  contextTypes: {\n    getCurrentPath: React.PropTypes.func.isRequired,\n    getCurrentRoutes: React.PropTypes.func.isRequired,\n    getCurrentPathname: React.PropTypes.func.isRequired,\n    getCurrentParams: React.PropTypes.func.isRequired,\n    getCurrentQuery: React.PropTypes.func.isRequired,\n    isActive: React.PropTypes.func.isRequired\n  },\n\n  /**\n   * Returns the current URL path.\n   */\n  getPath: function () {\n    return this.context.getCurrentPath();\n  },\n\n  /**\n   * Returns an array of the routes that are currently active.\n   */\n  getRoutes: function () {\n    return this.context.getCurrentRoutes();\n  },\n\n  /**\n   * Returns the current URL path without the query string.\n   */\n  getPathname: function () {\n    return this.context.getCurrentPathname();\n  },\n\n  /**\n   * Returns an object of the URL params that are currently active.\n   */\n  getParams: function () {\n    return this.context.getCurrentParams();\n  },\n\n  /**\n   * Returns an object of the query params that are currently active.\n   */\n  getQuery: function () {\n    return this.context.getCurrentQuery();\n  },\n\n  /**\n   * A helper method to determine if a given route, params, and query\n   * are active.\n   */\n  isActive: function (to, params, query) {\n    return this.context.isActive(to, params, query);\n  }\n\n};\n\nmodule.exports = State;\n","var React = require('react');\nvar assign = require('react/lib/Object.assign');\nvar Path = require('../utils/Path');\n\nfunction routeIsActive(activeRoutes, routeName) {\n  return activeRoutes.some(function (route) {\n    return route.name === routeName;\n  });\n}\n\nfunction paramsAreActive(activeParams, params) {\n  for (var property in params)\n    if (String(activeParams[property]) !== String(params[property]))\n      return false;\n\n  return true;\n}\n\nfunction queryIsActive(activeQuery, query) {\n  for (var property in query)\n    if (String(activeQuery[property]) !== String(query[property]))\n      return false;\n\n  return true;\n}\n\n/**\n * Provides the router with context for Router.State.\n */\nvar StateContext = {\n\n  /**\n   * Returns the current URL path + query string.\n   */\n  getCurrentPath: function () {\n    return this.state.path;\n  },\n\n  /**\n   * Returns a read-only array of the currently active routes.\n   */\n  getCurrentRoutes: function () {\n    return this.state.routes.slice(0);\n  },\n\n  /**\n   * Returns the current URL path without the query string.\n   */\n  getCurrentPathname: function () {\n    return this.state.pathname;\n  },\n\n  /**\n   * Returns a read-only object of the currently active URL parameters.\n   */\n  getCurrentParams: function () {\n    return assign({}, this.state.params);\n  },\n\n  /**\n   * Returns a read-only object of the currently active query parameters.\n   */\n  getCurrentQuery: function () {\n    return assign({}, this.state.query);\n  },\n\n  /**\n   * Returns true if the given route, params, and query are active.\n   */\n  isActive: function (to, params, query) {\n    if (Path.isAbsolute(to))\n      return to === this.state.path;\n\n    return routeIsActive(this.state.routes, to) &&\n      paramsAreActive(this.state.params, params) &&\n      (query == null || queryIsActive(this.state.query, query));\n  },\n\n  childContextTypes: {\n    getCurrentPath: React.PropTypes.func.isRequired,\n    getCurrentRoutes: React.PropTypes.func.isRequired,\n    getCurrentPathname: React.PropTypes.func.isRequired,\n    getCurrentParams: React.PropTypes.func.isRequired,\n    getCurrentQuery: React.PropTypes.func.isRequired,\n    isActive: React.PropTypes.func.isRequired\n  },\n\n  getChildContext: function () {\n    return {\n      getCurrentPath: this.getCurrentPath,\n      getCurrentRoutes: this.getCurrentRoutes,\n      getCurrentPathname: this.getCurrentPathname,\n      getCurrentParams: this.getCurrentParams,\n      getCurrentQuery: this.getCurrentQuery,\n      isActive: this.isActive\n    };\n  }\n\n};\n\nmodule.exports = StateContext;\n","/**\n * Represents a cancellation caused by navigating away\n * before the previous transition has fully resolved.\n */\nfunction Cancellation() { }\n\nmodule.exports = Cancellation;\n","var invariant = require('react/lib/invariant');\nvar canUseDOM = require('react/lib/ExecutionEnvironment').canUseDOM;\n\nvar History = {\n\n  /**\n   * Sends the browser back one entry in the history.\n   */\n  back: function () {\n    invariant(\n      canUseDOM,\n      'Cannot use History.back without a DOM'\n    );\n\n    // Do this first so that History.length will\n    // be accurate in location change listeners.\n    History.length -= 1;\n\n    window.history.back();\n  },\n\n  /**\n   * The current number of entries in the history.\n   */\n  length: 1\n\n};\n\nmodule.exports = History;\n","var invariant = require('react/lib/invariant');\nvar merge = require('qs/lib/utils').merge;\nvar qs = require('qs');\n\nvar paramCompileMatcher = /:([a-zA-Z_$][a-zA-Z0-9_$]*)|[*.()\\[\\]\\\\+|{}^$]/g;\nvar paramInjectMatcher = /:([a-zA-Z_$][a-zA-Z0-9_$?]*[?]?)|[*]/g;\nvar paramInjectTrailingSlashMatcher = /\\/\\/\\?|\\/\\?/g;\nvar queryMatcher = /\\?(.+)/;\n\nvar _compiledPatterns = {};\n\nfunction compilePattern(pattern) {\n  if (!(pattern in _compiledPatterns)) {\n    var paramNames = [];\n    var source = pattern.replace(paramCompileMatcher, function (match, paramName) {\n      if (paramName) {\n        paramNames.push(paramName);\n        return '([^/?#]+)';\n      } else if (match === '*') {\n        paramNames.push('splat');\n        return '(.*?)';\n      } else {\n        return '\\\\' + match;\n      }\n    });\n\n    _compiledPatterns[pattern] = {\n      matcher: new RegExp('^' + source + '$', 'i'),\n      paramNames: paramNames\n    };\n  }\n\n  return _compiledPatterns[pattern];\n}\n\nvar Path = {\n\n  /**\n   * Safely decodes special characters in the given URL path.\n   */\n  decode: function (path) {\n    return decodeURI(path.replace(/\\+/g, ' '));\n  },\n\n  /**\n   * Safely encodes special characters in the given URL path.\n   */\n  encode: function (path) {\n    return encodeURI(path).replace(/%20/g, '+');\n  },\n\n  /**\n   * Returns an array of the names of all parameters in the given pattern.\n   */\n  extractParamNames: function (pattern) {\n    return compilePattern(pattern).paramNames;\n  },\n\n  /**\n   * Extracts the portions of the given URL path that match the given pattern\n   * and returns an object of param name => value pairs. Returns null if the\n   * pattern does not match the given path.\n   */\n  extractParams: function (pattern, path) {\n    var object = compilePattern(pattern);\n    var match = path.match(object.matcher);\n\n    if (!match)\n      return null;\n\n    var params = {};\n\n    object.paramNames.forEach(function (paramName, index) {\n      params[paramName] = match[index + 1];\n    });\n\n    return params;\n  },\n\n  /**\n   * Returns a version of the given route path with params interpolated. Throws\n   * if there is a dynamic segment of the route path for which there is no param.\n   */\n  injectParams: function (pattern, params) {\n    params = params || {};\n\n    var splatIndex = 0;\n\n    return pattern.replace(paramInjectMatcher, function (match, paramName) {\n      paramName = paramName || 'splat';\n\n      // If param is optional don't check for existence\n      if (paramName.slice(-1) !== '?') {\n        invariant(\n          params[paramName] != null,\n          'Missing \"' + paramName + '\" parameter for path \"' + pattern + '\"'\n        );\n      } else {\n        paramName = paramName.slice(0, -1);\n\n        if (params[paramName] == null)\n          return '';\n      }\n\n      var segment;\n      if (paramName === 'splat' && Array.isArray(params[paramName])) {\n        segment = params[paramName][splatIndex++];\n\n        invariant(\n          segment != null,\n          'Missing splat # ' + splatIndex + ' for path \"' + pattern + '\"'\n        );\n      } else {\n        segment = params[paramName];\n      }\n\n      return segment;\n    }).replace(paramInjectTrailingSlashMatcher, '/');\n  },\n\n  /**\n   * Returns an object that is the result of parsing any query string contained\n   * in the given path, null if the path contains no query string.\n   */\n  extractQuery: function (path) {\n    var match = path.match(queryMatcher);\n    return match && qs.parse(match[1]);\n  },\n\n  /**\n   * Returns a version of the given path without the query string.\n   */\n  withoutQuery: function (path) {\n    return path.replace(queryMatcher, '');\n  },\n\n  /**\n   * Returns a version of the given path with the parameters in the given\n   * query merged into the query string.\n   */\n  withQuery: function (path, query) {\n    var existingQuery = Path.extractQuery(path);\n\n    if (existingQuery)\n      query = query ? merge(existingQuery, query) : existingQuery;\n\n    var queryString = query && qs.stringify(query);\n\n    if (queryString)\n      return Path.withoutQuery(path) + '?' + queryString;\n\n    return path;\n  },\n\n  /**\n   * Returns true if the given path is absolute.\n   */\n  isAbsolute: function (path) {\n    return path.charAt(0) === '/';\n  },\n\n  /**\n   * Returns a normalized version of the given path.\n   */\n  normalize: function (path, parentRoute) {\n    return path.replace(/^\\/*/, '/');\n  },\n\n  /**\n   * Joins two URL paths together.\n   */\n  join: function (a, b) {\n    return a.replace(/\\/*$/, '/') + b;\n  }\n\n};\n\nmodule.exports = Path;\n","var Promise = require('when/lib/Promise');\n\n// TODO: Use process.env.NODE_ENV check + envify to enable\n// when's promise monitor here when in dev.\n\nmodule.exports = Promise;\n","var PropTypes = {\n\n  /**\n   * Requires that the value of a prop be falsy.\n   */\n  falsy: function (props, propName, componentName) {\n    if (props[propName])\n      return new Error('<' + componentName + '> may not have a \"' + propName + '\" prop');\n  }\n\n};\n\nmodule.exports = PropTypes;\n","/**\n * Encapsulates a redirect to the given route.\n */\nfunction Redirect(to, params, query) {\n  this.to = to;\n  this.params = params;\n  this.query = query;\n}\n\nmodule.exports = Redirect;\n","var assign = require('react/lib/Object.assign');\nvar reversedArray = require('./reversedArray');\nvar Redirect = require('./Redirect');\nvar Promise = require('./Promise');\n\n/**\n * Runs all hook functions serially and calls callback(error) when finished.\n * A hook may return a promise if it needs to execute asynchronously.\n */\nfunction runHooks(hooks, callback) {\n  var promise;\n  try {\n    promise = hooks.reduce(function (promise, hook) {\n      // The first hook to use transition.wait makes the rest\n      // of the transition async from that point forward.\n      return promise ? promise.then(hook) : hook();\n    }, null);\n  } catch (error) {\n    return callback(error); // Sync error.\n  }\n\n  if (promise) {\n    // Use setTimeout to break the promise chain.\n    promise.then(function () {\n      setTimeout(callback);\n    }, function (error) {\n      setTimeout(function () {\n        callback(error);\n      });\n    });\n  } else {\n    callback();\n  }\n}\n\n/**\n * Calls the willTransitionFrom hook of all handlers in the given matches\n * serially in reverse with the transition object and the current instance of\n * the route's handler, so that the deepest nested handlers are called first.\n * Calls callback(error) when finished.\n */\nfunction runTransitionFromHooks(transition, routes, components, callback) {\n  components = reversedArray(components);\n\n  var hooks = reversedArray(routes).map(function (route, index) {\n    return function () {\n      var handler = route.handler;\n\n      if (!transition.isAborted && handler.willTransitionFrom)\n        return handler.willTransitionFrom(transition, components[index]);\n\n      var promise = transition._promise;\n      transition._promise = null;\n\n      return promise;\n    };\n  });\n\n  runHooks(hooks, callback);\n}\n\n/**\n * Calls the willTransitionTo hook of all handlers in the given matches\n * serially with the transition object and any params that apply to that\n * handler. Calls callback(error) when finished.\n */\nfunction runTransitionToHooks(transition, routes, params, query, callback) {\n  var hooks = routes.map(function (route) {\n    return function () {\n      var handler = route.handler;\n\n      if (!transition.isAborted && handler.willTransitionTo)\n        handler.willTransitionTo(transition, params, query);\n\n      var promise = transition._promise;\n      transition._promise = null;\n\n      return promise;\n    };\n  });\n\n  runHooks(hooks, callback);\n}\n\n/**\n * Encapsulates a transition to a given path.\n *\n * The willTransitionTo and willTransitionFrom handlers receive\n * an instance of this class as their first argument.\n */\nfunction Transition(path, retry) {\n  this.path = path;\n  this.abortReason = null;\n  this.isAborted = false;\n  this.retry = retry.bind(this);\n  this._promise = null;\n}\n\nassign(Transition.prototype, {\n\n  abort: function (reason) {\n    if (this.isAborted) {\n      // First abort wins.\n      return;\n    }\n\n    this.abortReason = reason;\n    this.isAborted = true;\n  },\n\n  redirect: function (to, params, query) {\n    this.abort(new Redirect(to, params, query));\n  },\n\n  wait: function (value) {\n    this._promise = Promise.resolve(value);\n  },\n\n  from: function (routes, components, callback) {\n    return runTransitionFromHooks(this, routes, components, callback);\n  },\n\n  to: function (routes, params, query, callback) {\n    return runTransitionToHooks(this, routes, params, query, callback);\n  }\n\n});\n\nmodule.exports = Transition;\n","/* jshint -W058 */\nvar React = require('react');\nvar warning = require('react/lib/warning');\nvar invariant = require('react/lib/invariant');\nvar canUseDOM = require('react/lib/ExecutionEnvironment').canUseDOM;\nvar ImitateBrowserBehavior = require('../behaviors/ImitateBrowserBehavior');\nvar RouteHandler = require('../components/RouteHandler');\nvar LocationActions = require('../actions/LocationActions');\nvar HashLocation = require('../locations/HashLocation');\nvar HistoryLocation = require('../locations/HistoryLocation');\nvar RefreshLocation = require('../locations/RefreshLocation');\nvar NavigationContext = require('../mixins/NavigationContext');\nvar StateContext = require('../mixins/StateContext');\nvar Scrolling = require('../mixins/Scrolling');\nvar createRoutesFromChildren = require('./createRoutesFromChildren');\nvar supportsHistory = require('./supportsHistory');\nvar Transition = require('./Transition');\nvar PropTypes = require('./PropTypes');\nvar Redirect = require('./Redirect');\nvar History = require('./History');\nvar Cancellation = require('./Cancellation');\nvar Path = require('./Path');\n\n/**\n * The default location for new routers.\n */\nvar DEFAULT_LOCATION = canUseDOM ? HashLocation : '/';\n\n/**\n * The default scroll behavior for new routers.\n */\nvar DEFAULT_SCROLL_BEHAVIOR = canUseDOM ? ImitateBrowserBehavior : null;\n\n/**\n * The default error handler for new routers.\n */\nfunction defaultErrorHandler(error) {\n  // Throw so we don't silently swallow async errors.\n  throw error; // This error probably originated in a transition hook.\n}\n\n/**\n * The default aborted transition handler for new routers.\n */\nfunction defaultAbortHandler(abortReason, location) {\n  if (typeof location === 'string')\n    throw new Error('Unhandled aborted transition! Reason: ' + abortReason);\n\n  if (abortReason instanceof Cancellation) {\n    return;\n  } else if (abortReason instanceof Redirect) {\n    location.replace(this.makePath(abortReason.to, abortReason.params, abortReason.query));\n  } else {\n    location.pop();\n  }\n}\n\nfunction findMatch(pathname, routes, defaultRoute, notFoundRoute) {\n  var match, route, params;\n\n  for (var i = 0, len = routes.length; i < len; ++i) {\n    route = routes[i];\n\n    // Check the subtree first to find the most deeply-nested match.\n    match = findMatch(pathname, route.childRoutes, route.defaultRoute, route.notFoundRoute);\n\n    if (match != null) {\n      match.routes.unshift(route);\n      return match;\n    }\n\n    // No routes in the subtree matched, so check this route.\n    params = Path.extractParams(route.path, pathname);\n\n    if (params)\n      return createMatch(route, params);\n  }\n\n  // No routes matched, so try the default route if there is one.\n  if (defaultRoute && (params = Path.extractParams(defaultRoute.path, pathname)))\n    return createMatch(defaultRoute, params);\n\n  // Last attempt: does the \"not found\" route match?\n  if (notFoundRoute && (params = Path.extractParams(notFoundRoute.path, pathname)))\n    return createMatch(notFoundRoute, params);\n\n  return match;\n}\n\nfunction createMatch(route, params) {\n  return { routes: [ route ], params: params };\n}\n\nfunction hasProperties(object, properties) {\n  for (var propertyName in properties)\n    if (properties.hasOwnProperty(propertyName) && object[propertyName] !== properties[propertyName])\n      return false;\n\n  return true;\n}\n\nfunction hasMatch(routes, route, prevParams, nextParams, prevQuery, nextQuery) {\n  return routes.some(function (r) {\n    if (r !== route)\n      return false;\n\n    var paramNames = route.paramNames;\n    var paramName;\n\n    // Ensure that all params the route cares about did not change.\n    for (var i = 0, len = paramNames.length; i < len; ++i) {\n      paramName = paramNames[i];\n\n      if (nextParams[paramName] !== prevParams[paramName])\n        return false;\n    }\n\n    // Ensure the query hasn't changed.\n    return hasProperties(prevQuery, nextQuery) && hasProperties(nextQuery, prevQuery);\n  });\n}\n\n/**\n * Creates and returns a new router using the given options. A router\n * is a ReactComponent class that knows how to react to changes in the\n * URL and keep the contents of the page in sync.\n *\n * Options may be any of the following:\n *\n * - routes           (required) The route config\n * - location         The location to use. Defaults to HashLocation when\n *                    the DOM is available, \"/\" otherwise\n * - scrollBehavior   The scroll behavior to use. Defaults to ImitateBrowserBehavior\n *                    when the DOM is available, null otherwise\n * - onError          A function that is used to handle errors\n * - onAbort          A function that is used to handle aborted transitions\n *\n * When rendering in a server-side environment, the location should simply\n * be the URL path that was used in the request, including the query string.\n */\nfunction createRouter(options) {\n  options = options || {};\n\n  if (typeof options === 'function') {\n    options = { routes: options }; // Router.create(<Route>)\n  } else if (Array.isArray(options)) {\n    options = { routes: options }; // Router.create([ <Route>, <Route> ])\n  }\n\n  var routes = [];\n  var namedRoutes = {};\n  var components = [];\n  var location = options.location || DEFAULT_LOCATION;\n  var scrollBehavior = options.scrollBehavior || DEFAULT_SCROLL_BEHAVIOR;\n  var onError = options.onError || defaultErrorHandler;\n  var onAbort = options.onAbort || defaultAbortHandler;\n  var state = {};\n  var nextState = {};\n  var pendingTransition = null;\n\n  function updateState() {\n    state = nextState;\n    nextState = {};\n  }\n\n  if (typeof location === 'string') {\n    warning(\n      !canUseDOM || process.env.NODE_ENV === 'test',\n      'You should not use a static location in a DOM environment because ' +\n      'the router will not be kept in sync with the current URL'\n    );\n  } else {\n    invariant(\n      canUseDOM,\n      'You cannot use %s without a DOM',\n      location\n    );\n  }\n\n  // Automatically fall back to full page refreshes in\n  // browsers that don't support the HTML history API.\n  if (location === HistoryLocation && !supportsHistory())\n    location = RefreshLocation;\n\n  var router = React.createClass({\n\n    displayName: 'Router',\n\n    mixins: [ NavigationContext, StateContext, Scrolling ],\n\n    statics: {\n\n      defaultRoute: null,\n      notFoundRoute: null,\n\n      /**\n       * Adds routes to this router from the given children object (see ReactChildren).\n       */\n      addRoutes: function (children) {\n        routes.push.apply(routes, createRoutesFromChildren(children, this, namedRoutes));\n      },\n\n      /**\n       * Returns an absolute URL path created from the given route\n       * name, URL parameters, and query.\n       */\n      makePath: function (to, params, query) {\n        var path;\n        if (Path.isAbsolute(to)) {\n          path = Path.normalize(to);\n        } else {\n          var route = namedRoutes[to];\n\n          invariant(\n            route,\n            'Unable to find <Route name=\"%s\">',\n            to\n          );\n\n          path = route.path;\n        }\n\n        return Path.withQuery(Path.injectParams(path, params), query);\n      },\n\n      /**\n       * Returns a string that may safely be used as the href of a link\n       * to the route with the given name, URL parameters, and query.\n       */\n      makeHref: function (to, params, query) {\n        var path = this.makePath(to, params, query);\n        return (location === HashLocation) ? '#' + path : path;\n      },\n\n      /**\n       * Transitions to the URL specified in the arguments by pushing\n       * a new URL onto the history stack.\n       */\n      transitionTo: function (to, params, query) {\n        invariant(\n          typeof location !== 'string',\n          'You cannot use transitionTo with a static location'\n        );\n\n        var path = this.makePath(to, params, query);\n\n        if (pendingTransition) {\n          // Replace so pending location does not stay in history.\n          location.replace(path);\n        } else {\n          location.push(path);\n        }\n      },\n\n      /**\n       * Transitions to the URL specified in the arguments by replacing\n       * the current URL in the history stack.\n       */\n      replaceWith: function (to, params, query) {\n        invariant(\n          typeof location !== 'string',\n          'You cannot use replaceWith with a static location'\n        );\n\n        location.replace(this.makePath(to, params, query));\n      },\n\n      /**\n       * Transitions to the previous URL if one is available. Returns true if the\n       * router was able to go back, false otherwise.\n       *\n       * Note: The router only tracks history entries in your application, not the\n       * current browser session, so you can safely call this function without guarding\n       * against sending the user back to some other site. However, when using\n       * RefreshLocation (which is the fallback for HistoryLocation in browsers that\n       * don't support HTML5 history) this method will *always* send the client back\n       * because we cannot reliably track history length.\n       */\n      goBack: function () {\n        invariant(\n          typeof location !== 'string',\n          'You cannot use goBack with a static location'\n        );\n\n        if (History.length > 1 || location === RefreshLocation) {\n          location.pop();\n          return true;\n        }\n\n        warning(false, 'goBack() was ignored because there is no router history');\n\n        return false;\n      },\n\n      /**\n       * Performs a match of the given pathname against this router and returns an object\n       * with the { routes, params } that match. Returns null if no match can be made.\n       */\n      match: function (pathname) {\n        return findMatch(pathname, routes, this.defaultRoute, this.notFoundRoute) || null;\n      },\n\n      /**\n       * Performs a transition to the given path and calls callback(error, abortReason)\n       * when the transition is finished. If both arguments are null the router's state\n       * was updated. Otherwise the transition did not complete.\n       *\n       * In a transition, a router first determines which routes are involved by beginning\n       * with the current route, up the route tree to the first parent route that is shared\n       * with the destination route, and back down the tree to the destination route. The\n       * willTransitionFrom hook is invoked on all route handlers we're transitioning away\n       * from, in reverse nesting order. Likewise, the willTransitionTo hook is invoked on\n       * all route handlers we're transitioning to.\n       *\n       * Both willTransitionFrom and willTransitionTo hooks may either abort or redirect the\n       * transition. To resolve asynchronously, they may use transition.wait(promise). If no\n       * hooks wait, the transition is fully synchronous.\n       */\n      dispatch: function (path, action, callback) {\n        if (pendingTransition) {\n          pendingTransition.abort(new Cancellation);\n          pendingTransition = null;\n        }\n\n        var prevPath = state.path;\n        if (prevPath === path)\n          return; // Nothing to do!\n\n        // Record the scroll position as early as possible to\n        // get it before browsers try update it automatically.\n        if (prevPath && action !== LocationActions.REPLACE)\n          this.recordScrollPosition(prevPath);\n\n        var pathname = Path.withoutQuery(path);\n        var match = this.match(pathname);\n\n        warning(\n          match != null,\n          'No route matches path \"%s\". Make sure you have <Route path=\"%s\"> somewhere in your routes',\n          path, path\n        );\n\n        if (match == null)\n          match = {};\n\n        var prevRoutes = state.routes || [];\n        var prevParams = state.params || {};\n        var prevQuery = state.query || {};\n\n        var nextRoutes = match.routes || [];\n        var nextParams = match.params || {};\n        var nextQuery = Path.extractQuery(path) || {};\n\n        var fromRoutes, toRoutes;\n        if (prevRoutes.length) {\n          fromRoutes = prevRoutes.filter(function (route) {\n            return !hasMatch(nextRoutes, route, prevParams, nextParams, prevQuery, nextQuery);\n          });\n\n          toRoutes = nextRoutes.filter(function (route) {\n            return !hasMatch(prevRoutes, route, prevParams, nextParams, prevQuery, nextQuery);\n          });\n        } else {\n          fromRoutes = [];\n          toRoutes = nextRoutes;\n        }\n\n        var transition = new Transition(path, this.replaceWith.bind(this, path));\n        pendingTransition = transition;\n\n        transition.from(fromRoutes, components, function (error) {\n          if (error || transition.isAborted)\n            return callback.call(router, error, transition);\n\n          transition.to(toRoutes, nextParams, nextQuery, function (error) {\n            if (error || transition.isAborted)\n              return callback.call(router, error, transition);\n\n            nextState.path = path;\n            nextState.action = action;\n            nextState.pathname = pathname;\n            nextState.routes = nextRoutes;\n            nextState.params = nextParams;\n            nextState.query = nextQuery;\n\n            callback.call(router, null, transition);\n          });\n        });\n      },\n\n      /**\n       * Starts this router and calls callback(router, state) when the route changes.\n       *\n       * If the router's location is static (i.e. a URL path in a server environment)\n       * the callback is called only once. Otherwise, the location should be one of the\n       * Router.*Location objects (e.g. Router.HashLocation or Router.HistoryLocation).\n       */\n      run: function (callback) {\n        var dispatchHandler = function (error, transition) {\n          pendingTransition = null;\n\n          if (error) {\n            onError.call(router, error);\n          } else if (transition.isAborted) {\n            onAbort.call(router, transition.abortReason, location);\n          } else {\n            callback.call(router, router, nextState);\n          }\n        };\n\n        if (typeof location === 'string') {\n          router.dispatch(location, null, dispatchHandler);\n        } else {\n          // Listen for changes to the location.\n          var changeListener = function (change) {\n            router.dispatch(change.path, change.type, dispatchHandler);\n          };\n\n          if (location.addChangeListener)\n            location.addChangeListener(changeListener);\n\n          // Bootstrap using the current path.\n          router.dispatch(location.getCurrentPath(), null, dispatchHandler);\n        }\n      },\n\n      teardown: function() {\n        location.removeChangeListener(this.changeListener);\n      }\n\n    },\n\n    propTypes: {\n      children: PropTypes.falsy\n    },\n\n    getLocation: function () {\n      return location;\n    },\n\n    getScrollBehavior: function () {\n      return scrollBehavior;\n    },\n\n    getRouteAtDepth: function (depth) {\n      var routes = this.state.routes;\n      return routes && routes[depth];\n    },\n\n    getRouteComponents: function () {\n      return components;\n    },\n\n    getInitialState: function () {\n      updateState();\n      return state;\n    },\n\n    componentWillReceiveProps: function () {\n      updateState();\n      this.setState(state);\n    },\n\n    componentWillUnmount: function() {\n      router.teardown();\n    },\n\n    render: function () {\n      return this.getRouteAtDepth(0) ? React.createElement(RouteHandler, this.props) : null;\n    },\n\n    childContextTypes: {\n      getRouteAtDepth: React.PropTypes.func.isRequired,\n      getRouteComponents: React.PropTypes.func.isRequired,\n      routeHandlers: React.PropTypes.array.isRequired\n    },\n\n    getChildContext: function () {\n      return {\n        getRouteComponents: this.getRouteComponents,\n        getRouteAtDepth: this.getRouteAtDepth,\n        routeHandlers: [ this ]\n      };\n    }\n\n  });\n\n  if (options.routes)\n    router.addRoutes(options.routes);\n\n  return router;\n}\n\nmodule.exports = createRouter;\n","/* jshint -W084 */\nvar React = require('react');\nvar warning = require('react/lib/warning');\nvar invariant = require('react/lib/invariant');\nvar DefaultRoute = require('../components/DefaultRoute');\nvar NotFoundRoute = require('../components/NotFoundRoute');\nvar Redirect = require('../components/Redirect');\nvar Route = require('../components/Route');\nvar Path = require('./Path');\n\nvar CONFIG_ELEMENT_TYPES = [\n  DefaultRoute.type,\n  NotFoundRoute.type,\n  Redirect.type,\n  Route.type\n];\n\nfunction createRedirectHandler(to, _params, _query) {\n  return React.createClass({\n    statics: {\n      willTransitionTo: function (transition, params, query) {\n        transition.redirect(to, _params || params, _query || query);\n      }\n    },\n\n    render: function () {\n      return null;\n    }\n  });\n}\n\nfunction checkPropTypes(componentName, propTypes, props) {\n  for (var propName in propTypes) {\n    if (propTypes.hasOwnProperty(propName)) {\n      var error = propTypes[propName](props, propName, componentName);\n\n      if (error instanceof Error)\n        warning(false, error.message);\n    }\n  }\n}\n\nfunction createRoute(element, parentRoute, namedRoutes) {\n  var type = element.type;\n  var props = element.props;\n  var componentName = (type && type.displayName) || 'UnknownComponent';\n\n  invariant(\n    CONFIG_ELEMENT_TYPES.indexOf(type) !== -1,\n    'Unrecognized route configuration element \"<%s>\"',\n    componentName\n  );\n\n  if (type.propTypes)\n    checkPropTypes(componentName, type.propTypes, props);\n\n  var route = { name: props.name };\n\n  if (props.ignoreScrollBehavior) {\n    route.ignoreScrollBehavior = true;\n  }\n\n  if (type === Redirect.type) {\n    route.handler = createRedirectHandler(props.to, props.params, props.query);\n    props.path = props.path || props.from || '*';\n  } else {\n    route.handler = props.handler;\n  }\n\n  var parentPath = (parentRoute && parentRoute.path) || '/';\n\n  if ((props.path || props.name) && type !== DefaultRoute.type && type !== NotFoundRoute.type) {\n    var path = props.path || props.name;\n\n    // Relative paths extend their parent.\n    if (!Path.isAbsolute(path))\n      path = Path.join(parentPath, path);\n\n    route.path = Path.normalize(path);\n  } else {\n    route.path = parentPath;\n\n    if (type === NotFoundRoute.type)\n      route.path += '*';\n  }\n\n  route.paramNames = Path.extractParamNames(route.path);\n\n  // Make sure the route's path has all params its parent needs.\n  if (parentRoute && Array.isArray(parentRoute.paramNames)) {\n    parentRoute.paramNames.forEach(function (paramName) {\n      invariant(\n        route.paramNames.indexOf(paramName) !== -1,\n        'The nested route path \"%s\" is missing the \"%s\" parameter of its parent path \"%s\"',\n        route.path, paramName, parentRoute.path\n      );\n    });\n  }\n\n  // Make sure the route can be looked up by <Link>s.\n  if (props.name) {\n    invariant(\n      namedRoutes[props.name] == null,\n      'You cannot use the name \"%s\" for more than one route',\n      props.name\n    );\n\n    namedRoutes[props.name] = route;\n  }\n\n  // Handle <NotFoundRoute>.\n  if (type === NotFoundRoute.type) {\n    invariant(\n      parentRoute,\n      '<NotFoundRoute> must have a parent <Route>'\n    );\n\n    invariant(\n      parentRoute.notFoundRoute == null,\n      'You may not have more than one <NotFoundRoute> per <Route>'\n    );\n\n    parentRoute.notFoundRoute = route;\n\n    return null;\n  }\n\n  // Handle <DefaultRoute>.\n  if (type === DefaultRoute.type) {\n    invariant(\n      parentRoute,\n      '<DefaultRoute> must have a parent <Route>'\n    );\n\n    invariant(\n      parentRoute.defaultRoute == null,\n      'You may not have more than one <DefaultRoute> per <Route>'\n    );\n\n    parentRoute.defaultRoute = route;\n\n    return null;\n  }\n\n  route.childRoutes = createRoutesFromChildren(props.children, route, namedRoutes);\n\n  return route;\n}\n\n/**\n * Creates and returns an array of route objects from the given ReactChildren.\n */\nfunction createRoutesFromChildren(children, parentRoute, namedRoutes) {\n  var routes = [];\n\n  React.Children.forEach(children, function (child) {\n    // Exclude <DefaultRoute>s and <NotFoundRoute>s.\n    if (child = createRoute(child, parentRoute, namedRoutes))\n      routes.push(child);\n  });\n\n  return routes;\n}\n\nmodule.exports = createRoutesFromChildren;\n","var invariant = require('react/lib/invariant');\nvar canUseDOM = require('react/lib/ExecutionEnvironment').canUseDOM;\n\n/**\n * Returns the current scroll position of the window as { x, y }.\n */\nfunction getWindowScrollPosition() {\n  invariant(\n    canUseDOM,\n    'Cannot get current scroll position without a DOM'\n  );\n\n  return {\n    x: window.pageXOffset || document.documentElement.scrollLeft,\n    y: window.pageYOffset || document.documentElement.scrollTop\n  };\n}\n\nmodule.exports = getWindowScrollPosition;\n","function reversedArray(array) {\n  return array.slice(0).reverse();\n}\n\nmodule.exports = reversedArray;\n","var createRouter = require('./createRouter');\n\n/**\n * A high-level convenience method that creates, configures, and\n * runs a router in one shot. The method signature is:\n *\n *   Router.run(routes[, location ], callback);\n *\n * Using `window.location.hash` to manage the URL, you could do:\n *\n *   Router.run(routes, function (Handler) {\n *     React.render(<Handler/>, document.body);\n *   });\n * \n * Using HTML5 history and a custom \"cursor\" prop:\n * \n *   Router.run(routes, Router.HistoryLocation, function (Handler) {\n *     React.render(<Handler cursor={cursor}/>, document.body);\n *   });\n *\n * Returns the newly created router.\n *\n * Note: If you need to specify further options for your router such\n * as error/abort handling or custom scroll behavior, use Router.create\n * instead.\n *\n *   var router = Router.create(options);\n *   router.run(function (Handler) {\n *     // ...\n *   });\n */\nfunction runRouter(routes, location, callback) {\n  if (typeof location === 'function') {\n    callback = location;\n    location = null;\n  }\n\n  var router = createRouter({\n    routes: routes,\n    location: location\n  });\n\n  router.run(callback);\n\n  return router;\n}\n\nmodule.exports = runRouter;\n","function supportsHistory() {\n  /*! taken from modernizr\n   * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\n   * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\n   * changed to avoid false negatives for Windows Phones: https://github.com/rackt/react-router/issues/586\n   */\n  var ua = navigator.userAgent;\n  if ((ua.indexOf('Android 2.') !== -1 ||\n      (ua.indexOf('Android 4.0') !== -1)) &&\n      ua.indexOf('Mobile Safari') !== -1 &&\n      ua.indexOf('Chrome') === -1 &&\n      ua.indexOf('Windows Phone') === -1) {\n    return false;\n  }\n  return (window.history && 'pushState' in window.history);\n}\n\nmodule.exports = supportsHistory;\n","module.exports = require('./lib');\n","// Load modules\n\nvar Stringify = require('./stringify');\nvar Parse = require('./parse');\n\n\n// Declare internals\n\nvar internals = {};\n\n\nmodule.exports = {\n    stringify: Stringify,\n    parse: Parse\n};\n","// Load modules\n\nvar Utils = require('./utils');\n\n\n// Declare internals\n\nvar internals = {\n    delimiter: '&',\n    depth: 5,\n    arrayLimit: 20,\n    parameterLimit: 1000\n};\n\n\ninternals.parseValues = function (str, options) {\n\n    var obj = {};\n    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);\n\n    for (var i = 0, il = parts.length; i < il; ++i) {\n        var part = parts[i];\n        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;\n\n        if (pos === -1) {\n            obj[Utils.decode(part)] = '';\n        }\n        else {\n            var key = Utils.decode(part.slice(0, pos));\n            var val = Utils.decode(part.slice(pos + 1));\n\n            if (!obj[key]) {\n                obj[key] = val;\n            }\n            else {\n                obj[key] = [].concat(obj[key]).concat(val);\n            }\n        }\n    }\n\n    return obj;\n};\n\n\ninternals.parseObject = function (chain, val, options) {\n\n    if (!chain.length) {\n        return val;\n    }\n\n    var root = chain.shift();\n\n    var obj = {};\n    if (root === '[]') {\n        obj = [];\n        obj = obj.concat(internals.parseObject(chain, val, options));\n    }\n    else {\n        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;\n        var index = parseInt(cleanRoot, 10);\n        if (!isNaN(index) &&\n            root !== cleanRoot &&\n            index <= options.arrayLimit) {\n\n            obj = [];\n            obj[index] = internals.parseObject(chain, val, options);\n        }\n        else {\n            obj[cleanRoot] = internals.parseObject(chain, val, options);\n        }\n    }\n\n    return obj;\n};\n\n\ninternals.parseKeys = function (key, val, options) {\n\n    if (!key) {\n        return;\n    }\n\n    // The regex chunks\n\n    var parent = /^([^\\[\\]]*)/;\n    var child = /(\\[[^\\[\\]]*\\])/g;\n\n    // Get the parent\n\n    var segment = parent.exec(key);\n\n    // Don't allow them to overwrite object prototype properties\n\n    if (Object.prototype.hasOwnProperty(segment[1])) {\n        return;\n    }\n\n    // Stash the parent if it exists\n\n    var keys = [];\n    if (segment[1]) {\n        keys.push(segment[1]);\n    }\n\n    // Loop through children appending to the array until we hit depth\n\n    var i = 0;\n    while ((segment = child.exec(key)) !== null && i < options.depth) {\n\n        ++i;\n        if (!Object.prototype.hasOwnProperty(segment[1].replace(/\\[|\\]/g, ''))) {\n            keys.push(segment[1]);\n        }\n    }\n\n    // If there's a remainder, just add whatever is left\n\n    if (segment) {\n        keys.push('[' + key.slice(segment.index) + ']');\n    }\n\n    return internals.parseObject(keys, val, options);\n};\n\n\nmodule.exports = function (str, options) {\n\n    if (str === '' ||\n        str === null ||\n        typeof str === 'undefined') {\n\n        return {};\n    }\n\n    options = options || {};\n    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : internals.delimiter;\n    options.depth = typeof options.depth === 'number' ? options.depth : internals.depth;\n    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : internals.arrayLimit;\n    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : internals.parameterLimit;\n\n    var tempObj = typeof str === 'string' ? internals.parseValues(str, options) : str;\n    var obj = {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0, il = keys.length; i < il; ++i) {\n        var key = keys[i];\n        var newObj = internals.parseKeys(key, tempObj[key], options);\n        obj = Utils.merge(obj, newObj);\n    }\n\n    return Utils.compact(obj);\n};\n","// Load modules\n\nvar Utils = require('./utils');\n\n\n// Declare internals\n\nvar internals = {\n    delimiter: '&'\n};\n\n\ninternals.stringify = function (obj, prefix) {\n\n    if (Utils.isBuffer(obj)) {\n        obj = obj.toString();\n    }\n    else if (obj instanceof Date) {\n        obj = obj.toISOString();\n    }\n    else if (obj === null) {\n        obj = '';\n    }\n\n    if (typeof obj === 'string' ||\n        typeof obj === 'number' ||\n        typeof obj === 'boolean') {\n\n        return [encodeURIComponent(prefix) + '=' + encodeURIComponent(obj)];\n    }\n\n    var values = [];\n\n    for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            values = values.concat(internals.stringify(obj[key], prefix + '[' + key + ']'));\n        }\n    }\n\n    return values;\n};\n\n\nmodule.exports = function (obj, options) {\n\n    options = options || {};\n    var delimiter = typeof options.delimiter === 'undefined' ? internals.delimiter : options.delimiter;\n\n    var keys = [];\n\n    for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            keys = keys.concat(internals.stringify(obj[key], key));\n        }\n    }\n\n    return keys.join(delimiter);\n};\n","// Load modules\n\n\n// Declare internals\n\nvar internals = {};\n\n\nexports.arrayToObject = function (source) {\n\n    var obj = {};\n    for (var i = 0, il = source.length; i < il; ++i) {\n        if (typeof source[i] !== 'undefined') {\n\n            obj[i] = source[i];\n        }\n    }\n\n    return obj;\n};\n\n\nexports.merge = function (target, source) {\n\n    if (!source) {\n        return target;\n    }\n\n    if (Array.isArray(source)) {\n        for (var i = 0, il = source.length; i < il; ++i) {\n            if (typeof source[i] !== 'undefined') {\n                if (typeof target[i] === 'object') {\n                    target[i] = exports.merge(target[i], source[i]);\n                }\n                else {\n                    target[i] = source[i];\n                }\n            }\n        }\n\n        return target;\n    }\n\n    if (Array.isArray(target)) {\n        if (typeof source !== 'object') {\n            target.push(source);\n            return target;\n        }\n        else {\n            target = exports.arrayToObject(target);\n        }\n    }\n\n    var keys = Object.keys(source);\n    for (var k = 0, kl = keys.length; k < kl; ++k) {\n        var key = keys[k];\n        var value = source[key];\n\n        if (value &&\n            typeof value === 'object') {\n\n            if (!target[key]) {\n                target[key] = value;\n            }\n            else {\n                target[key] = exports.merge(target[key], value);\n            }\n        }\n        else {\n            target[key] = value;\n        }\n    }\n\n    return target;\n};\n\n\nexports.decode = function (str) {\n\n    try {\n        return decodeURIComponent(str.replace(/\\+/g, ' '));\n    } catch (e) {\n        return str;\n    }\n};\n\n\nexports.compact = function (obj, refs) {\n\n    if (typeof obj !== 'object' ||\n        obj === null) {\n\n        return obj;\n    }\n\n    refs = refs || [];\n    var lookup = refs.indexOf(obj);\n    if (lookup !== -1) {\n        return refs[lookup];\n    }\n\n    refs.push(obj);\n\n    if (Array.isArray(obj)) {\n        var compacted = [];\n\n        for (var i = 0, l = obj.length; i < l; ++i) {\n            if (typeof obj[i] !== 'undefined') {\n                compacted.push(obj[i]);\n            }\n        }\n\n        return compacted;\n    }\n\n    var keys = Object.keys(obj);\n    for (var i = 0, il = keys.length; i < il; ++i) {\n        var key = keys[i];\n        obj[key] = exports.compact(obj[key], refs);\n    }\n\n    return obj;\n};\n\n\nexports.isRegExp = function (obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\n\nexports.isBuffer = function (obj) {\n\n    if (typeof Buffer !== 'undefined') {\n        return Buffer.isBuffer(obj);\n    }\n    else {\n        return false;\n    }\n};\n","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function (require) {\n\n\tvar makePromise = require('./makePromise');\n\tvar Scheduler = require('./Scheduler');\n\tvar async = require('./async');\n\n\treturn makePromise({\n\t\tscheduler: new Scheduler(async)\n\t});\n\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\t/**\n\t * Circular queue\n\t * @param {number} capacityPow2 power of 2 to which this queue's capacity\n\t *  will be set initially. eg when capacityPow2 == 3, queue capacity\n\t *  will be 8.\n\t * @constructor\n\t */\n\tfunction Queue(capacityPow2) {\n\t\tthis.head = this.tail = this.length = 0;\n\t\tthis.buffer = new Array(1 << capacityPow2);\n\t}\n\n\tQueue.prototype.push = function(x) {\n\t\tif(this.length === this.buffer.length) {\n\t\t\tthis._ensureCapacity(this.length * 2);\n\t\t}\n\n\t\tthis.buffer[this.tail] = x;\n\t\tthis.tail = (this.tail + 1) & (this.buffer.length - 1);\n\t\t++this.length;\n\t\treturn this.length;\n\t};\n\n\tQueue.prototype.shift = function() {\n\t\tvar x = this.buffer[this.head];\n\t\tthis.buffer[this.head] = void 0;\n\t\tthis.head = (this.head + 1) & (this.buffer.length - 1);\n\t\t--this.length;\n\t\treturn x;\n\t};\n\n\tQueue.prototype._ensureCapacity = function(capacity) {\n\t\tvar head = this.head;\n\t\tvar buffer = this.buffer;\n\t\tvar newBuffer = new Array(capacity);\n\t\tvar i = 0;\n\t\tvar len;\n\n\t\tif(head === 0) {\n\t\t\tlen = this.length;\n\t\t\tfor(; i<len; ++i) {\n\t\t\t\tnewBuffer[i] = buffer[i];\n\t\t\t}\n\t\t} else {\n\t\t\tcapacity = buffer.length;\n\t\t\tlen = this.tail;\n\t\t\tfor(; head<capacity; ++i, ++head) {\n\t\t\t\tnewBuffer[i] = buffer[head];\n\t\t\t}\n\n\t\t\tfor(head=0; head<len; ++i, ++head) {\n\t\t\t\tnewBuffer[i] = buffer[head];\n\t\t\t}\n\t\t}\n\n\t\tthis.buffer = newBuffer;\n\t\tthis.head = 0;\n\t\tthis.tail = this.length;\n\t};\n\n\treturn Queue;\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar Queue = require('./Queue');\n\n\t// Credit to Twisol (https://github.com/Twisol) for suggesting\n\t// this type of extensible queue + trampoline approach for next-tick conflation.\n\n\t/**\n\t * Async task scheduler\n\t * @param {function} async function to schedule a single async function\n\t * @constructor\n\t */\n\tfunction Scheduler(async) {\n\t\tthis._async = async;\n\t\tthis._queue = new Queue(15);\n\t\tthis._afterQueue = new Queue(5);\n\t\tthis._running = false;\n\n\t\tvar self = this;\n\t\tthis.drain = function() {\n\t\t\tself._drain();\n\t\t};\n\t}\n\n\t/**\n\t * Enqueue a task\n\t * @param {{ run:function }} task\n\t */\n\tScheduler.prototype.enqueue = function(task) {\n\t\tthis._add(this._queue, task);\n\t};\n\n\t/**\n\t * Enqueue a task to run after the main task queue\n\t * @param {{ run:function }} task\n\t */\n\tScheduler.prototype.afterQueue = function(task) {\n\t\tthis._add(this._afterQueue, task);\n\t};\n\n\t/**\n\t * Drain the handler queue entirely, and then the after queue\n\t */\n\tScheduler.prototype._drain = function() {\n\t\trunQueue(this._queue);\n\t\tthis._running = false;\n\t\trunQueue(this._afterQueue);\n\t};\n\n\t/**\n\t * Add a task to the q, and schedule drain if not already scheduled\n\t * @param {Queue} queue\n\t * @param {{run:function}} task\n\t * @private\n\t */\n\tScheduler.prototype._add = function(queue, task) {\n\t\tqueue.push(task);\n\t\tif(!this._running) {\n\t\t\tthis._running = true;\n\t\t\tthis._async(this.drain);\n\t\t}\n\t};\n\n\t/**\n\t * Run all the tasks in the q\n\t * @param queue\n\t */\n\tfunction runQueue(queue) {\n\t\twhile(queue.length > 0) {\n\t\t\tqueue.shift().run();\n\t\t}\n\t}\n\n\treturn Scheduler;\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\t// Sniff \"best\" async scheduling option\n\t// Prefer process.nextTick or MutationObserver, then check for\n\t// vertx and finally fall back to setTimeout\n\n\t/*jshint maxcomplexity:6*/\n\t/*global process,document,setTimeout,MutationObserver,WebKitMutationObserver*/\n\tvar nextTick, MutationObs;\n\n\tif (typeof process !== 'undefined' && process !== null &&\n\t\ttypeof process.nextTick === 'function') {\n\t\tnextTick = function(f) {\n\t\t\tprocess.nextTick(f);\n\t\t};\n\n\t} else if (MutationObs =\n\t\t(typeof MutationObserver === 'function' && MutationObserver) ||\n\t\t(typeof WebKitMutationObserver === 'function' && WebKitMutationObserver)) {\n\t\tnextTick = (function (document, MutationObserver) {\n\t\t\tvar scheduled;\n\t\t\tvar el = document.createElement('div');\n\t\t\tvar o = new MutationObserver(run);\n\t\t\to.observe(el, { attributes: true });\n\n\t\t\tfunction run() {\n\t\t\t\tvar f = scheduled;\n\t\t\t\tscheduled = void 0;\n\t\t\t\tf();\n\t\t\t}\n\n\t\t\treturn function (f) {\n\t\t\t\tscheduled = f;\n\t\t\t\tel.setAttribute('class', 'x');\n\t\t\t};\n\t\t}(document, MutationObs));\n\n\t} else {\n\t\tnextTick = (function(cjsRequire) {\n\t\t\tvar vertx;\n\t\t\ttry {\n\t\t\t\t// vert.x 1.x || 2.x\n\t\t\t\tvertx = cjsRequire('vertx');\n\t\t\t} catch (ignore) {}\n\n\t\t\tif (vertx) {\n\t\t\t\tif (typeof vertx.runOnLoop === 'function') {\n\t\t\t\t\treturn vertx.runOnLoop;\n\t\t\t\t}\n\t\t\t\tif (typeof vertx.runOnContext === 'function') {\n\t\t\t\t\treturn vertx.runOnContext;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// capture setTimeout to avoid being caught by fake timers\n\t\t\t// used in time based tests\n\t\t\tvar capturedSetTimeout = setTimeout;\n\t\t\treturn function (t) {\n\t\t\t\tcapturedSetTimeout(t, 0);\n\t\t\t};\n\t\t}(require));\n\t}\n\n\treturn nextTick;\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function makePromise(environment) {\n\n\t\tvar tasks = environment.scheduler;\n\n\t\tvar objectCreate = Object.create ||\n\t\t\tfunction(proto) {\n\t\t\t\tfunction Child() {}\n\t\t\t\tChild.prototype = proto;\n\t\t\t\treturn new Child();\n\t\t\t};\n\n\t\t/**\n\t\t * Create a promise whose fate is determined by resolver\n\t\t * @constructor\n\t\t * @returns {Promise} promise\n\t\t * @name Promise\n\t\t */\n\t\tfunction Promise(resolver, handler) {\n\t\t\tthis._handler = resolver === Handler ? handler : init(resolver);\n\t\t}\n\n\t\t/**\n\t\t * Run the supplied resolver\n\t\t * @param resolver\n\t\t * @returns {Pending}\n\t\t */\n\t\tfunction init(resolver) {\n\t\t\tvar handler = new Pending();\n\n\t\t\ttry {\n\t\t\t\tresolver(promiseResolve, promiseReject, promiseNotify);\n\t\t\t} catch (e) {\n\t\t\t\tpromiseReject(e);\n\t\t\t}\n\n\t\t\treturn handler;\n\n\t\t\t/**\n\t\t\t * Transition from pre-resolution state to post-resolution state, notifying\n\t\t\t * all listeners of the ultimate fulfillment or rejection\n\t\t\t * @param {*} x resolution value\n\t\t\t */\n\t\t\tfunction promiseResolve (x) {\n\t\t\t\thandler.resolve(x);\n\t\t\t}\n\t\t\t/**\n\t\t\t * Reject this promise with reason, which will be used verbatim\n\t\t\t * @param {Error|*} reason rejection reason, strongly suggested\n\t\t\t *   to be an Error type\n\t\t\t */\n\t\t\tfunction promiseReject (reason) {\n\t\t\t\thandler.reject(reason);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Issue a progress event, notifying all progress listeners\n\t\t\t * @param {*} x progress event payload to pass to all listeners\n\t\t\t */\n\t\t\tfunction promiseNotify (x) {\n\t\t\t\thandler.notify(x);\n\t\t\t}\n\t\t}\n\n\t\t// Creation\n\n\t\tPromise.resolve = resolve;\n\t\tPromise.reject = reject;\n\t\tPromise.never = never;\n\n\t\tPromise._defer = defer;\n\t\tPromise._handler = getHandler;\n\n\t\t/**\n\t\t * Returns a trusted promise. If x is already a trusted promise, it is\n\t\t * returned, otherwise returns a new trusted Promise which follows x.\n\t\t * @param  {*} x\n\t\t * @return {Promise} promise\n\t\t */\n\t\tfunction resolve(x) {\n\t\t\treturn isPromise(x) ? x\n\t\t\t\t: new Promise(Handler, new Async(getHandler(x)));\n\t\t}\n\n\t\t/**\n\t\t * Return a reject promise with x as its reason (x is used verbatim)\n\t\t * @param {*} x\n\t\t * @returns {Promise} rejected promise\n\t\t */\n\t\tfunction reject(x) {\n\t\t\treturn new Promise(Handler, new Async(new Rejected(x)));\n\t\t}\n\n\t\t/**\n\t\t * Return a promise that remains pending forever\n\t\t * @returns {Promise} forever-pending promise.\n\t\t */\n\t\tfunction never() {\n\t\t\treturn foreverPendingPromise; // Should be frozen\n\t\t}\n\n\t\t/**\n\t\t * Creates an internal {promise, resolver} pair\n\t\t * @private\n\t\t * @returns {Promise}\n\t\t */\n\t\tfunction defer() {\n\t\t\treturn new Promise(Handler, new Pending());\n\t\t}\n\n\t\t// Transformation and flow control\n\n\t\t/**\n\t\t * Transform this promise's fulfillment value, returning a new Promise\n\t\t * for the transformed result.  If the promise cannot be fulfilled, onRejected\n\t\t * is called with the reason.  onProgress *may* be called with updates toward\n\t\t * this promise's fulfillment.\n\t\t * @param {function=} onFulfilled fulfillment handler\n\t\t * @param {function=} onRejected rejection handler\n\t\t * @deprecated @param {function=} onProgress progress handler\n\t\t * @return {Promise} new promise\n\t\t */\n\t\tPromise.prototype.then = function(onFulfilled, onRejected) {\n\t\t\tvar parent = this._handler;\n\t\t\tvar state = parent.join().state();\n\n\t\t\tif ((typeof onFulfilled !== 'function' && state > 0) ||\n\t\t\t\t(typeof onRejected !== 'function' && state < 0)) {\n\t\t\t\t// Short circuit: value will not change, simply share handler\n\t\t\t\treturn new this.constructor(Handler, parent);\n\t\t\t}\n\n\t\t\tvar p = this._beget();\n\t\t\tvar child = p._handler;\n\n\t\t\tparent.chain(child, parent.receiver, onFulfilled, onRejected,\n\t\t\t\t\targuments.length > 2 ? arguments[2] : void 0);\n\n\t\t\treturn p;\n\t\t};\n\n\t\t/**\n\t\t * If this promise cannot be fulfilled due to an error, call onRejected to\n\t\t * handle the error. Shortcut for .then(undefined, onRejected)\n\t\t * @param {function?} onRejected\n\t\t * @return {Promise}\n\t\t */\n\t\tPromise.prototype['catch'] = function(onRejected) {\n\t\t\treturn this.then(void 0, onRejected);\n\t\t};\n\n\t\t/**\n\t\t * Creates a new, pending promise of the same type as this promise\n\t\t * @private\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype._beget = function() {\n\t\t\tvar parent = this._handler;\n\t\t\tvar child = new Pending(parent.receiver, parent.join().context);\n\t\t\treturn new this.constructor(Handler, child);\n\t\t};\n\n\t\t// Array combinators\n\n\t\tPromise.all = all;\n\t\tPromise.race = race;\n\n\t\t/**\n\t\t * Return a promise that will fulfill when all promises in the\n\t\t * input array have fulfilled, or will reject when one of the\n\t\t * promises rejects.\n\t\t * @param {array} promises array of promises\n\t\t * @returns {Promise} promise for array of fulfillment values\n\t\t */\n\t\tfunction all(promises) {\n\t\t\t/*jshint maxcomplexity:8*/\n\t\t\tvar resolver = new Pending();\n\t\t\tvar pending = promises.length >>> 0;\n\t\t\tvar results = new Array(pending);\n\n\t\t\tvar i, h, x, s;\n\t\t\tfor (i = 0; i < promises.length; ++i) {\n\t\t\t\tx = promises[i];\n\n\t\t\t\tif (x === void 0 && !(i in promises)) {\n\t\t\t\t\t--pending;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (maybeThenable(x)) {\n\t\t\t\t\th = getHandlerMaybeThenable(x);\n\n\t\t\t\t\ts = h.state();\n\t\t\t\t\tif (s === 0) {\n\t\t\t\t\t\th.fold(settleAt, i, results, resolver);\n\t\t\t\t\t} else if (s > 0) {\n\t\t\t\t\t\tresults[i] = h.value;\n\t\t\t\t\t\t--pending;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tunreportRemaining(promises, i+1, h);\n\t\t\t\t\t\tresolver.become(h);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tresults[i] = x;\n\t\t\t\t\t--pending;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(pending === 0) {\n\t\t\t\tresolver.become(new Fulfilled(results));\n\t\t\t}\n\n\t\t\treturn new Promise(Handler, resolver);\n\n\t\t\tfunction settleAt(i, x, resolver) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\tthis[i] = x;\n\t\t\t\tif(--pending === 0) {\n\t\t\t\t\tresolver.become(new Fulfilled(this));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction unreportRemaining(promises, start, rejectedHandler) {\n\t\t\tvar i, h, x;\n\t\t\tfor(i=start; i<promises.length; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif(maybeThenable(x)) {\n\t\t\t\t\th = getHandlerMaybeThenable(x);\n\n\t\t\t\t\tif(h !== rejectedHandler) {\n\t\t\t\t\t\th.visit(h, void 0, h._unreport);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Fulfill-reject competitive race. Return a promise that will settle\n\t\t * to the same state as the earliest input promise to settle.\n\t\t *\n\t\t * WARNING: The ES6 Promise spec requires that race()ing an empty array\n\t\t * must return a promise that is pending forever.  This implementation\n\t\t * returns a singleton forever-pending promise, the same singleton that is\n\t\t * returned by Promise.never(), thus can be checked with ===\n\t\t *\n\t\t * @param {array} promises array of promises to race\n\t\t * @returns {Promise} if input is non-empty, a promise that will settle\n\t\t * to the same outcome as the earliest input promise to settle. if empty\n\t\t * is empty, returns a promise that will never settle.\n\t\t */\n\t\tfunction race(promises) {\n\t\t\t// Sigh, race([]) is untestable unless we return *something*\n\t\t\t// that is recognizable without calling .then() on it.\n\t\t\tif(Object(promises) === promises && promises.length === 0) {\n\t\t\t\treturn never();\n\t\t\t}\n\n\t\t\tvar h = new Pending();\n\t\t\tvar i, x;\n\t\t\tfor(i=0; i<promises.length; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif (x !== void 0 && i in promises) {\n\t\t\t\t\tgetHandler(x).visit(h, h.resolve, h.reject);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new Promise(Handler, h);\n\t\t}\n\n\t\t// Promise internals\n\t\t// Below this, everything is @private\n\n\t\t/**\n\t\t * Get an appropriate handler for x, without checking for cycles\n\t\t * @param {*} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandler(x) {\n\t\t\tif(isPromise(x)) {\n\t\t\t\treturn x._handler.join();\n\t\t\t}\n\t\t\treturn maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);\n\t\t}\n\n\t\t/**\n\t\t * Get a handler for thenable x.\n\t\t * NOTE: You must only call this if maybeThenable(x) == true\n\t\t * @param {object|function|Promise} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandlerMaybeThenable(x) {\n\t\t\treturn isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);\n\t\t}\n\n\t\t/**\n\t\t * Get a handler for potentially untrusted thenable x\n\t\t * @param {*} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandlerUntrusted(x) {\n\t\t\ttry {\n\t\t\t\tvar untrustedThen = x.then;\n\t\t\t\treturn typeof untrustedThen === 'function'\n\t\t\t\t\t? new Thenable(untrustedThen, x)\n\t\t\t\t\t: new Fulfilled(x);\n\t\t\t} catch(e) {\n\t\t\t\treturn new Rejected(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Handler for a promise that is pending forever\n\t\t * @constructor\n\t\t */\n\t\tfunction Handler() {}\n\n\t\tHandler.prototype.when\n\t\t\t= Handler.prototype.become\n\t\t\t= Handler.prototype.notify\n\t\t\t= Handler.prototype.fail\n\t\t\t= Handler.prototype._unreport\n\t\t\t= Handler.prototype._report\n\t\t\t= noop;\n\n\t\tHandler.prototype._state = 0;\n\n\t\tHandler.prototype.state = function() {\n\t\t\treturn this._state;\n\t\t};\n\n\t\t/**\n\t\t * Recursively collapse handler chain to find the handler\n\t\t * nearest to the fully resolved value.\n\t\t * @returns {object} handler nearest the fully resolved value\n\t\t */\n\t\tHandler.prototype.join = function() {\n\t\t\tvar h = this;\n\t\t\twhile(h.handler !== void 0) {\n\t\t\t\th = h.handler;\n\t\t\t}\n\t\t\treturn h;\n\t\t};\n\n\t\tHandler.prototype.chain = function(to, receiver, fulfilled, rejected, progress) {\n\t\t\tthis.when({\n\t\t\t\tresolver: to,\n\t\t\t\treceiver: receiver,\n\t\t\t\tfulfilled: fulfilled,\n\t\t\t\trejected: rejected,\n\t\t\t\tprogress: progress\n\t\t\t});\n\t\t};\n\n\t\tHandler.prototype.visit = function(receiver, fulfilled, rejected, progress) {\n\t\t\tthis.chain(failIfRejected, receiver, fulfilled, rejected, progress);\n\t\t};\n\n\t\tHandler.prototype.fold = function(f, z, c, to) {\n\t\t\tthis.visit(to, function(x) {\n\t\t\t\tf.call(c, z, x, this);\n\t\t\t}, to.reject, to.notify);\n\t\t};\n\n\t\t/**\n\t\t * Handler that invokes fail() on any handler it becomes\n\t\t * @constructor\n\t\t */\n\t\tfunction FailIfRejected() {}\n\n\t\tinherit(Handler, FailIfRejected);\n\n\t\tFailIfRejected.prototype.become = function(h) {\n\t\t\th.fail();\n\t\t};\n\n\t\tvar failIfRejected = new FailIfRejected();\n\n\t\t/**\n\t\t * Handler that manages a queue of consumers waiting on a pending promise\n\t\t * @constructor\n\t\t */\n\t\tfunction Pending(receiver, inheritedContext) {\n\t\t\tPromise.createContext(this, inheritedContext);\n\n\t\t\tthis.consumers = void 0;\n\t\t\tthis.receiver = receiver;\n\t\t\tthis.handler = void 0;\n\t\t\tthis.resolved = false;\n\t\t}\n\n\t\tinherit(Handler, Pending);\n\n\t\tPending.prototype._state = 0;\n\n\t\tPending.prototype.resolve = function(x) {\n\t\t\tthis.become(getHandler(x));\n\t\t};\n\n\t\tPending.prototype.reject = function(x) {\n\t\t\tif(this.resolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.become(new Rejected(x));\n\t\t};\n\n\t\tPending.prototype.join = function() {\n\t\t\tif (!this.resolved) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tvar h = this;\n\n\t\t\twhile (h.handler !== void 0) {\n\t\t\t\th = h.handler;\n\t\t\t\tif (h === this) {\n\t\t\t\t\treturn this.handler = cycle();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn h;\n\t\t};\n\n\t\tPending.prototype.run = function() {\n\t\t\tvar q = this.consumers;\n\t\t\tvar handler = this.join();\n\t\t\tthis.consumers = void 0;\n\n\t\t\tfor (var i = 0; i < q.length; ++i) {\n\t\t\t\thandler.when(q[i]);\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.become = function(handler) {\n\t\t\tif(this.resolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.resolved = true;\n\t\t\tthis.handler = handler;\n\t\t\tif(this.consumers !== void 0) {\n\t\t\t\ttasks.enqueue(this);\n\t\t\t}\n\n\t\t\tif(this.context !== void 0) {\n\t\t\t\thandler._report(this.context);\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.when = function(continuation) {\n\t\t\tif(this.resolved) {\n\t\t\t\ttasks.enqueue(new ContinuationTask(continuation, this.handler));\n\t\t\t} else {\n\t\t\t\tif(this.consumers === void 0) {\n\t\t\t\t\tthis.consumers = [continuation];\n\t\t\t\t} else {\n\t\t\t\t\tthis.consumers.push(continuation);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.notify = function(x) {\n\t\t\tif(!this.resolved) {\n\t\t\t\ttasks.enqueue(new ProgressTask(x, this));\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.fail = function(context) {\n\t\t\tvar c = typeof context === 'undefined' ? this.context : context;\n\t\t\tthis.resolved && this.handler.join().fail(c);\n\t\t};\n\n\t\tPending.prototype._report = function(context) {\n\t\t\tthis.resolved && this.handler.join()._report(context);\n\t\t};\n\n\t\tPending.prototype._unreport = function() {\n\t\t\tthis.resolved && this.handler.join()._unreport();\n\t\t};\n\n\t\t/**\n\t\t * Wrap another handler and force it into a future stack\n\t\t * @param {object} handler\n\t\t * @constructor\n\t\t */\n\t\tfunction Async(handler) {\n\t\t\tthis.handler = handler;\n\t\t}\n\n\t\tinherit(Handler, Async);\n\n\t\tAsync.prototype.when = function(continuation) {\n\t\t\ttasks.enqueue(new ContinuationTask(continuation, this));\n\t\t};\n\n\t\tAsync.prototype._report = function(context) {\n\t\t\tthis.join()._report(context);\n\t\t};\n\n\t\tAsync.prototype._unreport = function() {\n\t\t\tthis.join()._unreport();\n\t\t};\n\n\t\t/**\n\t\t * Handler that wraps an untrusted thenable and assimilates it in a future stack\n\t\t * @param {function} then\n\t\t * @param {{then: function}} thenable\n\t\t * @constructor\n\t\t */\n\t\tfunction Thenable(then, thenable) {\n\t\t\tPending.call(this);\n\t\t\ttasks.enqueue(new AssimilateTask(then, thenable, this));\n\t\t}\n\n\t\tinherit(Pending, Thenable);\n\n\t\t/**\n\t\t * Handler for a fulfilled promise\n\t\t * @param {*} x fulfillment value\n\t\t * @constructor\n\t\t */\n\t\tfunction Fulfilled(x) {\n\t\t\tPromise.createContext(this);\n\t\t\tthis.value = x;\n\t\t}\n\n\t\tinherit(Handler, Fulfilled);\n\n\t\tFulfilled.prototype._state = 1;\n\n\t\tFulfilled.prototype.fold = function(f, z, c, to) {\n\t\t\trunContinuation3(f, z, this, c, to);\n\t\t};\n\n\t\tFulfilled.prototype.when = function(cont) {\n\t\t\trunContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);\n\t\t};\n\n\t\tvar errorId = 0;\n\n\t\t/**\n\t\t * Handler for a rejected promise\n\t\t * @param {*} x rejection reason\n\t\t * @constructor\n\t\t */\n\t\tfunction Rejected(x) {\n\t\t\tPromise.createContext(this);\n\n\t\t\tthis.id = ++errorId;\n\t\t\tthis.value = x;\n\t\t\tthis.handled = false;\n\t\t\tthis.reported = false;\n\n\t\t\tthis._report();\n\t\t}\n\n\t\tinherit(Handler, Rejected);\n\n\t\tRejected.prototype._state = -1;\n\n\t\tRejected.prototype.fold = function(f, z, c, to) {\n\t\t\tto.become(this);\n\t\t};\n\n\t\tRejected.prototype.when = function(cont) {\n\t\t\tif(typeof cont.rejected === 'function') {\n\t\t\t\tthis._unreport();\n\t\t\t}\n\t\t\trunContinuation1(cont.rejected, this, cont.receiver, cont.resolver);\n\t\t};\n\n\t\tRejected.prototype._report = function(context) {\n\t\t\ttasks.afterQueue(new ReportTask(this, context));\n\t\t};\n\n\t\tRejected.prototype._unreport = function() {\n\t\t\tthis.handled = true;\n\t\t\ttasks.afterQueue(new UnreportTask(this));\n\t\t};\n\n\t\tRejected.prototype.fail = function(context) {\n\t\t\tPromise.onFatalRejection(this, context === void 0 ? this.context : context);\n\t\t};\n\n\t\tfunction ReportTask(rejection, context) {\n\t\t\tthis.rejection = rejection;\n\t\t\tthis.context = context;\n\t\t}\n\n\t\tReportTask.prototype.run = function() {\n\t\t\tif(!this.rejection.handled) {\n\t\t\t\tthis.rejection.reported = true;\n\t\t\t\tPromise.onPotentiallyUnhandledRejection(this.rejection, this.context);\n\t\t\t}\n\t\t};\n\n\t\tfunction UnreportTask(rejection) {\n\t\t\tthis.rejection = rejection;\n\t\t}\n\n\t\tUnreportTask.prototype.run = function() {\n\t\t\tif(this.rejection.reported) {\n\t\t\t\tPromise.onPotentiallyUnhandledRejectionHandled(this.rejection);\n\t\t\t}\n\t\t};\n\n\t\t// Unhandled rejection hooks\n\t\t// By default, everything is a noop\n\n\t\t// TODO: Better names: \"annotate\"?\n\t\tPromise.createContext\n\t\t\t= Promise.enterContext\n\t\t\t= Promise.exitContext\n\t\t\t= Promise.onPotentiallyUnhandledRejection\n\t\t\t= Promise.onPotentiallyUnhandledRejectionHandled\n\t\t\t= Promise.onFatalRejection\n\t\t\t= noop;\n\n\t\t// Errors and singletons\n\n\t\tvar foreverPendingHandler = new Handler();\n\t\tvar foreverPendingPromise = new Promise(Handler, foreverPendingHandler);\n\n\t\tfunction cycle() {\n\t\t\treturn new Rejected(new TypeError('Promise cycle'));\n\t\t}\n\n\t\t// Task runners\n\n\t\t/**\n\t\t * Run a single consumer\n\t\t * @constructor\n\t\t */\n\t\tfunction ContinuationTask(continuation, handler) {\n\t\t\tthis.continuation = continuation;\n\t\t\tthis.handler = handler;\n\t\t}\n\n\t\tContinuationTask.prototype.run = function() {\n\t\t\tthis.handler.join().when(this.continuation);\n\t\t};\n\n\t\t/**\n\t\t * Run a queue of progress handlers\n\t\t * @constructor\n\t\t */\n\t\tfunction ProgressTask(value, handler) {\n\t\t\tthis.handler = handler;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tProgressTask.prototype.run = function() {\n\t\t\tvar q = this.handler.consumers;\n\t\t\tif(q === void 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var c, i = 0; i < q.length; ++i) {\n\t\t\t\tc = q[i];\n\t\t\t\trunNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Assimilate a thenable, sending it's value to resolver\n\t\t * @param {function} then\n\t\t * @param {object|function} thenable\n\t\t * @param {object} resolver\n\t\t * @constructor\n\t\t */\n\t\tfunction AssimilateTask(then, thenable, resolver) {\n\t\t\tthis._then = then;\n\t\t\tthis.thenable = thenable;\n\t\t\tthis.resolver = resolver;\n\t\t}\n\n\t\tAssimilateTask.prototype.run = function() {\n\t\t\tvar h = this.resolver;\n\t\t\ttryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);\n\n\t\t\tfunction _resolve(x) { h.resolve(x); }\n\t\t\tfunction _reject(x)  { h.reject(x); }\n\t\t\tfunction _notify(x)  { h.notify(x); }\n\t\t};\n\n\t\tfunction tryAssimilate(then, thenable, resolve, reject, notify) {\n\t\t\ttry {\n\t\t\t\tthen.call(thenable, resolve, reject, notify);\n\t\t\t} catch (e) {\n\t\t\t\treject(e);\n\t\t\t}\n\t\t}\n\n\t\t// Other helpers\n\n\t\t/**\n\t\t * @param {*} x\n\t\t * @returns {boolean} true iff x is a trusted Promise\n\t\t */\n\t\tfunction isPromise(x) {\n\t\t\treturn x instanceof Promise;\n\t\t}\n\n\t\t/**\n\t\t * Test just enough to rule out primitives, in order to take faster\n\t\t * paths in some code\n\t\t * @param {*} x\n\t\t * @returns {boolean} false iff x is guaranteed *not* to be a thenable\n\t\t */\n\t\tfunction maybeThenable(x) {\n\t\t\treturn (typeof x === 'object' || typeof x === 'function') && x !== null;\n\t\t}\n\n\t\tfunction runContinuation1(f, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.become(h);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReject(f, h.value, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\tfunction runContinuation3(f, x, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.become(h);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReject3(f, x, h.value, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\tfunction runNotify(f, x, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.notify(x);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReturn(f, x, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\t/**\n\t\t * Return f.call(thisArg, x), or if it throws return a rejected promise for\n\t\t * the thrown exception\n\t\t */\n\t\tfunction tryCatchReject(f, x, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tnext.become(getHandler(f.call(thisArg, x)));\n\t\t\t} catch(e) {\n\t\t\t\tnext.become(new Rejected(e));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Same as above, but includes the extra argument parameter.\n\t\t */\n\t\tfunction tryCatchReject3(f, x, y, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tf.call(thisArg, x, y, next);\n\t\t\t} catch(e) {\n\t\t\t\tnext.become(new Rejected(e));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Return f.call(thisArg, x), or if it throws, *return* the exception\n\t\t */\n\t\tfunction tryCatchReturn(f, x, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tnext.notify(f.call(thisArg, x));\n\t\t\t} catch(e) {\n\t\t\t\tnext.notify(e);\n\t\t\t}\n\t\t}\n\n\t\tfunction inherit(Parent, Child) {\n\t\t\tChild.prototype = objectCreate(Parent.prototype);\n\t\t\tChild.prototype.constructor = Child;\n\t\t}\n\n\t\tfunction noop() {}\n\n\t\treturn Promise;\n\t};\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n","/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule CSSCore\n * @typechecks\n */\n\nvar invariant = require(\"./invariant\");\n\n/**\n * The CSSCore module specifies the API (and implements most of the methods)\n * that should be used when dealing with the display of elements (via their\n * CSS classes and visibility on screen. It is an API focused on mutating the\n * display and not reading it as no logical state should be encoded in the\n * display of elements.\n */\n\nvar CSSCore = {\n\n  /**\n   * Adds the class passed in to the element if it doesn't already have it.\n   *\n   * @param {DOMElement} element the element to set the class on\n   * @param {string} className the CSS className\n   * @return {DOMElement} the element passed in\n   */\n  addClass: function(element, className) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      !/\\s/.test(className),\n      'CSSCore.addClass takes only a single class name. \"%s\" contains ' +\n      'multiple classes.', className\n    ) : invariant(!/\\s/.test(className)));\n\n    if (className) {\n      if (element.classList) {\n        element.classList.add(className);\n      } else if (!CSSCore.hasClass(element, className)) {\n        element.className = element.className + ' ' + className;\n      }\n    }\n    return element;\n  },\n\n  /**\n   * Removes the class passed in from the element\n   *\n   * @param {DOMElement} element the element to set the class on\n   * @param {string} className the CSS className\n   * @return {DOMElement} the element passed in\n   */\n  removeClass: function(element, className) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      !/\\s/.test(className),\n      'CSSCore.removeClass takes only a single class name. \"%s\" contains ' +\n      'multiple classes.', className\n    ) : invariant(!/\\s/.test(className)));\n\n    if (className) {\n      if (element.classList) {\n        element.classList.remove(className);\n      } else if (CSSCore.hasClass(element, className)) {\n        element.className = element.className\n          .replace(new RegExp('(^|\\\\s)' + className + '(?:\\\\s|$)', 'g'), '$1')\n          .replace(/\\s+/g, ' ') // multiple spaces to one\n          .replace(/^\\s*|\\s*$/g, ''); // trim the ends\n      }\n    }\n    return element;\n  },\n\n  /**\n   * Helper to add or remove a class from an element based on a condition.\n   *\n   * @param {DOMElement} element the element to set the class on\n   * @param {string} className the CSS className\n   * @param {*} bool condition to whether to add or remove the class\n   * @return {DOMElement} the element passed in\n   */\n  conditionClass: function(element, className, bool) {\n    return (bool ? CSSCore.addClass : CSSCore.removeClass)(element, className);\n  },\n\n  /**\n   * Tests whether the element has the class specified.\n   *\n   * @param {DOMNode|DOMWindow} element the element to set the class on\n   * @param {string} className the CSS className\n   * @return {boolean} true if the element has the class, false if not\n   */\n  hasClass: function(element, className) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      !/\\s/.test(className),\n      'CSS.hasClass takes only a single class name.'\n    ) : invariant(!/\\s/.test(className)));\n    if (element.classList) {\n      return !!className && element.classList.contains(className);\n    }\n    return (' ' + element.className + ' ').indexOf(' ' + className + ' ') > -1;\n  }\n\n};\n\nmodule.exports = CSSCore;\n","/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ExecutionEnvironment\n */\n\n/*jslint evil: true */\n\n\"use strict\";\n\nvar canUseDOM = !!(\n  typeof window !== 'undefined' &&\n  window.document &&\n  window.document.createElement\n);\n\n/**\n * Simple, lightweight module assisting with the detection and context of\n * Worker. Helps avoid circular dependencies and allows code to reason about\n * whether or not they are in a Worker, even if they never include the main\n * `ReactWorker` dependency.\n */\nvar ExecutionEnvironment = {\n\n  canUseDOM: canUseDOM,\n\n  canUseWorkers: typeof Worker !== 'undefined',\n\n  canUseEventListeners:\n    canUseDOM && !!(window.addEventListener || window.attachEvent),\n\n  canUseViewport: canUseDOM && !!window.screen,\n\n  isInWorker: !canUseDOM // For now, this is true - might change in the future.\n\n};\n\nmodule.exports = ExecutionEnvironment;\n","/**\n * Copyright 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule Object.assign\n */\n\n// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign\n\nfunction assign(target, sources) {\n  if (target == null) {\n    throw new TypeError('Object.assign target cannot be null or undefined');\n  }\n\n  var to = Object(target);\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {\n    var nextSource = arguments[nextIndex];\n    if (nextSource == null) {\n      continue;\n    }\n\n    var from = Object(nextSource);\n\n    // We don't currently support accessors nor proxies. Therefore this\n    // copy cannot throw. If we ever supported this then we must handle\n    // exceptions and side-effects. We don't support symbols so they won't\n    // be transferred.\n\n    for (var key in from) {\n      if (hasOwnProperty.call(from, key)) {\n        to[key] = from[key];\n      }\n    }\n  }\n\n  return to;\n};\n\nmodule.exports = assign;\n","/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactTransitionEvents\n */\n\n\"use strict\";\n\nvar ExecutionEnvironment = require(\"./ExecutionEnvironment\");\n\n/**\n * EVENT_NAME_MAP is used to determine which event fired when a\n * transition/animation ends, based on the style property used to\n * define that event.\n */\nvar EVENT_NAME_MAP = {\n  transitionend: {\n    'transition': 'transitionend',\n    'WebkitTransition': 'webkitTransitionEnd',\n    'MozTransition': 'mozTransitionEnd',\n    'OTransition': 'oTransitionEnd',\n    'msTransition': 'MSTransitionEnd'\n  },\n\n  animationend: {\n    'animation': 'animationend',\n    'WebkitAnimation': 'webkitAnimationEnd',\n    'MozAnimation': 'mozAnimationEnd',\n    'OAnimation': 'oAnimationEnd',\n    'msAnimation': 'MSAnimationEnd'\n  }\n};\n\nvar endEvents = [];\n\nfunction detectEvents() {\n  var testEl = document.createElement('div');\n  var style = testEl.style;\n\n  // On some platforms, in particular some releases of Android 4.x,\n  // the un-prefixed \"animation\" and \"transition\" properties are defined on the\n  // style object but the events that fire will still be prefixed, so we need\n  // to check if the un-prefixed events are useable, and if not remove them\n  // from the map\n  if (!('AnimationEvent' in window)) {\n    delete EVENT_NAME_MAP.animationend.animation;\n  }\n\n  if (!('TransitionEvent' in window)) {\n    delete EVENT_NAME_MAP.transitionend.transition;\n  }\n\n  for (var baseEventName in EVENT_NAME_MAP) {\n    var baseEvents = EVENT_NAME_MAP[baseEventName];\n    for (var styleName in baseEvents) {\n      if (styleName in style) {\n        endEvents.push(baseEvents[styleName]);\n        break;\n      }\n    }\n  }\n}\n\nif (ExecutionEnvironment.canUseDOM) {\n  detectEvents();\n}\n\n// We use the raw {add|remove}EventListener() call because EventListener\n// does not know how to remove event listeners and we really should\n// clean up. Also, these events are not triggered in older browsers\n// so we should be A-OK here.\n\nfunction addEventListener(node, eventName, eventListener) {\n  node.addEventListener(eventName, eventListener, false);\n}\n\nfunction removeEventListener(node, eventName, eventListener) {\n  node.removeEventListener(eventName, eventListener, false);\n}\n\nvar ReactTransitionEvents = {\n  addEndEventListener: function(node, eventListener) {\n    if (endEvents.length === 0) {\n      // If CSS transitions are not supported, trigger an \"end animation\"\n      // event immediately.\n      window.setTimeout(eventListener, 0);\n      return;\n    }\n    endEvents.forEach(function(endEvent) {\n      addEventListener(node, endEvent, eventListener);\n    });\n  },\n\n  removeEndEventListener: function(node, eventListener) {\n    if (endEvents.length === 0) {\n      return;\n    }\n    endEvents.forEach(function(endEvent) {\n      removeEventListener(node, endEvent, eventListener);\n    });\n  }\n};\n\nmodule.exports = ReactTransitionEvents;\n","/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule cx\n */\n\n/**\n * This function is used to mark string literals representing CSS class names\n * so that they can be transformed statically. This allows for modularization\n * and minification of CSS class names.\n *\n * In static_upstream, this function is actually implemented, but it should\n * eventually be replaced with something more descriptive, and the transform\n * that is used in the main stack should be ported for use elsewhere.\n *\n * @param string|object className to modularize, or an object of key/values.\n *                      In the object case, the values are conditions that\n *                      determine if the className keys should be included.\n * @param [string ...]  Variable list of classNames in the string case.\n * @return string       Renderable space-separated CSS className.\n */\nfunction cx(classNames) {\n  if (typeof classNames == 'object') {\n    return Object.keys(classNames).filter(function(className) {\n      return classNames[className];\n    }).join(' ');\n  } else {\n    return Array.prototype.join.call(arguments, ' ');\n  }\n}\n\nmodule.exports = cx;\n","/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule emptyFunction\n */\n\nfunction makeEmptyFunction(arg) {\n  return function() {\n    return arg;\n  };\n}\n\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\nfunction emptyFunction() {}\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\nemptyFunction.thatReturnsThis = function() { return this; };\nemptyFunction.thatReturnsArgument = function(arg) { return arg; };\n\nmodule.exports = emptyFunction;\n","/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule invariant\n */\n\n\"use strict\";\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (\"production\" !== process.env.NODE_ENV) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        'Invariant Violation: ' +\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n","/**\n * Copyright 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule warning\n */\n\n\"use strict\";\n\nvar emptyFunction = require(\"./emptyFunction\");\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = emptyFunction;\n\nif (\"production\" !== process.env.NODE_ENV) {\n  warning = function(condition, format ) {for (var args=[],$__0=2,$__1=arguments.length;$__0<$__1;$__0++) args.push(arguments[$__0]);\n    if (format === undefined) {\n      throw new Error(\n        '`warning(condition, format, ...args)` requires a warning ' +\n        'message argument'\n      );\n    }\n\n    if (!condition) {\n      var argIndex = 0;\n      console.warn('Warning: ' + format.replace(/%s/g, function()  {return args[argIndex++];}));\n    }\n  };\n}\n\nmodule.exports = warning;\n","module.exports={\n  \"name\": \"immutable\",\n  \"version\": \"4.0.0-rc.12\",\n  \"description\": \"Immutable Data Collections\",\n  \"license\": \"MIT\",\n  \"homepage\": \"https://immutable-js.com\",\n  \"author\": {\n    \"name\": \"Lee Byron\",\n    \"url\": \"https://github.com/leebyron\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/immutable-js/immutable-js.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/immutable-js/immutable-js/issues\"\n  },\n  \"main\": \"dist/immutable.js\",\n  \"module\": \"dist/immutable.es.js\",\n  \"typings\": \"dist/immutable-nonambient.d.ts\",\n  \"typescript\": {\n    \"definition\": \"dist/immutable.d.ts\"\n  },\n  \"scripts\": {\n    \"build\": \"run-s build:*\",\n    \"build:dist\": \"run-s clean:dist bundle:dist bundle:es copy:dist stats:dist prepare:dist\",\n    \"build:pages\": \"gulp --gulpfile ./resources/gulpfile.js default\",\n    \"stats:dist\": \"node ./resources/dist-stats.js\",\n    \"clean:dist\": \"rimraf dist\",\n    \"bundle:dist\": \"rollup -c ./resources/rollup-config.js\",\n    \"bundle:es\": \"rollup -c ./resources/rollup-config-es.js\",\n    \"copy:dist\": \"node ./resources/copy-dist-typedefs.js\",\n    \"prepare:dist\": \"./resources/prepare-dist.sh\",\n    \"format\": \"npm run lint:format -- --write\",\n    \"lint\": \"run-s lint:*\",\n    \"lint:ts\": \"tslint \\\"__tests__/**/*.ts\\\"\",\n    \"lint:js\": \"eslint \\\"{__tests__,src,pages/src,pages/lib}/**/*.js\\\"\",\n    \"lint:format\": \"prettier --check \\\"{__tests__,src,pages/src,pages/lib,perf,resources}/**/*{\\\\.js,\\\\.ts}\\\"\",\n    \"testonly\": \"./resources/jest\",\n    \"test\": \"run-s format build lint testonly test:types\",\n    \"check:git-clean\": \"./resources/check-changes\",\n    \"test:types\": \"run-s test:types:*\",\n    \"test:types:ts\": \"tsc ./type-definitions/Immutable.d.ts --lib es2015 && dtslint type-definitions/ts-tests\",\n    \"test:types:flow\": \"flow check type-definitions/tests --include-warnings\",\n    \"perf\": \"node ./resources/bench.js\",\n    \"start\": \"gulp --gulpfile ./resources/gulpfile.js dev\"\n  },\n  \"prettier\": {\n    \"singleQuote\": true,\n    \"trailingComma\": \"es5\",\n    \"semi\": true,\n    \"arrowParens\": \"avoid\"\n  },\n  \"jest\": {\n    \"moduleFileExtensions\": [\n      \"js\",\n      \"ts\"\n    ],\n    \"transform\": {\n      \"^.+\\\\.ts$\": \"<rootDir>/resources/jestPreprocessor.js\"\n    },\n    \"testRegex\": \"/__tests__/.*\\\\.(ts|js)$\",\n    \"unmockedModulePathPatterns\": [\n      \"./node_modules/react\"\n    ]\n  },\n  \"devDependencies\": {\n    \"benchmark\": \"2.1.4\",\n    \"browser-sync\": \"^2.26.12\",\n    \"browserify\": \"16.5.2\",\n    \"colors\": \"1.4.0\",\n    \"del\": \"6.0.0\",\n    \"dtslint\": \"4.1.0\",\n    \"eslint\": \"7.11.0\",\n    \"eslint-config-airbnb\": \"18.2.0\",\n    \"eslint-config-prettier\": \"6.12.0\",\n    \"eslint-plugin-import\": \"2.22.1\",\n    \"eslint-plugin-jsx-a11y\": \"6.3.1\",\n    \"eslint-plugin-prettier\": \"3.1.4\",\n    \"eslint-plugin-react\": \"7.21.4\",\n    \"flow-bin\": \"0.85.0\",\n    \"gulp\": \"4.0.2\",\n    \"gulp-concat\": \"2.6.1\",\n    \"gulp-filter\": \"6.0.0\",\n    \"gulp-header\": \"2.0.9\",\n    \"gulp-less\": \"4.0.1\",\n    \"gulp-size\": \"3.0.0\",\n    \"gulp-sourcemaps\": \"2.6.5\",\n    \"gulp-uglify\": \"3.0.2\",\n    \"gulp-util\": \"3.0.8\",\n    \"jasmine-check\": \"0.1.5\",\n    \"jest\": \"26.5.2\",\n    \"marked\": \"1.2.0\",\n    \"microtime\": \"3.0.0\",\n    \"mkdirp\": \"1.0.4\",\n    \"npm-run-all\": \"4.1.5\",\n    \"prettier\": \"^2.3.1\",\n    \"react\": \"^0.12.2\",\n    \"react-router\": \"^0.11.6\",\n    \"react-tools\": \"0.13.3\",\n    \"rimraf\": \"3.0.2\",\n    \"rollup\": \"2.29.0\",\n    \"rollup-plugin-buble\": \"0.19.2\",\n    \"rollup-plugin-commonjs\": \"9.1.3\",\n    \"rollup-plugin-json\": \"3.0.0\",\n    \"rollup-plugin-strip-banner\": \"2.0.0\",\n    \"through2\": \"4.0.2\",\n    \"transducers-js\": \"^0.4.174\",\n    \"tslint\": \"5.20.1\",\n    \"typescript\": \"3.0.3\",\n    \"uglify-js\": \"3.11.1\",\n    \"uglify-save-license\": \"0.4.1\",\n    \"vinyl-buffer\": \"1.0.1\",\n    \"vinyl-source-stream\": \"2.0.0\"\n  },\n  \"files\": [\n    \"dist\",\n    \"contrib\",\n    \"README.md\",\n    \"LICENSE\"\n  ],\n  \"keywords\": [\n    \"immutable\",\n    \"persistent\",\n    \"lazy\",\n    \"data\",\n    \"datastructure\",\n    \"functional\",\n    \"collection\",\n    \"stateless\",\n    \"sequence\",\n    \"iteration\"\n  ]\n}\n","module.exports={\"Immutable\":{\"doc\":{\"synopsis\":\"Immutable data encourages pure functions (data-in, data-out) and lends itself\\nto much simpler application development and enabling techniques from\\nfunctional programming such as lazy evaluation.\",\"description\":\"While designed to bring these powerful functional concepts to JavaScript, it\\npresents an Object-Oriented API familiar to Javascript engineers and closely\\nmirroring that of Array, Map, and Set. It is easy and efficient to convert to\\nand from plain Javascript types.\\n\\n## How to read these docs\\n\\nIn order to better explain what kinds of values the Immutable.js API expects\\nand produces, this documentation is presented in a statically typed dialect of\\nJavaScript (like [Flow][] or [TypeScript][]). You *don't need* to use these\\ntype checking tools in order to use Immutable.js, however becoming familiar\\nwith their syntax will help you get a deeper understanding of this API.\\n\\n**A few examples and how to read them.**\\n\\nAll methods describe the kinds of data they accept and the kinds of data\\nthey return. For example a function which accepts two numbers and returns\\na number would look like this:\\n\\n```js\\nsum(first: number, second: number): number\\n```\\n\\nSometimes, methods can accept different kinds of data or return different\\nkinds of data, and this is described with a *type variable*, which is\\ntypically in all-caps. For example, a function which always returns the same\\nkind of data it was provided would look like this:\\n\\n```js\\nidentity<T>(value: T): T\\n```\\n\\nType variables are defined with classes and referred to in methods. For\\nexample, a class that holds onto a value for you might look like this:\\n\\n```js\\nclass Box<T> {\\n  constructor(value: T)\\n  getValue(): T\\n}\\n```\\n\\nIn order to manipulate Immutable data, methods that we're used to affecting\\na Collection instead return a new Collection of the same type. The type\\n`this` refers to the same kind of class. For example, a List which returns\\nnew Lists when you `push` a value onto it might look like:\\n\\n```js\\nclass List<T> {\\n  push(value: T): this\\n}\\n```\\n\\nMany methods in Immutable.js accept values which implement the JavaScript\\n[Iterable][] protocol, and might appear like `Iterable<string>` for something\\nwhich represents sequence of strings. Typically in JavaScript we use plain\\nArrays (`[]`) when an Iterable is expected, but also all of the Immutable.js\\ncollections are iterable themselves!\\n\\nFor example, to get a value deep within a structure of data, we might use\\n`getIn` which expects an `Iterable` path:\\n\\n```\\ngetIn(path: Iterable<string | number>): unknown\\n```\\n\\nTo use this method, we could pass an array: `data.getIn([ \\\"key\\\", 2 ])`.\\n\\n\\nNote: All examples are presented in the modern [ES2015][] version of\\nJavaScript. Use tools like Babel to support older browsers.\\n\\nFor example:\\n\\n```js\\n// ES2015\\nconst mappedFoo = foo.map(x => x * x);\\n// ES5\\nvar mappedFoo = foo.map(function (x) { return x * x; });\\n```\\n\\n[ES2015]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla\\n[TypeScript]: https://www.typescriptlang.org/\\n[Flow]: https://flowtype.org/\\n[Iterable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\",\"notes\":[]},\"module\":{\"List\":{\"doc\":{\"synopsis\":\"Lists are ordered indexed dense collections, much like a JavaScript\\nArray.\",\"description\":\"Lists are immutable and fully persistent with O(log32 N) gets and sets,\\nand O(1) push and pop.\\n\\nLists implement Deque, with efficient addition and removal from both the\\nend (`push`, `pop`) and beginning (`unshift`, `shift`).\\n\\nUnlike a JavaScript Array, there is no distinction between an\\n\\\"unset\\\" index and an index set to `undefined`. `List#forEach` visits all\\nindices from 0 to size, regardless of whether they were explicitly defined.\",\"notes\":[]},\"module\":{\"isList\":{\"call\":{\"doc\":{\"synopsis\":\"True if the provided value is a List\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable');\\nList.isList([]); // false\\nList.isList(List()); // true\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeList\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":120}]}},\"of\":{\"call\":{\"doc\":{\"synopsis\":\"Creates a new List containing `values`.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable');\\nList.of(1, 2, 3, 4)\\n// List [ 1, 2, 3, 4 ]\\n```\\n\\nNote: Values are not altered or converted in any way.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable');\\nList.of({x:1}, 2, [3], 4)\\n// List [ { x: 1 }, 2, [ 3 ], 4 ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":141}]}}},\"call\":{\"doc\":{\"synopsis\":\"Create a new immutable List containing the values of the provided\\ncollection-like.\",\"description\":\"Note: `List` is a factory function and not a class, and does not use the\\n`new` keyword during construction.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { List, Set } = require('immutable')\\n\\nconst emptyList = List()\\n// List []\\n\\nconst plainArray = [ 1, 2, 3, 4 ]\\nconst listFromPlainArray = List(plainArray)\\n// List [ 1, 2, 3, 4 ]\\n\\nconst plainSet = Set([ 1, 2, 3, 4 ])\\nconst listFromPlainSet = List(plainSet)\\n// List [ 1, 2, 3, 4 ]\\n\\nconst arrayIterator = plainArray[Symbol.iterator]()\\nconst listFromCollectionArray = List(arrayIterator)\\n// List [ 1, 2, 3, 4 ]\\n\\nlistFromPlainArray.equals(listFromCollectionArray) // true\\nlistFromPlainSet.equals(listFromCollectionArray) // true\\nlistFromPlainSet.equals(listFromPlainArray) // true\\n```\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":17}]},\"line\":175},{\"typeParams\":[\"T\"],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":176},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":177}]},\"interface\":{\"line\":179,\"typeParams\":[\"T\"],\"extends\":[{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]}],\"groups\":[{\"members\":{\"#size\":{\"line\":184}}},{\"title\":\"Persistent changes\",\"members\":{\"#set\":{\"doc\":{\"synopsis\":\"Returns a new List which includes `value` at `index`. If `index` already\\nexists in this List, it will be replaced.\",\"description\":\"`index` may be a negative number, which indexes back from the end of the\\nList. `v.set(-1, \\\"value\\\")` sets the last item in the List.\\n\\nIf `index` larger than `size`, the returned List's `size` will be large\\nenough to include the `index`.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nconst originalList = List([ 0 ]);\\n// List [ 0 ]\\noriginalList.set(1, 1);\\n// List [ 0, 1 ]\\noriginalList.set(0, 'overwritten');\\n// List [ \\\"overwritten\\\" ]\\noriginalList.set(2, 2);\\n// List [ 0, undefined, 2 ]\\n\\nList().set(50000, 'value').size;\\n// 50001\\n```\\n\\nNote: `set` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":217}]},\"#delete\":{\"doc\":{\"synopsis\":\"Returns a new List which excludes this `index` and with a size 1 less\\nthan this List. Values at indices above `index` are shifted down by 1 to\\nfill the position.\",\"description\":\"This is synonymous with `list.splice(index, 1)`.\\n\\n`index` may be a negative number, which indexes back from the end of the\\nList. `v.delete(-1)` deletes the last item in the List.\\n\\nNote: `delete` cannot be safely used in IE8\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nList([ 0, 1, 2, 3, 4 ]).delete(0);\\n// List [ 1, 2, 3, 4 ]\\n```\\n\\nSince `delete()` re-indexes values, it produces a complete copy, which\\nhas `O(N)` complexity.\\n\\nNote: `delete` *cannot* be used in `withMutations`.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"remove\"}]},\"signatures\":[{\"params\":[{\"name\":\"index\",\"type\":{\"k\":2}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":246}]},\"#insert\":{\"doc\":{\"synopsis\":\"Returns a new List with `value` at `index` with a size 1 more than this\\nList. Values at indices above `index` are shifted over by 1.\",\"description\":\"This is synonymous with `list.splice(index, 0, value)`.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nList([ 0, 1, 2, 3, 4 ]).insert(6, 5)\\n// List [ 0, 1, 2, 3, 4, 5 ]\\n```\\n\\nSince `insert()` re-indexes values, it produces a complete copy, which\\nhas `O(N)` complexity.\\n\\nNote: `insert` *cannot* be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":268}]},\"#clear\":{\"doc\":{\"synopsis\":\"Returns a new List with 0 size and no values in constant time.\",\"description\":\"<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nList([ 1, 2, 3, 4 ]).clear()\\n// List []\\n```\\n\\nNote: `clear` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":283}]},\"#push\":{\"doc\":{\"synopsis\":\"Returns a new List with the provided `values` appended, starting at this\\nList's `size`.\",\"description\":\"<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nList([ 1, 2, 3, 4 ]).push(5)\\n// List [ 1, 2, 3, 4, 5 ]\\n```\\n\\nNote: `push` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":299}]},\"#pop\":{\"doc\":{\"synopsis\":\"Returns a new List with a size ones less than this List, excluding\\nthe last index in this List.\",\"description\":\"Note: this differs from `Array#pop` because it returns a new\\nList rather than the removed value. Use `last()` to get the last value\\nin this List.\\n\\n```js\\nList([ 1, 2, 3, 4 ]).pop()\\n// List[ 1, 2, 3 ]\\n```\\n\\nNote: `pop` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":316}]},\"#unshift\":{\"doc\":{\"synopsis\":\"Returns a new List with the provided `values` prepended, shifting other\\nvalues ahead to higher indices.\",\"description\":\"<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nList([ 2, 3, 4]).unshift(1);\\n// List [ 1, 2, 3, 4 ]\\n```\\n\\nNote: `unshift` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":332}]},\"#shift\":{\"doc\":{\"synopsis\":\"Returns a new List with a size ones less than this List, excluding\\nthe first index in this List, shifting all other values to a lower index.\",\"description\":\"Note: this differs from `Array#shift` because it returns a new\\nList rather than the removed value. Use `first()` to get the first\\nvalue in this List.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nList([ 0, 1, 2, 3, 4 ]).shift();\\n// List [ 1, 2, 3, 4 ]\\n```\\n\\nNote: `shift` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":352}]},\"#update\":{\"doc\":{\"synopsis\":\"Returns a new List with an updated value at `index` with the return\\nvalue of calling `updater` with the existing value, or `notSetValue` if\\n`index` was not set. If called with a single argument, `updater` is\\ncalled with the List itself.\",\"description\":\"`index` may be a negative number, which indexes back from the end of the\\nList. `v.update(-1)` updates the last item in the List.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nconst list = List([ 'a', 'b', 'c' ])\\nconst result = list.update(2, val => val.toUpperCase())\\n// List [ \\\"a\\\", \\\"b\\\", \\\"C\\\" ]\\n```\\n\\nThis can be very useful as a way to \\\"chain\\\" a normal function into a\\nsequence of methods. RxJS calls this \\\"let\\\" and lodash calls it \\\"thru\\\".\\n\\nFor example, to sum a List after mapping and filtering:\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nfunction sum(collection) {\\n  return collection.reduce((sum, x) => sum + x, 0)\\n}\\n\\nList([ 1, 2, 3 ])\\n  .map(x => x + 1)\\n  .filter(x => x % 2 === 0)\\n  .update(sum)\\n// 6\\n```\\n\\nNote: `update(index)` can be used in `withMutations`.\\n\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#update`\"}]},\"signatures\":[{\"params\":[{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":8,\"param\":\"T\"}}}],\"type\":{\"k\":10},\"line\":396},{\"params\":[{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":8,\"param\":\"T\"}}}],\"type\":{\"k\":10},\"line\":397},{\"typeParams\":[\"R\"],\"params\":[{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"R\"}}}],\"type\":{\"k\":8,\"param\":\"R\"},\"line\":398}]},\"#setSize\":{\"doc\":{\"synopsis\":\"Returns a new List with size `size`. If `size` is less than this\\nList's size, the new List will exclude values at the higher indices.\\nIf `size` is greater than this List's size, the new List will have\\nundefined values for the newly available indices.\",\"description\":\"When building a new List and the final size is known up front, `setSize`\\nused in conjunction with `withMutations` may result in the more\\nperformant construction.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"size\",\"type\":{\"k\":2}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":410}]}}},{\"title\":\"Deep persistent changes\",\"members\":{\"#setIn\":{\"doc\":{\"synopsis\":\"Returns a new List having set `value` at this `keyPath`. If any keys in\\n`keyPath` do not exist, a new immutable Map will be created at that key.\",\"description\":\"Index numbers are used as keys to determine the path to follow in\\nthe List.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nconst list = List([ 0, 1, 2, List([ 3, 4 ])])\\nlist.setIn([3, 0], 999);\\n// List [ 0, 1, 2, List [ 999, 4 ] ]\\n```\\n\\nPlain JavaScript Object or Arrays may be nested within an Immutable.js\\nCollection, and setIn() can update those values as well, treating them\\nimmutably by creating new copies of those values with the changes applied.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nconst list = List([ 0, 1, 2, { plain: 'object' }])\\nlist.setIn([3, 'plain'], 'value');\\n// List([ 0, 1, 2, { plain: 'value' }])\\n```\\n\\nNote: `setIn` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":10},\"line\":444}]},\"#deleteIn\":{\"doc\":{\"synopsis\":\"Returns a new List having removed the value at this `keyPath`. If any\\nkeys in `keyPath` do not exist, no change will occur.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nconst list = List([ 0, 1, 2, List([ 3, 4 ])])\\nlist.deleteIn([3, 0]);\\n// List [ 0, 1, 2, List [ 4 ] ]\\n```\\n\\nPlain JavaScript Object or Arrays may be nested within an Immutable.js\\nCollection, and removeIn() can update those values as well, treating them\\nimmutably by creating new copies of those values with the changes applied.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nconst list = List([ 0, 1, 2, { plain: 'object' }])\\nlist.removeIn([3, 'plain']);\\n// List([ 0, 1, 2, {}])\\n```\\n\\nNote: `deleteIn` *cannot* be safely used in `withMutations`.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"removeIn\"}]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}}],\"type\":{\"k\":10},\"line\":474}]},\"#updateIn\":{\"doc\":{\"synopsis\":\"Note: `updateIn` can be used in `withMutations`.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#updateIn`\"}]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"notSetValue\",\"type\":{\"k\":17}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":482},{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":483}]},\"#mergeIn\":{\"doc\":{\"synopsis\":\"Note: `mergeIn` can be used in `withMutations`.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#mergeIn`\"}]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":490}]},\"#mergeDeepIn\":{\"doc\":{\"synopsis\":\"Note: `mergeDeepIn` can be used in `withMutations`.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#mergeDeepIn`\"}]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":497}]}}},{\"title\":\"Transient changes\",\"members\":{\"#withMutations\":{\"doc\":{\"synopsis\":\"Note: Not all methods can be safely used on a mutable collection or within\\n`withMutations`! Check the documentation for each method to see if it\\nallows being used in `withMutations`.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#withMutations`\"}]},\"signatures\":[{\"params\":[{\"name\":\"mutator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"mutable\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":508}]},\"#asMutable\":{\"doc\":{\"synopsis\":\"An alternative API for withMutations()\",\"description\":\"Note: Not all methods can be safely used on a mutable collection or within\\n`withMutations`! Check the documentation for each method to see if it\\nallows being used in `withMutations`.\\n\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asMutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":519}]},\"#wasAltered\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#wasAltered`\"}]},\"signatures\":[{\"type\":{\"k\":1},\"line\":524}]},\"#asImmutable\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asImmutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":529}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new List with other values or collections concatenated to this one.\",\"description\":\"Note: `concat` can be used in `withMutations`.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"merge\"}]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"valuesOrCollections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"C\"}]},{\"k\":8,\"param\":\"C\"}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":540}]},\"#map\":{\"doc\":{\"synopsis\":\"Returns a new List with values passed through a\\n`mapper` function.\",\"description\":\"<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nList([ 1, 2 ]).map(x => 10 * x)\\n// List [ 10, 20 ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":555}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the List, returning a new List.\",\"description\":\"Similar to `list.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":565}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new List with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"F\"}]},\"line\":577},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":581}]},\"#zip\":{\"doc\":{\"synopsis\":\"Returns a List \\\"zipped\\\" with the provided collection.\",\"description\":\"Like `zipWith`, but using the default `zipper`: creating an `Array`.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nconst a = List([ 1, 2, 3 ]);\\nconst b = List([ 4, 5, 6 ]);\\nconst c = a.zip(b); // List [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":600},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":601},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":17}]},\"line\":602}]},\"#zipAll\":{\"doc\":{\"synopsis\":\"Returns a List \\\"zipped\\\" with the provided collections.\",\"description\":\"Unlike `zip`, `zipAll` continues zipping until the longest collection is\\nexhausted. Missing values from shorter collections are filled with `undefined`.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nconst a = List([ 1, 2 ]);\\nconst b = List([ 3, 4, 5 ]);\\nconst c = a.zipAll(b); // List [ [ 1, 3 ], [ 2, 4 ], [ undefined, 5 ] ]\\n```\\n\\nNote: Since zipAll will return a collection as large as the largest\\ninput, some results may contain undefined values. TypeScript cannot\\naccount for these without cases (as of v2.5).\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":623},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":624},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":17}]},\"line\":625}]},\"#zipWith\":{\"doc\":{\"synopsis\":\"Returns a List \\\"zipped\\\" with the provided collections by using a\\ncustom `zipper` function.\",\"description\":\"<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nconst a = List([ 1, 2, 3 ]);\\nconst b = List([ 4, 5, 6 ]);\\nconst c = a.zipWith((a, b) => a + b, b);\\n// List [ 5, 7, 9 ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":641},{\"typeParams\":[\"U\",\"V\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}},{\"name\":\"thirdValue\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"thirdCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":645},{\"typeParams\":[\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"any\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":650}]}}}]}},\"Map\":{\"doc\":{\"synopsis\":\"Immutable Map is an unordered Collection.Keyed of (key, value) pairs with\\n`O(log32 N)` gets and `O(log32 N)` persistent sets.\",\"description\":\"Iteration order of a Map is undefined, however is stable. Multiple\\niterations of the same Map will iterate in the same order.\\n\\nMap's keys can be of any type, and use `Immutable.is` to determine key\\nequality. This allows the use of any value (including NaN) as a key.\\n\\nBecause `Immutable.is` returns equality based on value semantics, and\\nImmutable collections are treated as values, any Immutable collection may\\nbe used as a key.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map, List } = require('immutable');\\nMap().set(List([ 1 ]), 'listofone').get(List([ 1 ]));\\n// 'listofone'\\n```\\n\\nAny JavaScript object may be used as a key, however strict identity is used\\nto evaluate key equality. Two similar looking objects will represent two\\ndifferent keys.\\n\\nImplemented by a hash-array mapped trie.\",\"notes\":[]},\"module\":{\"isMap\":{\"call\":{\"doc\":{\"synopsis\":\"True if the provided value is a Map\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap.isMap({}) // false\\nMap.isMap(Map()) // true\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeMap\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":696}]}}},\"call\":{\"doc\":{\"synopsis\":\"Creates a new Immutable Map.\",\"description\":\"Created with the same key value pairs as the provided Collection.Keyed or\\nJavaScript Object or expects a Collection of [K, V] tuple entries.\\n\\nNote: `Map` is a factory function and not a class, and does not use the\\n`new` keyword during construction.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap({ key: \\\"value\\\" })\\nMap([ [ \\\"key\\\", \\\"value\\\" ] ])\\n```\\n\\nKeep in mind, when using JS objects to construct Immutable Maps, that\\nJavaScript Object properties are always strings, even if written in a\\nquote-less shorthand, while Immutable Maps accept keys of any type.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable');\\\" }\\n-->\\n```js\\nlet obj = { 1: \\\"one\\\" }\\nObject.keys(obj) // [ \\\"1\\\" ]\\nassert.equal(obj[\\\"1\\\"], obj[1]) // \\\"one\\\" === \\\"one\\\"\\n\\nlet map = Map(obj)\\nassert.notEqual(map.get(\\\"1\\\"), map.get(1)) // \\\"one\\\" !== undefined\\n```\\n\\nProperty access for JavaScript Objects first converts the key to a string,\\nbut since Immutable Map keys can be of any type the argument to `get()` is\\nnot altered.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\",\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]}}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":753},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"obj\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":3},{\"k\":8,\"param\":\"V\"}]},\"line\":754},{\"typeParams\":[\"K\",\"V\"],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":755},{\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":17},{\"k\":17}]},\"line\":756}]},\"interface\":{\"line\":758,\"typeParams\":[\"K\",\"V\"],\"extends\":[{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}],\"groups\":[{\"members\":{\"#size\":{\"line\":763}}},{\"title\":\"Persistent changes\",\"members\":{\"#set\":{\"doc\":{\"synopsis\":\"Returns a new Map also containing the new key, value pair. If an equivalent\\nkey already exists in this Map, it will be replaced.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst originalMap = Map()\\nconst newerMap = originalMap.set('key', 'value')\\nconst newestMap = newerMap.set('key', 'newer value')\\n\\noriginalMap\\n// Map {}\\nnewerMap\\n// Map { \\\"key\\\": \\\"value\\\" }\\nnewestMap\\n// Map { \\\"key\\\": \\\"newer value\\\" }\\n```\\n\\nNote: `set` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":10},\"line\":788}]},\"#delete\":{\"doc\":{\"synopsis\":\"Returns a new Map which excludes this `key`.\",\"description\":\"Note: `delete` cannot be safely used in IE8, but is provided to mirror\\nthe ES6 collection API.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst originalMap = Map({\\n  key: 'value',\\n  otherKey: 'other value'\\n})\\n// Map { \\\"key\\\": \\\"value\\\", \\\"otherKey\\\": \\\"other value\\\" }\\noriginalMap.delete('otherKey')\\n// Map { \\\"key\\\": \\\"value\\\" }\\n```\\n\\nNote: `delete` can be used in `withMutations`.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"remove\"}]},\"signatures\":[{\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":10},\"line\":812}]},\"#deleteAll\":{\"doc\":{\"synopsis\":\"Returns a new Map which excludes the provided `keys`.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst names = Map({ a: \\\"Aaron\\\", b: \\\"Barry\\\", c: \\\"Connor\\\" })\\nnames.deleteAll([ 'a', 'c' ])\\n// Map { \\\"b\\\": \\\"Barry\\\" }\\n```\\n\\nNote: `deleteAll` can be used in `withMutations`.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"removeAll\"}]},\"signatures\":[{\"params\":[{\"name\":\"keys\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"K\"}]}}],\"type\":{\"k\":10},\"line\":830}]},\"#clear\":{\"doc\":{\"synopsis\":\"Returns a new Map containing no keys or values.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap({ key: 'value' }).clear()\\n// Map {}\\n```\\n\\nNote: `clear` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":845}]},\"#update\":{\"doc\":{\"synopsis\":\"Returns a new Map having updated the value at this `key` with the return\\nvalue of calling `updater` with the existing value.\",\"description\":\"Similar to: `map.set(key, updater(map.get(key)))`.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst aMap = Map({ key: 'value' })\\nconst newMap = aMap.update('key', value => value + value)\\n// Map { \\\"key\\\": \\\"valuevalue\\\" }\\n```\\n\\nThis is most commonly used to call methods on collections within a\\nstructure of data. For example, in order to `.push()` onto a nested `List`,\\n`update` and `push` can be used together:\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map, List } = require('immutable');\\\" }\\n-->\\n```js\\nconst aMap = Map({ nestedList: List([ 1, 2, 3 ]) })\\nconst newMap = aMap.update('nestedList', list => list.push(4))\\n// Map { \\\"nestedList\\\": List [ 1, 2, 3, 4 ] }\\n```\\n\\nWhen a `notSetValue` is provided, it is provided to the `updater`\\nfunction when the value at the key does not exist in the Map.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable');\\\" }\\n-->\\n```js\\nconst aMap = Map({ key: 'value' })\\nconst newMap = aMap.update('noKey', 'no value', value => value + value)\\n// Map { \\\"key\\\": \\\"value\\\", \\\"noKey\\\": \\\"no valueno value\\\" }\\n```\\n\\nHowever, if the `updater` function returns the same value it was called\\nwith, then no change will occur. This is still true if `notSetValue`\\nis provided.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable');\\\" }\\n-->\\n```js\\nconst aMap = Map({ apples: 10 })\\nconst newMap = aMap.update('oranges', 0, val => val)\\n// Map { \\\"apples\\\": 10 }\\nassert.strictEqual(newMap, map);\\n```\\n\\nFor code using ES2015 or later, using `notSetValue` is discourged in\\nfavor of function parameter default values. This helps to avoid any\\npotential confusion with identify functions as described above.\\n\\nThe previous example behaves differently when written with default values:\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable');\\\" }\\n-->\\n```js\\nconst aMap = Map({ apples: 10 })\\nconst newMap = aMap.update('oranges', (val = 0) => val)\\n// Map { \\\"apples\\\": 10, \\\"oranges\\\": 0 }\\n```\\n\\nIf no key is provided, then the `updater` function return value is\\nreturned as well.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable');\\\" }\\n-->\\n```js\\nconst aMap = Map({ key: 'value' })\\nconst result = aMap.update(aMap => aMap.get('key'))\\n// \\\"value\\\"\\n```\\n\\nThis can be very useful as a way to \\\"chain\\\" a normal function into a\\nsequence of methods. RxJS calls this \\\"let\\\" and lodash calls it \\\"thru\\\".\\n\\nFor example, to sum the values in a Map\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable');\\\" }\\n-->\\n```js\\nfunction sum(collection) {\\n  return collection.reduce((sum, x) => sum + x, 0)\\n}\\n\\nMap({ x: 1, y: 2, z: 3 })\\n  .map(x => x + 1)\\n  .filter(x => x % 2 === 0)\\n  .update(sum)\\n// 6\\n```\\n\\nNote: `update(key)` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"V\"}}}],\"type\":{\"k\":10},\"line\":949},{\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"V\"}}}],\"type\":{\"k\":10},\"line\":950},{\"typeParams\":[\"R\"],\"params\":[{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"R\"}}}],\"type\":{\"k\":8,\"param\":\"R\"},\"line\":951}]},\"#merge\":{\"doc\":{\"synopsis\":\"Returns a new Map resulting from merging the provided Collections\\n(or JS objects) into this Map. In other words, this takes each entry of\\neach collection and sets it on this Map.\",\"description\":\"Note: Values provided to `merge` are shallowly converted before being\\nmerged. No nested values are altered.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst one = Map({ a: 10, b: 20, c: 30 })\\nconst two = Map({ b: 40, a: 50, d: 60 })\\none.merge(two) // Map { \\\"a\\\": 50, \\\"b\\\": 40, \\\"c\\\": 30, \\\"d\\\": 60 }\\ntwo.merge(one) // Map { \\\"b\\\": 20, \\\"a\\\": 10, \\\"d\\\": 60, \\\"c\\\": 30 }\\n```\\n\\nNote: `merge` can be used in `withMutations`.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"concat\"}]},\"signatures\":[{\"typeParams\":[\"KC\",\"VC\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KC\"},{\"k\":8,\"param\":\"VC\"}]}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"KC\"}]},{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"VC\"}]}]},\"line\":974},{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"C\"}}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":3}]},{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":975}]},\"#mergeWith\":{\"doc\":{\"synopsis\":\"Like `merge()`, `mergeWith()` returns a new Map resulting from merging\\nthe provided Collections (or JS objects) into this Map, but uses the\\n`merger` function for dealing with conflicts.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst one = Map({ a: 10, b: 20, c: 30 })\\nconst two = Map({ b: 40, a: 50, d: 60 })\\none.mergeWith((oldVal, newVal) => oldVal / newVal, two)\\n// { \\\"a\\\": 0.2, \\\"b\\\": 0.5, \\\"c\\\": 30, \\\"d\\\": 60 }\\ntwo.mergeWith((oldVal, newVal) => oldVal / newVal, one)\\n// { \\\"b\\\": 2, \\\"a\\\": 5, \\\"d\\\": 60, \\\"c\\\": 30 }\\n```\\n\\nNote: `mergeWith` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"merger\",\"type\":{\"k\":7,\"params\":[{\"name\":\"oldVal\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"newVal\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":8,\"param\":\"V\"}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":997}]},\"#mergeDeep\":{\"doc\":{\"synopsis\":\"Like `merge()`, but when two Collections conflict, it merges them as well,\\nrecursing deeply through the nested data.\",\"description\":\"Note: Values provided to `merge` are shallowly converted before being\\nmerged. No nested values are altered unless they will also be merged at\\na deeper level.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst one = Map({ a: Map({ x: 10, y: 10 }), b: Map({ x: 20, y: 50 }) })\\nconst two = Map({ a: Map({ x: 2 }), b: Map({ y: 5 }), c: Map({ z: 3 }) })\\none.mergeDeep(two)\\n// Map {\\n//   \\\"a\\\": Map { \\\"x\\\": 2, \\\"y\\\": 10 },\\n//   \\\"b\\\": Map { \\\"x\\\": 20, \\\"y\\\": 5 },\\n//   \\\"c\\\": Map { \\\"z\\\": 3 }\\n// }\\n```\\n\\nNote: `mergeDeep` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":1025}]},\"#mergeDeepWith\":{\"doc\":{\"synopsis\":\"Like `mergeDeep()`, but when two non-Collections conflict, it uses the\\n`merger` function to determine the resulting value.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst one = Map({ a: Map({ x: 10, y: 10 }), b: Map({ x: 20, y: 50 }) })\\nconst two = Map({ a: Map({ x: 2 }), b: Map({ y: 5 }), c: Map({ z: 3 }) })\\none.mergeDeepWith((oldVal, newVal) => oldVal / newVal, two)\\n// Map {\\n//   \\\"a\\\": Map { \\\"x\\\": 5, \\\"y\\\": 10 },\\n//   \\\"b\\\": Map { \\\"x\\\": 20, \\\"y\\\": 10 },\\n//   \\\"c\\\": Map { \\\"z\\\": 3 }\\n// }\\n```\\n\\nNote: `mergeDeepWith` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"merger\",\"type\":{\"k\":7,\"params\":[{\"name\":\"oldVal\",\"type\":{\"k\":17}},{\"name\":\"newVal\",\"type\":{\"k\":17}},{\"name\":\"key\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":1046}]}}},{\"title\":\"Deep persistent changes\",\"members\":{\"#setIn\":{\"doc\":{\"synopsis\":\"Returns a new Map having set `value` at this `keyPath`. If any keys in\\n`keyPath` do not exist, a new immutable Map will be created at that key.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst originalMap = Map({\\n  subObject: Map({\\n    subKey: 'subvalue',\\n    subSubObject: Map({\\n      subSubKey: 'subSubValue'\\n    })\\n  })\\n})\\n\\nconst newMap = originalMap.setIn(['subObject', 'subKey'], 'ha ha!')\\n// Map {\\n//   \\\"subObject\\\": Map {\\n//     \\\"subKey\\\": \\\"ha ha!\\\",\\n//     \\\"subSubObject\\\": Map { \\\"subSubKey\\\": \\\"subSubValue\\\" }\\n//   }\\n// }\\n\\nconst newerMap = originalMap.setIn(\\n  ['subObject', 'subSubObject', 'subSubKey'],\\n  'ha ha ha!'\\n)\\n// Map {\\n//   \\\"subObject\\\": Map {\\n//     \\\"subKey\\\": \\\"subvalue\\\",\\n//     \\\"subSubObject\\\": Map { \\\"subSubKey\\\": \\\"ha ha ha!\\\" }\\n//   }\\n// }\\n```\\n\\nPlain JavaScript Object or Arrays may be nested within an Immutable.js\\nCollection, and setIn() can update those values as well, treating them\\nimmutably by creating new copies of those values with the changes applied.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst originalMap = Map({\\n  subObject: {\\n    subKey: 'subvalue',\\n    subSubObject: {\\n      subSubKey: 'subSubValue'\\n    }\\n  }\\n})\\n\\noriginalMap.setIn(['subObject', 'subKey'], 'ha ha!')\\n// Map {\\n//   \\\"subObject\\\": {\\n//     subKey: \\\"ha ha!\\\",\\n//     subSubObject: { subSubKey: \\\"subSubValue\\\" }\\n//   }\\n// }\\n```\\n\\nIf any key in the path exists but cannot be updated (such as a primitive\\nlike number or a custom Object like Date), an error will be thrown.\\n\\nNote: `setIn` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":10},\"line\":1120}]},\"#deleteIn\":{\"doc\":{\"synopsis\":\"Returns a new Map having removed the value at this `keyPath`. If any keys\\nin `keyPath` do not exist, no change will occur.\",\"description\":\"Note: `deleteIn` can be used in `withMutations`.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"removeIn\"}]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}}],\"type\":{\"k\":10},\"line\":1130}]},\"#updateIn\":{\"doc\":{\"synopsis\":\"Returns a new Map having applied the `updater` to the entry found at the\\nkeyPath.\",\"description\":\"This is most commonly used to call methods on collections nested within a\\nstructure of data. For example, in order to `.push()` onto a nested `List`,\\n`updateIn` and `push` can be used together:\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map, List } = require('immutable')\\nconst map = Map({ inMap: Map({ inList: List([ 1, 2, 3 ]) }) })\\nconst newMap = map.updateIn(['inMap', 'inList'], list => list.push(4))\\n// Map { \\\"inMap\\\": Map { \\\"inList\\\": List [ 1, 2, 3, 4 ] } }\\n```\\n\\nIf any keys in `keyPath` do not exist, new Immutable `Map`s will\\nbe created at those keys. If the `keyPath` does not already contain a\\nvalue, the `updater` function will be called with `notSetValue`, if\\nprovided, otherwise `undefined`.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable')\\\" }\\n-->\\n```js\\nconst map = Map({ a: Map({ b: Map({ c: 10 }) }) })\\nconst newMap = map.updateIn(['a', 'b', 'c'], val => val * 2)\\n// Map { \\\"a\\\": Map { \\\"b\\\": Map { \\\"c\\\": 20 } } }\\n```\\n\\nIf the `updater` function returns the same value it was called with, then\\nno change will occur. This is still true if `notSetValue` is provided.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable')\\\" }\\n-->\\n```js\\nconst map = Map({ a: Map({ b: Map({ c: 10 }) }) })\\nconst newMap = map.updateIn(['a', 'b', 'x'], 100, val => val)\\n// Map { \\\"a\\\": Map { \\\"b\\\": Map { \\\"c\\\": 10 } } }\\nassert.strictEqual(newMap, aMap)\\n```\\n\\nFor code using ES2015 or later, using `notSetValue` is discourged in\\nfavor of function parameter default values. This helps to avoid any\\npotential confusion with identify functions as described above.\\n\\nThe previous example behaves differently when written with default values:\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable')\\\" }\\n-->\\n```js\\nconst map = Map({ a: Map({ b: Map({ c: 10 }) }) })\\nconst newMap = map.updateIn(['a', 'b', 'x'], (val = 100) => val)\\n// Map { \\\"a\\\": Map { \\\"b\\\": Map { \\\"c\\\": 10, \\\"x\\\": 100 } } }\\n```\\n\\nPlain JavaScript Object or Arrays may be nested within an Immutable.js\\nCollection, and updateIn() can update those values as well, treating them\\nimmutably by creating new copies of those values with the changes applied.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable')\\\" }\\n-->\\n```js\\nconst map = Map({ a: { b: { c: 10 } } })\\nconst newMap = map.updateIn(['a', 'b', 'c'], val => val * 2)\\n// Map { \\\"a\\\": { b: { c: 20 } } }\\n```\\n\\nIf any key in the path exists but cannot be updated (such as a primitive\\nlike number or a custom Object like Date), an error will be thrown.\\n\\nNote: `updateIn` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"notSetValue\",\"type\":{\"k\":17}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":1209},{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":1210}]},\"#mergeIn\":{\"doc\":{\"synopsis\":\"A combination of `updateIn` and `merge`, returning a new Map, but\\nperforming the merge at a point arrived at by following the keyPath.\\nIn other words, these two lines are equivalent:\",\"description\":\"```js\\nmap.updateIn(['a', 'b', 'c'], abc => abc.merge(y))\\nmap.mergeIn(['a', 'b', 'c'], y)\\n```\\n\\nNote: `mergeIn` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":1224}]},\"#mergeDeepIn\":{\"doc\":{\"synopsis\":\"A combination of `updateIn` and `mergeDeep`, returning a new Map, but\\nperforming the deep merge at a point arrived at by following the keyPath.\\nIn other words, these two lines are equivalent:\",\"description\":\"```js\\nmap.updateIn(['a', 'b', 'c'], abc => abc.mergeDeep(y))\\nmap.mergeDeepIn(['a', 'b', 'c'], y)\\n```\\n\\nNote: `mergeDeepIn` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":1238}]}}},{\"title\":\"Transient changes\",\"members\":{\"#withMutations\":{\"doc\":{\"synopsis\":\"Every time you call one of the above functions, a new immutable Map is\\ncreated. If a pure function calls a number of these to produce a final\\nreturn value, then a penalty on performance and memory has been paid by\\ncreating all of the intermediate immutable Maps.\",\"description\":\"If you need to apply a series of mutations to produce a new immutable\\nMap, `withMutations()` creates a temporary mutable copy of the Map which\\ncan apply mutations in a highly performant manner. In fact, this is\\nexactly how complex mutations like `merge` are done.\\n\\nAs an example, this results in the creation of 2, not 4, new Maps:\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst map1 = Map()\\nconst map2 = map1.withMutations(map => {\\n  map.set('a', 1).set('b', 2).set('c', 3)\\n})\\nassert.equal(map1.size, 0)\\nassert.equal(map2.size, 3)\\n```\\n\\nNote: Not all methods can be used on a mutable collection or within\\n`withMutations`! Read the documentation for each method to see if it\\nis safe to use in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"mutator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"mutable\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":1270}]},\"#asMutable\":{\"doc\":{\"synopsis\":\"Another way to avoid creation of intermediate Immutable maps is to create\\na mutable copy of this collection. Mutable copies *always* return `this`,\\nand thus shouldn't be used for equality. Your function should never return\\na mutable copy of a collection, only use it internally to create a new\\ncollection.\",\"description\":\"If possible, use `withMutations` to work with temporary mutable copies as\\nit provides an easier to use API and considers many common optimizations.\\n\\nNote: if the collection is already mutable, `asMutable` returns itself.\\n\\nNote: Not all methods can be used on a mutable collection or within\\n`withMutations`! Read the documentation for each method to see if it\\nis safe to use in `withMutations`.\\n\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asImmutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":1290}]},\"#wasAltered\":{\"doc\":{\"synopsis\":\"Returns true if this is a mutable copy (see `asMutable()`) and mutative\\nalterations have been applied.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asMutable`\"}]},\"signatures\":[{\"type\":{\"k\":1},\"line\":1298}]},\"#asImmutable\":{\"doc\":{\"synopsis\":\"The yin to `asMutable`'s yang. Because it applies to mutable collections,\\nthis operation is *mutable* and may return itself (though may not\\nreturn itself, i.e. if the result is an empty collection). Once\\nperformed, the original mutable copy must no longer be mutated since it\\nmay be the immutable result.\",\"description\":\"If possible, use `withMutations` to work with temporary mutable copies as\\nit provides an easier to use API and considers many common optimizations.\\n\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asMutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":1312}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Map with values passed through a\\n`mapper` function.\",\"description\":\"    Map({ a: 1, b: 2 }).map(x => 10 * x)\\n    // Map { a: 10, b: 20 }\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"M\"}]},\"line\":1323}]},\"#mapKeys\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.mapKeys\"}]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"M\"},{\"k\":8,\"param\":\"V\"}]},\"line\":1331}]},\"#mapEntries\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.mapEntries\"}]},\"signatures\":[{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"entry\",\"type\":{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":1339}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Map, returning a new Map.\",\"description\":\"Similar to `data.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":1349}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Map with only the entries for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"F\"}]},\"line\":1361},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":1365}]},\"#flip\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.flip\"}]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"K\"}]},\"line\":1373}]}}}]}},\"OrderedMap\":{\"doc\":{\"synopsis\":\"A type of Map that has the additional guarantee that the iteration order of\\nentries will be the order in which they were set().\",\"description\":\"The iteration behavior of OrderedMap is the same as native ES6 Map and\\nJavaScript Object.\\n\\nNote that `OrderedMap` are more expensive than non-ordered `Map` and may\\nconsume more memory. `OrderedMap#set` is amortized O(log32 N), but not\\nstable.\",\"notes\":[]},\"module\":{\"isOrderedMap\":{\"call\":{\"doc\":{\"synopsis\":\"True if the provided value is an OrderedMap.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeOrderedMap\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":1394}]}}},\"call\":{\"doc\":{\"synopsis\":\"Creates a new Immutable OrderedMap.\",\"description\":\"Created with the same key value pairs as the provided Collection.Keyed or\\nJavaScript Object or expects a Collection of [K, V] tuple entries.\\n\\nThe iteration order of key-value pairs provided to this constructor will\\nbe preserved in the OrderedMap.\\n\\n    let newOrderedMap = OrderedMap({key: \\\"value\\\"})\\n    let newOrderedMap = OrderedMap([[\\\"key\\\", \\\"value\\\"]])\\n\\nNote: `OrderedMap` is a factory function and not a class, and does not use\\nthe `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\",\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]}}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":1412},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"obj\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":3},{\"k\":8,\"param\":\"V\"}]},\"line\":1413},{\"typeParams\":[\"K\",\"V\"],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":1414},{\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":17},{\"k\":17}]},\"line\":1415}]},\"interface\":{\"line\":1417,\"typeParams\":[\"K\",\"V\"],\"extends\":[{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}],\"groups\":[{\"members\":{\"#size\":{\"line\":1422},\"#set\":{\"doc\":{\"synopsis\":\"Returns a new OrderedMap also containing the new key, value pair. If an\\nequivalent key already exists in this OrderedMap, it will be replaced\\nwhile maintaining the existing order.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { OrderedMap } = require('immutable')\\nconst originalMap = OrderedMap({a:1, b:1, c:1})\\nconst updatedMap = originalMap.set('b', 2)\\n\\noriginalMap\\n// OrderedMap {a: 1, b: 1, c: 1}\\nupdatedMap\\n// OrderedMap {a: 1, b: 2, c: 1}\\n```\\n\\nNote: `set` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":10},\"line\":1443}]},\"#merge\":{\"doc\":{\"synopsis\":\"Returns a new OrderedMap resulting from merging the provided Collections\\n(or JS objects) into this OrderedMap. In other words, this takes each\\nentry of each collection and sets it on this OrderedMap.\",\"description\":\"Note: Values provided to `merge` are shallowly converted before being\\nmerged. No nested values are altered.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { OrderedMap } = require('immutable')\\nconst one = OrderedMap({ a: 10, b: 20, c: 30 })\\nconst two = OrderedMap({ b: 40, a: 50, d: 60 })\\none.merge(two) // OrderedMap { \\\"a\\\": 50, \\\"b\\\": 40, \\\"c\\\": 30, \\\"d\\\": 60 }\\ntwo.merge(one) // OrderedMap { \\\"b\\\": 20, \\\"a\\\": 10, \\\"d\\\": 60, \\\"c\\\": 30 }\\n```\\n\\nNote: `merge` can be used in `withMutations`.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"concat\"}]},\"signatures\":[{\"typeParams\":[\"KC\",\"VC\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KC\"},{\"k\":8,\"param\":\"VC\"}]}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"KC\"}]},{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"VC\"}]}]},\"line\":1466},{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"C\"}}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":3}]},{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":1467}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#map\":{\"doc\":{\"synopsis\":\"Returns a new OrderedMap with values passed through a\\n`mapper` function.\",\"description\":\"    OrderedMap({ a: 1, b: 2 }).map(x => 10 * x)\\n    // OrderedMap { \\\"a\\\": 10, \\\"b\\\": 20 }\\n\\nNote: `map()` always returns a new instance, even if it produced the same\\nvalue at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"M\"}]},\"line\":1483}]},\"#mapKeys\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.mapKeys\"}]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"M\"},{\"k\":8,\"param\":\"V\"}]},\"line\":1491}]},\"#mapEntries\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.mapEntries\"}]},\"signatures\":[{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"entry\",\"type\":{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":1499}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the OrderedMap, returning a new OrderedMap.\",\"description\":\"Similar to `data.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":1509}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new OrderedMap with only the entries for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"F\"}]},\"line\":1521},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":1525}]},\"#flip\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.flip\"}]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"K\"}]},\"line\":1533}]}}}]}},\"Set\":{\"doc\":{\"synopsis\":\"A Collection of unique values with `O(log32 N)` adds and has.\",\"description\":\"When iterating a Set, the entries will be (value, value) pairs. Iteration\\norder of a Set is undefined, however is stable. Multiple iterations of the\\nsame Set will iterate in the same order.\\n\\nSet values, like Map keys, may be of any type. Equality is determined using\\n`Immutable.is`, enabling Sets to uniquely include other Immutable\\ncollections, custom value types, and NaN.\",\"notes\":[]},\"module\":{\"isSet\":{\"call\":{\"doc\":{\"synopsis\":\"True if the provided value is a Set\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeSet\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":1553}]}},\"of\":{\"call\":{\"doc\":{\"synopsis\":\"Creates a new Set containing `values`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1558}]}},\"fromKeys\":{\"call\":{\"doc\":{\"synopsis\":\"`Set.fromKeys()` creates a new immutable Set containing the keys from\\nthis Collection or JavaScript Object.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"iter\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"T\"},{\"k\":17}]}}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1564},{\"params\":[{\"name\":\"obj\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":17}}]}}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":3}]},\"line\":1565}]}},\"intersect\":{\"call\":{\"doc\":{\"synopsis\":\"`Set.intersect()` creates a new immutable Set that is the intersection of\\na collection of other sets.\",\"description\":\"```js\\nconst { Set } = require('immutable')\\nconst intersected = Set.intersect([\\n  Set([ 'a', 'b', 'c' ])\\n  Set([ 'c', 'a', 't' ])\\n])\\n// Set [ \\\"a\\\", \\\"c\\\" ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"sets\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}]}}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1580}]}},\"union\":{\"call\":{\"doc\":{\"synopsis\":\"`Set.union()` creates a new immutable Set that is the union of a\\ncollection of other sets.\",\"description\":\"```js\\nconst { Set } = require('immutable')\\nconst unioned = Set.union([\\n  Set([ 'a', 'b', 'c' ])\\n  Set([ 'c', 'a', 't' ])\\n])\\n// Set [ \\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"t\\\" ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"sets\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}]}}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1595}]}}},\"call\":{\"doc\":{\"synopsis\":\"Create a new immutable Set containing the values of the provided\\ncollection-like.\",\"description\":\"Note: `Set` is a factory function and not a class, and does not use the\\n`new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":17}]},\"line\":1605},{\"typeParams\":[\"T\"],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1606},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1607}]},\"interface\":{\"line\":1609,\"typeParams\":[\"T\"],\"extends\":[{\"k\":9,\"name\":\"Collection.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]}],\"groups\":[{\"members\":{\"#size\":{\"line\":1614}}},{\"title\":\"Persistent changes\",\"members\":{\"#add\":{\"doc\":{\"synopsis\":\"Returns a new Set which also includes this value.\",\"description\":\"Note: `add` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":10},\"line\":1623}]},\"#delete\":{\"doc\":{\"synopsis\":\"Returns a new Set which excludes this value.\",\"description\":\"Note: `delete` can be used in `withMutations`.\\n\\nNote: `delete` **cannot** be safely used in IE8, use `remove` if\\nsupporting old browsers.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"remove\"}]},\"signatures\":[{\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":10},\"line\":1635}]},\"#clear\":{\"doc\":{\"synopsis\":\"Returns a new Set containing no values.\",\"description\":\"Note: `clear` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":1643}]},\"#union\":{\"doc\":{\"synopsis\":\"Returns a Set including any value from `collections` that does not already\\nexist in this Set.\",\"description\":\"Note: `union` can be used in `withMutations`.\",\"notes\":[{\"name\":\"alias\",\"body\":\"merge\"},{\"name\":\"alias\",\"body\":\"concat\"}]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"C\"}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":1653}]},\"#intersect\":{\"doc\":{\"synopsis\":\"Returns a Set which has removed any values not also contained\\nwithin `collections`.\",\"description\":\"Note: `intersect` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":1663}]},\"#subtract\":{\"doc\":{\"synopsis\":\"Returns a Set excluding any values contained within `collections`.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { OrderedSet } = require('immutable')\\nOrderedSet([ 1, 2, 3 ]).subtract([1, 3])\\n// OrderedSet [2]\\n```\\n\\nNote: `subtract` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":1677}]}}},{\"title\":\"Transient changes\",\"members\":{\"#withMutations\":{\"doc\":{\"synopsis\":\"Note: Not all methods can be used on a mutable collection or within\\n`withMutations`! Check the documentation for each method to see if it\\nmentions being safe to use in `withMutations`.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#withMutations`\"}]},\"signatures\":[{\"params\":[{\"name\":\"mutator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"mutable\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":1689}]},\"#asMutable\":{\"doc\":{\"synopsis\":\"Note: Not all methods can be used on a mutable collection or within\\n`withMutations`! Check the documentation for each method to see if it\\nmentions being safe to use in `withMutations`.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asMutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":1698}]},\"#wasAltered\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#wasAltered`\"}]},\"signatures\":[{\"type\":{\"k\":1},\"line\":1703}]},\"#asImmutable\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asImmutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":1708}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Set with values passed through a\\n`mapper` function.\",\"description\":\"    Set([1,2]).map(x => 10 * x)\\n    // Set [10,20]\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":1719}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Set, returning a new Set.\",\"description\":\"Similar to `set.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":1729}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Set with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"F\"}]},\"line\":1741},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":1745}]}}}]}},\"OrderedSet\":{\"doc\":{\"synopsis\":\"A type of Set that has the additional guarantee that the iteration order of\\nvalues will be the order in which they were `add`ed.\",\"description\":\"The iteration behavior of OrderedSet is the same as native ES6 Set.\\n\\nNote that `OrderedSet` are more expensive than non-ordered `Set` and may\\nconsume more memory. `OrderedSet#add` is amortized O(log32 N), but not\\nstable.\",\"notes\":[]},\"module\":{\"isOrderedSet\":{\"call\":{\"doc\":{\"synopsis\":\"True if the provided value is an OrderedSet.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeOrderedSet\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":1767}]}},\"of\":{\"call\":{\"doc\":{\"synopsis\":\"Creates a new OrderedSet containing `values`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1772}]}},\"fromKeys\":{\"call\":{\"doc\":{\"synopsis\":\"`OrderedSet.fromKeys()` creates a new immutable OrderedSet containing\\nthe keys from this Collection or JavaScript Object.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"iter\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"T\"},{\"k\":17}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1778},{\"params\":[{\"name\":\"obj\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":17}}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":3}]},\"line\":1779}]}}},\"call\":{\"doc\":{\"synopsis\":\"Create a new immutable OrderedSet containing the values of the provided\\ncollection-like.\",\"description\":\"Note: `OrderedSet` is a factory function and not a class, and does not use\\nthe `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":17}]},\"line\":1789},{\"typeParams\":[\"T\"],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1790},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1791}]},\"interface\":{\"line\":1793,\"typeParams\":[\"T\"],\"extends\":[{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]}],\"groups\":[{\"members\":{\"#size\":{\"line\":1798},\"#union\":{\"doc\":{\"synopsis\":\"Returns an OrderedSet including any value from `collections` that does\\nnot already exist in this OrderedSet.\",\"description\":\"Note: `union` can be used in `withMutations`.\",\"notes\":[{\"name\":\"alias\",\"body\":\"merge\"},{\"name\":\"alias\",\"body\":\"concat\"}]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"C\"}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":1808}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Set with values passed through a\\n`mapper` function.\",\"description\":\"    OrderedSet([ 1, 2 ]).map(x => 10 * x)\\n    // OrderedSet [10, 20]\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":1821}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the OrderedSet, returning a new OrderedSet.\",\"description\":\"Similar to `set.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":1831}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new OrderedSet with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"F\"}]},\"line\":1843},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":1847}]},\"#zip\":{\"doc\":{\"synopsis\":\"Returns an OrderedSet of the same type \\\"zipped\\\" with the provided\\ncollections.\",\"description\":\"Like `zipWith`, but using the default `zipper`: creating an `Array`.\\n\\n```js\\nconst a = OrderedSet([ 1, 2, 3 ])\\nconst b = OrderedSet([ 4, 5, 6 ])\\nconst c = a.zip(b)\\n// OrderedSet [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":1865},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other1\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":1866},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":17}]},\"line\":1867}]},\"#zipAll\":{\"doc\":{\"synopsis\":\"Returns a OrderedSet of the same type \\\"zipped\\\" with the provided\\ncollections.\",\"description\":\"Unlike `zip`, `zipAll` continues zipping until the longest collection is\\nexhausted. Missing values from shorter collections are filled with `undefined`.\\n\\n```js\\nconst a = OrderedSet([ 1, 2 ]);\\nconst b = OrderedSet([ 3, 4, 5 ]);\\nconst c = a.zipAll(b); // OrderedSet [ [ 1, 3 ], [ 2, 4 ], [ undefined, 5 ] ]\\n```\\n\\nNote: Since zipAll will return a collection as large as the largest\\ninput, some results may contain undefined values. TypeScript cannot\\naccount for these without cases (as of v2.5).\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":1886},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other1\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":1887},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":17}]},\"line\":1888}]},\"#zipWith\":{\"doc\":{\"synopsis\":\"Returns an OrderedSet of the same type \\\"zipped\\\" with the provided\\ncollections by using a custom `zipper` function.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Seq.Indexed.zipWith\"}]},\"signatures\":[{\"typeParams\":[\"U\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":1896},{\"typeParams\":[\"U\",\"V\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}},{\"name\":\"thirdValue\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"thirdCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":1900},{\"typeParams\":[\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"any\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":1905}]}}}]}},\"Stack\":{\"doc\":{\"synopsis\":\"Stacks are indexed collections which support very efficient O(1) addition\\nand removal from the front using `unshift(v)` and `shift()`.\",\"description\":\"For familiarity, Stack also provides `push(v)`, `pop()`, and `peek()`, but\\nbe aware that they also operate on the front of the list, unlike List or\\na JavaScript Array.\\n\\nNote: `reverse()` or any inherent reverse traversal (`reduceRight`,\\n`lastIndexOf`, etc.) is not efficient with a Stack.\\n\\nStack is implemented with a Single-Linked List.\",\"notes\":[]},\"module\":{\"isStack\":{\"call\":{\"doc\":{\"synopsis\":\"True if the provided value is a Stack\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeStack\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":1931}]}},\"of\":{\"call\":{\"doc\":{\"synopsis\":\"Creates a new Stack containing `values`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1936}]}}},\"call\":{\"doc\":{\"synopsis\":\"Create a new immutable Stack containing the values of the provided\\ncollection-like.\",\"description\":\"The iteration order of the provided collection is preserved in the\\nresulting `Stack`.\\n\\nNote: `Stack` is a factory function and not a class, and does not use the\\n`new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":17}]},\"line\":1949},{\"typeParams\":[\"T\"],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1950},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1951}]},\"interface\":{\"line\":1953,\"typeParams\":[\"T\"],\"extends\":[{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]}],\"groups\":[{\"members\":{\"#size\":{\"line\":1958}}},{\"title\":\"Reading values\",\"members\":{\"#peek\":{\"doc\":{\"synopsis\":\"Alias for `Stack.first()`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":11}]},\"line\":1965}]}}},{\"title\":\"Persistent changes\",\"members\":{\"#clear\":{\"doc\":{\"synopsis\":\"Returns a new Stack with 0 size and no values.\",\"description\":\"Note: `clear` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1975}]},\"#unshift\":{\"doc\":{\"synopsis\":\"Returns a new Stack with the provided `values` prepended, shifting other\\nvalues ahead to higher indices.\",\"description\":\"This is very efficient for Stack.\\n\\nNote: `unshift` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1985}]},\"#unshiftAll\":{\"doc\":{\"synopsis\":\"Like `Stack#unshift`, but accepts a collection rather than varargs.\",\"description\":\"Note: `unshiftAll` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"iter\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1992}]},\"#shift\":{\"doc\":{\"synopsis\":\"Returns a new Stack with a size ones less than this Stack, excluding\\nthe first item in this Stack, shifting all other values to a lower index.\",\"description\":\"Note: this differs from `Array#shift` because it returns a new\\nStack rather than the removed value. Use `first()` or `peek()` to get the\\nfirst value in this Stack.\\n\\nNote: `shift` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2004}]},\"#push\":{\"doc\":{\"synopsis\":\"Alias for `Stack#unshift` and is not equivalent to `List#push`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2009}]},\"#pushAll\":{\"doc\":{\"synopsis\":\"Alias for `Stack#unshiftAll`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"iter\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2014}]},\"#pop\":{\"doc\":{\"synopsis\":\"Alias for `Stack#shift` and is not equivalent to `List#pop`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2019}]}}},{\"title\":\"Transient changes\",\"members\":{\"#withMutations\":{\"doc\":{\"synopsis\":\"Note: Not all methods can be used on a mutable collection or within\\n`withMutations`! Check the documentation for each method to see if it\\nmentions being safe to use in `withMutations`.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#withMutations`\"}]},\"signatures\":[{\"params\":[{\"name\":\"mutator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"mutable\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":2031}]},\"#asMutable\":{\"doc\":{\"synopsis\":\"Note: Not all methods can be used on a mutable collection or within\\n`withMutations`! Check the documentation for each method to see if it\\nmentions being safe to use in `withMutations`.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asMutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":2040}]},\"#wasAltered\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#wasAltered`\"}]},\"signatures\":[{\"type\":{\"k\":1},\"line\":2045}]},\"#asImmutable\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asImmutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":2050}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new Stack with other collections concatenated to this one.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"valuesOrCollections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"C\"}]},{\"k\":8,\"param\":\"C\"}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":2057}]},\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Stack with values passed through a\\n`mapper` function.\",\"description\":\"    Stack([ 1, 2 ]).map(x => 10 * x)\\n    // Stack [ 10, 20 ]\\n\\nNote: `map()` always returns a new instance, even if it produced the same\\nvalue at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":2069}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Stack, returning a new Stack.\",\"description\":\"Similar to `stack.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":2079}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Set with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"F\"}]},\"line\":2091},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":2095}]},\"#zip\":{\"doc\":{\"synopsis\":\"Returns a Stack \\\"zipped\\\" with the provided collections.\",\"description\":\"Like `zipWith`, but using the default `zipper`: creating an `Array`.\\n\\n```js\\nconst a = Stack([ 1, 2, 3 ]);\\nconst b = Stack([ 4, 5, 6 ]);\\nconst c = a.zip(b); // Stack [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":2111},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":2112},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":17}]},\"line\":2113}]},\"#zipAll\":{\"doc\":{\"synopsis\":\"Returns a Stack \\\"zipped\\\" with the provided collections.\",\"description\":\"Unlike `zip`, `zipAll` continues zipping until the longest collection is\\nexhausted. Missing values from shorter collections are filled with `undefined`.\\n\\n```js\\nconst a = Stack([ 1, 2 ]);\\nconst b = Stack([ 3, 4, 5 ]);\\nconst c = a.zipAll(b); // Stack [ [ 1, 3 ], [ 2, 4 ], [ undefined, 5 ] ]\\n```\\n\\nNote: Since zipAll will return a collection as large as the largest\\ninput, some results may contain undefined values. TypeScript cannot\\naccount for these without cases (as of v2.5).\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":2131},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":2132},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":17}]},\"line\":2133}]},\"#zipWith\":{\"doc\":{\"synopsis\":\"Returns a Stack \\\"zipped\\\" with the provided collections by using a\\ncustom `zipper` function.\",\"description\":\"```js\\nconst a = Stack([ 1, 2, 3 ]);\\nconst b = Stack([ 4, 5, 6 ]);\\nconst c = a.zipWith((a, b) => a + b, b);\\n// Stack [ 5, 7, 9 ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":2146},{\"typeParams\":[\"U\",\"V\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}},{\"name\":\"thirdValue\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"thirdCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":2150},{\"typeParams\":[\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"any\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":2155}]}}}]}},\"Range\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a Seq.Indexed of numbers from `start` (inclusive) to `end`\\n(exclusive), by `step`, where `start` defaults to 0, `step` to 1, and `end` to\\ninfinity. When `start` is equal to `end`, returns empty range.\",\"description\":\"Note: `Range` is a factory function and not a class, and does not use the\\n`new` keyword during construction.\\n\\n```js\\nconst { Range } = require('immutable')\\nRange() // [ 0, 1, 2, 3, ... ]\\nRange(10) // [ 10, 11, 12, 13, ... ]\\nRange(10, 15) // [ 10, 11, 12, 13, 14 ]\\nRange(10, 30, 5) // [ 10, 15, 20, 25 ]\\nRange(30, 10, 5) // [ 30, 25, 20, 15 ]\\nRange(30, 30, 5) // []\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"start\",\"type\":{\"k\":2},\"optional\":true},{\"name\":\"end\",\"type\":{\"k\":2},\"optional\":true},{\"name\":\"step\",\"type\":{\"k\":2},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":2}]},\"line\":2180}]}},\"Repeat\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a Seq.Indexed of `value` repeated `times` times. When `times` is\\nnot defined, returns an infinite `Seq` of `value`.\",\"description\":\"Note: `Repeat` is a factory function and not a class, and does not use the\\n`new` keyword during construction.\\n\\n```js\\nconst { Repeat } = require('immutable')\\nRepeat('foo') // [ 'foo', 'foo', 'foo', ... ]\\nRepeat('bar', 4) // [ 'bar', 'bar', 'bar', 'bar' ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"times\",\"type\":{\"k\":2},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2196}]}},\"Record\":{\"doc\":{\"synopsis\":\"A record is similar to a JS object, but enforces a specific set of allowed\\nstring keys, and has default values.\",\"description\":\"The `Record()` function produces new Record Factories, which when called\\ncreate Record instances.\\n\\n```js\\nconst { Record } = require('immutable')\\nconst ABRecord = Record({ a: 1, b: 2 })\\nconst myRecord = ABRecord({ b: 3 })\\n```\\n\\nRecords always have a value for the keys they define. `remove`ing a key\\nfrom a record simply resets it to the default value for that key.\\n\\n```js\\nmyRecord.size // 2\\nmyRecord.get('a') // 1\\nmyRecord.get('b') // 3\\nconst myRecordWithoutB = myRecord.remove('b')\\nmyRecordWithoutB.get('b') // 2\\nmyRecordWithoutB.size // 2\\n```\\n\\nValues provided to the constructor not found in the Record type will\\nbe ignored. For example, in this case, ABRecord is provided a key \\\"x\\\" even\\nthough only \\\"a\\\" and \\\"b\\\" have been defined. The value for \\\"x\\\" will be\\nignored for this record.\\n\\n```js\\nconst myRecord = ABRecord({ b: 3, x: 10 })\\nmyRecord.get('x') // undefined\\n```\\n\\nBecause Records have a known set of string keys, property get access works\\nas expected, however property sets will throw an Error.\\n\\nNote: IE8 does not support property access. Only use `get()` when\\nsupporting IE8.\\n\\n```js\\nmyRecord.b // 3\\nmyRecord.b = 5 // throws Error\\n```\\n\\nRecord Types can be extended as well, allowing for custom methods on your\\nRecord. This is not a common pattern in functional environments, but is in\\nmany JS programs.\\n\\nHowever Record Types are more restricted than typical JavaScript classes.\\nThey do not use a class constructor, which also means they cannot use\\nclass properties (since those are technically part of a constructor).\\n\\nWhile Record Types can be syntactically created with the JavaScript `class`\\nform, the resulting Record function is actually a factory function, not a\\nclass constructor. Even though Record Types are not classes, JavaScript\\ncurrently requires the use of `new` when creating new Record instances if\\nthey are defined as a `class`.\\n\\n```\\nclass ABRecord extends Record({ a: 1, b: 2 }) {\\n  getAB() {\\n    return this.a + this.b;\\n  }\\n}\\n\\nvar myRecord = new ABRecord({b: 3})\\nmyRecord.getAB() // 4\\n```\\n\\n\\n**Flow Typing Records:**\\n\\nImmutable.js exports two Flow types designed to make it easier to use\\nRecords with flow typed code, `RecordOf<TProps>` and `RecordFactory<TProps>`.\\n\\nWhen defining a new kind of Record factory function, use a flow type that\\ndescribes the values the record contains along with `RecordFactory<TProps>`.\\nTo type instances of the Record (which the factory function returns),\\nuse `RecordOf<TProps>`.\\n\\nTypically, new Record definitions will export both the Record factory\\nfunction as well as the Record instance type for use in other code.\\n\\n```js\\nimport type { RecordFactory, RecordOf } from 'immutable';\\n\\n// Use RecordFactory<TProps> for defining new Record factory functions.\\ntype Point3DProps = { x: number, y: number, z: number };\\nconst defaultValues: Point3DProps = { x: 0, y: 0, z: 0 };\\nconst makePoint3D: RecordFactory<Point3DProps> = Record(defaultValues);\\nexport makePoint3D;\\n\\n// Use RecordOf<T> for defining new instances of that Record.\\nexport type Point3D = RecordOf<Point3DProps>;\\nconst some3DPoint: Point3D = makePoint3D({ x: 10, y: 20, z: 30 });\\n```\\n\\n**Flow Typing Record Subclasses:**\\n\\nRecords can be subclassed as a means to add additional methods to Record\\ninstances. This is generally discouraged in favor of a more functional API,\\nsince Subclasses have some minor overhead. However the ability to create\\na rich API on Record types can be quite valuable.\\n\\nWhen using Flow to type Subclasses, do not use `RecordFactory<TProps>`,\\ninstead apply the props type when subclassing:\\n\\n```js\\ntype PersonProps = {name: string, age: number};\\nconst defaultValues: PersonProps = {name: 'Aristotle', age: 2400};\\nconst PersonRecord = Record(defaultValues);\\nclass Person extends PersonRecord<PersonProps> {\\n  getName(): string {\\n    return this.get('name')\\n  }\\n\\n  setName(name: string): this {\\n    return this.set('name', name);\\n  }\\n}\\n```\\n\\n**Choosing Records vs plain JavaScript objects**\\n\\nRecords offer a persistently immutable alternative to plain JavaScript\\nobjects, however they're not required to be used within Immutable.js\\ncollections. In fact, the deep-access and deep-updating functions\\nlike `getIn()` and `setIn()` work with plain JavaScript Objects as well.\\n\\nDeciding to use Records or Objects in your application should be informed\\nby the tradeoffs and relative benefits of each:\\n\\n- *Runtime immutability*: plain JS objects may be carefully treated as\\n  immutable, however Record instances will *throw* if attempted to be\\n  mutated directly. Records provide this additional guarantee, however at\\n  some marginal runtime cost. While JS objects are mutable by nature, the\\n  use of type-checking tools like [Flow](https://medium.com/@gcanti/immutability-with-flow-faa050a1aef4)\\n  can help gain confidence in code written to favor immutability.\\n\\n- *Value equality*: Records use value equality when compared with `is()`\\n  or `record.equals()`. That is, two Records with the same keys and values\\n  are equal. Plain objects use *reference equality*. Two objects with the\\n  same keys and values are not equal since they are different objects.\\n  This is important to consider when using objects as keys in a `Map` or\\n  values in a `Set`, which use equality when retrieving values.\\n\\n- *API methods*: Records have a full featured API, with methods like\\n  `.getIn()`, and `.equals()`. These can make working with these values\\n  easier, but comes at the cost of not allowing keys with those names.\\n\\n- *Default values*: Records provide default values for every key, which\\n  can be useful when constructing Records with often unchanging values.\\n  However default values can make using Flow and TypeScript more laborious.\\n\\n- *Serialization*: Records use a custom internal representation to\\n  efficiently store and update their values. Converting to and from this\\n  form isn't free. If converting Records to plain objects is common,\\n  consider sticking with plain objects to begin with.\",\"notes\":[]},\"module\":{\"isRecord\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeRecord` is an instance of a Record.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeRecord\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":2365}]}},\"getDescriptiveName\":{\"call\":{\"doc\":{\"synopsis\":\"Records allow passing a second parameter to supply a descriptive name\\nthat appears when converting a Record to a string or in any error\\nmessages. A descriptive name for any record can be accessed by using this\\nmethod. If one was not provided, the string \\\"Record\\\" is returned.\",\"description\":\"```js\\nconst { Record } = require('immutable')\\nconst Person = Record({\\n  name: null\\n}, 'Person')\\n\\nvar me = Person({ name: 'My Name' })\\nme.toString() // \\\"Person { \\\"name\\\": \\\"My Name\\\" }\\\"\\nRecord.getDescriptiveName(me) // \\\"Person\\\"\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"record\",\"type\":{\"k\":9,\"name\":\"Record\",\"args\":[{\"k\":4,\"members\":[]}]}}],\"type\":{\"k\":3},\"line\":2384}]}},\"Factory\":{\"doc\":{\"synopsis\":\"A Record.Factory is created by the `Record()` function. Record instances\\nare created by passing it some of the accepted values for that Record\\ntype:\",\"description\":\"<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Record } = require('immutable')\\\" }\\n-->\\n```js\\n// makePerson is a Record Factory function\\nconst makePerson = Record({ name: null, favoriteColor: 'unknown' });\\n\\n// alan is a Record instance\\nconst alan = makePerson({ name: 'Alan' });\\n```\\n\\nNote that Record Factories return `Record<TProps> & Readonly<TProps>`,\\nthis allows use of both the Record instance API, and direct property\\naccess on the resulting instances:\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Record } = require('immutable');const makePerson = Record({ name: null, favoriteColor: 'unknown' });const alan = makePerson({ name: 'Alan' });\\\" }\\n-->\\n```js\\n// Use the Record API\\nconsole.log('Record API: ' + alan.get('name'))\\n\\n// Or direct property access (Readonly)\\nconsole.log('property access: ' + alan.name)\\n```\\n\\n**Flow Typing Records:**\\n\\nUse the `RecordFactory<TProps>` Flow type to get high quality type checking of\\nRecords:\\n\\n```js\\nimport type { RecordFactory, RecordOf } from 'immutable';\\n\\n// Use RecordFactory<TProps> for defining new Record factory functions.\\ntype PersonProps = { name: ?string, favoriteColor: string };\\nconst makePerson: RecordFactory<PersonProps> = Record({ name: null, favoriteColor: 'unknown' });\\n\\n// Use RecordOf<T> for defining new instances of that Record.\\ntype Person = RecordOf<PersonProps>;\\nconst alan: Person = makePerson({ name: 'Alan' });\\n```\",\"notes\":[]},\"module\":{},\"interface\":{\"line\":2436,\"typeParams\":[\"TProps\"],\"groups\":[{\"members\":{\"#displayName\":{\"line\":2444}}}]},\"call\":{\"signatures\":[{\"typeParams\":[\"TProps\"],\"params\":[{\"name\":\"values\",\"type\":{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Partial\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":3},{\"k\":17}]}]}]},\"optional\":true}],\"type\":{\"k\":13,\"types\":[{\"k\":9,\"name\":\"Record\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]},{\"k\":9,\"name\":\"Readonly\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]}]},\"line\":2447}]}}},\"call\":{\"doc\":{\"synopsis\":\"Unlike other types in Immutable.js, the `Record()` function creates a new\\nRecord Factory, which is a function that creates Record instances.\",\"description\":\"See above for examples of using `Record()`.\\n\\nNote: `Record` is a factory function and not a class, and does not use the\\n`new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"TProps\"],\"params\":[{\"name\":\"defaultValues\",\"type\":{\"k\":8,\"param\":\"TProps\"}},{\"name\":\"name\",\"type\":{\"k\":3},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Record.Factory\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]},\"line\":2459}]},\"interface\":{\"line\":2461,\"typeParams\":[\"TProps\"],\"groups\":[{\"title\":\"Reading values\",\"members\":{\"#has\":{\"signatures\":[{\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":1},\"line\":2465}]},\"#get\":{\"doc\":{\"synopsis\":\"Returns the value associated with the provided key, which may be the\\ndefault value defined when creating the Record factory function.\",\"description\":\"If the requested key is not defined by this Record type, then\\nnotSetValue will be returned if provided. Note that this scenario would\\nproduce an error when using Flow or TypeScript.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\"],\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}},\"line\":2475},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":8,\"param\":\"T\"},\"line\":2476}]}}},{\"title\":\"Reading deep values\",\"members\":{\"#hasIn\":{\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}}],\"type\":{\"k\":1},\"line\":2480}]},\"#getIn\":{\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}}],\"type\":{\"k\":17},\"line\":2481}]}}},{\"title\":\"Value equality\",\"members\":{\"#equals\":{\"signatures\":[{\"params\":[{\"name\":\"other\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":2485}]},\"#hashCode\":{\"signatures\":[{\"type\":{\"k\":2},\"line\":2486}]}}},{\"title\":\"Persistent changes\",\"members\":{\"#set\":{\"signatures\":[{\"typeParams\":[\"K\"],\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}}}],\"type\":{\"k\":10},\"line\":2490}]},\"#update\":{\"signatures\":[{\"typeParams\":[\"K\"],\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}}}],\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}}}}],\"type\":{\"k\":10},\"line\":2491}]},\"#merge\":{\"signatures\":[{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Partial\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":3},{\"k\":17}]}]}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":2492}]},\"#mergeDeep\":{\"signatures\":[{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Partial\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":3},{\"k\":17}]}]}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":2493}]},\"#mergeWith\":{\"signatures\":[{\"params\":[{\"name\":\"merger\",\"type\":{\"k\":7,\"params\":[{\"name\":\"oldVal\",\"type\":{\"k\":17}},{\"name\":\"newVal\",\"type\":{\"k\":17}},{\"name\":\"key\",\"type\":{\"k\":16,\"operator\":\"keyof\",\"type\":{\"k\":8,\"param\":\"TProps\"}}}],\"type\":{\"k\":17}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Partial\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":3},{\"k\":17}]}]}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":2495}]},\"#mergeDeepWith\":{\"signatures\":[{\"params\":[{\"name\":\"merger\",\"type\":{\"k\":7,\"params\":[{\"name\":\"oldVal\",\"type\":{\"k\":17}},{\"name\":\"newVal\",\"type\":{\"k\":17}},{\"name\":\"key\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Partial\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":3},{\"k\":17}]}]}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":2499}]},\"#delete\":{\"doc\":{\"synopsis\":\"Returns a new instance of this Record type with the value for the\\nspecific key set to its default value.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"alias\",\"body\":\"remove\"}]},\"signatures\":[{\"typeParams\":[\"K\"],\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":10},\"line\":2510}]},\"#clear\":{\"doc\":{\"synopsis\":\"Returns a new instance of this Record type with all values set\\nto their default values.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":2517}]}}},{\"title\":\"Deep persistent changes\",\"members\":{\"#setIn\":{\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":10},\"line\":2521}]},\"#updateIn\":{\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":2522}]},\"#mergeIn\":{\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":2523}]},\"#mergeDeepIn\":{\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":2524}]},\"#deleteIn\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"alias\",\"body\":\"removeIn\"}]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}}],\"type\":{\"k\":10},\"line\":2529}]}}},{\"title\":\"Conversion to JavaScript types\",\"members\":{\"#toJS\":{\"doc\":{\"synopsis\":\"Deeply converts this Record to equivalent native JavaScript Object.\",\"description\":\"Note: This method may not be overridden. Objects with custom\\nserialization to plain JS may override toJSON() instead.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":17}}]},\"line\":2540}]},\"#toJSON\":{\"doc\":{\"synopsis\":\"Shallowly converts this Record to equivalent native JavaScript Object.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":8,\"param\":\"TProps\"},\"line\":2545}]},\"#toObject\":{\"doc\":{\"synopsis\":\"Shallowly converts this Record to equivalent JavaScript Object.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":8,\"param\":\"TProps\"},\"line\":2550}]}}},{\"title\":\"Transient changes\",\"members\":{\"#withMutations\":{\"doc\":{\"synopsis\":\"Note: Not all methods can be used on a mutable collection or within\\n`withMutations`! Only `set` may be used mutatively.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#withMutations`\"}]},\"signatures\":[{\"params\":[{\"name\":\"mutator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"mutable\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":2560}]},\"#asMutable\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asMutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":2565}]},\"#wasAltered\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#wasAltered`\"}]},\"signatures\":[{\"type\":{\"k\":1},\"line\":2570}]},\"#asImmutable\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asImmutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":2575}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#toSeq\":{\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":16,\"operator\":\"keyof\",\"type\":{\"k\":8,\"param\":\"TProps\"}},{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":16,\"operator\":\"keyof\",\"type\":{\"k\":8,\"param\":\"TProps\"}}}]},\"line\":2579}]},\"#[Symbol.iterator]\":{\"signatures\":[{\"type\":{\"k\":9,\"name\":\"IterableIterator\",\"args\":[{\"k\":14,\"types\":[{\"k\":16,\"operator\":\"keyof\",\"type\":{\"k\":8,\"param\":\"TProps\"}},{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":16,\"operator\":\"keyof\",\"type\":{\"k\":8,\"param\":\"TProps\"}}}]}]},\"line\":2581}]}}}]}},\"Seq\":{\"doc\":{\"synopsis\":\"`Seq` describes a lazy operation, allowing them to efficiently chain\\nuse of all the higher-order collection methods (such as `map` and `filter`)\\nby not creating intermediate collections.\",\"description\":\"**Seq is immutable**  Once a Seq is created, it cannot be\\nchanged, appended to, rearranged or otherwise modified. Instead, any\\nmutative method called on a `Seq` will return a new `Seq`.\\n\\n**Seq is lazy**  `Seq` does as little work as necessary to respond to any\\nmethod call. Values are often created during iteration, including implicit\\niteration when reducing or converting to a concrete data structure such as\\na `List` or JavaScript `Array`.\\n\\nFor example, the following performs no work, because the resulting\\n`Seq`'s values are never iterated:\\n\\n```js\\nconst { Seq } = require('immutable')\\nconst oddSquares = Seq([ 1, 2, 3, 4, 5, 6, 7, 8 ])\\n  .filter(x => x % 2 !== 0)\\n  .map(x => x * x)\\n```\\n\\nOnce the `Seq` is used, it performs only the work necessary. In this\\nexample, no intermediate arrays are ever created, filter is called three\\ntimes, and map is only called once:\\n\\n```js\\noddSquares.get(1); // 9\\n```\\n\\nAny collection can be converted to a lazy Seq with `Seq()`.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst map = Map({ a: 1, b: 2, c: 3 })\\nconst lazySeq = Seq(map)\\n```\\n\\n`Seq` allows for the efficient chaining of operations, allowing for the\\nexpression of logic that can otherwise be very tedious:\\n\\n```js\\nlazySeq\\n  .flip()\\n  .map(key => key.toUpperCase())\\n  .flip()\\n// Seq { A: 1, B: 1, C: 1 }\\n```\\n\\nAs well as expressing logic that would otherwise seem memory or time\\nlimited, for example `Range` is a special kind of Lazy sequence.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Range } = require('immutable')\\nRange(1, Infinity)\\n  .skip(1000)\\n  .map(n => -n)\\n  .filter(n => n % 2 === 0)\\n  .take(2)\\n  .reduce((r, n) => r * n, 1)\\n// 1006008\\n```\\n\\nSeq is often used to provide a rich collection API to JavaScript Object.\\n\\n```js\\nSeq({ x: 0, y: 1, z: 2 }).map(v => v * 2).toObject();\\n// { x: 0, y: 2, z: 4 }\\n```\",\"notes\":[]},\"module\":{\"isSeq\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeSeq` is a Seq, it is not backed by a concrete\\nstructure such as Map, List, or Set.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeSeq\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":2673}]}},\"Keyed\":{\"doc\":{\"synopsis\":\"`Seq` which represents key-value pairs.\",\"description\":\"\",\"notes\":[]},\"module\":{},\"call\":{\"doc\":{\"synopsis\":\"Always returns a Seq.Keyed, if input is not keyed, expects an\\ncollection of [K, V] tuples.\",\"description\":\"Note: `Seq.Keyed` is a conversion function and not a class, and does not\\nuse the `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\",\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":2688},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"obj\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":3},{\"k\":8,\"param\":\"V\"}]},\"line\":2689},{\"typeParams\":[\"K\",\"V\"],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":2690},{\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":17},{\"k\":17}]},\"line\":2691}]},\"interface\":{\"line\":2693,\"typeParams\":[\"K\",\"V\"],\"extends\":[{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}],\"groups\":[{\"members\":{\"#toJS\":{\"doc\":{\"synopsis\":\"Deeply converts this Keyed Seq to equivalent native JavaScript Object.\",\"description\":\"Converts keys to Strings.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Object\"},\"line\":2699}]},\"#toJSON\":{\"doc\":{\"synopsis\":\"Shallowly converts this Keyed Seq to equivalent native JavaScript Object.\",\"description\":\"Converts keys to Strings.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]},\"line\":2706}]},\"#toArray\":{\"doc\":{\"synopsis\":\"Shallowly converts this collection to an Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":2711}]},\"#toSeq\":{\"doc\":{\"synopsis\":\"Returns itself\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":2716}]},\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new Seq with other collections concatenated to this one.\",\"description\":\"All entries will be present in the resulting Seq, even if they\\nhave the same key.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"KC\",\"VC\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KC\"},{\"k\":8,\"param\":\"VC\"}]}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"KC\"}]},{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"VC\"}]}]},\"line\":2724},{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"C\"}}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":3}]},{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":2725}]},\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Seq.Keyed with values passed through a\\n`mapper` function.\",\"description\":\"```js\\nconst { Seq } = require('immutable')\\nSeq.Keyed({ a: 1, b: 2 }).map(x => 10 * x)\\n// Seq { \\\"a\\\": 10, \\\"b\\\": 20 }\\n```\\n\\nNote: `map()` always returns a new instance, even if it produced the\\nsame value at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"M\"}]},\"line\":2740}]},\"#mapKeys\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.mapKeys\"}]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"M\"},{\"k\":8,\"param\":\"V\"}]},\"line\":2748}]},\"#mapEntries\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.mapEntries\"}]},\"signatures\":[{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"entry\",\"type\":{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":2756}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Seq, returning a Seq of the same type.\",\"description\":\"Similar to `seq.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":2766}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Seq with only the entries for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"F\"}]},\"line\":2778},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":2782}]},\"#flip\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.flip\"}]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"K\"}]},\"line\":2790}]}}}]}},\"Indexed\":{\"doc\":{\"synopsis\":\"`Seq` which represents an ordered indexed list of values.\",\"description\":\"\",\"notes\":[]},\"module\":{\"of\":{\"call\":{\"doc\":{\"synopsis\":\"Provides an Seq.Indexed of the values provided.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2802}]}}},\"call\":{\"doc\":{\"synopsis\":\"Always returns Seq.Indexed, discarding associated keys and\\nsupplying incrementing indices.\",\"description\":\"Note: `Seq.Indexed` is a conversion function and not a class, and does\\nnot use the `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":17}]},\"line\":2812},{\"typeParams\":[\"T\"],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2813},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2814}]},\"interface\":{\"line\":2816,\"typeParams\":[\"T\"],\"extends\":[{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":2},{\"k\":8,\"param\":\"T\"}]},{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]}],\"groups\":[{\"members\":{\"#toJS\":{\"doc\":{\"synopsis\":\"Deeply converts this Indexed Seq to equivalent native JavaScript Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"line\":2820}]},\"#toJSON\":{\"doc\":{\"synopsis\":\"Shallowly converts this Indexed Seq to equivalent native JavaScript Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2825}]},\"#toArray\":{\"doc\":{\"synopsis\":\"Shallowly converts this collection to an Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2830}]},\"#toSeq\":{\"doc\":{\"synopsis\":\"Returns itself\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":2835}]},\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new Seq with other collections concatenated to this one.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"valuesOrCollections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"C\"}]},{\"k\":8,\"param\":\"C\"}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":2840}]},\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Seq.Indexed with values passed through a\\n`mapper` function.\",\"description\":\"```js\\nconst { Seq } = require('immutable')\\nSeq.Indexed([ 1, 2 ]).map(x => 10 * x)\\n// Seq [ 10, 20 ]\\n```\\n\\nNote: `map()` always returns a new instance, even if it produced the\\nsame value at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":2855}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Seq, returning a a Seq of the same type.\",\"description\":\"Similar to `seq.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":2865}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Seq with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"F\"}]},\"line\":2877},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":2881}]},\"#zip\":{\"doc\":{\"synopsis\":\"Returns a Seq \\\"zipped\\\" with the provided collections.\",\"description\":\"Like `zipWith`, but using the default `zipper`: creating an `Array`.\\n\\n```js\\nconst a = Seq([ 1, 2, 3 ]);\\nconst b = Seq([ 4, 5, 6 ]);\\nconst c = a.zip(b); // Seq [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":2897},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":2898},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":17}]},\"line\":2899}]},\"#zipAll\":{\"doc\":{\"synopsis\":\"Returns a Seq \\\"zipped\\\" with the provided collections.\",\"description\":\"Unlike `zip`, `zipAll` continues zipping until the longest collection is\\nexhausted. Missing values from shorter collections are filled with `undefined`.\\n\\n```js\\nconst a = Seq([ 1, 2 ]);\\nconst b = Seq([ 3, 4, 5 ]);\\nconst c = a.zipAll(b); // Seq [ [ 1, 3 ], [ 2, 4 ], [ undefined, 5 ] ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":2913},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":2914},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":17}]},\"line\":2915}]},\"#zipWith\":{\"doc\":{\"synopsis\":\"Returns a Seq \\\"zipped\\\" with the provided collections by using a\\ncustom `zipper` function.\",\"description\":\"```js\\nconst a = Seq([ 1, 2, 3 ]);\\nconst b = Seq([ 4, 5, 6 ]);\\nconst c = a.zipWith((a, b) => a + b, b);\\n// Seq [ 5, 7, 9 ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":2928},{\"typeParams\":[\"U\",\"V\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}},{\"name\":\"thirdValue\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"thirdCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":2932},{\"typeParams\":[\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"any\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":2937}]}}}]}},\"Set\":{\"doc\":{\"synopsis\":\"`Seq` which represents a set of values.\",\"description\":\"Because `Seq` are often lazy, `Seq.Set` does not provide the same guarantee\\nof value uniqueness as the concrete `Set`.\",\"notes\":[]},\"module\":{\"of\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a Seq.Set of the provided values\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2955}]}}},\"call\":{\"doc\":{\"synopsis\":\"Always returns a Seq.Set, discarding associated indices or keys.\",\"description\":\"Note: `Seq.Set` is a conversion function and not a class, and does not\\nuse the `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":17}]},\"line\":2964},{\"typeParams\":[\"T\"],\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2965},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2966}]},\"interface\":{\"line\":2968,\"typeParams\":[\"T\"],\"extends\":[{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"T\"}]},{\"k\":9,\"name\":\"Collection.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]}],\"groups\":[{\"members\":{\"#toJS\":{\"doc\":{\"synopsis\":\"Deeply converts this Set Seq to equivalent native JavaScript Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"line\":2972}]},\"#toJSON\":{\"doc\":{\"synopsis\":\"Shallowly converts this Set Seq to equivalent native JavaScript Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2977}]},\"#toArray\":{\"doc\":{\"synopsis\":\"Shallowly converts this collection to an Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2982}]},\"#toSeq\":{\"doc\":{\"synopsis\":\"Returns itself\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":2987}]},\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new Seq with other collections concatenated to this one.\",\"description\":\"All entries will be present in the resulting Seq, even if they\\nare duplicates.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"U\"}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":2995}]},\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Seq.Set with values passed through a\\n`mapper` function.\",\"description\":\"```js\\nSeq.Set([ 1, 2 ]).map(x => 10 * x)\\n// Seq { 10, 20 }\\n```\\n\\nNote: `map()` always returns a new instance, even if it produced the\\nsame value at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":3009}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Seq, returning a Seq of the same type.\",\"description\":\"Similar to `seq.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":3019}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Seq with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"F\"}]},\"line\":3031},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":3035}]}}}]}}},\"call\":{\"doc\":{\"synopsis\":\"Creates a Seq.\",\"description\":\"Returns a particular kind of `Seq` based on the input.\\n\\n  * If a `Seq`, that same `Seq`.\\n  * If an `Collection`, a `Seq` of the same kind (Keyed, Indexed, or Set).\\n  * If an Array-like, an `Seq.Indexed`.\\n  * If an Iterable Object, an `Seq.Indexed`.\\n  * If an Object, a `Seq.Keyed`.\\n\\nNote: An Iterator itself will be treated as an object, becoming a `Seq.Keyed`,\\nwhich is usually not what you want. You should turn your Iterator Object into\\nan iterable object by defining a Symbol.iterator (or @@iterator) method which\\nreturns `this`.\\n\\nNote: `Seq` is a conversion function and not a class, and does not use the\\n`new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"S\"],\"params\":[{\"name\":\"seq\",\"type\":{\"k\":8,\"param\":\"S\"}}],\"type\":{\"k\":8,\"param\":\"S\"},\"line\":3062},{\"typeParams\":[\"K\",\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":3063},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3064},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Collection.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3065},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3066},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"obj\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":3},{\"k\":8,\"param\":\"V\"}]},\"line\":3067},{\"type\":{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":17},{\"k\":17}]},\"line\":3068}]},\"interface\":{\"line\":3070,\"typeParams\":[\"K\",\"V\"],\"extends\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}],\"groups\":[{\"members\":{\"#size\":{\"line\":3082}}},{\"title\":\"Force evaluation\",\"members\":{\"#cacheResult\":{\"doc\":{\"synopsis\":\"Because Sequences are lazy and designed to be chained together, they do\\nnot cache their results. For example, this map function is called a total\\nof 6 times, as each `join` iterates the Seq of three values.\",\"description\":\"    var squares = Seq([ 1, 2, 3 ]).map(x => x * x)\\n    squares.join() + squares.join()\\n\\nIf you know a `Seq` will be used multiple times, it may be more\\nefficient to first cache it in memory. Here, the map function is called\\nonly 3 times.\\n\\n    var squares = Seq([ 1, 2, 3 ]).map(x => x * x).cacheResult()\\n    squares.join() + squares.join()\\n\\nUse this method judiciously, as it must fully evaluate a Seq which can be\\na burden on memory and possibly performance.\\n\\nNote: after calling `cacheResult`, a Seq will always have a `size`.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":3107}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Seq with values passed through a\\n`mapper` function.\",\"description\":\"```js\\nconst { Seq } = require('immutable')\\nSeq([ 1, 2 ]).map(x => 10 * x)\\n// Seq [ 10, 20 ]\\n```\\n\\nNote: `map()` always returns a new instance, even if it produced the same\\nvalue at every step.\\nNote: used only for sets.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"M\"}]},\"line\":3124},{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":8,\"param\":\"M\"},{\"k\":8,\"param\":\"M\"}]},\"line\":3143}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Seq, returning a Seq of the same type.\",\"description\":\"Similar to `seq.map(...).flatten(true)`.\\nNote: Used only for sets.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"M\"}]},\"line\":3153},{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":8,\"param\":\"M\"},{\"k\":8,\"param\":\"M\"}]},\"line\":3164}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Seq with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"F\"}]},\"line\":3176},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":3180}]}}}]}},\"Collection\":{\"doc\":{\"synopsis\":\"The `Collection` is a set of (key, value) entries which can be iterated, and\\nis the base class for all collections in `immutable`, allowing them to\\nmake use of all the Collection methods (such as `map` and `filter`).\",\"description\":\"Note: A collection is always iterated in the same order, however that order\\nmay not always be well defined, as is the case for the `Map` and `Set`.\\n\\nCollection is the abstract base class for concrete data structures. It\\ncannot be constructed directly.\\n\\nImplementations should extend one of the subclasses, `Collection.Keyed`,\\n`Collection.Indexed`, or `Collection.Set`.\",\"notes\":[]},\"module\":{\"Keyed\":{\"doc\":{\"synopsis\":\"Keyed Collections have discrete keys tied to each value.\",\"description\":\"When iterating `Collection.Keyed`, each iteration will yield a `[K, V]`\\ntuple, in other words, `Collection#entries` is the default iterator for\\nKeyed Collections.\",\"notes\":[]},\"module\":{},\"call\":{\"doc\":{\"synopsis\":\"Creates a Collection.Keyed\",\"description\":\"Similar to `Collection()`, however it expects collection-likes of [K, V]\\ntuples if not constructed from a Collection.Keyed or JS Object.\\n\\nNote: `Collection.Keyed` is a conversion function and not a class, and\\ndoes not use the `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\",\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":3241},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"obj\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":3},{\"k\":8,\"param\":\"V\"}]},\"line\":3242}]},\"interface\":{\"line\":3244,\"typeParams\":[\"K\",\"V\"],\"extends\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}],\"groups\":[{\"members\":{\"#toJS\":{\"doc\":{\"synopsis\":\"Deeply converts this Keyed collection to equivalent native JavaScript Object.\",\"description\":\"Converts keys to Strings.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Object\"},\"line\":3250}]},\"#toJSON\":{\"doc\":{\"synopsis\":\"Shallowly converts this Keyed collection to equivalent native JavaScript Object.\",\"description\":\"Converts keys to Strings.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]},\"line\":3257}]},\"#toArray\":{\"doc\":{\"synopsis\":\"Shallowly converts this collection to an Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":3262}]},\"#toSeq\":{\"doc\":{\"synopsis\":\"Returns Seq.Keyed.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":3268}]}}},{\"title\":\"Sequence functions\",\"members\":{\"#flip\":{\"doc\":{\"synopsis\":\"Returns a new Collection.Keyed of the same type where the keys and values\\nhave been flipped.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap({ a: 'z', b: 'y' }).flip()\\n// Map { \\\"z\\\": \\\"a\\\", \\\"y\\\": \\\"b\\\" }\\n```\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"K\"}]},\"line\":3284}]},\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new Collection with other collections concatenated to this one.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"KC\",\"VC\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KC\"},{\"k\":8,\"param\":\"VC\"}]}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"KC\"}]},{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"VC\"}]}]},\"line\":3289},{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"C\"}}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":3}]},{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":3290}]},\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Collection.Keyed with values passed through a\\n`mapper` function.\",\"description\":\"```js\\nconst { Collection } = require('immutable')\\nCollection.Keyed({ a: 1, b: 2 }).map(x => 10 * x)\\n// Seq { \\\"a\\\": 10, \\\"b\\\": 20 }\\n```\\n\\nNote: `map()` always returns a new instance, even if it produced the\\nsame value at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"M\"}]},\"line\":3305}]},\"#mapKeys\":{\"doc\":{\"synopsis\":\"Returns a new Collection.Keyed of the same type with keys passed through\\na `mapper` function.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap({ a: 1, b: 2 }).mapKeys(x => x.toUpperCase())\\n// Map { \\\"A\\\": 1, \\\"B\\\": 2 }\\n```\\n\\nNote: `mapKeys()` always returns a new instance, even if it produced\\nthe same key at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"M\"},{\"k\":8,\"param\":\"V\"}]},\"line\":3324}]},\"#mapEntries\":{\"doc\":{\"synopsis\":\"Returns a new Collection.Keyed of the same type with entries\\n([key, value] tuples) passed through a `mapper` function.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap({ a: 1, b: 2 })\\n  .mapEntries(([ k, v ]) => [ k.toUpperCase(), v * 2 ])\\n// Map { \\\"A\\\": 2, \\\"B\\\": 4 }\\n```\\n\\nNote: `mapEntries()` always returns a new instance, even if it produced\\nthe same entry at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"entry\",\"type\":{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":3344}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Collection, returning a Collection of the same type.\",\"description\":\"Similar to `collection.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":3354}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Collection with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"F\"}]},\"line\":3366},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":3370}]},\"#[Symbol.iterator]\":{\"signatures\":[{\"type\":{\"k\":9,\"name\":\"IterableIterator\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":3375}]}}}]}},\"Indexed\":{\"doc\":{\"synopsis\":\"Indexed Collections have incrementing numeric keys. They exhibit\\nslightly different behavior than `Collection.Keyed` for some methods in order\\nto better mirror the behavior of JavaScript's `Array`, and add methods\\nwhich do not make sense on non-indexed Collections such as `indexOf`.\",\"description\":\"Unlike JavaScript arrays, `Collection.Indexed`s are always dense. \\\"Unset\\\"\\nindices and `undefined` indices are indistinguishable, and all indices from\\n0 to `size` are visited when iterated.\\n\\nAll Collection.Indexed methods return re-indexed Collections. In other words,\\nindices always start at 0 and increment until size. If you wish to\\npreserve indices, using them as keys, convert to a Collection.Keyed by\\ncalling `toKeyedSeq`.\",\"notes\":[]},\"module\":{},\"call\":{\"doc\":{\"synopsis\":\"Creates a new Collection.Indexed.\",\"description\":\"Note: `Collection.Indexed` is a conversion function and not a class, and\\ndoes not use the `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3402}]},\"interface\":{\"line\":3404,\"typeParams\":[\"T\"],\"extends\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":2},{\"k\":8,\"param\":\"T\"}]}],\"groups\":[{\"members\":{\"#toJS\":{\"doc\":{\"synopsis\":\"Deeply converts this Indexed collection to equivalent native JavaScript Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"line\":3408}]},\"#toJSON\":{\"doc\":{\"synopsis\":\"Shallowly converts this Indexed collection to equivalent native JavaScript Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3413}]},\"#toArray\":{\"doc\":{\"synopsis\":\"Shallowly converts this collection to an Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3418}]}}},{\"title\":\"Reading values\",\"members\":{\"#get\":{\"doc\":{\"synopsis\":\"Returns the value associated with the provided index, or notSetValue if\\nthe index is beyond the bounds of the Collection.\",\"description\":\"`index` may be a negative number, which indexes back from the end of the\\nCollection. `s.get(-1)` gets the last item in the Collection.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"NSV\"],\"params\":[{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"NSV\"}]},\"line\":3429},{\"params\":[{\"name\":\"index\",\"type\":{\"k\":2}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":11}]},\"line\":3430}]}}},{\"title\":\"Conversion to Seq\",\"members\":{\"#toSeq\":{\"doc\":{\"synopsis\":\"Returns Seq.Indexed.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3439}]},\"#fromEntrySeq\":{\"doc\":{\"synopsis\":\"If this is a collection of [key, value] entry tuples, it will return a\\nSeq.Keyed of those entries.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":17},{\"k\":17}]},\"line\":3445}]}}},{\"title\":\"Combination\",\"members\":{\"#interpose\":{\"doc\":{\"synopsis\":\"Returns a Collection of the same type with `separator` between each item\\nin this Collection.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"separator\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":10},\"line\":3454}]},\"#interleave\":{\"doc\":{\"synopsis\":\"Returns a Collection of the same type with the provided `collections`\\ninterleaved into this collection.\",\"description\":\"The resulting Collection includes the first item from each, then the\\nsecond from each, etc.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"require('immutable')\\\"}\\n-->\\n```js\\nconst { List } = require('immutable')\\nList([ 1, 2, 3 ]).interleave(List([ 'A', 'B', 'C' ]))\\n// List [ 1, \\\"A\\\", 2, \\\"B\\\", 3, \\\"C\\\" ]\\n```\\n\\nThe shortest Collection stops interleave.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable')\\\" }\\n-->\\n```js\\nList([ 1, 2, 3 ]).interleave(\\n  List([ 'A', 'B' ]),\\n  List([ 'X', 'Y', 'Z' ])\\n)\\n// List [ 1, \\\"A\\\", \\\"X\\\", 2, \\\"B\\\", \\\"Y\\\" ]\\n```\\n\\nSince `interleave()` re-indexes values, it produces a complete copy,\\nwhich has `O(N)` complexity.\\n\\nNote: `interleave` *cannot* be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"T\"}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":3490}]},\"#splice\":{\"doc\":{\"synopsis\":\"Splice returns a new indexed Collection by replacing a region of this\\nCollection with new values. If values are not provided, it only skips the\\nregion to be removed.\",\"description\":\"`index` may be a negative number, which indexes back from the end of the\\nCollection. `s.splice(-2)` splices after the second to last item.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nList([ 'a', 'b', 'c', 'd' ]).splice(1, 2, 'q', 'r', 's')\\n// List [ \\\"a\\\", \\\"q\\\", \\\"r\\\", \\\"s\\\", \\\"d\\\" ]\\n```\\n\\nSince `splice()` re-indexes values, it produces a complete copy, which\\nhas `O(N)` complexity.\\n\\nNote: `splice` *cannot* be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"removeNum\",\"type\":{\"k\":2}},{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":3512}]},\"#zip\":{\"doc\":{\"synopsis\":\"Returns a Collection of the same type \\\"zipped\\\" with the provided\\ncollections.\",\"description\":\"Like `zipWith`, but using the default `zipper`: creating an `Array`.\\n\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable')\\\" }\\n-->\\n```js\\nconst a = List([ 1, 2, 3 ]);\\nconst b = List([ 4, 5, 6 ]);\\nconst c = a.zip(b); // List [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":3534},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":3535},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":17}]},\"line\":3536}]},\"#zipAll\":{\"doc\":{\"synopsis\":\"Returns a Collection \\\"zipped\\\" with the provided collections.\",\"description\":\"Unlike `zip`, `zipAll` continues zipping until the longest collection is\\nexhausted. Missing values from shorter collections are filled with `undefined`.\\n\\n```js\\nconst a = List([ 1, 2 ]);\\nconst b = List([ 3, 4, 5 ]);\\nconst c = a.zipAll(b); // List [ [ 1, 3 ], [ 2, 4 ], [ undefined, 5 ] ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":3550},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":3551},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":17}]},\"line\":3552}]},\"#zipWith\":{\"doc\":{\"synopsis\":\"Returns a Collection of the same type \\\"zipped\\\" with the provided\\ncollections by using a custom `zipper` function.\",\"description\":\"<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable')\\\" }\\n-->\\n```js\\nconst a = List([ 1, 2, 3 ]);\\nconst b = List([ 4, 5, 6 ]);\\nconst c = a.zipWith((a, b) => a + b, b);\\n// List [ 5, 7, 9 ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":3568},{\"typeParams\":[\"U\",\"V\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}},{\"name\":\"thirdValue\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"thirdCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":3572},{\"typeParams\":[\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"any\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":3577}]}}},{\"title\":\"Search for value\",\"members\":{\"#indexOf\":{\"doc\":{\"synopsis\":\"Returns the first index at which a given value can be found in the\\nCollection, or -1 if it is not present.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"searchValue\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":2},\"line\":3589}]},\"#lastIndexOf\":{\"doc\":{\"synopsis\":\"Returns the last index at which a given value can be found in the\\nCollection, or -1 if it is not present.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"searchValue\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":2},\"line\":3595}]},\"#findIndex\":{\"doc\":{\"synopsis\":\"Returns the first index in the Collection where a value satisfies the\\nprovided predicate function. Otherwise -1 is returned.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":2},\"line\":3601}]},\"#findLastIndex\":{\"doc\":{\"synopsis\":\"Returns the last index in the Collection where a value satisfies the\\nprovided predicate function. Otherwise -1 is returned.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":2},\"line\":3610}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new Collection with other collections concatenated to this one.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"valuesOrCollections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"C\"}]},{\"k\":8,\"param\":\"C\"}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":3620}]},\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Collection.Indexed with values passed through a\\n`mapper` function.\",\"description\":\"```js\\nconst { Collection } = require('immutable')\\nCollection.Indexed([1,2]).map(x => 10 * x)\\n// Seq [ 1, 2 ]\\n```\\n\\nNote: `map()` always returns a new instance, even if it produced the\\nsame value at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":3635}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Collection, returning a Collection of the same type.\",\"description\":\"Similar to `collection.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":3645}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Collection with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"F\"}]},\"line\":3657},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":3661}]},\"#[Symbol.iterator]\":{\"signatures\":[{\"type\":{\"k\":9,\"name\":\"IterableIterator\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3666}]}}}]}},\"Set\":{\"doc\":{\"synopsis\":\"Set Collections only represent values. They have no associated keys or\\nindices. Duplicate values are possible in the lazy `Seq.Set`s, however\\nthe concrete `Set` Collection does not allow duplicate values.\",\"description\":\"Collection methods on Collection.Set such as `map` and `forEach` will provide\\nthe value as both the first and second arguments to the provided function.\\n\\n```js\\nconst { Collection } = require('immutable')\\nconst seq = Collection.Set([ 'A', 'B', 'C' ])\\n// Seq { \\\"A\\\", \\\"B\\\", \\\"C\\\" }\\nseq.forEach((v, k) =>\\n assert.equal(v, k)\\n)\\n```\",\"notes\":[]},\"module\":{},\"call\":{\"doc\":{\"synopsis\":\"Similar to `Collection()`, but always returns a Collection.Set.\",\"description\":\"Note: `Collection.Set` is a factory function and not a class, and does\\nnot use the `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3695}]},\"interface\":{\"line\":3697,\"typeParams\":[\"T\"],\"extends\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"T\"}]}],\"groups\":[{\"members\":{\"#toJS\":{\"doc\":{\"synopsis\":\"Deeply converts this Set collection to equivalent native JavaScript Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"line\":3701}]},\"#toJSON\":{\"doc\":{\"synopsis\":\"Shallowly converts this Set collection to equivalent native JavaScript Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3706}]},\"#toArray\":{\"doc\":{\"synopsis\":\"Shallowly converts this collection to an Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3711}]},\"#toSeq\":{\"doc\":{\"synopsis\":\"Returns Seq.Set.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3717}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new Collection with other collections concatenated to this one.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"U\"}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Set\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":3724}]},\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Collection.Set with values passed through a\\n`mapper` function.\",\"description\":\"```\\nCollection.Set([ 1, 2 ]).map(x => 10 * x)\\n// Seq { 1, 2 }\\n```\\n\\nNote: `map()` always returns a new instance, even if it produced the\\nsame value at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Set\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":3738}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Collection, returning a Collection of the same type.\",\"description\":\"Similar to `collection.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Set\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":3748}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Collection with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Set\",\"args\":[{\"k\":8,\"param\":\"F\"}]},\"line\":3760},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":3764}]},\"#[Symbol.iterator]\":{\"signatures\":[{\"type\":{\"k\":9,\"name\":\"IterableIterator\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3769}]}}}]}}},\"call\":{\"doc\":{\"synopsis\":\"Creates a Collection.\",\"description\":\"The type of Collection created is based on the input.\\n\\n  * If an `Collection`, that same `Collection`.\\n  * If an Array-like, an `Collection.Indexed`.\\n  * If an Object with an Iterator defined, an `Collection.Indexed`.\\n  * If an Object, an `Collection.Keyed`.\\n\\nThis methods forces the conversion of Objects and Strings to Collections.\\nIf you want to ensure that a Collection of one item is returned, use\\n`Seq.of`.\\n\\nNote: An Iterator itself will be treated as an object, becoming a `Seq.Keyed`,\\nwhich is usually not what you want. You should turn your Iterator Object into\\nan iterable object by defining a Symbol.iterator (or @@iterator) method which\\nreturns `this`.\\n\\nNote: `Collection` is a conversion function and not a class, and does not\\nuse the `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"I\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"I\"}}],\"type\":{\"k\":8,\"param\":\"I\"},\"line\":3796},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3797},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"obj\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":3},{\"k\":8,\"param\":\"V\"}]},\"line\":3798}]},\"interface\":{\"line\":3800,\"typeParams\":[\"K\",\"V\"],\"extends\":[{\"k\":9,\"name\":\"ValueObject\"}],\"groups\":[{\"title\":\"Value equality\",\"members\":{\"#equals\":{\"doc\":{\"synopsis\":\"True if this and the other Collection have value equality, as defined\\nby `Immutable.is()`.\",\"description\":\"Note: This is equivalent to `Immutable.is(this, other)`, but provided to\\nallow for chained expressions.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"other\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":3811}]},\"#hashCode\":{\"doc\":{\"synopsis\":\"Computes and returns the hashed identity for this Collection.\",\"description\":\"The `hashCode` of a Collection is used to determine potential equality,\\nand is used when adding this to a `Set` or as a key in a `Map`, enabling\\nlookup via a different instance.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Set,  List } = require('immutable')\\\" }\\n-->\\n```js\\nconst a = List([ 1, 2, 3 ]);\\nconst b = List([ 1, 2, 3 ]);\\nassert.notStrictEqual(a, b); // different instances\\nconst set = Set([ a ]);\\nassert.equal(set.has(b), true);\\n```\\n\\nIf two values have the same `hashCode`, they are [not guaranteed\\nto be equal][Hash Collision]. If two values have different `hashCode`s,\\nthey must not be equal.\\n\\n[Hash Collision]: https://en.wikipedia.org/wiki/Collision_(computer_science)\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":2},\"line\":3837}]}}},{\"title\":\"Reading values\",\"members\":{\"#get\":{\"doc\":{\"synopsis\":\"Returns the value associated with the provided key, or notSetValue if\\nthe Collection does not contain this key.\",\"description\":\"Note: it is possible a key may be associated with an `undefined` value,\\nso if `notSetValue` is not provided and this method returns `undefined`,\\nthat does not guarantee the key was not found.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"NSV\"],\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]},\"line\":3850},{\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":3851}]},\"#has\":{\"doc\":{\"synopsis\":\"True if a key exists within this `Collection`, using `Immutable.is`\\nto determine equality\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":1},\"line\":3857}]},\"#includes\":{\"doc\":{\"synopsis\":\"True if a value exists within this `Collection`, using `Immutable.is`\\nto determine equality\",\"description\":\"\",\"notes\":[{\"name\":\"alias\",\"body\":\"contains\"}]},\"signatures\":[{\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":1},\"line\":3864}]},\"#first\":{\"doc\":{\"synopsis\":\"In case the `Collection` is not empty returns the first element of the\\n`Collection`.\\nIn case the `Collection` is empty returns the optional default\\nvalue if provided, if no default value is provided returns undefined.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"NSV\"],\"params\":[{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]},\"line\":3873}]},\"#last\":{\"doc\":{\"synopsis\":\"In case the `Collection` is not empty returns the last element of the\\n`Collection`.\\nIn case the `Collection` is empty returns the optional default\\nvalue if provided, if no default value is provided returns undefined.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"NSV\"],\"params\":[{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]},\"line\":3881}]}}},{\"title\":\"Reading deep values\",\"members\":{\"#getIn\":{\"doc\":{\"synopsis\":\"Returns the value found by following a path of keys or indices through\\nnested Collections.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map, List } = require('immutable')\\nconst deepData = Map({ x: List([ Map({ y: 123 }) ]) });\\ndeepData.getIn(['x', 0, 'y']) // 123\\n```\\n\\nPlain JavaScript Object or Arrays may be nested within an Immutable.js\\nCollection, and getIn() can access those values as well:\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map, List } = require('immutable')\\nconst deepData = Map({ x: [ { y: 123 } ] });\\ndeepData.getIn(['x', 0, 'y']) // 123\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"searchKeyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"notSetValue\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":17},\"line\":3906}]},\"#hasIn\":{\"doc\":{\"synopsis\":\"True if the result of following a path of keys or indices through nested\\nCollections results in a set value.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"searchKeyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}}],\"type\":{\"k\":1},\"line\":3912}]}}},{\"title\":\"Persistent changes\",\"members\":{\"#update\":{\"doc\":{\"synopsis\":\"This can be very useful as a way to \\\"chain\\\" a normal function into a\\nsequence of methods. RxJS calls this \\\"let\\\" and lodash calls it \\\"thru\\\".\",\"description\":\"For example, to sum a Seq after mapping and filtering:\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Seq } = require('immutable')\\n\\nfunction sum(collection) {\\n  return collection.reduce((sum, x) => sum + x, 0)\\n}\\n\\nSeq([ 1, 2, 3 ])\\n  .map(x => x + 1)\\n  .filter(x => x % 2 === 0)\\n  .update(sum)\\n// 6\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"R\"],\"params\":[{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"R\"}}}],\"type\":{\"k\":8,\"param\":\"R\"},\"line\":3937}]}}},{\"title\":\"Conversion to JavaScript types\",\"members\":{\"#toJS\":{\"doc\":{\"synopsis\":\"Deeply converts this Collection to equivalent native JavaScript Array or Object.\",\"description\":\"`Collection.Indexed`, and `Collection.Set` become `Array`, while\\n`Collection.Keyed` become `Object`, converting keys to Strings.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":17}}]}]},\"line\":3948}]},\"#toJSON\":{\"doc\":{\"synopsis\":\"Shallowly converts this Collection to equivalent native JavaScript Array or Object.\",\"description\":\"`Collection.Indexed`, and `Collection.Set` become `Array`, while\\n`Collection.Keyed` become `Object`, converting keys to Strings.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"V\"}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}]},\"line\":3956}]},\"#toArray\":{\"doc\":{\"synopsis\":\"Shallowly converts this collection to an Array.\",\"description\":\"`Collection.Indexed`, and `Collection.Set` produce an Array of values.\\n`Collection.Keyed` produce an Array of [key, value] tuples.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"V\"}]},{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]}]},\"line\":3964}]},\"#toObject\":{\"doc\":{\"synopsis\":\"Shallowly converts this Collection to an Object.\",\"description\":\"Converts keys to Strings.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]},\"line\":3971}]}}},{\"title\":\"Conversion to Collections\",\"members\":{\"#toMap\":{\"doc\":{\"synopsis\":\"Converts this Collection to a Map, Throws if keys are not hashable.\",\"description\":\"Note: This is equivalent to `Map(this.toKeyedSeq())`, but provided\\nfor convenience and to allow for chained expressions.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":3982}]},\"#toOrderedMap\":{\"doc\":{\"synopsis\":\"Converts this Collection to a Map, maintaining the order of iteration.\",\"description\":\"Note: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but\\nprovided for convenience and to allow for chained expressions.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":3990}]},\"#toSet\":{\"doc\":{\"synopsis\":\"Converts this Collection to a Set, discarding keys. Throws if values\\nare not hashable.\",\"description\":\"Note: This is equivalent to `Set(this)`, but provided to allow for\\nchained expressions.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":3999}]},\"#toOrderedSet\":{\"doc\":{\"synopsis\":\"Converts this Collection to a Set, maintaining the order of iteration and\\ndiscarding keys.\",\"description\":\"Note: This is equivalent to `OrderedSet(this.valueSeq())`, but provided\\nfor convenience and to allow for chained expressions.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":4008}]},\"#toList\":{\"doc\":{\"synopsis\":\"Converts this Collection to a List, discarding keys.\",\"description\":\"This is similar to `List(collection)`, but provided to allow for chained\\nexpressions. However, when called on `Map` or other keyed collections,\\n`collection.toList()` discards the keys and creates a list of only the\\nvalues, whereas `List(collection)` creates a list of entry tuples.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map, List } = require('immutable')\\nvar myMap = Map({ a: 'Apple', b: 'Banana' })\\nList(myMap) // List [ [ \\\"a\\\", \\\"Apple\\\" ], [ \\\"b\\\", \\\"Banana\\\" ] ]\\nmyMap.toList() // List [ \\\"Apple\\\", \\\"Banana\\\" ]\\n```\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":4026}]},\"#toStack\":{\"doc\":{\"synopsis\":\"Converts this Collection to a Stack, discarding keys. Throws if values\\nare not hashable.\",\"description\":\"Note: This is equivalent to `Stack(this)`, but provided to allow for\\nchained expressions.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":4035}]}}},{\"title\":\"Conversion to Seq\",\"members\":{\"#toSeq\":{\"doc\":{\"synopsis\":\"Converts this Collection to a Seq of the same kind (indexed,\\nkeyed, or set).\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":4044}]},\"#toKeyedSeq\":{\"doc\":{\"synopsis\":\"Returns a Seq.Keyed from this Collection where indices are treated as keys.\",\"description\":\"This is useful if you want to operate on an\\nCollection.Indexed and preserve the [index, value] pairs.\\n\\nThe returned Seq will have identical iteration order as\\nthis Collection.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Seq } = require('immutable')\\nconst indexedSeq = Seq([ 'A', 'B', 'C' ])\\n// Seq [ \\\"A\\\", \\\"B\\\", \\\"C\\\" ]\\nindexedSeq.filter(v => v === 'B')\\n// Seq [ \\\"B\\\" ]\\nconst keyedSeq = indexedSeq.toKeyedSeq()\\n// Seq { 0: \\\"A\\\", 1: \\\"B\\\", 2: \\\"C\\\" }\\nkeyedSeq.filter(v => v === 'B')\\n// Seq { 1: \\\"B\\\" }\\n```\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":4068}]},\"#toIndexedSeq\":{\"doc\":{\"synopsis\":\"Returns an Seq.Indexed of the values of this Collection, discarding keys.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":4073}]},\"#toSetSeq\":{\"doc\":{\"synopsis\":\"Returns a Seq.Set of the values of this Collection, discarding keys.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":4078}]}}},{\"title\":\"Iterators\",\"members\":{\"#keys\":{\"doc\":{\"synopsis\":\"An iterator of this `Collection`'s keys.\",\"description\":\"Note: this will return an ES6 iterator which does not support\\nImmutable.js sequence algorithms. Use `keySeq` instead, if this is\\nwhat you want.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"IterableIterator\",\"args\":[{\"k\":8,\"param\":\"K\"}]},\"line\":4090}]},\"#values\":{\"doc\":{\"synopsis\":\"An iterator of this `Collection`'s values.\",\"description\":\"Note: this will return an ES6 iterator which does not support\\nImmutable.js sequence algorithms. Use `valueSeq` instead, if this is\\nwhat you want.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"IterableIterator\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":4099}]},\"#entries\":{\"doc\":{\"synopsis\":\"An iterator of this `Collection`'s entries as `[ key, value ]` tuples.\",\"description\":\"Note: this will return an ES6 iterator which does not support\\nImmutable.js sequence algorithms. Use `entrySeq` instead, if this is\\nwhat you want.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"IterableIterator\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":4108}]}}},{\"title\":\"Collections (Seq)\",\"members\":{\"#keySeq\":{\"doc\":{\"synopsis\":\"Returns a new Seq.Indexed of the keys of this Collection,\\ndiscarding values.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"K\"}]},\"line\":4117}]},\"#valueSeq\":{\"doc\":{\"synopsis\":\"Returns an Seq.Indexed of the values of this Collection, discarding keys.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":4122}]},\"#entrySeq\":{\"doc\":{\"synopsis\":\"Returns a new Seq.Indexed of [key, value] tuples.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":4127}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type with values passed through a\\n`mapper` function.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Collection } = require('immutable')\\nCollection({ a: 1, b: 2 }).map(x => 10 * x)\\n// Seq { \\\"a\\\": 10, \\\"b\\\": 20 }\\n```\\n\\nNote: `map()` always returns a new instance, even if it produced the same\\nvalue at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"M\"}]},\"line\":4146}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type with only the entries for which\\nthe `predicate` function returns true.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap({ a: 1, b: 2, c: 3, d: 4}).filter(x => x % 2 === 0)\\n// Map { \\\"b\\\": 2, \\\"d\\\": 4 }\\n```\\n\\nNote: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"F\"}]},\"line\":4173},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":4177}]},\"#filterNot\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type with only the entries for which\\nthe `predicate` function returns false.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)\\n// Map { \\\"a\\\": 1, \\\"c\\\": 3 }\\n```\\n\\nNote: `filterNot()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":4196}]},\"#reverse\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type in reverse order.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":4204}]},\"#sort\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which includes the same entries,\\nstably sorted by using a `comparator`.\",\"description\":\"If a `comparator` is not provided, a default comparator uses `<` and `>`.\\n\\n`comparator(valueA, valueB)`:\\n\\n  * Returns `0` if the elements should not be swapped.\\n  * Returns `-1` (or any negative number) if `valueA` comes before `valueB`\\n  * Returns `1` (or any positive number) if `valueA` comes after `valueB`\\n  * Is pure, i.e. it must always return the same value for the same pair\\n    of values.\\n\\nWhen sorting collections which have no defined order, their ordered\\nequivalents will be returned. e.g. `map.sort()` returns OrderedMap.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap({ \\\"c\\\": 3, \\\"a\\\": 1, \\\"b\\\": 2 }).sort((a, b) => {\\n  if (a < b) { return -1; }\\n  if (a > b) { return 1; }\\n  if (a === b) { return 0; }\\n});\\n// OrderedMap { \\\"a\\\": 1, \\\"b\\\": 2, \\\"c\\\": 3 }\\n```\\n\\nNote: `sort()` Always returns a new instance, even if the original was\\nalready sorted.\\n\\nNote: This is always an eager operation.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"comparator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"valueA\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"valueB\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":2}},\"optional\":true}],\"type\":{\"k\":10},\"line\":4239}]},\"#sortBy\":{\"doc\":{\"synopsis\":\"Like `sort`, but also accepts a `comparatorValueMapper` which allows for\\nsorting by more sophisticated means:\",\"description\":\"    hitters.sortBy(hitter => hitter.avgHits)\\n\\nNote: `sortBy()` Always returns a new instance, even if the original was\\nalready sorted.\\n\\nNote: This is always an eager operation.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"comparatorValueMapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"C\"}}},{\"name\":\"comparator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"valueA\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"valueB\",\"type\":{\"k\":8,\"param\":\"C\"}}],\"type\":{\"k\":2}},\"optional\":true}],\"type\":{\"k\":10},\"line\":4252}]},\"#groupBy\":{\"doc\":{\"synopsis\":\"Returns a `Collection.Keyed` of `Collection.Keyeds`, grouped by the return\\nvalue of the `grouper` function.\",\"description\":\"Note: This is always an eager operation.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { List, Map } = require('immutable')\\nconst listOfMaps = List([\\n  Map({ v: 0 }),\\n  Map({ v: 1 }),\\n  Map({ v: 1 }),\\n  Map({ v: 0 }),\\n  Map({ v: 2 })\\n])\\nconst groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))\\n// Map {\\n//   0: List [ Map{ \\\"v\\\": 0 }, Map { \\\"v\\\": 0 } ],\\n//   1: List [ Map{ \\\"v\\\": 1 }, Map { \\\"v\\\": 1 } ],\\n//   2: List [ Map{ \\\"v\\\": 2 } ],\\n// }\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"G\"],\"params\":[{\"name\":\"grouper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"G\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"G\"},{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":4281}]}}},{\"title\":\"Side effects\",\"members\":{\"#forEach\":{\"doc\":{\"synopsis\":\"The `sideEffect` is executed for every entry in the Collection.\",\"description\":\"Unlike `Array#forEach`, if any call of `sideEffect` returns\\n`false`, the iteration will stop. Returns the number of entries iterated\\n(including the last iteration which returned false).\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"sideEffect\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":2},\"line\":4296}]}}},{\"title\":\"Creating subsets\",\"members\":{\"#slice\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type representing a portion of this\\nCollection from start up to but not including end.\",\"description\":\"If begin is negative, it is offset from the end of the Collection. e.g.\\n`slice(-2)` returns a Collection of the last two entries. If it is not\\nprovided the new Collection will begin at the beginning of this Collection.\\n\\nIf end is negative, it is offset from the end of the Collection. e.g.\\n`slice(0, -1)` returns a Collection of everything but the last entry. If\\nit is not provided, the new Collection will continue through the end of\\nthis Collection.\\n\\nIf the requested slice is equivalent to the current Collection, then it\\nwill return itself.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"begin\",\"type\":{\"k\":2},\"optional\":true},{\"name\":\"end\",\"type\":{\"k\":2},\"optional\":true}],\"type\":{\"k\":10},\"line\":4320}]},\"#rest\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type containing all entries except\\nthe first.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":4326}]},\"#butLast\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type containing all entries except\\nthe last.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":4332}]},\"#skip\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which excludes the first `amount`\\nentries from this Collection.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"amount\",\"type\":{\"k\":2}}],\"type\":{\"k\":10},\"line\":4338}]},\"#skipLast\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which excludes the last `amount`\\nentries from this Collection.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"amount\",\"type\":{\"k\":2}}],\"type\":{\"k\":10},\"line\":4344}]},\"#skipWhile\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which includes entries starting\\nfrom when `predicate` first returns false.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\\n  .skipWhile(x => x.match(/g/))\\n// List [ \\\"cat\\\", \\\"hat\\\", \\\"god\\\" ]\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":4358}]},\"#skipUntil\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which includes entries starting\\nfrom when `predicate` first returns true.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\\n  .skipUntil(x => x.match(/hat/))\\n// List [ \\\"hat\\\", \\\"god\\\" ]\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":4375}]},\"#take\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which includes the first `amount`\\nentries from this Collection.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"amount\",\"type\":{\"k\":2}}],\"type\":{\"k\":10},\"line\":4384}]},\"#takeLast\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which includes the last `amount`\\nentries from this Collection.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"amount\",\"type\":{\"k\":2}}],\"type\":{\"k\":10},\"line\":4390}]},\"#takeWhile\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which includes entries from this\\nCollection as long as the `predicate` returns true.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\\n  .takeWhile(x => x.match(/o/))\\n// List [ \\\"dog\\\", \\\"frog\\\" ]\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":4404}]},\"#takeUntil\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which includes entries from this\\nCollection as long as the `predicate` returns false.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\\n  .takeUntil(x => x.match(/at/))\\n// List [ \\\"dog\\\", \\\"frog\\\" ]\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":4421}]}}},{\"title\":\"Combination\",\"members\":{\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type with other values and\\ncollection-like concatenated to this one.\",\"description\":\"For Seqs, all entries will be present in the resulting Seq, even if they\\nhave the same key.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"valuesOrCollections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]},\"line\":4436}]},\"#flatten\":{\"doc\":{\"synopsis\":\"Flattens nested Collections.\",\"description\":\"Will deeply flatten the Collection by default, returning a Collection of the\\nsame type, but a `depth` can be provided in the form of a number or\\nboolean (where true means to shallowly flatten one level). A depth of 0\\n(or shallow: false) will deeply flatten.\\n\\nFlattens only others Collection, not Arrays or Objects.\\n\\nNote: `flatten(true)` operates on Collection<unknown, Collection<K, V>> and\\nreturns Collection<K, V>\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"depth\",\"type\":{\"k\":2},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]},\"line\":4451},{\"params\":[{\"name\":\"shallow\",\"type\":{\"k\":1},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]},\"line\":4452}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Collection, returning a Collection of the same type.\",\"description\":\"Similar to `collection.map(...).flatten(true)`.\\nUsed for Dictionaries only.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"M\"}]},\"line\":4459},{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":4470}]}}},{\"title\":\"Reducing a value\",\"members\":{\"#reduce\":{\"doc\":{\"synopsis\":\"Reduces the Collection to a value by calling the `reducer` for every entry\\nin the Collection and passing along the reduced value.\",\"description\":\"If `initialReduction` is not provided, the first item in the\\nCollection will be used.\\n\",\"notes\":[{\"name\":\"see\",\"body\":\"`Array#reduce`.\"}]},\"signatures\":[{\"typeParams\":[\"R\"],\"params\":[{\"name\":\"reducer\",\"type\":{\"k\":7,\"params\":[{\"name\":\"reduction\",\"type\":{\"k\":8,\"param\":\"R\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"R\"}}},{\"name\":\"initialReduction\",\"type\":{\"k\":8,\"param\":\"R\"}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":8,\"param\":\"R\"},\"line\":4486},{\"typeParams\":[\"R\"],\"params\":[{\"name\":\"reducer\",\"type\":{\"k\":7,\"params\":[{\"name\":\"reduction\",\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"R\"}]}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"R\"}}}],\"type\":{\"k\":8,\"param\":\"R\"},\"line\":4491}]},\"#reduceRight\":{\"doc\":{\"synopsis\":\"Reduces the Collection in reverse (from the right side).\",\"description\":\"Note: Similar to this.reverse().reduce(), and provided for parity\\nwith `Array#reduceRight`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"R\"],\"params\":[{\"name\":\"reducer\",\"type\":{\"k\":7,\"params\":[{\"name\":\"reduction\",\"type\":{\"k\":8,\"param\":\"R\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"R\"}}},{\"name\":\"initialReduction\",\"type\":{\"k\":8,\"param\":\"R\"}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":8,\"param\":\"R\"},\"line\":4501},{\"typeParams\":[\"R\"],\"params\":[{\"name\":\"reducer\",\"type\":{\"k\":7,\"params\":[{\"name\":\"reduction\",\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"R\"}]}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"R\"}}}],\"type\":{\"k\":8,\"param\":\"R\"},\"line\":4506}]},\"#every\":{\"doc\":{\"synopsis\":\"True if `predicate` returns true for all entries in the Collection.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":1},\"line\":4513}]},\"#some\":{\"doc\":{\"synopsis\":\"True if `predicate` returns true for any entry in the Collection.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":1},\"line\":4521}]},\"#join\":{\"doc\":{\"synopsis\":\"Joins values together as a string, inserting a separator between each.\\nThe default separator is `\\\",\\\"`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"separator\",\"type\":{\"k\":3},\"optional\":true}],\"type\":{\"k\":3},\"line\":4530}]},\"#isEmpty\":{\"doc\":{\"synopsis\":\"Returns true if this Collection includes no values.\",\"description\":\"For some lazy `Seq`, `isEmpty` might need to iterate to determine\\nemptiness. At most one iteration will occur.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":1},\"line\":4538}]},\"#count\":{\"doc\":{\"synopsis\":\"Returns the size of this Collection.\",\"description\":\"Regardless of if this Collection can describe its size lazily (some Seqs\\ncannot), this method will always return the correct size. E.g. it\\nevaluates a lazy `Seq` if necessary.\\n\\nIf `predicate` is provided, then this returns the count of entries in the\\nCollection for which the `predicate` returns true.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":2},\"line\":4550},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":2},\"line\":4551}]},\"#countBy\":{\"doc\":{\"synopsis\":\"Returns a `Seq.Keyed` of counts, grouped by the return value of\\nthe `grouper` function.\",\"description\":\"Note: This is not a lazy operation.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"G\"],\"params\":[{\"name\":\"grouper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"G\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"G\"},{\"k\":2}]},\"line\":4562}]}}},{\"title\":\"Search for value\",\"members\":{\"#find\":{\"doc\":{\"synopsis\":\"Returns the first value for which the `predicate` returns true.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"V\"},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":4573}]},\"#findLast\":{\"doc\":{\"synopsis\":\"Returns the last value for which the `predicate` returns true.\",\"description\":\"Note: `predicate` will be called for each entry in reverse.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"V\"},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":4584}]},\"#findEntry\":{\"doc\":{\"synopsis\":\"Returns the first [key, value] entry for which the `predicate` returns true.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"V\"},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},{\"k\":11}]},\"line\":4593}]},\"#findLastEntry\":{\"doc\":{\"synopsis\":\"Returns the last [key, value] entry for which the `predicate`\\nreturns true.\",\"description\":\"Note: `predicate` will be called for each entry in reverse.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"V\"},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},{\"k\":11}]},\"line\":4605}]},\"#findKey\":{\"doc\":{\"synopsis\":\"Returns the key for which the `predicate` returns true.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":11}]},\"line\":4614}]},\"#findLastKey\":{\"doc\":{\"synopsis\":\"Returns the last key for which the `predicate` returns true.\",\"description\":\"Note: `predicate` will be called for each entry in reverse.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":11}]},\"line\":4624}]},\"#keyOf\":{\"doc\":{\"synopsis\":\"Returns the key associated with the search value, or undefined.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"searchValue\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":11}]},\"line\":4632}]},\"#lastKeyOf\":{\"doc\":{\"synopsis\":\"Returns the last key associated with the search value, or undefined.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"searchValue\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":11}]},\"line\":4637}]},\"#max\":{\"doc\":{\"synopsis\":\"Returns the maximum value in this collection. If any values are\\ncomparatively equivalent, the first one found will be returned.\",\"description\":\"The `comparator` is used in the same way as `Collection#sort`. If it is not\\nprovided, the default comparator is `>`.\\n\\nWhen two values are considered equivalent, the first encountered will be\\nreturned. Otherwise, `max` will operate independent of the order of input\\nas long as the comparator is commutative. The default comparator `>` is\\ncommutative *only* when types do not differ.\\n\\nIf `comparator` returns 0 and either value is NaN, undefined, or null,\\nthat value will be returned.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"comparator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"valueA\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"valueB\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":2}},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":4654}]},\"#maxBy\":{\"doc\":{\"synopsis\":\"Like `max`, but also accepts a `comparatorValueMapper` which allows for\\ncomparing by more sophisticated means:\",\"description\":\"    hitters.maxBy(hitter => hitter.avgHits);\\n\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"comparatorValueMapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"C\"}}},{\"name\":\"comparator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"valueA\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"valueB\",\"type\":{\"k\":8,\"param\":\"C\"}}],\"type\":{\"k\":2}},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":4663}]},\"#min\":{\"doc\":{\"synopsis\":\"Returns the minimum value in this collection. If any values are\\ncomparatively equivalent, the first one found will be returned.\",\"description\":\"The `comparator` is used in the same way as `Collection#sort`. If it is not\\nprovided, the default comparator is `<`.\\n\\nWhen two values are considered equivalent, the first encountered will be\\nreturned. Otherwise, `min` will operate independent of the order of input\\nas long as the comparator is commutative. The default comparator `<` is\\ncommutative *only* when types do not differ.\\n\\nIf `comparator` returns 0 and either value is NaN, undefined, or null,\\nthat value will be returned.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"comparator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"valueA\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"valueB\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":2}},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":4683}]},\"#minBy\":{\"doc\":{\"synopsis\":\"Like `min`, but also accepts a `comparatorValueMapper` which allows for\\ncomparing by more sophisticated means:\",\"description\":\"    hitters.minBy(hitter => hitter.avgHits);\\n\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"comparatorValueMapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"C\"}}},{\"name\":\"comparator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"valueA\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"valueB\",\"type\":{\"k\":8,\"param\":\"C\"}}],\"type\":{\"k\":2}},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":4692}]}}},{\"title\":\"Comparison\",\"members\":{\"#isSubset\":{\"doc\":{\"synopsis\":\"True if `iter` includes every value in this Collection.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"iter\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":1},\"line\":4703}]},\"#isSuperset\":{\"doc\":{\"synopsis\":\"True if this Collection includes every value in `iter`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"iter\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":1},\"line\":4708}]}}}]}},\"ValueObject\":{\"interface\":{\"line\":4714,\"doc\":{\"synopsis\":\"The interface to fulfill to qualify as a Value Object.\",\"description\":\"\",\"notes\":[]},\"groups\":[{\"members\":{\"#equals\":{\"doc\":{\"synopsis\":\"True if this and the other Collection have value equality, as defined\\nby `Immutable.is()`.\",\"description\":\"Note: This is equivalent to `Immutable.is(this, other)`, but provided to\\nallow for chained expressions.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"other\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4722}]},\"#hashCode\":{\"doc\":{\"synopsis\":\"Computes and returns the hashed identity for this Collection.\",\"description\":\"The `hashCode` of a Collection is used to determine potential equality,\\nand is used when adding this to a `Set` or as a key in a `Map`, enabling\\nlookup via a different instance.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { List, Set } = require('immutable');\\nconst a = List([ 1, 2, 3 ]);\\nconst b = List([ 1, 2, 3 ]);\\nassert.notStrictEqual(a, b); // different instances\\nconst set = Set([ a ]);\\nassert.equal(set.has(b), true);\\n```\\n\\nNote: hashCode() MUST return a Uint32 number. The easiest way to\\nguarantee this is to return `myHash | 0` from a custom implementation.\\n\\nIf two values have the same `hashCode`, they are [not guaranteed\\nto be equal][Hash Collision]. If two values have different `hashCode`s,\\nthey must not be equal.\\n\\nNote: `hashCode()` is not guaranteed to always be called before\\n`equals()`. Most but not all Immutable.js collections use hash codes to\\norganize their internal data structures, while all Immutable.js\\ncollections use equality during lookups.\\n\\n[Hash Collision]: https://en.wikipedia.org/wiki/Collision_(computer_science)\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":2},\"line\":4755}]}}}]}},\"fromJS\":{\"call\":{\"doc\":{\"synopsis\":\"Deeply converts plain JS objects and arrays to Immutable Maps and Lists.\",\"description\":\"If a `reviver` is optionally provided, it will be called with every\\ncollection as a Seq (beginning with the most nested collections\\nand proceeding to the top-level collection itself), along with the key\\nreferring to each collection and the parent JS object provided as `this`.\\nFor the top level, object, the key will be `\\\"\\\"`. This `reviver` is expected\\nto return a new Immutable Collection, allowing for custom conversions from\\ndeep JS objects. Finally, a `path` is provided which is the sequence of\\nkeys to this value from the starting value.\\n\\n`reviver` acts similarly to the [same parameter in `JSON.parse`][1].\\n\\nIf `reviver` is not provided, the default behavior will convert Objects\\ninto Maps and Arrays into Lists like so:\\n\\n<!-- runkit:activate -->\\n```js\\nconst { fromJS, isKeyed } = require('immutable')\\nfunction (key, value) {\\n  return isKeyed(value) ? value.toMap() : value.toList()\\n}\\n```\\n\\n`fromJS` is conservative in its conversion. It will only convert\\narrays which pass `Array.isArray` to Lists, and only raw objects (no custom\\nprototype) to Map.\\n\\nAccordingly, this example converts native JS data to OrderedMap and List:\\n\\n<!-- runkit:activate -->\\n```js\\nconst { fromJS, isKeyed } = require('immutable')\\nfromJS({ a: {b: [10, 20, 30]}, c: 40}, function (key, value, path) {\\n  console.log(key, value, path)\\n  return isKeyed(value) ? value.toOrderedMap() : value.toList()\\n})\\n\\n> \\\"b\\\", [ 10, 20, 30 ], [ \\\"a\\\", \\\"b\\\" ]\\n> \\\"a\\\", {b: [10, 20, 30]}, [ \\\"a\\\" ]\\n> \\\"\\\", {a: {b: [10, 20, 30]}, c: 40}, []\\n```\\n\\nKeep in mind, when using JS objects to construct Immutable Maps, that\\nJavaScript Object properties are always strings, even if written in a\\nquote-less shorthand, while Immutable Maps accept keys of any type.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nlet obj = { 1: \\\"one\\\" };\\nObject.keys(obj); // [ \\\"1\\\" ]\\nassert.equal(obj[\\\"1\\\"], obj[1]); // \\\"one\\\" === \\\"one\\\"\\n\\nlet map = Map(obj);\\nassert.notEqual(map.get(\\\"1\\\"), map.get(1)); // \\\"one\\\" !== undefined\\n```\\n\\nProperty access for JavaScript Objects first converts the key to a string,\\nbut since Immutable Map keys can be of any type the argument to `get()` is\\nnot altered.\\n\\n[1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Example.3A_Using_the_reviver_parameter\\n     \\\"Using the reviver parameter\\\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"jsValue\",\"type\":{\"k\":17}},{\"name\":\"reviver\",\"type\":{\"k\":7,\"params\":[{\"name\":\"key\",\"type\":{\"k\":12,\"types\":[{\"k\":3},{\"k\":2}]}},{\"name\":\"sequence\",\"type\":{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":3},{\"k\":17}]},{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":17}]}]}},{\"name\":\"path\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":3},{\"k\":2}]}]},\"optional\":true}],\"type\":{\"k\":17}},\"optional\":true}],\"type\":{\"k\":17},\"line\":4824}]}},\"is\":{\"call\":{\"doc\":{\"synopsis\":\"Value equality check with semantics similar to `Object.is`, but treats\\nImmutable `Collection`s as values, equal if the second `Collection` includes\\nequivalent values.\",\"description\":\"It's used throughout Immutable when checking for equality, including `Map`\\nkey equality and `Set` membership.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map, is } = require('immutable')\\nconst map1 = Map({ a: 1, b: 1, c: 1 })\\nconst map2 = Map({ a: 1, b: 1, c: 1 })\\nassert.equal(map1 !== map2, true)\\nassert.equal(Object.is(map1, map2), false)\\nassert.equal(is(map1, map2), true)\\n```\\n\\n`is()` compares primitive types like strings and numbers, Immutable.js\\ncollections like `Map` and `List`, but also any custom object which\\nimplements `ValueObject` by providing `equals()` and `hashCode()` methods.\\n\\nNote: Unlike `Object.is`, `Immutable.is` assumes `0` and `-0` are the same\\nvalue, matching the behavior of ES6 Map key equality.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"first\",\"type\":{\"k\":17}},{\"name\":\"second\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4858}]}},\"hash\":{\"call\":{\"doc\":{\"synopsis\":\"The `hash()` function is an important part of how Immutable determines if\\ntwo values are equivalent and is used to determine how to store those\\nvalues. Provided with any value, `hash()` will return a 31-bit integer.\",\"description\":\"When designing Objects which may be equal, it's important that when a\\n`.equals()` method returns true, that both values `.hashCode()` method\\nreturn the same value. `hash()` may be used to produce those values.\\n\\nFor non-Immutable Objects that do not provide a `.hashCode()` functions\\n(including plain Objects, plain Arrays, Date objects, etc), a unique hash\\nvalue will be created for each *instance*. That is, the create hash\\nrepresents referential equality, and not value equality for Objects. This\\nensures that if that Object is mutated over time that its hash code will\\nremain consistent, allowing Objects to be used as keys and values in\\nImmutable.js collections.\\n\\nNote that `hash()` attempts to balance between speed and avoiding\\ncollisions, however it makes no attempt to produce secure hashes.\\n\\n*New in Version 4.0*\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":2},\"line\":4882}]}},\"isImmutable\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeImmutable` is an Immutable Collection or Record.\",\"description\":\"Note: Still returns true even if the collections is within a `withMutations()`.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { isImmutable, Map, List, Stack } = require('immutable');\\nisImmutable([]); // false\\nisImmutable({}); // false\\nisImmutable(Map()); // true\\nisImmutable(List()); // true\\nisImmutable(Stack()); // true\\nisImmutable(Map().asMutable()); // true\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeImmutable\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4900}]}},\"isCollection\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeCollection` is a Collection, or any of its subclasses.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { isCollection, Map, List, Stack } = require('immutable');\\nisCollection([]); // false\\nisCollection({}); // false\\nisCollection(Map()); // true\\nisCollection(List()); // true\\nisCollection(Stack()); // true\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeCollection\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4915}]}},\"isKeyed\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeKeyed` is a Collection.Keyed, or any of its subclasses.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { isKeyed, Map, List, Stack } = require('immutable');\\nisKeyed([]); // false\\nisKeyed({}); // false\\nisKeyed(Map()); // true\\nisKeyed(List()); // false\\nisKeyed(Stack()); // false\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeKeyed\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4930}]}},\"isIndexed\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeIndexed` is a Collection.Indexed, or any of its subclasses.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { isIndexed, Map, List, Stack, Set } = require('immutable');\\nisIndexed([]); // false\\nisIndexed({}); // false\\nisIndexed(Map()); // false\\nisIndexed(List()); // true\\nisIndexed(Stack()); // true\\nisIndexed(Set()); // false\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeIndexed\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4946}]}},\"isAssociative\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeAssociative` is either a Keyed or Indexed Collection.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { isAssociative, Map, List, Stack, Set } = require('immutable');\\nisAssociative([]); // false\\nisAssociative({}); // false\\nisAssociative(Map()); // true\\nisAssociative(List()); // true\\nisAssociative(Stack()); // true\\nisAssociative(Set()); // false\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeAssociative\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4962}]}},\"isOrdered\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeOrdered` is a Collection where iteration order is well\\ndefined. True for Collection.Indexed as well as OrderedMap and OrderedSet.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { isOrdered, Map, OrderedMap, List, Set } = require('immutable');\\nisOrdered([]); // false\\nisOrdered({}); // false\\nisOrdered(Map()); // false\\nisOrdered(OrderedMap()); // true\\nisOrdered(List()); // true\\nisOrdered(Set()); // false\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeOrdered\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4979}]}},\"isValueObject\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeValue` is a JavaScript Object which has *both* `equals()`\\nand `hashCode()` methods.\",\"description\":\"Any two instances of *value objects* can be compared for value equality with\\n`Immutable.is()` and can be used as keys in a `Map` or members in a `Set`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeValue\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4988}]}},\"isSeq\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeSeq` is a Seq.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeSeq\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4994}]}},\"isList\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeList` is a List.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeList\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4999}]}},\"isMap\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeMap` is a Map.\",\"description\":\"Also true for OrderedMaps.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeMap\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":5006}]}},\"isOrderedMap\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeOrderedMap` is an OrderedMap.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeOrderedMap\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":5011}]}},\"isStack\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeStack` is a Stack.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeStack\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":5016}]}},\"isSet\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeSet` is a Set.\",\"description\":\"Also true for OrderedSets.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeSet\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":5023}]}},\"isOrderedSet\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeOrderedSet` is an OrderedSet.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeOrderedSet\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":5028}]}},\"isRecord\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeRecord` is a Record.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeRecord\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":5033}]}},\"get\":{\"call\":{\"doc\":{\"synopsis\":\"Returns the value within the provided collection associated with the\\nprovided key, or notSetValue if the key is not defined in the collection.\",\"description\":\"A functional alternative to `collection.get(key)` which will also work on\\nplain Objects and Arrays as an alternative for `collection[key]`.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { get } = require('immutable')\\nget([ 'dog', 'frog', 'cat' ], 2) // 'frog'\\nget({ x: 123, y: 456 }, 'x') // 123\\nget({ x: 123, y: 456 }, 'z', 'ifNotSet') // 'ifNotSet'\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\",\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":5052},{\"typeParams\":[\"K\",\"V\",\"NSV\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]},\"line\":5053},{\"typeParams\":[\"TProps\",\"K\"],\"params\":[{\"name\":\"record\",\"type\":{\"k\":9,\"name\":\"Record\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":17}}],\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}},\"line\":5054},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"key\",\"type\":{\"k\":2}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":5055},{\"typeParams\":[\"V\",\"NSV\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]},\"line\":5056},{\"typeParams\":[\"C\",\"K\"],\"params\":[{\"name\":\"object\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":17}}],\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"C\"},\"index\":{\"k\":8,\"param\":\"K\"}},\"line\":5057},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}},{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":5058},{\"typeParams\":[\"V\",\"NSV\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}},{\"name\":\"key\",\"type\":{\"k\":3}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]},\"line\":5059}]}},\"has\":{\"call\":{\"doc\":{\"synopsis\":\"Returns true if the key is defined in the provided collection.\",\"description\":\"A functional alternative to `collection.has(key)` which will also work with\\nplain Objects and Arrays as an alternative for\\n`collection.hasOwnProperty(key)`.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { has } = require('immutable')\\nhas([ 'dog', 'frog', 'cat' ], 2) // true\\nhas([ 'dog', 'frog', 'cat' ], 5) // false\\nhas({ x: 123, y: 456 }, 'x') // true\\nhas({ x: 123, y: 456 }, 'z') // false\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Object\"}},{\"name\":\"key\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":5077}]}},\"remove\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the value at key removed.\",\"description\":\"A functional alternative to `collection.remove(key)` which will also work\\nwith plain Objects and Arrays as an alternative for\\n`delete collectionCopy[key]`.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { remove } = require('immutable')\\nconst originalArray = [ 'dog', 'frog', 'cat' ]\\nremove(originalArray, 1) // [ 'dog', 'cat' ]\\nconsole.log(originalArray) // [ 'dog', 'frog', 'cat' ]\\nconst originalObject = { x: 123, y: 456 }\\nremove(originalObject, 'x') // { y: 456 }\\nconsole.log(originalObject) // { x: 123, y: 456 }\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\",\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5097},{\"typeParams\":[\"TProps\",\"C\",\"K\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5098},{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":2}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5099},{\"typeParams\":[\"C\",\"K\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5100},{\"typeParams\":[\"C\",\"K\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5101}]}},\"set\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the value at key set to the provided\\nvalue.\",\"description\":\"A functional alternative to `collection.set(key, value)` which will also\\nwork with plain Objects and Arrays as an alternative for\\n`collectionCopy[key] = value`.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { set } = require('immutable')\\nconst originalArray = [ 'dog', 'frog', 'cat' ]\\nset(originalArray, 1, 'cow') // [ 'dog', 'cow', 'cat' ]\\nconsole.log(originalArray) // [ 'dog', 'frog', 'cat' ]\\nconst originalObject = { x: 123, y: 456 }\\nset(originalObject, 'x', 789) // { x: 789, y: 456 }\\nconsole.log(originalObject) // { x: 123, y: 456 }\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\",\"V\",\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5122},{\"typeParams\":[\"TProps\",\"C\",\"K\"],\"params\":[{\"name\":\"record\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5123},{\"typeParams\":[\"V\",\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5124},{\"typeParams\":[\"C\",\"K\"],\"params\":[{\"name\":\"object\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"C\"},\"index\":{\"k\":8,\"param\":\"K\"}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5125},{\"typeParams\":[\"V\",\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":3}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5126}]}},\"update\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the value at key set to the result of\\nproviding the existing value to the updating function.\",\"description\":\"A functional alternative to `collection.update(key, fn)` which will also\\nwork with plain Objects and Arrays as an alternative for\\n`collectionCopy[key] = fn(collection[key])`.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { update } = require('immutable')\\nconst originalArray = [ 'dog', 'frog', 'cat' ]\\nupdate(originalArray, 1, val => val.toUpperCase()) // [ 'dog', 'FROG', 'cat' ]\\nconsole.log(originalArray) // [ 'dog', 'frog', 'cat' ]\\nconst originalObject = { x: 123, y: 456 }\\nupdate(originalObject, 'x', val => val * 6) // { x: 738, y: 456 }\\nconsole.log(originalObject) // { x: 123, y: 456 }\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\",\"V\",\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"V\"}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5147},{\"typeParams\":[\"K\",\"V\",\"C\",\"NSV\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]}}],\"type\":{\"k\":8,\"param\":\"V\"}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5148},{\"typeParams\":[\"TProps\",\"C\",\"K\"],\"params\":[{\"name\":\"record\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}}}],\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5149},{\"typeParams\":[\"TProps\",\"C\",\"K\",\"NSV\"],\"params\":[{\"name\":\"record\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":12,\"types\":[{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}},{\"k\":8,\"param\":\"NSV\"}]}}],\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5150},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"V\"}}}],\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":5151},{\"typeParams\":[\"V\",\"NSV\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]}}],\"type\":{\"k\":8,\"param\":\"V\"}}}],\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":5152},{\"typeParams\":[\"C\",\"K\"],\"params\":[{\"name\":\"object\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"C\"},\"index\":{\"k\":8,\"param\":\"K\"}}}],\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"C\"},\"index\":{\"k\":8,\"param\":\"K\"}}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5153},{\"typeParams\":[\"C\",\"K\",\"NSV\"],\"params\":[{\"name\":\"object\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":12,\"types\":[{\"k\":15,\"type\":{\"k\":8,\"param\":\"C\"},\"index\":{\"k\":8,\"param\":\"K\"}},{\"k\":8,\"param\":\"NSV\"}]}}],\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"C\"},\"index\":{\"k\":8,\"param\":\"K\"}}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5154},{\"typeParams\":[\"V\",\"C\",\"K\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"V\"}}}],\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]},\"line\":5155},{\"typeParams\":[\"V\",\"C\",\"K\",\"NSV\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]}}],\"type\":{\"k\":8,\"param\":\"V\"}}}],\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]},\"line\":5156}]}},\"getIn\":{\"call\":{\"doc\":{\"synopsis\":\"Returns the value at the provided key path starting at the provided\\ncollection, or notSetValue if the key path is not defined.\",\"description\":\"A functional alternative to `collection.getIn(keypath)` which will also\\nwork with plain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { getIn } = require('immutable')\\ngetIn({ x: { y: { z: 123 }}}, ['x', 'y', 'z']) // 123\\ngetIn({ x: { y: { z: 123 }}}, ['x', 'q', 'p'], 'ifNotSet') // 'ifNotSet'\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"collection\",\"type\":{\"k\":17}},{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"notSetValue\",\"type\":{\"k\":17}}],\"type\":{\"k\":17},\"line\":5172}]}},\"hasIn\":{\"call\":{\"doc\":{\"synopsis\":\"Returns true if the key path is defined in the provided collection.\",\"description\":\"A functional alternative to `collection.hasIn(keypath)` which will also\\nwork with plain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { hasIn } = require('immutable')\\nhasIn({ x: { y: { z: 123 }}}, ['x', 'y', 'z']) // true\\nhasIn({ x: { y: { z: 123 }}}, ['x', 'q', 'p']) // false\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"collection\",\"type\":{\"k\":17}},{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}}],\"type\":{\"k\":1},\"line\":5187}]}},\"removeIn\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the value at the key path removed.\",\"description\":\"A functional alternative to `collection.removeIn(keypath)` which will also\\nwork with plain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { removeIn } = require('immutable')\\nconst original = { x: { y: { z: 123 }}}\\nremoveIn(original, ['x', 'y', 'z']) // { x: { y: {}}}\\nconsole.log(original) // { x: { y: { z: 123 }}}\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5203}]}},\"setIn\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the value at the key path set to the\\nprovided value.\",\"description\":\"A functional alternative to `collection.setIn(keypath)` which will also\\nwork with plain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { setIn } = require('immutable')\\nconst original = { x: { y: { z: 123 }}}\\nsetIn(original, ['x', 'y', 'z'], 456) // { x: { y: { z: 456 }}}\\nconsole.log(original) // { x: { y: { z: 123 }}}\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5220}]}},\"updateIn\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the value at key path set to the\\nresult of providing the existing value to the updating function.\",\"description\":\"A functional alternative to `collection.updateIn(keypath)` which will also\\nwork with plain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { updateIn } = require('immutable')\\nconst original = { x: { y: { z: 123 }}}\\nupdateIn(original, ['x', 'y', 'z'], val => val * 6) // { x: { y: { z: 738 }}}\\nconsole.log(original) // { x: { y: { z: 123 }}}\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5237},{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"notSetValue\",\"type\":{\"k\":17}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5238}]}},\"merge\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the remaining collections merged in.\",\"description\":\"A functional alternative to `collection.merge()` which will also work with\\nplain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { merge } = require('immutable')\\nconst original = { x: 123, y: 456 }\\nmerge(original, { y: 789, z: 'abc' }) // { x: 123, y: 789, z: 'abc' }\\nconsole.log(original) // { x: 123, y: 456 }\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":17},{\"k\":17}]}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":17}}]}]}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5254}]}},\"mergeWith\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the remaining collections merged in,\\ncalling the `merger` function whenever an existing value is encountered.\",\"description\":\"A functional alternative to `collection.mergeWith()` which will also work\\nwith plain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { mergeWith } = require('immutable')\\nconst original = { x: 123, y: 456 }\\nmergeWith(\\n  (oldVal, newVal) => oldVal + newVal,\\n  original,\\n  { y: 789, z: 'abc' }\\n) // { x: 123, y: 1245, z: 'abc' }\\nconsole.log(original) // { x: 123, y: 456 }\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"merger\",\"type\":{\"k\":7,\"params\":[{\"name\":\"oldVal\",\"type\":{\"k\":17}},{\"name\":\"newVal\",\"type\":{\"k\":17}},{\"name\":\"key\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}},{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":17},{\"k\":17}]}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":17}}]}]}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5278}]}},\"mergeDeep\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the remaining collections merged in\\ndeeply (recursively).\",\"description\":\"A functional alternative to `collection.mergeDeep()` which will also work\\nwith plain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { mergeDeep } = require('immutable')\\nconst original = { x: { y: 123 }}\\nmergeDeep(original, { x: { z: 456 }}) // { x: { y: 123, z: 456 }}\\nconsole.log(original) // { x: { y: 123 }}\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":17},{\"k\":17}]}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":17}}]}]}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5299}]}},\"mergeDeepWith\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the remaining collections merged in\\ndeeply (recursively), calling the `merger` function whenever an existing\\nvalue is encountered.\",\"description\":\"A functional alternative to `collection.mergeDeepWith()` which will also\\nwork with plain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { mergeDeepWith } = require('immutable')\\nconst original = { x: { y: 123 }}\\nmergeDeepWith(\\n  (oldVal, newVal) => oldVal + newVal,\\n  original,\\n  { x: { y: 456 }}\\n) // { x: { y: 579 }}\\nconsole.log(original) // { x: { y: 123 }}\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"merger\",\"type\":{\"k\":7,\"params\":[{\"name\":\"oldVal\",\"type\":{\"k\":17}},{\"name\":\"newVal\",\"type\":{\"k\":17}},{\"name\":\"key\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}},{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":17},{\"k\":17}]}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":17}}]}]}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5324}]}}}},\"immutable\":{\"module\":{}}}","var TypeKind = {\n  Any: 0,\n\n  Boolean: 1,\n  Number: 2,\n  String: 3,\n  Object: 4,\n  Array: 5,\n  Never: 6,\n  Function: 7,\n\n  Param: 8,\n  Type: 9,\n\n  This: 10,\n  Undefined: 11,\n  Union: 12,\n  Intersection: 13,\n  Tuple: 14,\n  Indexed: 15,\n  Operator: 16,\n\n  Unknown: 17,\n};\n\nmodule.exports = TypeKind;\n","var $__0=    require('../../'),Seq=$__0.Seq;\n// Note: intentionally using raw defs, not getTypeDefs to avoid circular ref.\nvar defs = require('../generated/immutable.d.json');\n\nfunction collectMemberGroups(interfaceDef, options) {\n  var members = {};\n\n  if (interfaceDef) {\n    collectFromDef(interfaceDef);\n  }\n\n  var groups = { '': [] };\n\n  if (options.showInGroups) {\n    Seq(members).forEach(function(member)  {\n      (groups[member.group] || (groups[member.group] = [])).push(member);\n    });\n  } else {\n    groups[''] = Seq(members)\n      .sortBy(function(member)  {return member.memberName;})\n      .toArray();\n  }\n\n  if (!options.showInherited) {\n    groups = Seq(groups)\n      .map(function(members)  {return members.filter(function(member)  {return !member.inherited;});})\n      .toObject();\n  }\n\n  return groups;\n\n  function collectFromDef(def, name) {\n    def.groups &&\n      def.groups.forEach(function(g)  {\n        Seq(g.members).forEach(function(memberDef, memberName)  {\n          collectMember(g.title || '', memberName, memberDef);\n        });\n      });\n\n    def.extends &&\n      def.extends.forEach(function(e)  {\n        var superModule = defs.Immutable;\n        e.name.split('.').forEach(function(part)  {\n          superModule =\n            superModule && superModule.module && superModule.module[part];\n        });\n        var superInterface = superModule && superModule.interface;\n        if (superInterface) {\n          collectFromDef(superInterface, e.name);\n        }\n      });\n\n    function collectMember(group, memberName, memberDef) {\n      var member = members[memberName];\n      if (member) {\n        if (!member.inherited) {\n          member.overrides = { name:name, def:def, memberDef:memberDef };\n        }\n        if (!member.group && group) {\n          member.group = group;\n        }\n      } else {\n        member = {\n          group:group,\n          memberName: memberName.substr(1),\n          memberDef:memberDef,\n        };\n        if (def !== interfaceDef) {\n          member.inherited = { name:name, def:def };\n        }\n        members[memberName] = member;\n      }\n    }\n  }\n}\n\nmodule.exports = collectMemberGroups;\n","var markdownDocs = require('./markdownDocs');\nvar defs = require('../generated/immutable.d.json');\n\nmarkdownDocs(defs);\n\nmodule.exports = defs;\n","var marked = require('marked');\nvar $__0=    require('../../'),Seq=$__0.Seq;\nvar prism = require('./prism');\nvar collectMemberGroups = require('./collectMemberGroups');\n// Note: intentionally using raw defs, not getTypeDefs to avoid circular ref.\nvar defs = require('../generated/immutable.d.json');\n\nfunction collectAllMembersForAllTypes(defs) {\n  var allMembers = new WeakMap();\n  _collectAllMembersForAllTypes(defs);\n  return allMembers;\n  function _collectAllMembersForAllTypes(defs) {\n    Seq(defs).forEach(function(def)  {\n      if (def.interface) {\n        var groups = collectMemberGroups(def.interface, {\n          showInherited: true,\n        });\n        allMembers.set(\n          def.interface,\n          Seq.Keyed(\n            groups[''].map(function(member)  {return [member.memberName, member.memberDef];})\n          ).toObject()\n        );\n      }\n      if (def.module) {\n        _collectAllMembersForAllTypes(def.module);\n      }\n    });\n    return allMembers;\n  }\n}\n\nvar allMembers = collectAllMembersForAllTypes(defs);\n\n// functions come before keywords\nprism.languages.insertBefore('javascript', 'keyword', {\n  var: /\\b(this)\\b/g,\n  'block-keyword': /\\b(if|else|while|for|function)\\b/g,\n  primitive: /\\b(true|false|null|undefined)\\b/g,\n  function: prism.languages.function,\n});\n\nprism.languages.insertBefore('javascript', {\n  qualifier: /\\b[A-Z][a-z0-9_]+/g,\n});\n\nmarked.setOptions({\n  xhtml: true,\n  highlight: function(code)  {return prism.highlight(code, prism.languages.javascript);},\n});\n\nvar renderer = new marked.Renderer();\n\nconst runkitRegExp = /^<!--\\s*runkit:activate((.|\\n)*)-->(.|\\n)*$/;\nconst runkitContext = { options: '{}', activated: false };\n\nrenderer.html = function (text) {\n  const result = runkitRegExp.exec(text);\n\n  if (!result) return text;\n\n  runkitContext.activated = true;\n  try {\n    runkitContext.options = result[1] ? JSON.parse(result[1]) : {};\n  } catch (e) {\n    runkitContext.options = {};\n  }\n  return text;\n};\n\nrenderer.code = function (code, lang, escaped) {\n  if (this.options.highlight) {\n    var out = this.options.highlight(code, lang);\n    if (out != null && out !== code) {\n      escaped = true;\n      code = out;\n    }\n  }\n\n  const runItButton = runkitContext.activated\n    ? '<a class=\"try-it\" data-options=\"' +\n      escape(JSON.stringify(runkitContext.options)) +\n      '\" onClick=\"runIt(this)\">run it</a>'\n    : '';\n\n  runkitContext.activated = false;\n  runkitContext.options = '{}';\n\n  return (\n    '<code class=\"codeBlock\">' +\n    (escaped ? code : escapeCode(code, true)) +\n    runItButton +\n    '</code>'\n  );\n};\n\nvar METHOD_RX = /^(\\w+)(?:[#.](\\w+))?(?:\\(\\))?$/;\nvar PARAM_RX = /^\\w+$/;\nvar MDN_TYPES = {\n  Array: true,\n  Object: true,\n  JSON: true,\n};\nvar MDN_BASE_URL =\n  'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/';\n\nrenderer.codespan = function (text) {\n  return '<code>' + decorateCodeSpan(text, this.options) + '</code>';\n};\n\nfunction decorateCodeSpan(text, options) {\n  var context = options.context;\n\n  if (\n    context.signatures &&\n    PARAM_RX.test(text) &&\n    context.signatures.some(\n      function(sig)  {return sig.params && sig.params.some(function(param)  {return param.name === text;});}\n    )\n  ) {\n    return '<span class=\"t param\">' + text + '</span>';\n  }\n\n  var method = METHOD_RX.exec(text);\n  if (method) {\n    method = method.slice(1).filter(Boolean);\n    if (MDN_TYPES[method[0]]) {\n      return (\n        '<a href=\"' + MDN_BASE_URL + method.join('/') + '\">' + text + '</a>'\n      );\n    }\n    if (\n      context.typePath &&\n      !arrEndsWith(context.typePath, method) &&\n      !arrEndsWith(context.typePath.slice(0, -1), method)\n    ) {\n      var path = findPath(context, method);\n      if (path) {\n        var relPath = context.relPath || '';\n        return (\n          '<a target=\"_self\" href=\"' +\n          relPath +\n          '#/' +\n          path.slice(1).join('/') +\n          '\">' +\n          text +\n          '</a>'\n        );\n      }\n    }\n  }\n\n  if (options.highlight) {\n    return options.highlight(unescapeCode(text), prism.languages.javascript);\n  }\n\n  return text;\n}\n\nfunction arrEndsWith(arr1, arr2) {\n  for (var ii = 1; ii <= arr2.length; ii++) {\n    if (arr2[arr2.length - ii] !== arr1[arr1.length - ii]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction findPath(context, search) {\n  var relative = context.typePath;\n\n  for (var ii = 0; ii <= relative.length; ii++) {\n    var path = relative.slice(0, relative.length - ii).concat(search);\n    if (\n      path.reduce(\n        function(def, name) \n          {return def &&\n          ((def.module && def.module[name]) ||\n            (def.interface &&\n              allMembers &&\n              allMembers.get(def.interface)[name]) ||\n            undefined);},\n        { module: defs }\n      )\n    ) {\n      return path;\n    }\n  }\n}\n\nfunction escapeCode(code) {\n  return code\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;');\n}\n\nfunction unescapeCode(code) {\n  return code\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&quot;/g, '\"')\n    .replace(/&#39;/g, \"'\")\n    .replace(/&amp;/g, '&');\n}\n\nfunction markdown(content, context) {\n  context || (context = {});\n  return content ? marked(content, { renderer:renderer, context:context }) : content;\n}\n\nmodule.exports = markdown;\n","var $__0=    require('../../'),Seq=$__0.Seq;\nvar markdown = require('./markdown');\n\nfunction markdownDocs(defs) {\n  markdownTypes(defs, []);\n\n  function markdownTypes(typeDefs, path) {\n    Seq(typeDefs).forEach(function(typeDef, typeName)  {\n      var typePath = path.concat(typeName);\n      markdownDoc(typeDef.doc, { typePath:typePath });\n      typeDef.call &&\n        markdownDoc(typeDef.call.doc, {\n          typePath:typePath,\n          signatures: typeDef.call.signatures,\n        });\n      if (typeDef.interface) {\n        markdownDoc(typeDef.interface.doc, { defs:defs, typePath:typePath });\n        Seq(typeDef.interface.groups).forEach(function(group) \n          {return Seq(group.members).forEach(function(member, memberName) \n            {return markdownDoc(member.doc, {\n              typePath: typePath.concat(memberName.slice(1)),\n              signatures: member.signatures,\n            });}\n          );}\n        );\n      }\n      typeDef.module && markdownTypes(typeDef.module, typePath);\n    });\n  }\n}\n\nfunction markdownDoc(doc, context) {\n  if (!doc) {\n    return;\n  }\n  doc.synopsis && (doc.synopsis = markdown(doc.synopsis, context));\n  doc.description && (doc.description = markdown(doc.description, context));\n  doc.notes &&\n    doc.notes.forEach(function(note)  {\n      if (note.name !== 'alias') {\n        note.body = markdown(note.body, context);\n      }\n    });\n}\n\nmodule.exports = markdownDocs;\n","/* eslint-disable */\n\n/* **********************************************\n     Begin prism-core.js\n********************************************** */\n\nself =\n  typeof window !== 'undefined'\n    ? window // if in browser\n    : typeof WorkerGlobalScope !== 'undefined' &&\n      self instanceof WorkerGlobalScope\n    ? self // if in worker\n    : {}; // if in node js\n\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n * MIT license http://www.opensource.org/licenses/mit-license.php/\n * @author Lea Verou http://lea.verou.me\n */\n\nvar Prism = (function () {\n  // Private helper vars\n  var lang = /\\blang(?:uage)?-(?!\\*)(\\w+)\\b/i;\n\n  var _ = (self.Prism = {\n    util: {\n      encode: function (tokens) {\n        if (tokens instanceof Token) {\n          return new Token(\n            tokens.type,\n            _.util.encode(tokens.content),\n            tokens.alias\n          );\n        } else if (_.util.type(tokens) === 'Array') {\n          return tokens.map(_.util.encode);\n        } else {\n          return tokens\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/\\u00a0/g, ' ');\n        }\n      },\n\n      type: function (o) {\n        return Object.prototype.toString.call(o).match(/\\[object (\\w+)\\]/)[1];\n      },\n\n      // Deep clone a language definition (e.g. to extend it)\n      clone: function (o) {\n        var type = _.util.type(o);\n\n        switch (type) {\n          case 'Object':\n            var clone = {};\n\n            for (var key in o) {\n              if (o.hasOwnProperty(key)) {\n                clone[key] = _.util.clone(o[key]);\n              }\n            }\n\n            return clone;\n\n          case 'Array':\n            return o.slice();\n        }\n\n        return o;\n      },\n    },\n\n    languages: {\n      extend: function (id, redef) {\n        var lang = _.util.clone(_.languages[id]);\n\n        for (var key in redef) {\n          lang[key] = redef[key];\n        }\n\n        return lang;\n      },\n\n      /**\n       * Insert a token before another token in a language literal\n       * As this needs to recreate the object (we cannot actually insert before keys in object literals),\n       * we cannot just provide an object, we need anobject and a key.\n       * @param inside The key (or language id) of the parent\n       * @param before The key to insert before. If not provided, the function appends instead.\n       * @param insert Object with the key/value pairs to insert\n       * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.\n       */\n      insertBefore: function (inside, before, insert, root) {\n        root = root || _.languages;\n        var grammar = root[inside];\n\n        if (arguments.length == 2) {\n          insert = arguments[1];\n\n          for (var newToken in insert) {\n            if (insert.hasOwnProperty(newToken)) {\n              grammar[newToken] = insert[newToken];\n            }\n          }\n\n          return grammar;\n        }\n\n        var ret = {};\n\n        for (var token in grammar) {\n          if (grammar.hasOwnProperty(token)) {\n            if (token == before) {\n              for (var newToken in insert) {\n                if (insert.hasOwnProperty(newToken)) {\n                  ret[newToken] = insert[newToken];\n                }\n              }\n            }\n\n            ret[token] = grammar[token];\n          }\n        }\n\n        // Update references in other language definitions\n        _.languages.DFS(_.languages, function (key, value) {\n          if (value === root[inside] && key != inside) {\n            this[key] = ret;\n          }\n        });\n\n        return (root[inside] = ret);\n      },\n\n      // Traverse a language definition with Depth First Search\n      DFS: function (o, callback, type) {\n        for (var i in o) {\n          if (o.hasOwnProperty(i)) {\n            callback.call(o, i, o[i], type || i);\n\n            if (_.util.type(o[i]) === 'Object') {\n              _.languages.DFS(o[i], callback);\n            } else if (_.util.type(o[i]) === 'Array') {\n              _.languages.DFS(o[i], callback, i);\n            }\n          }\n        }\n      },\n    },\n\n    highlightAll: function (async, callback) {\n      var elements = document.querySelectorAll(\n        'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'\n      );\n\n      for (var i = 0, element; (element = elements[i++]); ) {\n        _.highlightElement(element, async === true, callback);\n      }\n    },\n\n    highlightElement: function (element, async, callback) {\n      // Find language\n      var language,\n        grammar,\n        parent = element;\n\n      while (parent && !lang.test(parent.className)) {\n        parent = parent.parentNode;\n      }\n\n      if (parent) {\n        language = (parent.className.match(lang) || [, ''])[1];\n        grammar = _.languages[language];\n      }\n\n      if (!grammar) {\n        return;\n      }\n\n      // Set language on the element, if not present\n      element.className =\n        element.className.replace(lang, '').replace(/\\s+/g, ' ') +\n        ' language-' +\n        language;\n\n      // Set language on the parent, for styling\n      parent = element.parentNode;\n\n      if (/pre/i.test(parent.nodeName)) {\n        parent.className =\n          parent.className.replace(lang, '').replace(/\\s+/g, ' ') +\n          ' language-' +\n          language;\n      }\n\n      var code = element.textContent;\n\n      if (!code) {\n        return;\n      }\n\n      var env = {\n        element: element,\n        language: language,\n        grammar: grammar,\n        code: code,\n      };\n\n      _.hooks.run('before-highlight', env);\n\n      if (async && self.Worker) {\n        var worker = new Worker(_.filename);\n\n        worker.onmessage = function (evt) {\n          env.highlightedCode = Token.stringify(JSON.parse(evt.data), language);\n\n          _.hooks.run('before-insert', env);\n\n          env.element.innerHTML = env.highlightedCode;\n\n          callback && callback.call(env.element);\n          _.hooks.run('after-highlight', env);\n        };\n\n        worker.postMessage(\n          JSON.stringify({\n            language: env.language,\n            code: env.code,\n          })\n        );\n      } else {\n        env.highlightedCode = _.highlight(env.code, env.grammar, env.language);\n\n        _.hooks.run('before-insert', env);\n\n        env.element.innerHTML = env.highlightedCode;\n\n        callback && callback.call(element);\n\n        _.hooks.run('after-highlight', env);\n      }\n    },\n\n    highlight: function (text, grammar, language) {\n      var tokens = _.tokenize(text, grammar);\n      return Token.stringify(_.util.encode(tokens), language);\n    },\n\n    tokenize: function (text, grammar, language) {\n      var Token = _.Token;\n\n      var strarr = [text];\n\n      var rest = grammar.rest;\n\n      if (rest) {\n        for (var token in rest) {\n          grammar[token] = rest[token];\n        }\n\n        delete grammar.rest;\n      }\n\n      tokenloop: for (var token in grammar) {\n        if (!grammar.hasOwnProperty(token) || !grammar[token]) {\n          continue;\n        }\n\n        var patterns = grammar[token];\n        patterns = _.util.type(patterns) === 'Array' ? patterns : [patterns];\n\n        for (var j = 0; j < patterns.length; ++j) {\n          var pattern = patterns[j],\n            inside = pattern.inside,\n            lookbehind = !!pattern.lookbehind,\n            lookbehindLength = 0,\n            alias = pattern.alias;\n\n          pattern = pattern.pattern || pattern;\n\n          for (var i = 0; i < strarr.length; i++) {\n            // Dont cache length as it changes during the loop\n\n            var str = strarr[i];\n\n            if (strarr.length > text.length) {\n              // Something went terribly wrong, ABORT, ABORT!\n              break tokenloop;\n            }\n\n            if (str instanceof Token) {\n              continue;\n            }\n\n            pattern.lastIndex = 0;\n\n            var match = pattern.exec(str);\n\n            if (match) {\n              if (lookbehind) {\n                lookbehindLength = match[1].length;\n              }\n\n              var from = match.index - 1 + lookbehindLength,\n                match = match[0].slice(lookbehindLength),\n                len = match.length,\n                to = from + len,\n                before = str.slice(0, from + 1),\n                after = str.slice(to + 1);\n\n              var args = [i, 1];\n\n              if (before) {\n                args.push(before);\n              }\n\n              var wrapped = new Token(\n                token,\n                inside ? _.tokenize(match, inside) : match,\n                alias\n              );\n\n              args.push(wrapped);\n\n              if (after) {\n                args.push(after);\n              }\n\n              Array.prototype.splice.apply(strarr, args);\n            }\n          }\n        }\n      }\n\n      return strarr;\n    },\n\n    hooks: {\n      all: {},\n\n      add: function (name, callback) {\n        var hooks = _.hooks.all;\n\n        hooks[name] = hooks[name] || [];\n\n        hooks[name].push(callback);\n      },\n\n      run: function (name, env) {\n        var callbacks = _.hooks.all[name];\n\n        if (!callbacks || !callbacks.length) {\n          return;\n        }\n\n        for (var i = 0, callback; (callback = callbacks[i++]); ) {\n          callback(env);\n        }\n      },\n    },\n  });\n\n  var Token = (_.Token = function (type, content, alias) {\n    this.type = type;\n    this.content = content;\n    this.alias = alias;\n  });\n\n  Token.stringify = function (o, language, parent) {\n    if (typeof o == 'string') {\n      return o;\n    }\n\n    if (Object.prototype.toString.call(o) == '[object Array]') {\n      return o\n        .map(function (element) {\n          return Token.stringify(element, language, o);\n        })\n        .join('');\n    }\n\n    var env = {\n      type: o.type,\n      content: Token.stringify(o.content, language, parent),\n      tag: 'span',\n      classes: ['token', o.type],\n      attributes: {},\n      language: language,\n      parent: parent,\n    };\n\n    if (env.type == 'comment') {\n      env.attributes['spellcheck'] = 'true';\n    }\n\n    if (o.alias) {\n      var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];\n      Array.prototype.push.apply(env.classes, aliases);\n    }\n\n    _.hooks.run('wrap', env);\n\n    var attributes = '';\n\n    for (var name in env.attributes) {\n      attributes += name + '=\"' + (env.attributes[name] || '') + '\"';\n    }\n\n    return (\n      '<' +\n      env.tag +\n      ' class=\"' +\n      env.classes.join(' ') +\n      '\" ' +\n      attributes +\n      '>' +\n      env.content +\n      '</' +\n      env.tag +\n      '>'\n    );\n  };\n\n  if (!self.document) {\n    if (!self.addEventListener) {\n      // in Node.js\n      return self.Prism;\n    }\n    // In worker\n    self.addEventListener(\n      'message',\n      function (evt) {\n        var message = JSON.parse(evt.data),\n          lang = message.language,\n          code = message.code;\n\n        self.postMessage(\n          JSON.stringify(_.util.encode(_.tokenize(code, _.languages[lang])))\n        );\n        self.close();\n      },\n      false\n    );\n\n    return self.Prism;\n  }\n\n  // Get current script and highlight\n  var script = document.getElementsByTagName('script');\n\n  script = script[script.length - 1];\n\n  if (script) {\n    _.filename = script.src;\n\n    if (document.addEventListener && !script.hasAttribute('data-manual')) {\n      document.addEventListener('DOMContentLoaded', _.highlightAll);\n    }\n  }\n\n  return self.Prism;\n})();\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = Prism;\n}\n\n/* **********************************************\n     Begin prism-markup.js\n********************************************** */\n\nPrism.languages.markup = {\n  comment: /<!--[\\w\\W]*?-->/g,\n  prolog: /<\\?.+?\\?>/,\n  doctype: /<!DOCTYPE.+?>/,\n  cdata: /<!\\[CDATA\\[[\\w\\W]*?]]>/i,\n  tag: {\n    pattern:\n      /<\\/?[\\w:-]+\\s*(?:\\s+[\\w:-]+(?:=(?:(\"|')(\\\\?[\\w\\W])*?\\1|[^\\s'\">=]+))?\\s*)*\\/?>/gi,\n    inside: {\n      tag: {\n        pattern: /^<\\/?[\\w:-]+/i,\n        inside: {\n          punctuation: /^<\\/?/,\n          namespace: /^[\\w-]+?:/,\n        },\n      },\n      'attr-value': {\n        pattern: /=(?:('|\")[\\w\\W]*?(\\1)|[^\\s>]+)/gi,\n        inside: {\n          punctuation: /=|>|\"/g,\n        },\n      },\n      punctuation: /\\/?>/g,\n      'attr-name': {\n        pattern: /[\\w:-]+/g,\n        inside: {\n          namespace: /^[\\w-]+?:/,\n        },\n      },\n    },\n  },\n  entity: /\\&#?[\\da-z]{1,8};/gi,\n};\n\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add('wrap', function (env) {\n  if (env.type === 'entity') {\n    env.attributes['title'] = env.content.replace(/&amp;/, '&');\n  }\n});\n\n/* **********************************************\n     Begin prism-css.js\n********************************************** */\n\nPrism.languages.css = {\n  comment: /\\/\\*[\\w\\W]*?\\*\\//g,\n  atrule: {\n    pattern: /@[\\w-]+?.*?(;|(?=\\s*{))/gi,\n    inside: {\n      punctuation: /[;:]/g,\n    },\n  },\n  url: /url\\(([\"']?).*?\\1\\)/gi,\n  selector: /[^\\{\\}\\s][^\\{\\};]*(?=\\s*\\{)/g,\n  property: /(\\b|\\B)[\\w-]+(?=\\s*:)/gi,\n  string: /(\"|')(\\\\?.)*?\\1/g,\n  important: /\\B!important\\b/gi,\n  punctuation: /[\\{\\};:]/g,\n  function: /[-a-z0-9]+(?=\\()/gi,\n};\n\nif (Prism.languages.markup) {\n  Prism.languages.insertBefore('markup', 'tag', {\n    style: {\n      pattern: /<style[\\w\\W]*?>[\\w\\W]*?<\\/style>/gi,\n      inside: {\n        tag: {\n          pattern: /<style[\\w\\W]*?>|<\\/style>/gi,\n          inside: Prism.languages.markup.tag.inside,\n        },\n        rest: Prism.languages.css,\n      },\n      alias: 'language-css',\n    },\n  });\n\n  Prism.languages.insertBefore(\n    'inside',\n    'attr-value',\n    {\n      'style-attr': {\n        pattern: /\\s*style=(\"|').+?\\1/gi,\n        inside: {\n          'attr-name': {\n            pattern: /^\\s*style/gi,\n            inside: Prism.languages.markup.tag.inside,\n          },\n          punctuation: /^\\s*=\\s*['\"]|['\"]\\s*$/,\n          'attr-value': {\n            pattern: /.+/gi,\n            inside: Prism.languages.css,\n          },\n        },\n        alias: 'language-css',\n      },\n    },\n    Prism.languages.markup.tag\n  );\n}\n\n/* **********************************************\n     Begin prism-clike.js\n********************************************** */\n\nPrism.languages.clike = {\n  comment: [\n    {\n      pattern: /(^|[^\\\\])\\/\\*[\\w\\W]*?\\*\\//g,\n      lookbehind: true,\n    },\n    {\n      pattern: /(^|[^\\\\:])\\/\\/.*?(\\r?\\n|$)/g,\n      lookbehind: true,\n    },\n  ],\n  string: /(\"|')(\\\\?.)*?\\1/g,\n  'class-name': {\n    pattern:\n      /((?:(?:class|interface|extends|implements|trait|instanceof|new)\\s+)|(?:catch\\s+\\())[a-z0-9_\\.\\\\]+/gi,\n    lookbehind: true,\n    inside: {\n      punctuation: /(\\.|\\\\)/,\n    },\n  },\n  keyword:\n    /\\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/g,\n  boolean: /\\b(true|false)\\b/g,\n  function: {\n    pattern: /[a-z0-9_]+\\(/gi,\n    inside: {\n      punctuation: /\\(/,\n    },\n  },\n  number: /\\b-?(0x[\\dA-Fa-f]+|\\d*\\.?\\d+([Ee]-?\\d+)?)\\b/g,\n  operator: /[-+]{1,2}|!|<=?|>=?|={1,3}|&{1,2}|\\|?\\||\\?|\\*|\\/|\\~|\\^|\\%/g,\n  ignore: /&(lt|gt|amp);/gi,\n  punctuation: /[{}[\\];(),.:]/g,\n};\n\n/* **********************************************\n     Begin prism-javascript.js\n********************************************** */\n\nPrism.languages.javascript = Prism.languages.extend('clike', {\n  keyword:\n    /\\b(break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|get|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|set|static|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\\b/g,\n  number: /\\b-?(0x[\\dA-Fa-f]+|\\d*\\.?\\d+([Ee]-?\\d+)?|NaN|-?Infinity)\\b/g,\n});\n\nPrism.languages.insertBefore('javascript', 'keyword', {\n  regex: {\n    pattern:\n      /(^|[^/])\\/(?!\\/)(\\[.+?]|\\\\.|[^/\\r\\n])+\\/[gim]{0,3}(?=\\s*($|[\\r\\n,.;})]))/g,\n    lookbehind: true,\n  },\n});\n\nif (Prism.languages.markup) {\n  Prism.languages.insertBefore('markup', 'tag', {\n    script: {\n      pattern: /<script[\\w\\W]*?>[\\w\\W]*?<\\/script>/gi,\n      inside: {\n        tag: {\n          pattern: /<script[\\w\\W]*?>|<\\/script>/gi,\n          inside: Prism.languages.markup.tag.inside,\n        },\n        rest: Prism.languages.javascript,\n      },\n      alias: 'language-javascript',\n    },\n  });\n}\n\n/* **********************************************\n     Begin prism-file-highlight.js\n********************************************** */\n\n(function () {\n  if (!self.Prism || !self.document || !document.querySelector) {\n    return;\n  }\n\n  var Extensions = {\n    js: 'javascript',\n    html: 'markup',\n    svg: 'markup',\n    xml: 'markup',\n    py: 'python',\n    rb: 'ruby',\n  };\n\n  Array.prototype.slice\n    .call(document.querySelectorAll('pre[data-src]'))\n    .forEach(function (pre) {\n      var src = pre.getAttribute('data-src');\n      var extension = (src.match(/\\.(\\w+)$/) || [, ''])[1];\n      var language = Extensions[extension] || extension;\n\n      var code = document.createElement('code');\n      code.className = 'language-' + language;\n\n      pre.textContent = '';\n\n      code.textContent = 'Loading';\n\n      pre.appendChild(code);\n\n      var xhr = new XMLHttpRequest();\n\n      xhr.open('GET', src, true);\n\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState == 4) {\n          if (xhr.status < 400 && xhr.responseText) {\n            code.textContent = xhr.responseText;\n\n            Prism.highlightElement(code);\n          } else if (xhr.status >= 400) {\n            code.textContent =\n              ' Error ' +\n              xhr.status +\n              ' while fetching file: ' +\n              xhr.statusText;\n          } else {\n            code.textContent = ' Error: File does not exist or is empty';\n          }\n        }\n      };\n\n      xhr.send(null);\n    });\n})();\n","global.runIt = function runIt(button) {\n  if (!global.RunKit) return;\n\n  var container = document.createElement('div');\n  var codeElement = button.parentNode;\n  var parent = codeElement.parentNode;\n\n  parent.insertBefore(container, codeElement);\n  parent.removeChild(codeElement);\n  codeElement.removeChild(button);\n\n  const options = JSON.parse(unescape(button.dataset.options));\n\n  function withCorrectVersion(code) {\n    return code.replace(\n      /require\\('immutable'\\)/g,\n      \"require('immutable@4.0.0-rc.9')\"\n    );\n  }\n\n  global.RunKit.createNotebook({\n    element: container,\n    nodeVersion: options.nodeVersion || '*',\n    preamble: withCorrectVersion(\n      'const assert = (' +\n        makeAssert +\n        \")(require('immutable'));\" +\n        (options.preamble || '')\n    ),\n    source: withCorrectVersion(\n      codeElement.textContent.replace(/\\n(>[^\\n]*\\n?)+$/g, '')\n    ),\n    minHeight: '52px',\n    onLoad: function (notebook) {\n      notebook.evaluate();\n    },\n  });\n};\n\nfunction makeAssert(I) {\n  var isIterable = I.isIterable || I.Iterable.isIterable;\n  var html = (\"\\n    <style>\\n      * {\\n        font-size: 14px;\\n        font-family: monospace;\\n      }\\n\\n      code {\\n        font-family: monospace;\\n        color: #4183C4;\\n        text-decoration: none;\\n        text-decoration: none;\\n        background: rgba(65, 131, 196, 0.1);\\n        border-radius: 2px;\\n        padding: 2px;\\n    }\\n\\n      .success {\\n        color: rgba(84,184,54,1.0);\\n      }\\n\\n      .success:before {\\n        content: \\\"\\\";\\n      }\\n\\n      .failure {\\n        color: rgba(220,47,33,1.0);\\n      }\\n\\n      .failure i {\\n        color: rgba(210,44,31,1.0);\\n      }\\n\\n      .failure:before {\\n        content: \\\"\\\";\\n      }\\n    </style>\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n);\n\n  function compare(lhs, rhs, same, identical) {\n    var both = !identical && isIterable(lhs) && isIterable(rhs);\n\n    if (both) return lhs.equals(rhs);\n\n    return lhs === rhs;\n  }\n\n  function message(lhs, rhs, same, identical) {\n    var result = compare(lhs, rhs, same, identical);\n    var comparison = result\n      ? identical\n        ? 'strict equal to'\n        : 'does equal'\n      : identical\n      ? 'not strict equal to'\n      : 'does not equal';\n    var className = result === same ? 'success' : 'failure';\n    var lhsString = isIterable(lhs) ? lhs + '' : JSON.stringify(lhs);\n    var rhsString = isIterable(rhs) ? rhs + '' : JSON.stringify(rhs);\n\n    return (html += (\"\\n      <span class=\\\"\" + \nclassName + \"\\\">\\n        <code>\" + \nlhsString + \"</code>\\n        \" + \ncomparison + \"\\n        <code>\" + \nrhsString + \"</code>\\n      </span><br/>\"\n));\n  }\n\n  function equal(lhs, rhs) {\n    return message(lhs, rhs, true);\n  }\n\n  function notEqual(lhs, rhs) {\n    return message(lhs, rhs, false);\n  }\n\n  function strictEqual(lhs, rhs) {\n    return message(lhs, rhs, true, true);\n  }\n\n  function notStrictEqual(lhs, rhs) {\n    return message(lhs, rhs, false, true);\n  }\n\n  return { equal:equal, notEqual:notEqual, strictEqual:strictEqual, notStrictEqual:notStrictEqual };\n}\n","var React = require('react');\nvar CSSCore = require('react/lib/CSSCore');\nvar Router = require('react-router');\nvar $__0=    require('../../../../'),Seq=$__0.Seq;\nvar TypeKind = require('../../../lib/TypeKind');\nvar defs = require('../../../lib/getTypeDefs');\n\nvar InterfaceDef = React.createClass({displayName: \"InterfaceDef\",\n  render:function() {\n    var name = this.props.name;\n    var def = this.props.def;\n    return (\n      React.createElement(\"span\", {className: \"t interfaceDef\"}, \n        React.createElement(\"span\", {className: \"t keyword\"}, \"type \"), \n        React.createElement(\"span\", {className: \"t typeName\"}, name), \n        def.typeParams && [\n          '<',\n          Seq(def.typeParams)\n            .map(function(t, k)  \n              {return React.createElement(\"span\", {className: \"t typeParam\", key: k}, \n                t\n              );}\n            )\n            .interpose(', ')\n            .toArray(),\n          '>',\n        ], \n        def.extends && [\n          React.createElement(\"span\", {className: \"t keyword\"}, \" extends \"),\n          Seq(def.extends)\n            .map(function(e, i)  {return React.createElement(TypeDef, {key: i, type: e});})\n            .interpose(', ')\n            .toArray(),\n        ], \n        def.implements && [\n          React.createElement(\"span\", {className: \"t keyword\"}, \" implements \"),\n          Seq(def.implements)\n            .map(function(e, i)  {return React.createElement(TypeDef, {key: i, type: e});})\n            .interpose(', ')\n            .toArray(),\n        ]\n      )\n    );\n  },\n});\n\nexports.InterfaceDef = InterfaceDef;\n\nvar CallSigDef = React.createClass({displayName: \"CallSigDef\",\n  render:function() {\n    var info = this.props.info;\n    var module = this.props.module;\n    var name = this.props.name;\n    var callSig = this.props.callSig || {};\n\n    var shouldWrap = callSigLength(info, module, name, callSig) > 80;\n\n    return (\n      React.createElement(\"span\", {className: \"t callSig\"}, \n        module && [React.createElement(\"span\", {className: \"t fnQualifier\"}, module), '.'], \n        React.createElement(\"span\", {className: \"t fnName\"}, name), \n        callSig.typeParams && [\n          '<',\n          Seq(callSig.typeParams)\n            .map(function(t)  {return React.createElement(\"span\", {className: \"t typeParam\"}, t);})\n            .interpose(', ')\n            .toArray(),\n          '>',\n        ], \n        '(', \n        callSig && functionParams(info, callSig.params, shouldWrap), \n        ')', \n        callSig.type && [': ', React.createElement(TypeDef, {info: info, type: callSig.type})]\n      )\n    );\n  },\n});\n\nexports.CallSigDef = CallSigDef;\n\nvar TypeDef = React.createClass({displayName: \"TypeDef\",\n  render:function() {\n    var info = this.props.info;\n    var type = this.props.type;\n    var prefix = this.props.prefix;\n    switch (type.k) {\n      case TypeKind.Never:\n        return this.wrap('primitive', 'never');\n      case TypeKind.Any:\n        return this.wrap('primitive', 'any');\n      case TypeKind.Unknown:\n        return this.wrap('primitive', 'unknown');\n      case TypeKind.This:\n        return this.wrap('primitive', 'this');\n      case TypeKind.Undefined:\n        return this.wrap('primitive', 'undefined');\n      case TypeKind.Boolean:\n        return this.wrap('primitive', 'boolean');\n      case TypeKind.Number:\n        return this.wrap('primitive', 'number');\n      case TypeKind.String:\n        return this.wrap('primitive', 'string');\n      case TypeKind.Union:\n        return this.wrap('union', [\n          Seq(type.types)\n            .map(function(t)  {return React.createElement(TypeDef, {info: info, type: t});})\n            .interpose(' | ')\n            .toArray(),\n        ]);\n      case TypeKind.Intersection:\n        return this.wrap('intersection', [\n          Seq(type.types)\n            .map(function(t)  {return React.createElement(TypeDef, {info: info, type: t});})\n            .interpose(' & ')\n            .toArray(),\n        ]);\n      case TypeKind.Tuple:\n        return this.wrap('tuple', [\n          '[',\n          Seq(type.types)\n            .map(function(t)  {return React.createElement(TypeDef, {info: info, type: t});})\n            .interpose(', ')\n            .toArray(),\n          ']',\n        ]);\n      case TypeKind.Object:\n        return this.wrap('object', [\n          '{',\n          Seq(type.members)\n            .map(function(t)  {return React.createElement(MemberDef, {member: t});})\n            .interpose(', ')\n            .toArray(),\n          '}',\n        ]);\n      case TypeKind.Indexed:\n        return this.wrap('indexed', [\n          React.createElement(TypeDef, {info: info, type: type.type}),\n          '[',\n          React.createElement(TypeDef, {info: info, type: type.index}),\n          ']',\n        ]);\n      case TypeKind.Operator:\n        return this.wrap('operator', [\n          this.wrap('primitive', type.operator),\n          ' ',\n          React.createElement(TypeDef, {info: info, type: type.type}),\n        ]);\n      case TypeKind.Array:\n        return this.wrap('array', [\n          React.createElement(TypeDef, {info: info, type: type.type}),\n          '[]',\n        ]);\n      case TypeKind.Function:\n        var shouldWrap = (prefix || 0) + funcLength(info, type) > 78;\n        return this.wrap('function', [\n          type.typeParams && [\n            '<',\n            Seq(type.typeParams)\n              .map(function(t, k)  \n                {return React.createElement(\"span\", {className: \"t typeParam\", key: k}, \n                  t\n                );}\n              )\n              .interpose(', ')\n              .toArray(),\n            '>',\n          ],\n          '(',\n          functionParams(info, type.params, shouldWrap),\n          ') => ',\n          React.createElement(TypeDef, {info: info, type: type.type}),\n        ]);\n      case TypeKind.Param:\n        return info && info.propMap[info.defining + '<' + type.param] ? (\n          React.createElement(TypeDef, {type: info.propMap[info.defining + '<' + type.param]})\n        ) : (\n          this.wrap('typeParam', type.param)\n        );\n      case TypeKind.Type:\n        var qualifiedType = (type.qualifier || []).concat([type.name]);\n        var qualifiedTypeName = qualifiedType.join('.');\n        var def = qualifiedTypeName\n          .split('.')\n          .reduce(\n            function(def, name)  {return def && def.module && def.module[name];},\n            defs.Immutable\n          );\n        var typeNameElement = [\n          type.qualifier && [\n            Seq(type.qualifier)\n              .map(function(q)  {return React.createElement(\"span\", {className: \"t typeQualifier\"}, q);})\n              .interpose('.')\n              .toArray(),\n            '.',\n          ],\n          React.createElement(\"span\", {className: \"t typeName\"}, type.name),\n        ];\n        if (def) {\n          typeNameElement = (\n            React.createElement(Router.Link, {to: '/' + qualifiedTypeName}, \n              typeNameElement\n            )\n          );\n        }\n        return this.wrap('type', [\n          typeNameElement,\n          type.args && [\n            '<',\n            Seq(type.args)\n              .map(function(a)  {return React.createElement(TypeDef, {info: info, type: a});})\n              .interpose(', ')\n              .toArray(),\n            '>',\n          ],\n        ]);\n    }\n    throw new Error('Unknown kind ' + type.k);\n  },\n\n  mouseOver:function(event) {\n    CSSCore.addClass(this.getDOMNode(), 'over');\n    event.stopPropagation();\n  },\n\n  mouseOut:function() {\n    CSSCore.removeClass(this.getDOMNode(), 'over');\n  },\n\n  wrap:function(className, child) {\n    return (\n      React.createElement(\"span\", {\n        className: 't ' + className, \n        onMouseOver: this.mouseOver, \n        onFocus: this.mouseOver, \n        onMouseOut: this.mouseOut, \n        onBlur: this.mouseOut\n      }, \n        child\n      )\n    );\n  },\n});\n\nexports.TypeDef = TypeDef;\n\nvar MemberDef = React.createClass({displayName: \"MemberDef\",\n  render:function() {\n    var module = this.props.module;\n    var member = this.props.member;\n    return (\n      React.createElement(\"span\", {className: \"t member\"}, \n        module && [React.createElement(\"span\", {className: \"t fnQualifier\"}, module), '.'], \n        member.index ? (\n          ['[', functionParams(null, member.params), ']']\n        ) : (\n          React.createElement(\"span\", {className: \"t memberName\"}, member.name)\n        ), \n        member.type && [': ', React.createElement(TypeDef, {type: member.type})]\n      )\n    );\n  },\n});\n\nexports.MemberDef = MemberDef;\n\nfunction functionParams(info, params, shouldWrap) {\n  var elements = Seq(params)\n    .map(function(t)  {return [\n      t.varArgs ? '...' : null,\n      React.createElement(\"span\", {className: \"t param\"}, t.name),\n      t.optional ? '?: ' : ': ',\n      React.createElement(TypeDef, {\n        prefix: t.name.length + (t.varArgs ? 3 : 0) + (t.optional ? 3 : 2), \n        info: info, \n        type: t.type}\n      ),\n    ];})\n    .interpose(shouldWrap ? [',', React.createElement(\"br\", null)] : ', ')\n    .toArray();\n  return shouldWrap ? (\n    React.createElement(\"div\", {className: \"t blockParams\"}, elements)\n  ) : (\n    elements\n  );\n}\n\nfunction callSigLength(info, module, name, sig) {\n  return (module ? module.length + 1 : 0) + name.length + funcLength(info, sig);\n}\n\nfunction funcLength(info, sig) {\n  return (\n    (sig.typeParams ? 2 + sig.typeParams.join(', ').length : 0) +\n    2 +\n    (sig.params ? paramLength(info, sig.params) : 0) +\n    (sig.type ? 2 + typeLength(info, sig.type) : 0)\n  );\n}\n\nfunction paramLength(info, params) {\n  return params.reduce(\n    function(s, p) \n      {return s +\n      (p.varArgs ? 3 : 0) +\n      p.name.length +\n      (p.optional ? 3 : 2) +\n      typeLength(info, p.type);},\n    (params.length - 1) * 2\n  );\n}\n\nfunction memberLength(info, members) {\n  return members.reduce(\n    function(s, m) \n      {return s +\n      (m.index ? paramLength(info, m.params) + 4 : m.name + 2) +\n      typeLength(info, m.type);},\n    (members.length - 1) * 2\n  );\n}\n\nfunction typeLength(info, type) {\n  if (!type) {\n    throw new Error('Expected type');\n  }\n  switch (type.k) {\n    case TypeKind.Never:\n      return 5;\n    case TypeKind.Any:\n      return 3;\n    case TypeKind.Unknown:\n      return 7;\n    case TypeKind.This:\n      return 4;\n    case TypeKind.Undefined:\n      return 9;\n    case TypeKind.Boolean:\n      return 7;\n    case TypeKind.Number:\n      return 6;\n    case TypeKind.String:\n      return 6;\n    case TypeKind.Union:\n    case TypeKind.Intersection:\n      return (\n        type.types.reduce(function(s, t)  {return s + typeLength(info, t);}, 0) +\n        (type.types.length - 1) * 3\n      );\n    case TypeKind.Tuple:\n      return (\n        2 +\n        type.types.reduce(function(s, t)  {return s + typeLength(info, t);}, 0) +\n        (type.types.length - 1) * 2\n      );\n    case TypeKind.Object:\n      return 2 + memberLength(info, type.members);\n    case TypeKind.Indexed:\n      return 2 + typeLength(info, type.type) + typeLength(info, type.index);\n    case TypeKind.Operator:\n      return 1 + type.operator.length + typeLength(info, type.type);\n    case TypeKind.Array:\n      return typeLength(info, type.type) + 2;\n    case TypeKind.Function:\n      return 2 + funcLength(info, type);\n    case TypeKind.Param:\n      return info && info.propMap[info.defining + '<' + type.param]\n        ? typeLength(null, info.propMap[info.defining + '<' + type.param])\n        : type.param.length;\n    case TypeKind.Type:\n      return (\n        (type.qualifier ? 1 + type.qualifier.join('.').length : 0) +\n        type.name.length +\n        (!type.args\n          ? 0\n          : type.args.reduce(\n              function(s, a)  {return s + typeLength(info, a);},\n              type.args.length * 2\n            ))\n      );\n  }\n  throw new Error('Type with unknown kind ' + JSON.stringify(type));\n}\n","var React = require('react');\nvar SVGSet = require('../../src/SVGSet');\nvar Logo = require('../../src/Logo');\nvar packageJson = require('../../../../package.json');\n\nvar DocHeader = React.createClass({displayName: \"DocHeader\",\n  render:function() {\n    return (\n      React.createElement(\"div\", {className: \"header\"}, \n        React.createElement(\"div\", {className: \"miniHeader\"}, \n          React.createElement(\"div\", {className: \"miniHeaderContents\"}, \n            React.createElement(\"a\", {href: \"../\", target: \"_self\", className: \"miniLogo\"}, \n              React.createElement(SVGSet, null, \n                React.createElement(Logo, {color: \"#FC4349\"}), \n                React.createElement(Logo, {color: \"#2C3E50\", inline: true})\n              )\n            ), \n            React.createElement(\"a\", {href: \"./\", target: \"_self\"}, \n              \"Docs (v\", \n              packageJson.version, \")\"\n            ), \n            React.createElement(\"a\", {href: \"https://stackoverflow.com/questions/tagged/immutable.js?sort=votes\"}, \n              \"Questions\"\n            ), \n            React.createElement(\"a\", {href: \"https://github.com/immutable-js/immutable-js/\"}, \"Github\")\n          )\n        )\n      )\n    );\n  },\n});\n\nmodule.exports = DocHeader;\n","var React = require('react');\nvar Router = require('react-router');\nvar $__0=    require('../../../../'),Seq=$__0.Seq;\nvar Markdown = require('./MarkDown');\n\nvar DocOverview = React.createClass({displayName: \"DocOverview\",\n  render:function() {\n    var def = this.props.def;\n    var doc = def.doc;\n\n    return (\n      React.createElement(\"div\", null, \n        doc && (\n          React.createElement(\"section\", null, \n            React.createElement(Markdown, {contents: doc.synopsis}), \n            doc.description && React.createElement(Markdown, {contents: doc.description})\n          )\n        ), \n\n        React.createElement(\"h4\", {className: \"groupTitle\"}, \"API\"), \n\n        Seq(def.module)\n          .map(function(t, name)  {\n            var isFunction = !t.interface && !t.module;\n            if (isFunction) {\n              t = t.call;\n            }\n            return (\n              React.createElement(\"section\", {key: name, className: \"interfaceMember\"}, \n                React.createElement(\"h3\", {className: \"memberLabel\"}, \n                  React.createElement(Router.Link, {to: '/' + name}, \n                    name + (isFunction ? '()' : '')\n                  )\n                ), \n                t.doc && (\n                  React.createElement(Markdown, {className: \"detail\", contents: t.doc.synopsis})\n                )\n              )\n            );\n          })\n          .valueSeq()\n          .toArray()\n      )\n    );\n  },\n});\n\nmodule.exports = DocOverview;\n","var React = require('react');\n\nvar DocSearch = React.createClass({displayName: \"DocSearch\",\n  getInitialState:function() {\n    return { enabled: true };\n  },\n  componentDidMount:function() {\n    var script = document.createElement('script');\n    var firstScript = document.getElementsByTagName('script')[0];\n    script.src =\n      'https://cdn.jsdelivr.net/npm/docsearch.js@2.5.2/dist/cdn/docsearch.min.js';\n    script.addEventListener(\n      'load',\n      function()  {\n        // Initialize Algolia search.\n        if (window.docsearch) {\n          window.docsearch({\n            apiKey: '83f61f865ef4cb682e0432410c2f7809',\n            indexName: 'immutable_js',\n            inputSelector: '#algolia-docsearch',\n          });\n        } else {\n          this.setState({ enabled: false });\n        }\n      }.bind(this),\n      false\n    );\n    firstScript.parentNode.insertBefore(script, firstScript);\n\n    var link = document.createElement('link');\n    var firstLink = document.getElementsByTagName('link')[0];\n    link.rel = 'stylesheet';\n    link.href =\n      'https://cdn.jsdelivr.net/npm/docsearch.js@2.5.2/dist/cdn/docsearch.min.css';\n    firstLink.parentNode.insertBefore(link, firstLink);\n  },\n  render:function() {\n    return this.state.enabled ? (\n      React.createElement(\"input\", {\n        id: \"algolia-docsearch\", \n        className: \"docSearch\", \n        type: \"search\", \n        placeholder: \"Search Immutable.js Documentation\"}\n      )\n    ) : null;\n  },\n});\n\nmodule.exports = DocSearch;\n","var React = require('react');\n\nvar MarkDown = React.createClass({displayName: \"MarkDown\",\n  shouldComponentUpdate:function() {\n    return false;\n  },\n\n  render:function() {\n    var html = this.props.contents;\n    return (\n      React.createElement(\"div\", {\n        className: this.props.className, \n        dangerouslySetInnerHTML: { __html: html}}\n      )\n    );\n  },\n});\n\nmodule.exports = MarkDown;\n","var React = require('react');\nvar ReactTransitionEvents = require('react/lib/ReactTransitionEvents');\nvar Router = require('react-router');\nvar $__0=     require('./Defs'),CallSigDef=$__0.CallSigDef,MemberDef=$__0.MemberDef;\nvar PageDataMixin = require('./PageDataMixin');\nvar isMobile = require('./isMobile');\nvar MarkDown = require('./MarkDown');\n\nvar $__1=    React.addons,TransitionGroup=$__1.TransitionGroup;\n\nvar MemberDoc = React.createClass({displayName: \"MemberDoc\",\n  mixins: [PageDataMixin, Router.Navigation],\n\n  getInitialState:function() {\n    var showDetail = this.props.showDetail;\n    return { detail: showDetail };\n  },\n\n  componentDidMount:function() {\n    if (this.props.showDetail) {\n      var node = this.getDOMNode();\n      var navType = this.getPageData().type;\n      if (navType === 'init' || navType === 'push') {\n        window.scrollTo(window.scrollX, offsetTop(node) - FIXED_HEADER_HEIGHT);\n      }\n    }\n  },\n\n  componentWillReceiveProps:function(nextProps) {\n    if (nextProps.showDetail && !this.props.showDetail) {\n      this.scrollTo = true;\n      this.setState({ detail: true });\n    }\n  },\n\n  componentDidUpdate:function() {\n    if (this.scrollTo) {\n      this.scrollTo = false;\n      var node = this.getDOMNode();\n      var navType = this.getPageData().type;\n      if (navType === 'init' || navType === 'push') {\n        window.scrollTo(window.scrollX, offsetTop(node) - FIXED_HEADER_HEIGHT);\n      }\n    }\n  },\n\n  toggleDetail:function() {\n    // Note: removed this because it drops the URL bar on mobile, and that's\n    // the only place it's currently being used.\n    // var member = this.props.member;\n    // var name = member.memberName;\n    // var typeName = this.props.parentName;\n    // var showDetail = this.props.showDetail;\n    // if (!this.state.detail) {\n    //   this.replaceWith('/' + (typeName ? typeName + '/' : '') + name );\n    // } else if (this.state.detail && showDetail) {\n    //   this.replaceWith('/' + (typeName || '') );\n    // }\n    this.setState({ detail: !this.state.detail });\n  },\n\n  render:function() {\n    var typePropMap = this.props.typePropMap;\n    var member = this.props.member;\n    var module = member.isStatic ? this.props.parentName : null;\n    var name = member.memberName;\n    var def = member.memberDef;\n    var doc = def.doc || {};\n    var isProp = !def.signatures;\n\n    var typeInfo = member.inherited && {\n      propMap: typePropMap,\n      defining: member.inherited.name,\n    };\n\n    var showDetail = isMobile ? this.state.detail : true;\n\n    var memberAnchorLink = this.props.parentName + '/' + name;\n\n    return (\n      React.createElement(\"div\", {className: \"interfaceMember\"}, \n        React.createElement(\"h3\", {className: \"memberLabel\"}, \n          React.createElement(Router.Link, {\n            to: '/' + memberAnchorLink, \n            onClick: isMobile ? this.toggleDetail : null\n          }, \n            (module ? module + '.' : '') + name + (isProp ? '' : '()')\n          )\n        ), \n        React.createElement(TransitionGroup, {childFactory: makeSlideDown}, \n          showDetail && (\n            React.createElement(\"div\", {key: \"detail\", className: \"detail\"}, \n              doc.synopsis && (\n                React.createElement(MarkDown, {className: \"synopsis\", contents: doc.synopsis})\n              ), \n              isProp ? (\n                React.createElement(\"code\", {className: \"codeBlock memberSignature\"}, \n                  React.createElement(MemberDef, {\n                    module: module, \n                    member: { name:name, type: def.type}}\n                  )\n                )\n              ) : (\n                React.createElement(\"code\", {className: \"codeBlock memberSignature\"}, \n                  def.signatures.map(function(callSig, i)  {return [\n                    React.createElement(CallSigDef, {\n                      key: i, \n                      info: typeInfo, \n                      module: module, \n                      name: name, \n                      callSig: callSig}\n                    ),\n                    '\\n',\n                  ];})\n                )\n              ), \n              member.inherited && (\n                React.createElement(\"section\", null, \n                  React.createElement(\"h4\", {className: \"infoHeader\"}, \"Inherited from\"), \n                  React.createElement(\"code\", null, \n                    React.createElement(Router.Link, {to: '/' + member.inherited.name + '/' + name}, \n                      member.inherited.name + '#' + name\n                    )\n                  )\n                )\n              ), \n              member.overrides && (\n                React.createElement(\"section\", null, \n                  React.createElement(\"h4\", {className: \"infoHeader\"}, \"Overrides\"), \n                  React.createElement(\"code\", null, \n                    React.createElement(Router.Link, {to: '/' + member.overrides.name + '/' + name}, \n                      member.overrides.name + '#' + name\n                    )\n                  )\n                )\n              ), \n              doc.notes &&\n                doc.notes.map(function(note, i)  \n                  {return React.createElement(\"section\", {key: i}, \n                    React.createElement(\"h4\", {className: \"infoHeader\"}, note.name), \n                    note.name === 'alias' ? (\n                      React.createElement(\"code\", null, \n                        React.createElement(CallSigDef, {name: note.body})\n                      )\n                    ) : (\n                      React.createElement(MarkDown, {className: \"discussion\", contents: note.body})\n                    )\n                  );}\n                ), \n              doc.description && (\n                React.createElement(\"section\", null, \n                  React.createElement(\"h4\", {className: \"infoHeader\"}, \n                    doc.description.substr(0, 5) === '<code'\n                      ? 'Example'\n                      : 'Discussion'\n                  ), \n                  React.createElement(MarkDown, {className: \"discussion\", contents: doc.description})\n                )\n              )\n            )\n          )\n        )\n      )\n    );\n  },\n});\n\nfunction makeSlideDown(child) {\n  return React.createElement(SlideDown, null, child);\n}\n\nvar SlideDown = React.createClass({displayName: \"SlideDown\",\n  componentWillEnter:function(done) {\n    this.slide(false, done);\n  },\n\n  componentWillLeave:function(done) {\n    this.slide(true, done);\n  },\n\n  slide:function(slidingUp, done) {\n    var node = this.getDOMNode();\n    node.style.height = 'auto';\n    var height = getComputedStyle(node).height;\n    var start = slidingUp ? height : 0;\n    var end = slidingUp ? 0 : height;\n    node.style.transition = '';\n    node.style.height = start;\n    node.style.transition = 'height 0.35s ease-in-out';\n    var endListener = function()  {\n      ReactTransitionEvents.removeEndEventListener(node, endListener);\n      done();\n    };\n    ReactTransitionEvents.addEndEventListener(node, endListener);\n    this.timeout = setTimeout(function()  {\n      node.style.height = end;\n    }, 17);\n  },\n\n  render:function() {\n    return this.props.children;\n  },\n});\n\nvar FIXED_HEADER_HEIGHT = 75;\n\nfunction offsetTop(node) {\n  var top = 0;\n  do {\n    top += node.offsetTop;\n  } while ((node = node.offsetParent));\n  return top;\n}\n\nmodule.exports = MemberDoc;\n","var React = require('react');\n\nmodule.exports = {\n  contextTypes: {\n    getPageData: React.PropTypes.func.isRequired,\n  },\n\n  /**\n   * Returns the most recent change event.\n   */\n  getPageData:function() {\n    return this.context.getPageData();\n  },\n};\n","var React = require('react');\nvar Router = require('react-router');\nvar $__0=     require('../../../../'),Map=$__0.Map,Seq=$__0.Seq;\nvar defs = require('../../../lib/getTypeDefs');\n\nvar SideBar = React.createClass({displayName: \"SideBar\",\n  render:function() {\n    var type = defs.Immutable;\n\n    return (\n      React.createElement(\"div\", {className: \"sideBar\"}, \n        React.createElement(\"div\", {className: \"toolBar\"}, \n          React.createElement(\"div\", {\n            onClick: this.props.toggleShowInGroups, \n            onKeyPress: this.props.toggleShowInGroups\n          }, \n            React.createElement(\"span\", {className: this.props.showInGroups && 'selected'}, \n              \"Grouped\"\n            ), \n            '  ', \n            React.createElement(\"span\", {className: this.props.showInGroups || 'selected'}, \n              \"Alphabetized\"\n            )\n          ), \n          React.createElement(\"div\", {\n            onClick: this.props.toggleShowInherited, \n            onKeyPress: this.props.toggleShowInherited\n          }, \n            React.createElement(\"span\", {className: this.props.showInherited && 'selected'}, \n              \"Inherited\"\n            ), \n            '  ', \n            React.createElement(\"span\", {className: this.props.showInherited || 'selected'}, \n              \"Defined\"\n            )\n          )\n        ), \n        React.createElement(\"div\", {className: \"scrollContent\"}, \n          React.createElement(\"h4\", {className: \"groupTitle\"}, \"API\"), \n          Seq(type.module)\n            .flatMap(function(t, name)  {return flattenSubmodules(Map(), t, name);})\n            .map(function(t, name)  {return this.renderSideBarType(name, t);}.bind(this))\n            .valueSeq()\n            .toArray()\n        )\n      )\n    );\n  },\n\n  renderSideBarType:function(typeName, type) {\n    var isFocus = this.props.focus === typeName;\n    var isFunction = !type.interface && !type.module;\n    var call = type.call;\n    var functions = Seq(type.module).filter(function(t)  {return !t.interface && !t.module;});\n\n    var label = typeName + (isFunction ? '()' : '');\n\n    if (!isFocus) {\n      label = React.createElement(Router.Link, {to: '/' + typeName}, label);\n    }\n\n    var memberGroups = this.props.memberGroups;\n\n    var members =\n      !isFocus || isFunction ? null : (\n        React.createElement(\"div\", {className: \"members\"}, \n          call && (\n            React.createElement(\"section\", null, \n              React.createElement(\"h4\", {className: \"groupTitle\"}, \"Construction\"), \n              React.createElement(\"div\", null, \n                React.createElement(Router.Link, {to: '/' + typeName + '/' + typeName}, \n                  typeName + '()'\n                )\n              )\n            )\n          ), \n\n          functions.count() > 0 && (\n            React.createElement(\"section\", null, \n              React.createElement(\"h4\", {className: \"groupTitle\"}, \"Static Methods\"), \n              functions\n                .map(function(t, name)  \n                  {return React.createElement(\"div\", {key: name}, \n                    React.createElement(Router.Link, {to: '/' + typeName + '/' + name}, \n                      typeName + '.' + name + '()'\n                    )\n                  );}\n                )\n                .valueSeq()\n                .toArray()\n            )\n          ), \n\n          React.createElement(\"section\", null, \n            Seq(memberGroups)\n              .map(function(members, title) \n                {return members.length === 0\n                  ? null\n                  : Seq([\n                      React.createElement(\"h4\", {key: title || 'Members', className: \"groupTitle\"}, \n                        title || 'Members'\n                      ),\n                      Seq(members).map(function(member)  \n                        {return React.createElement(\"div\", {key: member.memberName}, \n                          React.createElement(Router.Link, {\n                            to: '/' + typeName + '/' + member.memberName\n                          }, \n                            member.memberName +\n                              (member.memberDef.signatures ? '()' : '')\n                          )\n                        );}\n                      ),\n                    ]);}\n              )\n              .flatten()\n              .valueSeq()\n              .toArray()\n          )\n        )\n      );\n\n    return (\n      React.createElement(\"div\", {key: typeName}, \n        React.createElement(\"h2\", null, label), \n        members\n      )\n    );\n  },\n});\n\nfunction flattenSubmodules(modules, type, name) {\n  modules = modules.set(name, type);\n  return type.module\n    ? Seq(type.module)\n        .filter(function(t)  {return t.interface || t.module;})\n        .reduce(\n          function(modules, subT, subName) \n            {return flattenSubmodules(modules, subT, name + '.' + subName);},\n          modules\n        )\n    : modules;\n}\n\nmodule.exports = SideBar;\n","var React = require('react');\nvar Router = require('react-router');\nvar $__0=    require('../../../../'),Seq=$__0.Seq;\nvar $__1=     require('./Defs'),InterfaceDef=$__1.InterfaceDef,CallSigDef=$__1.CallSigDef;\nvar MemberDoc = require('./MemberDoc');\nvar isMobile = require('./isMobile');\nvar SideBar = require('./SideBar');\nvar MarkDown = require('./MarkDown');\nvar DocOverview = require('./DocOverview');\nvar collectMemberGroups = require('../../../lib/collectMemberGroups');\nvar TypeKind = require('../../../lib/TypeKind');\nvar defs = require('../../../lib/getTypeDefs');\n\nvar typeDefURL =\n  'https://github.com/immutable-js/immutable-js/blob/main/type-definitions/Immutable.d.ts';\nvar issuesURL = 'https://github.com/immutable-js/immutable-js/issues';\n\nvar Disclaimer = function () {\n  return (\n    React.createElement(\"section\", {className: \"disclaimer\"}, \n      \"This documentation is generated from\", ' ', \n      React.createElement(\"a\", {href: typeDefURL}, \"Immutable.d.ts\"), \". Pull requests and\", ' ', \n      React.createElement(\"a\", {href: issuesURL}, \"Issues\"), \" welcome.\"\n    )\n  );\n};\n\nvar TypeDocumentation = React.createClass({displayName: \"TypeDocumentation\",\n  getInitialState:function() {\n    return {\n      showInherited: true,\n      showInGroups: true,\n    };\n  },\n\n  toggleShowInGroups:function() {\n    this.setState({ showInGroups: !this.state.showInGroups });\n  },\n\n  toggleShowInherited:function() {\n    this.setState({ showInherited: !this.state.showInherited });\n  },\n\n  render:function() {\n    var name = this.props.name;\n    var memberName = this.props.memberName;\n    var def = this.props.def;\n\n    var memberGroups = collectMemberGroups(def && def.interface, {\n      showInGroups: this.state.showInGroups,\n      showInherited: this.state.showInherited,\n    });\n\n    return (\n      React.createElement(\"div\", null, \n        isMobile || (\n          React.createElement(SideBar, {\n            focus: name, \n            memberGroups: memberGroups, \n            toggleShowInherited: this.toggleShowInherited, \n            toggleShowInGroups: this.toggleShowInGroups, \n            showInGroups: this.state.showInGroups, \n            showInherited: this.state.showInherited}\n          )\n        ), \n        React.createElement(\"div\", {key: name, className: \"docContents\"}, \n          !def ? (\n            React.createElement(NotFound, null)\n          ) : !name ? (\n            React.createElement(DocOverview, {def: def})\n          ) : !def.interface && !def.module ? (\n            React.createElement(FunctionDoc, {name: name, def: def.call})\n          ) : (\n            React.createElement(TypeDoc, {\n              name: name, \n              def: def, \n              memberName: memberName, \n              memberGroups: memberGroups}\n            )\n          )\n        )\n      )\n    );\n  },\n});\n\nfunction NotFound() {\n  return React.createElement(\"div\", null, \"Not found\");\n}\n\nvar FunctionDoc = React.createClass({displayName: \"FunctionDoc\",\n  render:function() {\n    var name = this.props.name;\n    var def = this.props.def;\n    var doc = def.doc || {};\n\n    return (\n      React.createElement(\"div\", null, \n        React.createElement(\"h1\", {className: \"typeHeader\"}, name + '()'), \n        doc.synopsis && (\n          React.createElement(MarkDown, {className: \"synopsis\", contents: doc.synopsis})\n        ), \n        React.createElement(\"code\", {className: \"codeBlock memberSignature\"}, \n          def.signatures.map(function(callSig, i)  {return [\n            React.createElement(CallSigDef, {key: i, name: name, callSig: callSig}),\n            '\\n',\n          ];})\n        ), \n        doc.notes &&\n          doc.notes.map(function(note, i)  \n            {return React.createElement(\"section\", {key: i}, \n              React.createElement(\"h4\", {className: \"infoHeader\"}, note.name), \n              note.name === 'alias' ? (\n                React.createElement(CallSigDef, {name: note.body})\n              ) : (\n                note.body\n              )\n            );}\n          ), \n        doc.description && (\n          React.createElement(\"section\", null, \n            React.createElement(\"h4\", {className: \"infoHeader\"}, \n              doc.description.substr(0, 5) === '<code'\n                ? 'Example'\n                : 'Discussion'\n            ), \n            React.createElement(MarkDown, {className: \"discussion\", contents: doc.description})\n          )\n        ), \n        React.createElement(Disclaimer, null)\n      )\n    );\n  },\n});\n\nvar TypeDoc = React.createClass({displayName: \"TypeDoc\",\n  render:function() {\n    var name = this.props.name;\n    var def = this.props.def;\n    var memberName = this.props.memberName;\n    var memberGroups = this.props.memberGroups;\n\n    var doc = def.doc || {};\n    var call = def.call;\n    var functions = Seq(def.module).filter(function(t)  {return !t.interface && !t.module;});\n    var types = Seq(def.module).filter(function(t)  {return t.interface || t.module;});\n    var interfaceDef = def.interface;\n    var typePropMap = getTypePropMap(interfaceDef);\n\n    return (\n      React.createElement(\"div\", null, \n        React.createElement(\"h1\", {className: \"typeHeader\"}, name), \n        doc.synopsis && (\n          React.createElement(MarkDown, {className: \"synopsis\", contents: doc.synopsis})\n        ), \n        interfaceDef && (\n          React.createElement(\"code\", {className: \"codeBlock memberSignature\"}, \n            React.createElement(InterfaceDef, {name: name, def: interfaceDef})\n          )\n        ), \n\n        doc.notes &&\n          doc.notes.map(function(note, i)  \n            {return React.createElement(\"section\", {key: i}, \n              React.createElement(\"h4\", {className: \"infoHeader\"}, note.name), \n              note.name === 'alias' ? (\n                React.createElement(CallSigDef, {name: note.body})\n              ) : (\n                note.body\n              )\n            );}\n          ), \n\n        doc.description && (\n          React.createElement(\"section\", null, \n            React.createElement(\"h4\", {className: \"infoHeader\"}, \n              doc.description.substr(0, 5) === '<code'\n                ? 'Example'\n                : 'Discussion'\n            ), \n            React.createElement(MarkDown, {className: \"discussion\", contents: doc.description})\n          )\n        ), \n\n        types.count() > 0 && (\n          React.createElement(\"section\", null, \n            React.createElement(\"h4\", {className: \"groupTitle\"}, \"Sub-types\"), \n            types\n              .map(function(t, typeName)  \n                {return React.createElement(\"div\", {key: typeName}, \n                  React.createElement(Router.Link, {\n                    to: '/' + (name ? name + '.' + typeName : typeName)\n                  }, \n                    name ? name + '.' + typeName : typeName\n                  )\n                );}\n              )\n              .valueSeq()\n              .toArray()\n          )\n        ), \n\n        call && (\n          React.createElement(\"section\", null, \n            React.createElement(\"h4\", {className: \"groupTitle\"}, \"Construction\"), \n            React.createElement(MemberDoc, {\n              showDetail: name === memberName, \n              parentName: name, \n              member: {\n                memberName: name,\n                memberDef: call,\n              }}\n            )\n          )\n        ), \n\n        functions.count() > 0 && (\n          React.createElement(\"section\", null, \n            React.createElement(\"h4\", {className: \"groupTitle\"}, \"Static methods\"), \n            functions\n              .map(function(t, fnName)  \n                {return React.createElement(MemberDoc, {\n                  key: fnName, \n                  showDetail: fnName === memberName, \n                  parentName: name, \n                  member: {\n                    memberName: fnName,\n                    memberDef: t.call,\n                    isStatic: true,\n                  }}\n                );}\n              )\n              .valueSeq()\n              .toArray()\n          )\n        ), \n\n        React.createElement(\"section\", null, \n          Seq(memberGroups)\n            .map(function(members, title) \n              {return members.length === 0\n                ? null\n                : Seq([\n                    React.createElement(\"h4\", {key: title || 'Members', className: \"groupTitle\"}, \n                      title || 'Members'\n                    ),\n                    Seq(members).map(function(member)  \n                      {return React.createElement(MemberDoc, {\n                        typePropMap: typePropMap, \n                        key: member.memberName, \n                        showDetail: member.memberName === memberName, \n                        parentName: name, \n                        member: member}\n                      );}\n                    ),\n                  ]);}\n            )\n            .flatten()\n            .valueSeq()\n            .toArray()\n        ), \n\n        React.createElement(Disclaimer, null)\n      )\n    );\n  },\n});\n\n/**\n * Get a map from super type parameter to concrete type definition. This is\n * used when rendering inherited type definitions to ensure contextually\n * relevant information.\n *\n * Example:\n *\n *   type A<T> implements B<number, T>\n *   type B<K, V> implements C<K, V, V>\n *   type C<X, Y, Z>\n *\n * parse C:\n *   {}\n *\n * parse B:\n *   { C<X: K\n *     C<Y: V\n *     C<Z: V }\n *\n * parse A:\n *   { B<K: number\n *     B<V: T\n *     C<X: number\n *     C<Y: T\n *     C<Z: T }\n */\nfunction getTypePropMap(def) {\n  var map = {};\n  def &&\n    def.extends &&\n    def.extends.forEach(function(e)  {\n      var superModule = defs.Immutable;\n      e.name.split('.').forEach(function(part)  {\n        superModule =\n          superModule && superModule.module && superModule.module[part];\n      });\n      var superInterface = superModule && superModule.interface;\n      if (superInterface) {\n        var interfaceMap = Seq(superInterface.typeParams)\n          .toKeyedSeq()\n          .flip()\n          .map(function(i)  {return e.args[i];})\n          .toObject();\n        Seq(interfaceMap).forEach(function(v, k)  {\n          map[e.name + '<' + k] = v;\n        });\n        var superMap = getTypePropMap(superInterface);\n        Seq(superMap).forEach(function(v, k)  {\n          map[k] = v.k === TypeKind.Param ? interfaceMap[v.param] : v;\n        });\n      }\n    });\n  return map;\n}\n\nmodule.exports = TypeDocumentation;\n","var React = require('react');\nvar assign = require('react/lib/Object.assign');\nvar Router = require('react-router');\nvar DocHeader = require('./DocHeader');\nvar DocSearch = require('./DocSearch.js');\nvar TypeDocumentation = require('./TypeDocumentation');\nvar defs = require('../../../lib/getTypeDefs');\n\nvar $__0=      Router,Route=$__0.Route,DefaultRoute=$__0.DefaultRoute,RouteHandler=$__0.RouteHandler;\n\nrequire('../../../lib/runkit-embed');\n\nvar Documentation = React.createClass({displayName: \"Documentation\",\n  render:function() {\n    return (\n      React.createElement(\"div\", null, \n        React.createElement(DocHeader, null), \n        React.createElement(\"div\", {className: \"pageBody\", id: \"body\"}, \n          React.createElement(\"div\", {className: \"contents\"}, \n            React.createElement(DocSearch, null), \n            React.createElement(RouteHandler, null)\n          )\n        )\n      )\n    );\n  },\n});\n\nvar DocDeterminer = React.createClass({displayName: \"DocDeterminer\",\n  mixins: [Router.State],\n\n  render:function() {\n    var $__0=      determineDoc(this.getPath()),def=$__0.def,name=$__0.name,memberName=$__0.memberName;\n    return React.createElement(TypeDocumentation, {def: def, name: name, memberName: memberName});\n  },\n});\n\nfunction determineDoc(path) {\n  var $__0=    path.split('/'),name=$__0[1],memberName=$__0[2];\n\n  var namePath = name ? name.split('.') : [];\n  var def = namePath.reduce(\n    function(def, subName)  {return def && def.module && def.module[subName];},\n    defs.Immutable\n  );\n\n  return { def:def, name:name, memberName:memberName };\n}\n\nmodule.exports = React.createClass({displayName: \"exports\",\n  childContextTypes: {\n    getPageData: React.PropTypes.func.isRequired,\n  },\n\n  getChildContext:function() {\n    return {\n      getPageData: this.getPageData,\n    };\n  },\n\n  getPageData:function() {\n    return this.pageData;\n  },\n\n  componentWillMount:function() {\n    var location;\n    var scrollBehavior;\n\n    if (window.document) {\n      location = Router.HashLocation;\n      location.addChangeListener(function(change)  {\n        this.pageData = assign({}, change, determineDoc(change.path));\n      }.bind(this));\n\n      this.pageData = !window.document\n        ? {}\n        : assign(\n            {\n              path: location.getCurrentPath(),\n              type: 'init',\n            },\n            determineDoc(location.getCurrentPath())\n          );\n\n      scrollBehavior = {\n        updateScrollPosition: function(position, actionType)  {\n          switch (actionType) {\n            case 'push':\n              return this.getPageData().memberName\n                ? null\n                : window.scrollTo(0, 0);\n            case 'pop':\n              return window.scrollTo(\n                position ? position.x : 0,\n                position ? position.y : 0\n              );\n          }\n        }.bind(this),\n      };\n    }\n\n    Router.create({\n      routes: (\n        React.createElement(Route, {handler: Documentation, path: \"/\"}, \n          React.createElement(DefaultRoute, {handler: DocDeterminer}), \n          React.createElement(Route, {name: \"type\", path: \"/:name\", handler: DocDeterminer}), \n          React.createElement(Route, {\n            name: \"method\", \n            path: \"/:name/:memberName\", \n            handler: DocDeterminer}\n          )\n        )\n      ),\n      location: location,\n      scrollBehavior: scrollBehavior,\n    }).run(function(Handler)  {\n      this.setState({ handler: Handler });\n      if (window.document) {\n        window.document.title = (this.pageData.name + \"  Immutable.js\");\n      }\n    }.bind(this));\n  },\n\n  // TODO: replace this. this is hacky and probably wrong\n\n  componentDidMount:function() {\n    setTimeout(function()  {\n      this.pageData.type = '';\n    }.bind(this), 0);\n  },\n\n  componentDidUpdate:function() {\n    setTimeout(function()  {\n      this.pageData.type = '';\n    }.bind(this), 0);\n  },\n\n  render:function() {\n    var Handler = this.state.handler;\n    return React.createElement(Handler, null);\n  },\n});\n","var isMobile =\n  window.matchMedia && window.matchMedia('(max-device-width: 680px)');\nmodule.exports = false && !!(isMobile && isMobile.matches);\n","var React = require('react');\n\nvar Logo = React.createClass({displayName: \"Logo\",\n  shouldComponentUpdate: function (nextProps) {\n    return nextProps.opacity !== this.props.opacity;\n  },\n\n  render: function () {\n    var opacity = this.props.opacity;\n    if (opacity === undefined) {\n      opacity = 1;\n    }\n    return !this.props.inline ? (\n      React.createElement(\"g\", {fill: this.props.color, style: { opacity: this.props.opacity}}, \n        React.createElement(\"path\", {d: \"M0,0l13.9,0v41.1H0L0,0z\"}), \n        React.createElement(\"path\", {d: \"M18.2,0L29,0l10.7,15.8L50.4,0l10.9,0v41.1H48.1V26.3l-8.4,12.3l-8.4-12.3v14.8H18.2V0z\"}), \n        React.createElement(\"path\", {d: \"M65.5,0l10.9,0L87,15.8L97.7,0l10.9,0v41.1H95.4V26.3L87,38.7l-8.4-12.3v14.8H65.5V0z\"}), \n        React.createElement(\"path\", {\n          d: \"M128.6,42.2c-2.6,0-4.9-0.3-7-1c-2.1-0.7-3.9-1.6-5.4-3c-1.5-1.3-2.6-3-3.4-5c-0.8-2-1.2-4.4-1.2-7.1V0\" + ' ' +\n          \"l13.1,0v25.6c0,1.4,0.3,2.5,0.9,3.3c0.6,0.8,1.6,1.1,3,1.1c1.4,0,2.4-0.4,3-1.1c0.6-0.8,0.9-1.9,0.9-3.3V0l13.2,0v26.1\" + ' ' +\n          \"c0,2.7-0.4,5.1-1.2,7.1c-0.8,2-2,3.7-3.5,5c-1.5,1.3-3.3,2.3-5.4,3C133.5,41.8,131.2,42.2,128.6,42.2z\"}\n        ), \n        React.createElement(\"path\", {d: \"M155.4,10.8h-7.6V0l28.7,0v10.8h-7.6v30.3h-13.6V10.8z\"}), \n        React.createElement(\"path\", {\n          d: \"M186.4,0l9.9,0l15.6,41.1h-12.9l-1.4-3.7h-12.5l-1.4,3.7h-12.9L186.4,0z M194.1,28.4l-2.8-7.2l-2.8,7.2\" + ' ' +\n          \"H194.1z\"}\n        ), \n        React.createElement(\"path\", {\n          d: \"M212.9,0L229,0c2.1,0,3.9,0.2,5.6,0.7c1.7,0.5,3.2,1.2,4.4,2.1s2.2,2.1,2.8,3.5c0.7,1.4,1,3,1,4.8\" + ' ' +\n          \"c0,1.3-0.2,2.4-0.5,3.4c-0.3,0.9-0.7,1.7-1,2.3c-0.5,0.7-1,1.4-1.5,1.8c0.9,0.6,1.7,1.3,2.5,2.2c0.6,0.8,1.2,1.8,1.7,3\" + ' ' +\n          \"c0.5,1.2,0.8,2.7,0.8,4.4c0,2-0.3,3.8-1,5.4c-0.7,1.6-1.7,3-3,4.1c-1.3,1.1-2.9,2-4.7,2.6c-1.9,0.6-4,0.9-6.3,0.9h-16.8V0z\" + ' ' +\n           \"M230.2,12.5c0-1.9-1-2.8-3.1-2.8h-1.5v5.7h1.5C229.2,15.4,230.2,14.4,230.2,12.5z M227.1,31.4c3.1,0,4.7-1.2,4.7-3.6\" + ' ' +\n          \"c0-2.4-1.6-3.6-4.7-3.6h-1.5v7.2H227.1z\"}\n        ), \n        React.createElement(\"path\", {d: \"M248.3,0L262,0v30.3h11.3v10.8h-25V0z\"}), \n        React.createElement(\"path\", {d: \"M275.3,0l24.2,0v10.8h-11.1v4.6h10.9v10.2h-10.9v4.7H300v10.8h-24.7V0z\"})\n      )\n    ) : (\n      React.createElement(\"g\", {fill: this.props.color, style: { opacity: this.props.opacity}}, \n        React.createElement(\"path\", {d: \"M0,0l13.9,0v41.1H0L0,0z M7.8,36.2V4.9H6.2v31.3H7.8z\"}), \n        React.createElement(\"path\", {\n          d: \"M18.2,0L29,0l10.7,15.8L50.4,0l10.9,0v41.1H48.1V26.3l-8.4,12.3l-8.4-12.3v14.8H18.2V0z M25.9,36.2V7.9\" + ' ' +\n          \"L39.7,28L53.5,7.9v28.3h1.6V4.9h-1.6L39.7,25.2L25.9,4.9h-1.6v31.3H25.9z\"}\n        ), \n        React.createElement(\"path\", {\n          d: \"M65.5,0l10.9,0L87,15.8L97.7,0l10.9,0v41.1H95.4V26.3L87,38.7l-8.4-12.3v14.8H65.5V0z M73.2,36.2V7.9\" + ' ' +\n          \"L87,28l13.7-20.1v28.3h1.6V4.9h-1.6L87,25.2L73.2,4.9h-1.6v31.3H73.2z\"}\n        ), \n        React.createElement(\"path\", {\n          d: \"M128.6,42.2c-2.6,0-4.9-0.3-7-1c-2.1-0.7-3.9-1.6-5.4-3c-1.5-1.3-2.6-3-3.4-5c-0.8-2-1.2-4.4-1.2-7.1V0\" + ' ' +\n          \"l13.1,0v25.6c0,1.4,0.3,2.5,0.9,3.3c0.6,0.8,1.6,1.1,3,1.1c1.4,0,2.4-0.4,3-1.1c0.6-0.8,0.9-1.9,0.9-3.3V0l13.2,0v26.1\" + ' ' +\n          \"c0,2.7-0.4,5.1-1.2,7.1c-0.8,2-2,3.7-3.5,5c-1.5,1.3-3.3,2.3-5.4,3C133.5,41.8,131.2,42.2,128.6,42.2z M128.6,34.8\" + ' ' +\n          \"c-6.2,0-9.2-3-9.2-9.1V4.9h-1.6v20.8c0,3.5,0.9,6.1,2.8,7.9c1.9,1.8,4.6,2.7,8,2.7c3.5,0,6.2-0.9,8.1-2.7c1.9-1.8,2.8-4.5,2.8-7.9\" + ' ' +\n          \"V4.9h-1.7v20.8C137.8,31.7,134.8,34.8,128.6,34.8z\"}\n        ), \n        React.createElement(\"path\", {d: \"M155.4,10.8h-7.6V0l28.7,0v10.8h-7.6v30.3h-13.6V10.8z M163,36.2V6.4h8.8V4.9h-19.2v1.5h8.8v29.8H163z\"}), \n        React.createElement(\"path\", {\n          d: \"M186.4,0l9.9,0l15.6,41.1h-12.9l-1.4-3.7h-12.5l-1.4,3.7h-12.9L186.4,0z M180,36.2l1.2-3.1h20.3l1.2,3.1\" + ' ' +\n          \"h1.7L192.5,4.9h-2.3l-11.9,31.3H180z M191.3,6.4l9.6,25.2h-19.2L191.3,6.4z M194.1,28.4l-2.8-7.2l-2.8,7.2H194.1z\"}\n        ), \n        React.createElement(\"path\", {\n          d: \"M212.9,0L229,0c2.1,0,3.9,0.2,5.6,0.7c1.7,0.5,3.2,1.2,4.4,2.1s2.2,2.1,2.8,3.5c0.7,1.4,1,3,1,4.8\" + ' ' +\n          \"c0,1.3-0.2,2.4-0.5,3.4c-0.3,0.9-0.7,1.7-1,2.3c-0.5,0.7-1,1.4-1.5,1.8c0.9,0.6,1.7,1.3,2.5,2.2c0.6,0.8,1.2,1.8,1.7,3\" + ' ' +\n          \"c0.5,1.2,0.8,2.7,0.8,4.4c0,2-0.3,3.8-1,5.4c-0.7,1.6-1.7,3-3,4.1c-1.3,1.1-2.9,2-4.7,2.6c-1.9,0.6-4,0.9-6.3,0.9h-16.8V0z\" + ' ' +\n           \"M228,36.2c3.6,0,6.3-0.8,8-2.3c1.7-1.6,2.6-3.6,2.6-6.2c0-1.7-0.4-3-1.1-4c-0.7-1-1.5-1.8-2.3-2.4c-1-0.7-2.2-1.1-3.4-1.4\" + ' ' +\n          \"c1-0.3,1.9-0.7,2.7-1.4c0.7-0.5,1.3-1.3,1.9-2.2s0.8-2.1,0.8-3.5c0-2.6-0.8-4.5-2.5-5.9c-1.6-1.3-3.9-2-6.7-2h-8.9v31.3H228z\" + ' ' +\n           \"M220.7,19.1V6.4l7.3,0c2.7,0,4.6,0.6,5.8,1.8c1.2,1.2,1.8,2.7,1.8,4.6c0,1.9-0.6,3.4-1.8,4.6c-1.2,1.2-3.1,1.8-5.8,1.8H220.7z\" + ' ' +\n           \"M220.7,34.7V20.6h7.2c1.3,0,2.5,0.1,3.5,0.4c1.1,0.3,2,0.7,2.9,1.2c0.8,0.6,1.5,1.3,1.9,2.2c0.5,0.9,0.7,2,0.7,3.2\" + ' ' +\n          \"c0,2.5-0.8,4.3-2.5,5.4c-1.7,1.1-3.9,1.7-6.6,1.7H220.7z M230.2,12.5c0-1.9-1-2.8-3.1-2.8h-1.5v5.7h1.5\" + ' ' +\n          \"C229.2,15.4,230.2,14.4,230.2,12.5z M227.1,31.4c3.1,0,4.7-1.2,4.7-3.6c0-2.4-1.6-3.6-4.7-3.6h-1.5v7.2H227.1z\"}\n        ), \n        React.createElement(\"path\", {d: \"M248.3,0L262,0v30.3h11.3v10.8h-25V0z M269.9,36.2v-1.5h-13.8V4.9h-1.6v31.3H269.9z\"}), \n        React.createElement(\"path\", {\n          d: \"M275.3,0l24.2,0v10.8h-11.1v4.6h10.9v10.2h-10.9v4.7H300v10.8h-24.7V0z M295.4,36.2v-1.5h-12.3V21.2h11.7\" + ' ' +\n          \"v-1.5h-11.7V6.4h12.3V4.9h-13.9v31.3H295.4z\"}\n        )\n      )\n    );\n  },\n});\n\nmodule.exports = Logo;\n","var React = require('react');\n\nvar SVGSet = React.createClass({displayName: \"SVGSet\",\n  render: function () {\n    return (\n      React.createElement(\"svg\", {className: \"svg\", style: this.props.style, viewBox: \"0 0 300 42.2\"}, \n        this.props.children\n      )\n    );\n  },\n});\n\nmodule.exports = SVGSet;\n","module.exports = global.Immutable;\n","module.exports = global.React;\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi8uLi8uLi9kaXN0L2ltbXV0YWJsZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2FjdGlvbnMvTG9jYXRpb25BY3Rpb25zLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2JlaGF2aW9ycy9JbWl0YXRlQnJvd3NlckJlaGF2aW9yLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2JlaGF2aW9ycy9TY3JvbGxUb1RvcEJlaGF2aW9yLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2NvbXBvbmVudHMvRGVmYXVsdFJvdXRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2NvbXBvbmVudHMvTGluay5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy9jb21wb25lbnRzL05vdEZvdW5kUm91dGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvY29tcG9uZW50cy9SZWRpcmVjdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy9jb21wb25lbnRzL1JvdXRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2NvbXBvbmVudHMvUm91dGVIYW5kbGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2xvY2F0aW9ucy9IYXNoTG9jYXRpb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvbG9jYXRpb25zL0hpc3RvcnlMb2NhdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy9sb2NhdGlvbnMvUmVmcmVzaExvY2F0aW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL21peGlucy9GYWtlTm9kZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy9taXhpbnMvTmF2aWdhdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy9taXhpbnMvTmF2aWdhdGlvbkNvbnRleHQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvbWl4aW5zL1JvdXRlSGFuZGxlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy9taXhpbnMvU2Nyb2xsaW5nLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL21peGlucy9TdGF0ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy9taXhpbnMvU3RhdGVDb250ZXh0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL3V0aWxzL0NhbmNlbGxhdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy91dGlscy9IaXN0b3J5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL3V0aWxzL1BhdGguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvdXRpbHMvUHJvbWlzZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy91dGlscy9Qcm9wVHlwZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvdXRpbHMvUmVkaXJlY3QuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvdXRpbHMvVHJhbnNpdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy91dGlscy9jcmVhdGVSb3V0ZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvdXRpbHMvY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL3V0aWxzL2dldFdpbmRvd1Njcm9sbFBvc2l0aW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL3V0aWxzL3JldmVyc2VkQXJyYXkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvdXRpbHMvcnVuUm91dGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL3V0aWxzL3N1cHBvcnRzSGlzdG9yeS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL3FzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvcXMvbGliL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvcXMvbGliL3BhcnNlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvcXMvbGliL3N0cmluZ2lmeS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL3FzL2xpYi91dGlscy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL3doZW4vbGliL1Byb21pc2UuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL25vZGVfbW9kdWxlcy93aGVuL2xpYi9RdWV1ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL3doZW4vbGliL1NjaGVkdWxlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL3doZW4vbGliL2FzeW5jLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvd2hlbi9saWIvbWFrZVByb21pc2UuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL0NTU0NvcmUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9PYmplY3QuYXNzaWduLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFRyYW5zaXRpb25FdmVudHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2N4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9pbnZhcmlhbnQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL3dhcm5pbmcuanMiLCIuLi8uLi8uLi9wYWNrYWdlLmpzb24iLCIuLi8uLi9nZW5lcmF0ZWQvaW1tdXRhYmxlLmQuanNvbiIsIi4uLy4uL2xpYi9UeXBlS2luZC5qcyIsIi4uLy4uL2xpYi9jb2xsZWN0TWVtYmVyR3JvdXBzLmpzIiwiLi4vLi4vbGliL2dldFR5cGVEZWZzLmpzIiwiLi4vLi4vbGliL21hcmtkb3duLmpzIiwiLi4vLi4vbGliL21hcmtkb3duRG9jcy5qcyIsIi4uLy4uL2xpYi9wcmlzbS5qcyIsIi4uLy4uL2xpYi9ydW5raXQtZW1iZWQuanMiLCJzcmMvRGVmcy5qcyIsInNyYy9Eb2NIZWFkZXIuanMiLCJzcmMvRG9jT3ZlcnZpZXcuanMiLCJzcmMvRG9jU2VhcmNoLmpzIiwic3JjL01hcmtEb3duLmpzIiwic3JjL01lbWJlckRvYy5qcyIsInNyYy9QYWdlRGF0YU1peGluLmpzIiwic3JjL1NpZGVCYXIuanMiLCJzcmMvVHlwZURvY3VtZW50YXRpb24uanMiLCJzcmMvaW5kZXguanMiLCJzcmMvaXNNb2JpbGUuanMiLCIuLi9zcmMvTG9nby5qcyIsIi4uL3NyYy9TVkdTZXQuanMiLCIuLi8uLi8uLi9yZXNvdXJjZXMvaW1tdXRhYmxlLWdsb2JhbC5qcyIsIi4uLy4uLy4uL3Jlc291cmNlcy9yZWFjdC1nbG9iYWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL3RMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDanZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1eEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdElBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ROQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlJQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNiQTtBQUNBOzs7OztBQ0RBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIvKipcbiAqIE1JVCBMaWNlbnNlXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBMZWUgQnlyb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLkltbXV0YWJsZSA9IHt9KSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIERFTEVURSA9ICdkZWxldGUnO1xuXG4gIC8vIENvbnN0YW50cyBkZXNjcmliaW5nIHRoZSBzaXplIG9mIHRyaWUgbm9kZXMuXG4gIHZhciBTSElGVCA9IDU7IC8vIFJlc3VsdGVkIGluIGJlc3QgcGVyZm9ybWFuY2UgYWZ0ZXIgX19fX19fP1xuICB2YXIgU0laRSA9IDEgPDwgU0hJRlQ7XG4gIHZhciBNQVNLID0gU0laRSAtIDE7XG5cbiAgLy8gQSBjb25zaXN0ZW50IHNoYXJlZCB2YWx1ZSByZXByZXNlbnRpbmcgXCJub3Qgc2V0XCIgd2hpY2ggZXF1YWxzIG5vdGhpbmcgb3RoZXJcbiAgLy8gdGhhbiBpdHNlbGYsIGFuZCBub3RoaW5nIHRoYXQgY291bGQgYmUgcHJvdmlkZWQgZXh0ZXJuYWxseS5cbiAgdmFyIE5PVF9TRVQgPSB7fTtcblxuICAvLyBCb29sZWFuIHJlZmVyZW5jZXMsIFJvdWdoIGVxdWl2YWxlbnQgb2YgYGJvb2wgJmAuXG4gIGZ1bmN0aW9uIE1ha2VSZWYoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IGZhbHNlIH07XG4gIH1cblxuICBmdW5jdGlvbiBTZXRSZWYocmVmKSB7XG4gICAgaWYgKHJlZikge1xuICAgICAgcmVmLnZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBBIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSB2YWx1ZSByZXByZXNlbnRpbmcgYW4gXCJvd25lclwiIGZvciB0cmFuc2llbnQgd3JpdGVzXG4gIC8vIHRvIHRyaWVzLiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgb25seSBldmVyIGVxdWFsIGl0c2VsZiwgYW5kIHdpbGwgbm90IGVxdWFsXG4gIC8vIHRoZSByZXR1cm4gb2YgYW55IHN1YnNlcXVlbnQgY2FsbCBvZiB0aGlzIGZ1bmN0aW9uLlxuICBmdW5jdGlvbiBPd25lcklEKCkge31cblxuICBmdW5jdGlvbiBlbnN1cmVTaXplKGl0ZXIpIHtcbiAgICBpZiAoaXRlci5zaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGl0ZXIuc2l6ZSA9IGl0ZXIuX19pdGVyYXRlKHJldHVyblRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlci5zaXplO1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcEluZGV4KGl0ZXIsIGluZGV4KSB7XG4gICAgLy8gVGhpcyBpbXBsZW1lbnRzIFwiaXMgYXJyYXkgaW5kZXhcIiB3aGljaCB0aGUgRUNNQVN0cmluZyBzcGVjIGRlZmluZXMgYXM6XG4gICAgLy9cbiAgICAvLyAgICAgQSBTdHJpbmcgcHJvcGVydHkgbmFtZSBQIGlzIGFuIGFycmF5IGluZGV4IGlmIGFuZCBvbmx5IGlmXG4gICAgLy8gICAgIFRvU3RyaW5nKFRvVWludDMyKFApKSBpcyBlcXVhbCB0byBQIGFuZCBUb1VpbnQzMihQKSBpcyBub3QgZXF1YWxcbiAgICAvLyAgICAgdG8gMl4zMuKIkjEuXG4gICAgLy9cbiAgICAvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtYXJyYXktZXhvdGljLW9iamVjdHNcbiAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgICAgdmFyIHVpbnQzMkluZGV4ID0gaW5kZXggPj4+IDA7IC8vIE4gPj4+IDAgaXMgc2hvcnRoYW5kIGZvciBUb1VpbnQzMlxuICAgICAgaWYgKCcnICsgdWludDMySW5kZXggIT09IGluZGV4IHx8IHVpbnQzMkluZGV4ID09PSA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgICB9XG4gICAgICBpbmRleCA9IHVpbnQzMkluZGV4O1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXggPCAwID8gZW5zdXJlU2l6ZShpdGVyKSArIGluZGV4IDogaW5kZXg7XG4gIH1cblxuICBmdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gd2hvbGVTbGljZShiZWdpbiwgZW5kLCBzaXplKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICgoYmVnaW4gPT09IDAgJiYgIWlzTmVnKGJlZ2luKSkgfHxcbiAgICAgICAgKHNpemUgIT09IHVuZGVmaW5lZCAmJiBiZWdpbiA8PSAtc2l6ZSkpICYmXG4gICAgICAoZW5kID09PSB1bmRlZmluZWQgfHwgKHNpemUgIT09IHVuZGVmaW5lZCAmJiBlbmQgPj0gc2l6ZSkpXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVCZWdpbihiZWdpbiwgc2l6ZSkge1xuICAgIHJldHVybiByZXNvbHZlSW5kZXgoYmVnaW4sIHNpemUsIDApO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUVuZChlbmQsIHNpemUpIHtcbiAgICByZXR1cm4gcmVzb2x2ZUluZGV4KGVuZCwgc2l6ZSwgc2l6ZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlSW5kZXgoaW5kZXgsIHNpemUsIGRlZmF1bHRJbmRleCkge1xuICAgIC8vIFNhbml0aXplIGluZGljZXMgdXNpbmcgdGhpcyBzaG9ydGhhbmQgZm9yIFRvSW50MzIoYXJndW1lbnQpXG4gICAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvaW50MzJcbiAgICByZXR1cm4gaW5kZXggPT09IHVuZGVmaW5lZFxuICAgICAgPyBkZWZhdWx0SW5kZXhcbiAgICAgIDogaXNOZWcoaW5kZXgpXG4gICAgICA/IHNpemUgPT09IEluZmluaXR5XG4gICAgICAgID8gc2l6ZVxuICAgICAgICA6IE1hdGgubWF4KDAsIHNpemUgKyBpbmRleCkgfCAwXG4gICAgICA6IHNpemUgPT09IHVuZGVmaW5lZCB8fCBzaXplID09PSBpbmRleFxuICAgICAgPyBpbmRleFxuICAgICAgOiBNYXRoLm1pbihzaXplLCBpbmRleCkgfCAwO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOZWcodmFsdWUpIHtcbiAgICAvLyBBY2NvdW50IGZvciAtMCB3aGljaCBpcyBuZWdhdGl2ZSwgYnV0IG5vdCBsZXNzIHRoYW4gMC5cbiAgICByZXR1cm4gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPT09IC1JbmZpbml0eSk7XG4gIH1cblxuICB2YXIgSVNfQ09MTEVDVElPTl9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9JVEVSQUJMRV9fQEAnO1xuXG4gIGZ1bmN0aW9uIGlzQ29sbGVjdGlvbihtYXliZUNvbGxlY3Rpb24pIHtcbiAgICByZXR1cm4gQm9vbGVhbihtYXliZUNvbGxlY3Rpb24gJiYgbWF5YmVDb2xsZWN0aW9uW0lTX0NPTExFQ1RJT05fU1lNQk9MXSk7XG4gIH1cblxuICB2YXIgSVNfS0VZRURfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfS0VZRURfX0BAJztcblxuICBmdW5jdGlvbiBpc0tleWVkKG1heWJlS2V5ZWQpIHtcbiAgICByZXR1cm4gQm9vbGVhbihtYXliZUtleWVkICYmIG1heWJlS2V5ZWRbSVNfS0VZRURfU1lNQk9MXSk7XG4gIH1cblxuICB2YXIgSVNfSU5ERVhFRF9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9JTkRFWEVEX19AQCc7XG5cbiAgZnVuY3Rpb24gaXNJbmRleGVkKG1heWJlSW5kZXhlZCkge1xuICAgIHJldHVybiBCb29sZWFuKG1heWJlSW5kZXhlZCAmJiBtYXliZUluZGV4ZWRbSVNfSU5ERVhFRF9TWU1CT0xdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQXNzb2NpYXRpdmUobWF5YmVBc3NvY2lhdGl2ZSkge1xuICAgIHJldHVybiBpc0tleWVkKG1heWJlQXNzb2NpYXRpdmUpIHx8IGlzSW5kZXhlZChtYXliZUFzc29jaWF0aXZlKTtcbiAgfVxuXG4gIHZhciBDb2xsZWN0aW9uID0gZnVuY3Rpb24gQ29sbGVjdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBpc0NvbGxlY3Rpb24odmFsdWUpID8gdmFsdWUgOiBTZXEodmFsdWUpO1xuICB9O1xuXG4gIHZhciBLZXllZENvbGxlY3Rpb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChDb2xsZWN0aW9uKSB7XG4gICAgZnVuY3Rpb24gS2V5ZWRDb2xsZWN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNLZXllZCh2YWx1ZSkgPyB2YWx1ZSA6IEtleWVkU2VxKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoIENvbGxlY3Rpb24gKSBLZXllZENvbGxlY3Rpb24uX19wcm90b19fID0gQ29sbGVjdGlvbjtcbiAgICBLZXllZENvbGxlY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZSApO1xuICAgIEtleWVkQ29sbGVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBLZXllZENvbGxlY3Rpb247XG5cbiAgICByZXR1cm4gS2V5ZWRDb2xsZWN0aW9uO1xuICB9KENvbGxlY3Rpb24pKTtcblxuICB2YXIgSW5kZXhlZENvbGxlY3Rpb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChDb2xsZWN0aW9uKSB7XG4gICAgZnVuY3Rpb24gSW5kZXhlZENvbGxlY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0luZGV4ZWQodmFsdWUpID8gdmFsdWUgOiBJbmRleGVkU2VxKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoIENvbGxlY3Rpb24gKSBJbmRleGVkQ29sbGVjdGlvbi5fX3Byb3RvX18gPSBDb2xsZWN0aW9uO1xuICAgIEluZGV4ZWRDb2xsZWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGUgKTtcbiAgICBJbmRleGVkQ29sbGVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbmRleGVkQ29sbGVjdGlvbjtcblxuICAgIHJldHVybiBJbmRleGVkQ29sbGVjdGlvbjtcbiAgfShDb2xsZWN0aW9uKSk7XG5cbiAgdmFyIFNldENvbGxlY3Rpb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChDb2xsZWN0aW9uKSB7XG4gICAgZnVuY3Rpb24gU2V0Q29sbGVjdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQ29sbGVjdGlvbih2YWx1ZSkgJiYgIWlzQXNzb2NpYXRpdmUodmFsdWUpID8gdmFsdWUgOiBTZXRTZXEodmFsdWUpO1xuICAgIH1cblxuICAgIGlmICggQ29sbGVjdGlvbiApIFNldENvbGxlY3Rpb24uX19wcm90b19fID0gQ29sbGVjdGlvbjtcbiAgICBTZXRDb2xsZWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGUgKTtcbiAgICBTZXRDb2xsZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNldENvbGxlY3Rpb247XG5cbiAgICByZXR1cm4gU2V0Q29sbGVjdGlvbjtcbiAgfShDb2xsZWN0aW9uKSk7XG5cbiAgQ29sbGVjdGlvbi5LZXllZCA9IEtleWVkQ29sbGVjdGlvbjtcbiAgQ29sbGVjdGlvbi5JbmRleGVkID0gSW5kZXhlZENvbGxlY3Rpb247XG4gIENvbGxlY3Rpb24uU2V0ID0gU2V0Q29sbGVjdGlvbjtcblxuICB2YXIgSVNfU0VRX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX1NFUV9fQEAnO1xuXG4gIGZ1bmN0aW9uIGlzU2VxKG1heWJlU2VxKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4obWF5YmVTZXEgJiYgbWF5YmVTZXFbSVNfU0VRX1NZTUJPTF0pO1xuICB9XG5cbiAgdmFyIElTX1JFQ09SRF9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9SRUNPUkRfX0BAJztcblxuICBmdW5jdGlvbiBpc1JlY29yZChtYXliZVJlY29yZCkge1xuICAgIHJldHVybiBCb29sZWFuKG1heWJlUmVjb3JkICYmIG1heWJlUmVjb3JkW0lTX1JFQ09SRF9TWU1CT0xdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSW1tdXRhYmxlKG1heWJlSW1tdXRhYmxlKSB7XG4gICAgcmV0dXJuIGlzQ29sbGVjdGlvbihtYXliZUltbXV0YWJsZSkgfHwgaXNSZWNvcmQobWF5YmVJbW11dGFibGUpO1xuICB9XG5cbiAgdmFyIElTX09SREVSRURfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfT1JERVJFRF9fQEAnO1xuXG4gIGZ1bmN0aW9uIGlzT3JkZXJlZChtYXliZU9yZGVyZWQpIHtcbiAgICByZXR1cm4gQm9vbGVhbihtYXliZU9yZGVyZWQgJiYgbWF5YmVPcmRlcmVkW0lTX09SREVSRURfU1lNQk9MXSk7XG4gIH1cblxuICB2YXIgSVRFUkFURV9LRVlTID0gMDtcbiAgdmFyIElURVJBVEVfVkFMVUVTID0gMTtcbiAgdmFyIElURVJBVEVfRU5UUklFUyA9IDI7XG5cbiAgdmFyIFJFQUxfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcblxuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gUkVBTF9JVEVSQVRPUl9TWU1CT0wgfHwgRkFVWF9JVEVSQVRPUl9TWU1CT0w7XG5cbiAgdmFyIEl0ZXJhdG9yID0gZnVuY3Rpb24gSXRlcmF0b3IobmV4dCkge1xuICAgIHRoaXMubmV4dCA9IG5leHQ7XG4gIH07XG5cbiAgSXRlcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiAnW0l0ZXJhdG9yXSc7XG4gIH07XG5cbiAgSXRlcmF0b3IuS0VZUyA9IElURVJBVEVfS0VZUztcbiAgSXRlcmF0b3IuVkFMVUVTID0gSVRFUkFURV9WQUxVRVM7XG4gIEl0ZXJhdG9yLkVOVFJJRVMgPSBJVEVSQVRFX0VOVFJJRVM7XG5cbiAgSXRlcmF0b3IucHJvdG90eXBlLmluc3BlY3QgPSBJdGVyYXRvci5wcm90b3R5cGUudG9Tb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfTtcbiAgSXRlcmF0b3IucHJvdG90eXBlW0lURVJBVE9SX1NZTUJPTF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgZnVuY3Rpb24gaXRlcmF0b3JWYWx1ZSh0eXBlLCBrLCB2LCBpdGVyYXRvclJlc3VsdCkge1xuICAgIHZhciB2YWx1ZSA9IHR5cGUgPT09IDAgPyBrIDogdHlwZSA9PT0gMSA/IHYgOiBbaywgdl07XG4gICAgaXRlcmF0b3JSZXN1bHRcbiAgICAgID8gKGl0ZXJhdG9yUmVzdWx0LnZhbHVlID0gdmFsdWUpXG4gICAgICA6IChpdGVyYXRvclJlc3VsdCA9IHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIHJldHVybiBpdGVyYXRvclJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGl0ZXJhdG9yRG9uZSgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBmdW5jdGlvbiBoYXNJdGVyYXRvcihtYXliZUl0ZXJhYmxlKSB7XG4gICAgcmV0dXJuICEhZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSXRlcmF0b3IobWF5YmVJdGVyYXRvcikge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yICYmIHR5cGVvZiBtYXliZUl0ZXJhdG9yLm5leHQgPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJdGVyYXRvcihpdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihpdGVyYWJsZSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm4gJiYgaXRlcmF0b3JGbi5jYWxsKGl0ZXJhYmxlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4oaXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9XG4gICAgICBpdGVyYWJsZSAmJlxuICAgICAgKChSRUFMX0lURVJBVE9SX1NZTUJPTCAmJiBpdGVyYWJsZVtSRUFMX0lURVJBVE9SX1NZTUJPTF0pIHx8XG4gICAgICAgIGl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICB2YWx1ZSAmJlxuICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZS5sZW5ndGgpICYmXG4gICAgICB2YWx1ZS5sZW5ndGggPj0gMCAmJlxuICAgICAgKHZhbHVlLmxlbmd0aCA9PT0gMFxuICAgICAgICA/IC8vIE9ubHkge2xlbmd0aDogMH0gaXMgY29uc2lkZXJlZCBBcnJheS1saWtlLlxuICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPT09IDFcbiAgICAgICAgOiAvLyBBbiBvYmplY3QgaXMgb25seSBBcnJheS1saWtlIGlmIGl0IGhhcyBhIHByb3BlcnR5IHdoZXJlIHRoZSBsYXN0IHZhbHVlXG4gICAgICAgICAgLy8gaW4gdGhlIGFycmF5LWxpa2UgbWF5IGJlIGZvdW5kICh3aGljaCBjb3VsZCBiZSB1bmRlZmluZWQpLlxuICAgICAgICAgIHZhbHVlLmhhc093blByb3BlcnR5KHZhbHVlLmxlbmd0aCAtIDEpKVxuICAgICk7XG4gIH1cblxuICB2YXIgU2VxID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQ29sbGVjdGlvbikge1xuICAgIGZ1bmN0aW9uIFNlcSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBlbXB0eVNlcXVlbmNlKClcbiAgICAgICAgOiBpc0ltbXV0YWJsZSh2YWx1ZSlcbiAgICAgICAgPyB2YWx1ZS50b1NlcSgpXG4gICAgICAgIDogc2VxRnJvbVZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoIENvbGxlY3Rpb24gKSBTZXEuX19wcm90b19fID0gQ29sbGVjdGlvbjtcbiAgICBTZXEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZSApO1xuICAgIFNlcS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXE7XG5cbiAgICBTZXEucHJvdG90eXBlLnRvU2VxID0gZnVuY3Rpb24gdG9TZXEgKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFNlcS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdTZXEgeycsICd9Jyk7XG4gICAgfTtcblxuICAgIFNlcS5wcm90b3R5cGUuY2FjaGVSZXN1bHQgPSBmdW5jdGlvbiBjYWNoZVJlc3VsdCAoKSB7XG4gICAgICBpZiAoIXRoaXMuX2NhY2hlICYmIHRoaXMuX19pdGVyYXRlVW5jYWNoZWQpIHtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSB0aGlzLmVudHJ5U2VxKCkudG9BcnJheSgpO1xuICAgICAgICB0aGlzLnNpemUgPSB0aGlzLl9jYWNoZS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLy8gYWJzdHJhY3QgX19pdGVyYXRlVW5jYWNoZWQoZm4sIHJldmVyc2UpXG5cbiAgICBTZXEucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciBjYWNoZSA9IHRoaXMuX2NhY2hlO1xuICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIHZhciBzaXplID0gY2FjaGUubGVuZ3RoO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpICE9PSBzaXplKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gY2FjaGVbcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKytdO1xuICAgICAgICAgIGlmIChmbihlbnRyeVsxXSwgZW50cnlbMF0sIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX19pdGVyYXRlVW5jYWNoZWQoZm4sIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICAvLyBhYnN0cmFjdCBfX2l0ZXJhdG9yVW5jYWNoZWQodHlwZSwgcmV2ZXJzZSlcblxuICAgIFNlcS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBjYWNoZSA9IHRoaXMuX2NhY2hlO1xuICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIHZhciBzaXplID0gY2FjaGUubGVuZ3RoO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChpID09PSBzaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbnRyeSA9IGNhY2hlW3JldmVyc2UgPyBzaXplIC0gKytpIDogaSsrXTtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9faXRlcmF0b3JVbmNhY2hlZCh0eXBlLCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNlcTtcbiAgfShDb2xsZWN0aW9uKSk7XG5cbiAgdmFyIEtleWVkU2VxID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoU2VxKSB7XG4gICAgZnVuY3Rpb24gS2V5ZWRTZXEodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gZW1wdHlTZXF1ZW5jZSgpLnRvS2V5ZWRTZXEoKVxuICAgICAgICA6IGlzQ29sbGVjdGlvbih2YWx1ZSlcbiAgICAgICAgPyBpc0tleWVkKHZhbHVlKVxuICAgICAgICAgID8gdmFsdWUudG9TZXEoKVxuICAgICAgICAgIDogdmFsdWUuZnJvbUVudHJ5U2VxKClcbiAgICAgICAgOiBpc1JlY29yZCh2YWx1ZSlcbiAgICAgICAgPyB2YWx1ZS50b1NlcSgpXG4gICAgICAgIDoga2V5ZWRTZXFGcm9tVmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIGlmICggU2VxICkgS2V5ZWRTZXEuX19wcm90b19fID0gU2VxO1xuICAgIEtleWVkU2VxLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNlcSAmJiBTZXEucHJvdG90eXBlICk7XG4gICAgS2V5ZWRTZXEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gS2V5ZWRTZXE7XG5cbiAgICBLZXllZFNlcS5wcm90b3R5cGUudG9LZXllZFNlcSA9IGZ1bmN0aW9uIHRvS2V5ZWRTZXEgKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHJldHVybiBLZXllZFNlcTtcbiAgfShTZXEpKTtcblxuICB2YXIgSW5kZXhlZFNlcSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNlcSkge1xuICAgIGZ1bmN0aW9uIEluZGV4ZWRTZXEodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gZW1wdHlTZXF1ZW5jZSgpXG4gICAgICAgIDogaXNDb2xsZWN0aW9uKHZhbHVlKVxuICAgICAgICA/IGlzS2V5ZWQodmFsdWUpXG4gICAgICAgICAgPyB2YWx1ZS5lbnRyeVNlcSgpXG4gICAgICAgICAgOiB2YWx1ZS50b0luZGV4ZWRTZXEoKVxuICAgICAgICA6IGlzUmVjb3JkKHZhbHVlKVxuICAgICAgICA/IHZhbHVlLnRvU2VxKCkuZW50cnlTZXEoKVxuICAgICAgICA6IGluZGV4ZWRTZXFGcm9tVmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIGlmICggU2VxICkgSW5kZXhlZFNlcS5fX3Byb3RvX18gPSBTZXE7XG4gICAgSW5kZXhlZFNlcS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTZXEgJiYgU2VxLnByb3RvdHlwZSApO1xuICAgIEluZGV4ZWRTZXEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW5kZXhlZFNlcTtcblxuICAgIEluZGV4ZWRTZXEub2YgPSBmdW5jdGlvbiBvZiAoLyouLi52YWx1ZXMqLykge1xuICAgICAgcmV0dXJuIEluZGV4ZWRTZXEoYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgSW5kZXhlZFNlcS5wcm90b3R5cGUudG9JbmRleGVkU2VxID0gZnVuY3Rpb24gdG9JbmRleGVkU2VxICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBJbmRleGVkU2VxLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ1NlcSBbJywgJ10nKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEluZGV4ZWRTZXE7XG4gIH0oU2VxKSk7XG5cbiAgdmFyIFNldFNlcSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNlcSkge1xuICAgIGZ1bmN0aW9uIFNldFNlcSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgaXNDb2xsZWN0aW9uKHZhbHVlKSAmJiAhaXNBc3NvY2lhdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IEluZGV4ZWRTZXEodmFsdWUpXG4gICAgICApLnRvU2V0U2VxKCk7XG4gICAgfVxuXG4gICAgaWYgKCBTZXEgKSBTZXRTZXEuX19wcm90b19fID0gU2VxO1xuICAgIFNldFNlcS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTZXEgJiYgU2VxLnByb3RvdHlwZSApO1xuICAgIFNldFNlcS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXRTZXE7XG5cbiAgICBTZXRTZXEub2YgPSBmdW5jdGlvbiBvZiAoLyouLi52YWx1ZXMqLykge1xuICAgICAgcmV0dXJuIFNldFNlcShhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBTZXRTZXEucHJvdG90eXBlLnRvU2V0U2VxID0gZnVuY3Rpb24gdG9TZXRTZXEgKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXRTZXE7XG4gIH0oU2VxKSk7XG5cbiAgU2VxLmlzU2VxID0gaXNTZXE7XG4gIFNlcS5LZXllZCA9IEtleWVkU2VxO1xuICBTZXEuU2V0ID0gU2V0U2VxO1xuICBTZXEuSW5kZXhlZCA9IEluZGV4ZWRTZXE7XG5cbiAgU2VxLnByb3RvdHlwZVtJU19TRVFfU1lNQk9MXSA9IHRydWU7XG5cbiAgLy8gI3ByYWdtYSBSb290IFNlcXVlbmNlc1xuXG4gIHZhciBBcnJheVNlcSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEluZGV4ZWRTZXEpIHtcbiAgICBmdW5jdGlvbiBBcnJheVNlcShhcnJheSkge1xuICAgICAgdGhpcy5fYXJyYXkgPSBhcnJheTtcbiAgICAgIHRoaXMuc2l6ZSA9IGFycmF5Lmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAoIEluZGV4ZWRTZXEgKSBBcnJheVNlcS5fX3Byb3RvX18gPSBJbmRleGVkU2VxO1xuICAgIEFycmF5U2VxLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEluZGV4ZWRTZXEgJiYgSW5kZXhlZFNlcS5wcm90b3R5cGUgKTtcbiAgICBBcnJheVNlcS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBcnJheVNlcTtcblxuICAgIEFycmF5U2VxLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzKGluZGV4KSA/IHRoaXMuX2FycmF5W3dyYXBJbmRleCh0aGlzLCBpbmRleCldIDogbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIEFycmF5U2VxLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLl9hcnJheTtcbiAgICAgIHZhciBzaXplID0gYXJyYXkubGVuZ3RoO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgd2hpbGUgKGkgIT09IHNpemUpIHtcbiAgICAgICAgdmFyIGlpID0gcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKys7XG4gICAgICAgIGlmIChmbihhcnJheVtpaV0sIGlpLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGk7XG4gICAgfTtcblxuICAgIEFycmF5U2VxLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5fYXJyYXk7XG4gICAgICB2YXIgc2l6ZSA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaSA9PT0gc2l6ZSkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWkgPSByZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrKztcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaWksIGFycmF5W2lpXSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEFycmF5U2VxO1xuICB9KEluZGV4ZWRTZXEpKTtcblxuICB2YXIgT2JqZWN0U2VxID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoS2V5ZWRTZXEpIHtcbiAgICBmdW5jdGlvbiBPYmplY3RTZXEob2JqZWN0KSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgICB0aGlzLl9vYmplY3QgPSBvYmplY3Q7XG4gICAgICB0aGlzLl9rZXlzID0ga2V5cztcbiAgICAgIHRoaXMuc2l6ZSA9IGtleXMubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmICggS2V5ZWRTZXEgKSBPYmplY3RTZXEuX19wcm90b19fID0gS2V5ZWRTZXE7XG4gICAgT2JqZWN0U2VxLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEtleWVkU2VxICYmIEtleWVkU2VxLnByb3RvdHlwZSApO1xuICAgIE9iamVjdFNlcS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPYmplY3RTZXE7XG5cbiAgICBPYmplY3RTZXEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoa2V5LCBub3RTZXRWYWx1ZSkge1xuICAgICAgaWYgKG5vdFNldFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIXRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX29iamVjdFtrZXldO1xuICAgIH07XG5cbiAgICBPYmplY3RTZXEucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9vYmplY3QsIGtleSk7XG4gICAgfTtcblxuICAgIE9iamVjdFNlcS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIG9iamVjdCA9IHRoaXMuX29iamVjdDtcbiAgICAgIHZhciBrZXlzID0gdGhpcy5fa2V5cztcbiAgICAgIHZhciBzaXplID0ga2V5cy5sZW5ndGg7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB3aGlsZSAoaSAhPT0gc2l6ZSkge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tyZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrK107XG4gICAgICAgIGlmIChmbihvYmplY3Rba2V5XSwga2V5LCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGk7XG4gICAgfTtcblxuICAgIE9iamVjdFNlcS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBvYmplY3QgPSB0aGlzLl9vYmplY3Q7XG4gICAgICB2YXIga2V5cyA9IHRoaXMuX2tleXM7XG4gICAgICB2YXIgc2l6ZSA9IGtleXMubGVuZ3RoO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpID09PSBzaXplKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW3JldmVyc2UgPyBzaXplIC0gKytpIDogaSsrXTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwga2V5LCBvYmplY3Rba2V5XSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE9iamVjdFNlcTtcbiAgfShLZXllZFNlcSkpO1xuICBPYmplY3RTZXEucHJvdG90eXBlW0lTX09SREVSRURfU1lNQk9MXSA9IHRydWU7XG5cbiAgdmFyIENvbGxlY3Rpb25TZXEgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbmRleGVkU2VxKSB7XG4gICAgZnVuY3Rpb24gQ29sbGVjdGlvblNlcShjb2xsZWN0aW9uKSB7XG4gICAgICB0aGlzLl9jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgICAgIHRoaXMuc2l6ZSA9IGNvbGxlY3Rpb24ubGVuZ3RoIHx8IGNvbGxlY3Rpb24uc2l6ZTtcbiAgICB9XG5cbiAgICBpZiAoIEluZGV4ZWRTZXEgKSBDb2xsZWN0aW9uU2VxLl9fcHJvdG9fXyA9IEluZGV4ZWRTZXE7XG4gICAgQ29sbGVjdGlvblNlcS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkU2VxICYmIEluZGV4ZWRTZXEucHJvdG90eXBlICk7XG4gICAgQ29sbGVjdGlvblNlcS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb2xsZWN0aW9uU2VxO1xuXG4gICAgQ29sbGVjdGlvblNlcS5wcm90b3R5cGUuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbiBfX2l0ZXJhdGVVbmNhY2hlZCAoZm4sIHJldmVyc2UpIHtcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcy5fY29sbGVjdGlvbjtcbiAgICAgIHZhciBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGNvbGxlY3Rpb24pO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgaWYgKGlzSXRlcmF0b3IoaXRlcmF0b3IpKSB7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGZuKHN0ZXAudmFsdWUsIGl0ZXJhdGlvbnMrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG5cbiAgICBDb2xsZWN0aW9uU2VxLnByb3RvdHlwZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yVW5jYWNoZWQgKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcy5fY29sbGVjdGlvbjtcbiAgICAgIHZhciBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGNvbGxlY3Rpb24pO1xuICAgICAgaWYgKCFpc0l0ZXJhdG9yKGl0ZXJhdG9yKSkge1xuICAgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGl0ZXJhdG9yRG9uZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiBzdGVwLmRvbmUgPyBzdGVwIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHN0ZXAudmFsdWUpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBDb2xsZWN0aW9uU2VxO1xuICB9KEluZGV4ZWRTZXEpKTtcblxuICAvLyAjIHByYWdtYSBIZWxwZXIgZnVuY3Rpb25zXG5cbiAgdmFyIEVNUFRZX1NFUTtcblxuICBmdW5jdGlvbiBlbXB0eVNlcXVlbmNlKCkge1xuICAgIHJldHVybiBFTVBUWV9TRVEgfHwgKEVNUFRZX1NFUSA9IG5ldyBBcnJheVNlcShbXSkpO1xuICB9XG5cbiAgZnVuY3Rpb24ga2V5ZWRTZXFGcm9tVmFsdWUodmFsdWUpIHtcbiAgICB2YXIgc2VxID0gQXJyYXkuaXNBcnJheSh2YWx1ZSlcbiAgICAgID8gbmV3IEFycmF5U2VxKHZhbHVlKVxuICAgICAgOiBoYXNJdGVyYXRvcih2YWx1ZSlcbiAgICAgID8gbmV3IENvbGxlY3Rpb25TZXEodmFsdWUpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgICBpZiAoc2VxKSB7XG4gICAgICByZXR1cm4gc2VxLmZyb21FbnRyeVNlcSgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIG5ldyBPYmplY3RTZXEodmFsdWUpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ0V4cGVjdGVkIEFycmF5IG9yIGNvbGxlY3Rpb24gb2JqZWN0IG9mIFtrLCB2XSBlbnRyaWVzLCBvciBrZXllZCBvYmplY3Q6ICcgK1xuICAgICAgICB2YWx1ZVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBpbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKSB7XG4gICAgdmFyIHNlcSA9IG1heWJlSW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSk7XG4gICAgaWYgKHNlcSkge1xuICAgICAgcmV0dXJuIHNlcTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdFeHBlY3RlZCBBcnJheSBvciBjb2xsZWN0aW9uIG9iamVjdCBvZiB2YWx1ZXM6ICcgKyB2YWx1ZVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXFGcm9tVmFsdWUodmFsdWUpIHtcbiAgICB2YXIgc2VxID0gbWF5YmVJbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKTtcbiAgICBpZiAoc2VxKSB7XG4gICAgICByZXR1cm4gc2VxO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIG5ldyBPYmplY3RTZXEodmFsdWUpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ0V4cGVjdGVkIEFycmF5IG9yIGNvbGxlY3Rpb24gb2JqZWN0IG9mIHZhbHVlcywgb3Iga2V5ZWQgb2JqZWN0OiAnICsgdmFsdWVcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF5YmVJbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQXJyYXlMaWtlKHZhbHVlKVxuICAgICAgPyBuZXcgQXJyYXlTZXEodmFsdWUpXG4gICAgICA6IGhhc0l0ZXJhdG9yKHZhbHVlKVxuICAgICAgPyBuZXcgQ29sbGVjdGlvblNlcSh2YWx1ZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIElTX01BUF9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9NQVBfX0BAJztcblxuICBmdW5jdGlvbiBpc01hcChtYXliZU1hcCkge1xuICAgIHJldHVybiBCb29sZWFuKG1heWJlTWFwICYmIG1heWJlTWFwW0lTX01BUF9TWU1CT0xdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT3JkZXJlZE1hcChtYXliZU9yZGVyZWRNYXApIHtcbiAgICByZXR1cm4gaXNNYXAobWF5YmVPcmRlcmVkTWFwKSAmJiBpc09yZGVyZWQobWF5YmVPcmRlcmVkTWFwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVmFsdWVPYmplY3QobWF5YmVWYWx1ZSkge1xuICAgIHJldHVybiBCb29sZWFuKFxuICAgICAgbWF5YmVWYWx1ZSAmJlxuICAgICAgICB0eXBlb2YgbWF5YmVWYWx1ZS5lcXVhbHMgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdHlwZW9mIG1heWJlVmFsdWUuaGFzaENvZGUgPT09ICdmdW5jdGlvbidcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIGV4dGVuc2lvbiBvZiB0aGUgXCJzYW1lLXZhbHVlXCIgYWxnb3JpdGhtIGFzIFtkZXNjcmliZWQgZm9yIHVzZSBieSBFUzYgTWFwXG4gICAqIGFuZCBTZXRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hcCNLZXlfZXF1YWxpdHkpXG4gICAqXG4gICAqIE5hTiBpcyBjb25zaWRlcmVkIHRoZSBzYW1lIGFzIE5hTiwgaG93ZXZlciAtMCBhbmQgMCBhcmUgY29uc2lkZXJlZCB0aGUgc2FtZVxuICAgKiB2YWx1ZSwgd2hpY2ggaXMgZGlmZmVyZW50IGZyb20gdGhlIGFsZ29yaXRobSBkZXNjcmliZWQgYnlcbiAgICogW2BPYmplY3QuaXNgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXMpLlxuICAgKlxuICAgKiBUaGlzIGlzIGV4dGVuZGVkIGZ1cnRoZXIgdG8gYWxsb3cgT2JqZWN0cyB0byBkZXNjcmliZSB0aGUgdmFsdWVzIHRoZXlcbiAgICogcmVwcmVzZW50LCBieSB3YXkgb2YgYHZhbHVlT2ZgIG9yIGBlcXVhbHNgIChhbmQgYGhhc2hDb2RlYCkuXG4gICAqXG4gICAqIE5vdGU6IGJlY2F1c2Ugb2YgdGhpcyBleHRlbnNpb24sIHRoZSBrZXkgZXF1YWxpdHkgb2YgSW1tdXRhYmxlLk1hcCBhbmQgdGhlXG4gICAqIHZhbHVlIGVxdWFsaXR5IG9mIEltbXV0YWJsZS5TZXQgd2lsbCBkaWZmZXIgZnJvbSBFUzYgTWFwIGFuZCBTZXQuXG4gICAqXG4gICAqICMjIyBEZWZpbmluZyBjdXN0b20gdmFsdWVzXG4gICAqXG4gICAqIFRoZSBlYXNpZXN0IHdheSB0byBkZXNjcmliZSB0aGUgdmFsdWUgYW4gb2JqZWN0IHJlcHJlc2VudHMgaXMgYnkgaW1wbGVtZW50aW5nXG4gICAqIGB2YWx1ZU9mYC4gRm9yIGV4YW1wbGUsIGBEYXRlYCByZXByZXNlbnRzIGEgdmFsdWUgYnkgcmV0dXJuaW5nIGEgdW5peFxuICAgKiB0aW1lc3RhbXAgZm9yIGB2YWx1ZU9mYDpcbiAgICpcbiAgICogICAgIHZhciBkYXRlMSA9IG5ldyBEYXRlKDEyMzQ1Njc4OTAwMDApOyAvLyBGcmkgRmViIDEzIDIwMDkgLi4uXG4gICAqICAgICB2YXIgZGF0ZTIgPSBuZXcgRGF0ZSgxMjM0NTY3ODkwMDAwKTtcbiAgICogICAgIGRhdGUxLnZhbHVlT2YoKTsgLy8gMTIzNDU2Nzg5MDAwMFxuICAgKiAgICAgYXNzZXJ0KCBkYXRlMSAhPT0gZGF0ZTIgKTtcbiAgICogICAgIGFzc2VydCggSW1tdXRhYmxlLmlzKCBkYXRlMSwgZGF0ZTIgKSApO1xuICAgKlxuICAgKiBOb3RlOiBvdmVycmlkaW5nIGB2YWx1ZU9mYCBtYXkgaGF2ZSBvdGhlciBpbXBsaWNhdGlvbnMgaWYgeW91IHVzZSB0aGlzIG9iamVjdFxuICAgKiB3aGVyZSBKYXZhU2NyaXB0IGV4cGVjdHMgYSBwcmltaXRpdmUsIHN1Y2ggYXMgaW1wbGljaXQgc3RyaW5nIGNvZXJjaW9uLlxuICAgKlxuICAgKiBGb3IgbW9yZSBjb21wbGV4IHR5cGVzLCBlc3BlY2lhbGx5IGNvbGxlY3Rpb25zLCBpbXBsZW1lbnRpbmcgYHZhbHVlT2ZgIG1heVxuICAgKiBub3QgYmUgcGVyZm9ybWFudC4gQW4gYWx0ZXJuYXRpdmUgaXMgdG8gaW1wbGVtZW50IGBlcXVhbHNgIGFuZCBgaGFzaENvZGVgLlxuICAgKlxuICAgKiBgZXF1YWxzYCB0YWtlcyBhbm90aGVyIG9iamVjdCwgcHJlc3VtYWJseSBvZiBzaW1pbGFyIHR5cGUsIGFuZCByZXR1cm5zIHRydWVcbiAgICogaWYgaXQgaXMgZXF1YWwuIEVxdWFsaXR5IGlzIHN5bW1ldHJpY2FsLCBzbyB0aGUgc2FtZSByZXN1bHQgc2hvdWxkIGJlXG4gICAqIHJldHVybmVkIGlmIHRoaXMgYW5kIHRoZSBhcmd1bWVudCBhcmUgZmxpcHBlZC5cbiAgICpcbiAgICogICAgIGFzc2VydCggYS5lcXVhbHMoYikgPT09IGIuZXF1YWxzKGEpICk7XG4gICAqXG4gICAqIGBoYXNoQ29kZWAgcmV0dXJucyBhIDMyYml0IGludGVnZXIgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgb2JqZWN0IHdoaWNoIHdpbGxcbiAgICogYmUgdXNlZCB0byBkZXRlcm1pbmUgaG93IHRvIHN0b3JlIHRoZSB2YWx1ZSBvYmplY3QgaW4gYSBNYXAgb3IgU2V0LiBZb3UgbXVzdFxuICAgKiBwcm92aWRlIGJvdGggb3IgbmVpdGhlciBtZXRob2RzLCBvbmUgbXVzdCBub3QgZXhpc3Qgd2l0aG91dCB0aGUgb3RoZXIuXG4gICAqXG4gICAqIEFsc28sIGFuIGltcG9ydGFudCByZWxhdGlvbnNoaXAgYmV0d2VlbiB0aGVzZSBtZXRob2RzIG11c3QgYmUgdXBoZWxkOiBpZiB0d29cbiAgICogdmFsdWVzIGFyZSBlcXVhbCwgdGhleSAqbXVzdCogcmV0dXJuIHRoZSBzYW1lIGhhc2hDb2RlLiBJZiB0aGUgdmFsdWVzIGFyZSBub3RcbiAgICogZXF1YWwsIHRoZXkgbWlnaHQgaGF2ZSB0aGUgc2FtZSBoYXNoQ29kZTsgdGhpcyBpcyBjYWxsZWQgYSBoYXNoIGNvbGxpc2lvbixcbiAgICogYW5kIHdoaWxlIHVuZGVzaXJhYmxlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBpdCBpcyBhY2NlcHRhYmxlLlxuICAgKlxuICAgKiAgICAgaWYgKGEuZXF1YWxzKGIpKSB7XG4gICAqICAgICAgIGFzc2VydCggYS5oYXNoQ29kZSgpID09PSBiLmhhc2hDb2RlKCkgKTtcbiAgICogICAgIH1cbiAgICpcbiAgICogQWxsIEltbXV0YWJsZSBjb2xsZWN0aW9ucyBhcmUgVmFsdWUgT2JqZWN0czogdGhleSBpbXBsZW1lbnQgYGVxdWFscygpYFxuICAgKiBhbmQgYGhhc2hDb2RlKClgLlxuICAgKi9cbiAgZnVuY3Rpb24gaXModmFsdWVBLCB2YWx1ZUIpIHtcbiAgICBpZiAodmFsdWVBID09PSB2YWx1ZUIgfHwgKHZhbHVlQSAhPT0gdmFsdWVBICYmIHZhbHVlQiAhPT0gdmFsdWVCKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghdmFsdWVBIHx8ICF2YWx1ZUIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIHZhbHVlQS52YWx1ZU9mID09PSAnZnVuY3Rpb24nICYmXG4gICAgICB0eXBlb2YgdmFsdWVCLnZhbHVlT2YgPT09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIHZhbHVlQSA9IHZhbHVlQS52YWx1ZU9mKCk7XG4gICAgICB2YWx1ZUIgPSB2YWx1ZUIudmFsdWVPZigpO1xuICAgICAgaWYgKHZhbHVlQSA9PT0gdmFsdWVCIHx8ICh2YWx1ZUEgIT09IHZhbHVlQSAmJiB2YWx1ZUIgIT09IHZhbHVlQikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIXZhbHVlQSB8fCAhdmFsdWVCKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICEhKFxuICAgICAgaXNWYWx1ZU9iamVjdCh2YWx1ZUEpICYmXG4gICAgICBpc1ZhbHVlT2JqZWN0KHZhbHVlQikgJiZcbiAgICAgIHZhbHVlQS5lcXVhbHModmFsdWVCKVxuICAgICk7XG4gIH1cblxuICB2YXIgaW11bCA9XG4gICAgdHlwZW9mIE1hdGguaW11bCA9PT0gJ2Z1bmN0aW9uJyAmJiBNYXRoLmltdWwoMHhmZmZmZmZmZiwgMikgPT09IC0yXG4gICAgICA/IE1hdGguaW11bFxuICAgICAgOiBmdW5jdGlvbiBpbXVsKGEsIGIpIHtcbiAgICAgICAgICBhIHw9IDA7IC8vIGludFxuICAgICAgICAgIGIgfD0gMDsgLy8gaW50XG4gICAgICAgICAgdmFyIGMgPSBhICYgMHhmZmZmO1xuICAgICAgICAgIHZhciBkID0gYiAmIDB4ZmZmZjtcbiAgICAgICAgICAvLyBTaGlmdCBieSAwIGZpeGVzIHRoZSBzaWduIG9uIHRoZSBoaWdoIHBhcnQuXG4gICAgICAgICAgcmV0dXJuIChjICogZCArICgoKChhID4+PiAxNikgKiBkICsgYyAqIChiID4+PiAxNikpIDw8IDE2KSA+Pj4gMCkpIHwgMDsgLy8gaW50XG4gICAgICAgIH07XG5cbiAgLy8gdjggaGFzIGFuIG9wdGltaXphdGlvbiBmb3Igc3RvcmluZyAzMS1iaXQgc2lnbmVkIG51bWJlcnMuXG4gIC8vIFZhbHVlcyB3aGljaCBoYXZlIGVpdGhlciAwMCBvciAxMSBhcyB0aGUgaGlnaCBvcmRlciBiaXRzIHF1YWxpZnkuXG4gIC8vIFRoaXMgZnVuY3Rpb24gZHJvcHMgdGhlIGhpZ2hlc3Qgb3JkZXIgYml0IGluIGEgc2lnbmVkIG51bWJlciwgbWFpbnRhaW5pbmdcbiAgLy8gdGhlIHNpZ24gYml0LlxuICBmdW5jdGlvbiBzbWkoaTMyKSB7XG4gICAgcmV0dXJuICgoaTMyID4+PiAxKSAmIDB4NDAwMDAwMDApIHwgKGkzMiAmIDB4YmZmZmZmZmYpO1xuICB9XG5cbiAgdmFyIGRlZmF1bHRWYWx1ZU9mID0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mO1xuXG4gIGZ1bmN0aW9uIGhhc2gobykge1xuICAgIHN3aXRjaCAodHlwZW9mIG8pIHtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAvLyBUaGUgaGFzaCB2YWx1ZXMgZm9yIGJ1aWx0LWluIGNvbnN0YW50cyBhcmUgYSAxIHZhbHVlIGZvciBlYWNoIDUtYnl0ZVxuICAgICAgICAvLyBzaGlmdCByZWdpb24gZXhwZWN0IGZvciB0aGUgZmlyc3QsIHdoaWNoIGVuY29kZXMgdGhlIHZhbHVlLiBUaGlzXG4gICAgICAgIC8vIHJlZHVjZXMgdGhlIG9kZHMgb2YgYSBoYXNoIGNvbGxpc2lvbiBmb3IgdGhlc2UgY29tbW9uIHZhbHVlcy5cbiAgICAgICAgcmV0dXJuIG8gPyAweDQyMTA4NDIxIDogMHg0MjEwODQyMDtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIHJldHVybiBoYXNoTnVtYmVyKG8pO1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmV0dXJuIG8ubGVuZ3RoID4gU1RSSU5HX0hBU0hfQ0FDSEVfTUlOX1NUUkxFTlxuICAgICAgICAgID8gY2FjaGVkSGFzaFN0cmluZyhvKVxuICAgICAgICAgIDogaGFzaFN0cmluZyhvKTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgIGlmIChvID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIDB4NDIxMDg0MjI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvLmhhc2hDb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gRHJvcCBhbnkgaGlnaCBiaXRzIGZyb20gYWNjaWRlbnRhbGx5IGxvbmcgaGFzaCBjb2Rlcy5cbiAgICAgICAgICByZXR1cm4gc21pKG8uaGFzaENvZGUobykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvLnZhbHVlT2YgIT09IGRlZmF1bHRWYWx1ZU9mICYmIHR5cGVvZiBvLnZhbHVlT2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvID0gby52YWx1ZU9mKG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYXNoSlNPYmoobyk7XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gMHg0MjEwODQyMztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0eXBlb2Ygby50b1N0cmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBoYXNoU3RyaW5nKG8udG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSB0eXBlICcgKyB0eXBlb2YgbyArICcgY2Fubm90IGJlIGhhc2hlZC4nKTtcbiAgICB9XG4gIH1cblxuICAvLyBDb21wcmVzcyBhcmJpdHJhcmlseSBsYXJnZSBudW1iZXJzIGludG8gc21pIGhhc2hlcy5cbiAgZnVuY3Rpb24gaGFzaE51bWJlcihuKSB7XG4gICAgaWYgKG4gIT09IG4gfHwgbiA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIgaGFzaCA9IG4gfCAwO1xuICAgIGlmIChoYXNoICE9PSBuKSB7XG4gICAgICBoYXNoIF49IG4gKiAweGZmZmZmZmZmO1xuICAgIH1cbiAgICB3aGlsZSAobiA+IDB4ZmZmZmZmZmYpIHtcbiAgICAgIG4gLz0gMHhmZmZmZmZmZjtcbiAgICAgIGhhc2ggXj0gbjtcbiAgICB9XG4gICAgcmV0dXJuIHNtaShoYXNoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhY2hlZEhhc2hTdHJpbmcoc3RyaW5nKSB7XG4gICAgdmFyIGhhc2hlZCA9IHN0cmluZ0hhc2hDYWNoZVtzdHJpbmddO1xuICAgIGlmIChoYXNoZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaGFzaGVkID0gaGFzaFN0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKFNUUklOR19IQVNIX0NBQ0hFX1NJWkUgPT09IFNUUklOR19IQVNIX0NBQ0hFX01BWF9TSVpFKSB7XG4gICAgICAgIFNUUklOR19IQVNIX0NBQ0hFX1NJWkUgPSAwO1xuICAgICAgICBzdHJpbmdIYXNoQ2FjaGUgPSB7fTtcbiAgICAgIH1cbiAgICAgIFNUUklOR19IQVNIX0NBQ0hFX1NJWkUrKztcbiAgICAgIHN0cmluZ0hhc2hDYWNoZVtzdHJpbmddID0gaGFzaGVkO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaGVkO1xuICB9XG5cbiAgLy8gaHR0cDovL2pzcGVyZi5jb20vaGFzaGluZy1zdHJpbmdzXG4gIGZ1bmN0aW9uIGhhc2hTdHJpbmcoc3RyaW5nKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgaGFzaCBmcm9tIEpWTVxuICAgIC8vIFRoZSBoYXNoIGNvZGUgZm9yIGEgc3RyaW5nIGlzIGNvbXB1dGVkIGFzXG4gICAgLy8gc1swXSAqIDMxIF4gKG4gLSAxKSArIHNbMV0gKiAzMSBeIChuIC0gMikgKyAuLi4gKyBzW24gLSAxXSxcbiAgICAvLyB3aGVyZSBzW2ldIGlzIHRoZSBpdGggY2hhcmFjdGVyIG9mIHRoZSBzdHJpbmcgYW5kIG4gaXMgdGhlIGxlbmd0aCBvZlxuICAgIC8vIHRoZSBzdHJpbmcuIFdlIFwibW9kXCIgdGhlIHJlc3VsdCB0byBtYWtlIGl0IGJldHdlZW4gMCAoaW5jbHVzaXZlKSBhbmQgMl4zMVxuICAgIC8vIChleGNsdXNpdmUpIGJ5IGRyb3BwaW5nIGhpZ2ggYml0cy5cbiAgICB2YXIgaGFzaGVkID0gMDtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgc3RyaW5nLmxlbmd0aDsgaWkrKykge1xuICAgICAgaGFzaGVkID0gKDMxICogaGFzaGVkICsgc3RyaW5nLmNoYXJDb2RlQXQoaWkpKSB8IDA7XG4gICAgfVxuICAgIHJldHVybiBzbWkoaGFzaGVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc2hKU09iaihvYmopIHtcbiAgICB2YXIgaGFzaGVkO1xuICAgIGlmICh1c2luZ1dlYWtNYXApIHtcbiAgICAgIGhhc2hlZCA9IHdlYWtNYXAuZ2V0KG9iaik7XG4gICAgICBpZiAoaGFzaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGhhc2hlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNoZWQgPSBvYmpbVUlEX0hBU0hfS0VZXTtcbiAgICBpZiAoaGFzaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBoYXNoZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgaGFzaGVkID0gb2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlICYmIG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZVtVSURfSEFTSF9LRVldO1xuICAgICAgaWYgKGhhc2hlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBoYXNoZWQ7XG4gICAgICB9XG5cbiAgICAgIGhhc2hlZCA9IGdldElFTm9kZUhhc2gob2JqKTtcbiAgICAgIGlmIChoYXNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaGFzaGVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhhc2hlZCA9ICsrb2JqSGFzaFVJRDtcbiAgICBpZiAob2JqSGFzaFVJRCAmIDB4NDAwMDAwMDApIHtcbiAgICAgIG9iakhhc2hVSUQgPSAwO1xuICAgIH1cblxuICAgIGlmICh1c2luZ1dlYWtNYXApIHtcbiAgICAgIHdlYWtNYXAuc2V0KG9iaiwgaGFzaGVkKTtcbiAgICB9IGVsc2UgaWYgKGlzRXh0ZW5zaWJsZSAhPT0gdW5kZWZpbmVkICYmIGlzRXh0ZW5zaWJsZShvYmopID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb24tZXh0ZW5zaWJsZSBvYmplY3RzIGFyZSBub3QgYWxsb3dlZCBhcyBrZXlzLicpO1xuICAgIH0gZWxzZSBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIFVJRF9IQVNIX0tFWSwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogaGFzaGVkLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBvYmoucHJvcGVydHlJc0VudW1lcmFibGUgPT09IG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVcbiAgICApIHtcbiAgICAgIC8vIFNpbmNlIHdlIGNhbid0IGRlZmluZSBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IG9uIHRoZSBvYmplY3RcbiAgICAgIC8vIHdlJ2xsIGhpamFjayBvbmUgb2YgdGhlIGxlc3MtdXNlZCBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIHRvXG4gICAgICAvLyBzYXZlIG91ciBoYXNoIG9uIGl0LiBTaW5jZSB0aGlzIGlzIGEgZnVuY3Rpb24gaXQgd2lsbCBub3Qgc2hvdyB1cCBpblxuICAgICAgLy8gYEpTT04uc3RyaW5naWZ5YCB3aGljaCBpcyB3aGF0IHdlIHdhbnQuXG4gICAgICBvYmoucHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5hcHBseShcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIGFyZ3VtZW50c1xuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZVtVSURfSEFTSF9LRVldID0gaGFzaGVkO1xuICAgIH0gZWxzZSBpZiAob2JqLm5vZGVUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgY291bGRuJ3QgZ2V0IHRoZSBJRSBgdW5pcXVlSURgIHRvIHVzZSBhcyBhIGhhc2hcbiAgICAgIC8vIGFuZCB3ZSBjb3VsZG4ndCB1c2UgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSB0byBleHBsb2l0IHRoZVxuICAgICAgLy8gZG9udEVudW0gYnVnIHNvIHdlIHNpbXBseSBhZGQgdGhlIGBVSURfSEFTSF9LRVlgIG9uIHRoZSBub2RlXG4gICAgICAvLyBpdHNlbGYuXG4gICAgICBvYmpbVUlEX0hBU0hfS0VZXSA9IGhhc2hlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gc2V0IGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgb24gb2JqZWN0LicpO1xuICAgIH1cblxuICAgIHJldHVybiBoYXNoZWQ7XG4gIH1cblxuICAvLyBHZXQgcmVmZXJlbmNlcyB0byBFUzUgb2JqZWN0IG1ldGhvZHMuXG4gIHZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xuXG4gIC8vIFRydWUgaWYgT2JqZWN0LmRlZmluZVByb3BlcnR5IHdvcmtzIGFzIGV4cGVjdGVkLiBJRTggZmFpbHMgdGhpcyB0ZXN0LlxuICB2YXIgY2FuRGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdAJywge30pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSkoKTtcblxuICAvLyBJRSBoYXMgYSBgdW5pcXVlSURgIHByb3BlcnR5IG9uIERPTSBub2Rlcy4gV2UgY2FuIGNvbnN0cnVjdCB0aGUgaGFzaCBmcm9tIGl0XG4gIC8vIGFuZCBhdm9pZCBtZW1vcnkgbGVha3MgZnJvbSB0aGUgSUUgY2xvbmVOb2RlIGJ1Zy5cbiAgZnVuY3Rpb24gZ2V0SUVOb2RlSGFzaChub2RlKSB7XG4gICAgaWYgKG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA+IDApIHtcbiAgICAgIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgICAgICBjYXNlIDE6IC8vIEVsZW1lbnRcbiAgICAgICAgICByZXR1cm4gbm9kZS51bmlxdWVJRDtcbiAgICAgICAgY2FzZSA5OiAvLyBEb2N1bWVudFxuICAgICAgICAgIHJldHVybiBub2RlLmRvY3VtZW50RWxlbWVudCAmJiBub2RlLmRvY3VtZW50RWxlbWVudC51bmlxdWVJRDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiBwb3NzaWJsZSwgdXNlIGEgV2Vha01hcC5cbiAgdmFyIHVzaW5nV2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nO1xuICB2YXIgd2Vha01hcDtcbiAgaWYgKHVzaW5nV2Vha01hcCkge1xuICAgIHdlYWtNYXAgPSBuZXcgV2Vha01hcCgpO1xuICB9XG5cbiAgdmFyIG9iakhhc2hVSUQgPSAwO1xuXG4gIHZhciBVSURfSEFTSF9LRVkgPSAnX19pbW11dGFibGVoYXNoX18nO1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFVJRF9IQVNIX0tFWSA9IFN5bWJvbChVSURfSEFTSF9LRVkpO1xuICB9XG5cbiAgdmFyIFNUUklOR19IQVNIX0NBQ0hFX01JTl9TVFJMRU4gPSAxNjtcbiAgdmFyIFNUUklOR19IQVNIX0NBQ0hFX01BWF9TSVpFID0gMjU1O1xuICB2YXIgU1RSSU5HX0hBU0hfQ0FDSEVfU0laRSA9IDA7XG4gIHZhciBzdHJpbmdIYXNoQ2FjaGUgPSB7fTtcblxuICB2YXIgVG9LZXllZFNlcXVlbmNlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoS2V5ZWRTZXEpIHtcbiAgICBmdW5jdGlvbiBUb0tleWVkU2VxdWVuY2UoaW5kZXhlZCwgdXNlS2V5cykge1xuICAgICAgdGhpcy5faXRlciA9IGluZGV4ZWQ7XG4gICAgICB0aGlzLl91c2VLZXlzID0gdXNlS2V5cztcbiAgICAgIHRoaXMuc2l6ZSA9IGluZGV4ZWQuc2l6ZTtcbiAgICB9XG5cbiAgICBpZiAoIEtleWVkU2VxICkgVG9LZXllZFNlcXVlbmNlLl9fcHJvdG9fXyA9IEtleWVkU2VxO1xuICAgIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBLZXllZFNlcSAmJiBLZXllZFNlcS5wcm90b3R5cGUgKTtcbiAgICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9LZXllZFNlcXVlbmNlO1xuXG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLmdldChrZXksIG5vdFNldFZhbHVlKTtcbiAgICB9O1xuXG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIuaGFzKGtleSk7XG4gICAgfTtcblxuICAgIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUudmFsdWVTZXEgPSBmdW5jdGlvbiB2YWx1ZVNlcSAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci52YWx1ZVNlcSgpO1xuICAgIH07XG5cbiAgICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB2YXIgcmV2ZXJzZWRTZXF1ZW5jZSA9IHJldmVyc2VGYWN0b3J5KHRoaXMsIHRydWUpO1xuICAgICAgaWYgKCF0aGlzLl91c2VLZXlzKSB7XG4gICAgICAgIHJldmVyc2VkU2VxdWVuY2UudmFsdWVTZXEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuX2l0ZXIudG9TZXEoKS5yZXZlcnNlKCk7IH07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV2ZXJzZWRTZXF1ZW5jZTtcbiAgICB9O1xuXG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKG1hcHBlciwgY29udGV4dCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHZhciBtYXBwZWRTZXF1ZW5jZSA9IG1hcEZhY3RvcnkodGhpcywgbWFwcGVyLCBjb250ZXh0KTtcbiAgICAgIGlmICghdGhpcy5fdXNlS2V5cykge1xuICAgICAgICBtYXBwZWRTZXF1ZW5jZS52YWx1ZVNlcSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5faXRlci50b1NlcSgpLm1hcChtYXBwZXIsIGNvbnRleHQpOyB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcHBlZFNlcXVlbmNlO1xuICAgIH07XG5cbiAgICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5faXRlci5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIGZuKHYsIGssIHRoaXMkMSk7IH0sIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICByZXR1cm4gVG9LZXllZFNlcXVlbmNlO1xuICB9KEtleWVkU2VxKSk7XG4gIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGVbSVNfT1JERVJFRF9TWU1CT0xdID0gdHJ1ZTtcblxuICB2YXIgVG9JbmRleGVkU2VxdWVuY2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbmRleGVkU2VxKSB7XG4gICAgZnVuY3Rpb24gVG9JbmRleGVkU2VxdWVuY2UoaXRlcikge1xuICAgICAgdGhpcy5faXRlciA9IGl0ZXI7XG4gICAgICB0aGlzLnNpemUgPSBpdGVyLnNpemU7XG4gICAgfVxuXG4gICAgaWYgKCBJbmRleGVkU2VxICkgVG9JbmRleGVkU2VxdWVuY2UuX19wcm90b19fID0gSW5kZXhlZFNlcTtcbiAgICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkU2VxICYmIEluZGV4ZWRTZXEucHJvdG90eXBlICk7XG4gICAgVG9JbmRleGVkU2VxdWVuY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9JbmRleGVkU2VxdWVuY2U7XG5cbiAgICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLmluY2x1ZGVzKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgVG9JbmRleGVkU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICByZXZlcnNlICYmIGVuc3VyZVNpemUodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci5fX2l0ZXJhdGUoXG4gICAgICAgIGZ1bmN0aW9uICh2KSB7IHJldHVybiBmbih2LCByZXZlcnNlID8gdGhpcyQxLnNpemUgLSArK2kgOiBpKyssIHRoaXMkMSk7IH0sXG4gICAgICAgIHJldmVyc2VcbiAgICAgICk7XG4gICAgfTtcblxuICAgIFRvSW5kZXhlZFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX2l0ZXIuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUywgcmV2ZXJzZSk7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICByZXZlcnNlICYmIGVuc3VyZVNpemUodGhpcyk7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiBzdGVwLmRvbmVcbiAgICAgICAgICA/IHN0ZXBcbiAgICAgICAgICA6IGl0ZXJhdG9yVmFsdWUoXG4gICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIHJldmVyc2UgPyB0aGlzJDEuc2l6ZSAtICsraSA6IGkrKyxcbiAgICAgICAgICAgICAgc3RlcC52YWx1ZSxcbiAgICAgICAgICAgICAgc3RlcFxuICAgICAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gVG9JbmRleGVkU2VxdWVuY2U7XG4gIH0oSW5kZXhlZFNlcSkpO1xuXG4gIHZhciBUb1NldFNlcXVlbmNlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoU2V0U2VxKSB7XG4gICAgZnVuY3Rpb24gVG9TZXRTZXF1ZW5jZShpdGVyKSB7XG4gICAgICB0aGlzLl9pdGVyID0gaXRlcjtcbiAgICAgIHRoaXMuc2l6ZSA9IGl0ZXIuc2l6ZTtcbiAgICB9XG5cbiAgICBpZiAoIFNldFNlcSApIFRvU2V0U2VxdWVuY2UuX19wcm90b19fID0gU2V0U2VxO1xuICAgIFRvU2V0U2VxdWVuY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2V0U2VxICYmIFNldFNlcS5wcm90b3R5cGUgKTtcbiAgICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRvU2V0U2VxdWVuY2U7XG5cbiAgICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIuaW5jbHVkZXMoa2V5KTtcbiAgICB9O1xuXG4gICAgVG9TZXRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLl9faXRlcmF0ZShmdW5jdGlvbiAodikgeyByZXR1cm4gZm4odiwgdiwgdGhpcyQxKTsgfSwgcmV2ZXJzZSk7XG4gICAgfTtcblxuICAgIFRvU2V0U2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9pdGVyLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMsIHJldmVyc2UpO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICByZXR1cm4gc3RlcC5kb25lXG4gICAgICAgICAgPyBzdGVwXG4gICAgICAgICAgOiBpdGVyYXRvclZhbHVlKHR5cGUsIHN0ZXAudmFsdWUsIHN0ZXAudmFsdWUsIHN0ZXApO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBUb1NldFNlcXVlbmNlO1xuICB9KFNldFNlcSkpO1xuXG4gIHZhciBGcm9tRW50cmllc1NlcXVlbmNlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoS2V5ZWRTZXEpIHtcbiAgICBmdW5jdGlvbiBGcm9tRW50cmllc1NlcXVlbmNlKGVudHJpZXMpIHtcbiAgICAgIHRoaXMuX2l0ZXIgPSBlbnRyaWVzO1xuICAgICAgdGhpcy5zaXplID0gZW50cmllcy5zaXplO1xuICAgIH1cblxuICAgIGlmICggS2V5ZWRTZXEgKSBGcm9tRW50cmllc1NlcXVlbmNlLl9fcHJvdG9fXyA9IEtleWVkU2VxO1xuICAgIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggS2V5ZWRTZXEgJiYgS2V5ZWRTZXEucHJvdG90eXBlICk7XG4gICAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGcm9tRW50cmllc1NlcXVlbmNlO1xuXG4gICAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuZW50cnlTZXEgPSBmdW5jdGlvbiBlbnRyeVNlcSAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci50b1NlcSgpO1xuICAgIH07XG5cbiAgICBGcm9tRW50cmllc1NlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIuX19pdGVyYXRlKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAvLyBDaGVjayBpZiBlbnRyeSBleGlzdHMgZmlyc3Qgc28gYXJyYXkgYWNjZXNzIGRvZXNuJ3QgdGhyb3cgZm9yIGhvbGVzXG4gICAgICAgIC8vIGluIHRoZSBwYXJlbnQgaXRlcmF0aW9uLlxuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB2YXIgaW5kZXhlZENvbGxlY3Rpb24gPSBpc0NvbGxlY3Rpb24oZW50cnkpO1xuICAgICAgICAgIHJldHVybiBmbihcbiAgICAgICAgICAgIGluZGV4ZWRDb2xsZWN0aW9uID8gZW50cnkuZ2V0KDEpIDogZW50cnlbMV0sXG4gICAgICAgICAgICBpbmRleGVkQ29sbGVjdGlvbiA/IGVudHJ5LmdldCgwKSA6IGVudHJ5WzBdLFxuICAgICAgICAgICAgdGhpcyQxXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSwgcmV2ZXJzZSk7XG4gICAgfTtcblxuICAgIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9pdGVyLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMsIHJldmVyc2UpO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgZW50cnkgZXhpc3RzIGZpcnN0IHNvIGFycmF5IGFjY2VzcyBkb2Vzbid0IHRocm93IGZvciBob2xlc1xuICAgICAgICAgIC8vIGluIHRoZSBwYXJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFbnRyeShlbnRyeSk7XG4gICAgICAgICAgICB2YXIgaW5kZXhlZENvbGxlY3Rpb24gPSBpc0NvbGxlY3Rpb24oZW50cnkpO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUoXG4gICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIGluZGV4ZWRDb2xsZWN0aW9uID8gZW50cnkuZ2V0KDApIDogZW50cnlbMF0sXG4gICAgICAgICAgICAgIGluZGV4ZWRDb2xsZWN0aW9uID8gZW50cnkuZ2V0KDEpIDogZW50cnlbMV0sXG4gICAgICAgICAgICAgIHN0ZXBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEZyb21FbnRyaWVzU2VxdWVuY2U7XG4gIH0oS2V5ZWRTZXEpKTtcblxuICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUuY2FjaGVSZXN1bHQgPVxuICAgIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUuY2FjaGVSZXN1bHQgPVxuICAgIFRvU2V0U2VxdWVuY2UucHJvdG90eXBlLmNhY2hlUmVzdWx0ID1cbiAgICBGcm9tRW50cmllc1NlcXVlbmNlLnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9XG4gICAgICBjYWNoZVJlc3VsdFRocm91Z2g7XG5cbiAgZnVuY3Rpb24gZmxpcEZhY3RvcnkoY29sbGVjdGlvbikge1xuICAgIHZhciBmbGlwU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gICAgZmxpcFNlcXVlbmNlLl9pdGVyID0gY29sbGVjdGlvbjtcbiAgICBmbGlwU2VxdWVuY2Uuc2l6ZSA9IGNvbGxlY3Rpb24uc2l6ZTtcbiAgICBmbGlwU2VxdWVuY2UuZmxpcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbGxlY3Rpb247IH07XG4gICAgZmxpcFNlcXVlbmNlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmV2ZXJzZWRTZXF1ZW5jZSA9IGNvbGxlY3Rpb24ucmV2ZXJzZS5hcHBseSh0aGlzKTsgLy8gc3VwZXIucmV2ZXJzZSgpXG4gICAgICByZXZlcnNlZFNlcXVlbmNlLmZsaXAgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2xsZWN0aW9uLnJldmVyc2UoKTsgfTtcbiAgICAgIHJldHVybiByZXZlcnNlZFNlcXVlbmNlO1xuICAgIH07XG4gICAgZmxpcFNlcXVlbmNlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGNvbGxlY3Rpb24uaW5jbHVkZXMoa2V5KTsgfTtcbiAgICBmbGlwU2VxdWVuY2UuaW5jbHVkZXMgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBjb2xsZWN0aW9uLmhhcyhrZXkpOyB9O1xuICAgIGZsaXBTZXF1ZW5jZS5jYWNoZVJlc3VsdCA9IGNhY2hlUmVzdWx0VGhyb3VnaDtcbiAgICBmbGlwU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIGZuKGssIHYsIHRoaXMkMSkgIT09IGZhbHNlOyB9LCByZXZlcnNlKTtcbiAgICB9O1xuICAgIGZsaXBTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbiAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHR5cGUgPT09IElURVJBVEVfRU5UUklFUykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmICghc3RlcC5kb25lKSB7XG4gICAgICAgICAgICB2YXIgayA9IHN0ZXAudmFsdWVbMF07XG4gICAgICAgICAgICBzdGVwLnZhbHVlWzBdID0gc3RlcC52YWx1ZVsxXTtcbiAgICAgICAgICAgIHN0ZXAudmFsdWVbMV0gPSBrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKFxuICAgICAgICB0eXBlID09PSBJVEVSQVRFX1ZBTFVFUyA/IElURVJBVEVfS0VZUyA6IElURVJBVEVfVkFMVUVTLFxuICAgICAgICByZXZlcnNlXG4gICAgICApO1xuICAgIH07XG4gICAgcmV0dXJuIGZsaXBTZXF1ZW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcEZhY3RvcnkoY29sbGVjdGlvbiwgbWFwcGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIG1hcHBlZFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGNvbGxlY3Rpb24pO1xuICAgIG1hcHBlZFNlcXVlbmNlLnNpemUgPSBjb2xsZWN0aW9uLnNpemU7XG4gICAgbWFwcGVkU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gY29sbGVjdGlvbi5oYXMoa2V5KTsgfTtcbiAgICBtYXBwZWRTZXF1ZW5jZS5nZXQgPSBmdW5jdGlvbiAoa2V5LCBub3RTZXRWYWx1ZSkge1xuICAgICAgdmFyIHYgPSBjb2xsZWN0aW9uLmdldChrZXksIE5PVF9TRVQpO1xuICAgICAgcmV0dXJuIHYgPT09IE5PVF9TRVRcbiAgICAgICAgPyBub3RTZXRWYWx1ZVxuICAgICAgICA6IG1hcHBlci5jYWxsKGNvbnRleHQsIHYsIGtleSwgY29sbGVjdGlvbik7XG4gICAgfTtcbiAgICBtYXBwZWRTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLl9faXRlcmF0ZShcbiAgICAgICAgZnVuY3Rpb24gKHYsIGssIGMpIHsgcmV0dXJuIGZuKG1hcHBlci5jYWxsKGNvbnRleHQsIHYsIGssIGMpLCBrLCB0aGlzJDEpICE9PSBmYWxzZTsgfSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgKTtcbiAgICB9O1xuICAgIG1hcHBlZFNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCByZXZlcnNlKTtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgIHZhciBrZXkgPSBlbnRyeVswXTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgbWFwcGVyLmNhbGwoY29udGV4dCwgZW50cnlbMV0sIGtleSwgY29sbGVjdGlvbiksXG4gICAgICAgICAgc3RlcFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gbWFwcGVkU2VxdWVuY2U7XG4gIH1cblxuICBmdW5jdGlvbiByZXZlcnNlRmFjdG9yeShjb2xsZWN0aW9uLCB1c2VLZXlzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmV2ZXJzZWRTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcbiAgICByZXZlcnNlZFNlcXVlbmNlLl9pdGVyID0gY29sbGVjdGlvbjtcbiAgICByZXZlcnNlZFNlcXVlbmNlLnNpemUgPSBjb2xsZWN0aW9uLnNpemU7XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29sbGVjdGlvbjsgfTtcbiAgICBpZiAoY29sbGVjdGlvbi5mbGlwKSB7XG4gICAgICByZXZlcnNlZFNlcXVlbmNlLmZsaXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmbGlwU2VxdWVuY2UgPSBmbGlwRmFjdG9yeShjb2xsZWN0aW9uKTtcbiAgICAgICAgZmxpcFNlcXVlbmNlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2xsZWN0aW9uLmZsaXAoKTsgfTtcbiAgICAgICAgcmV0dXJuIGZsaXBTZXF1ZW5jZTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldmVyc2VkU2VxdWVuY2UuZ2V0ID0gZnVuY3Rpb24gKGtleSwgbm90U2V0VmFsdWUpIHsgcmV0dXJuIGNvbGxlY3Rpb24uZ2V0KHVzZUtleXMgPyBrZXkgOiAtMSAtIGtleSwgbm90U2V0VmFsdWUpOyB9O1xuICAgIHJldmVyc2VkU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gY29sbGVjdGlvbi5oYXModXNlS2V5cyA/IGtleSA6IC0xIC0ga2V5KTsgfTtcbiAgICByZXZlcnNlZFNlcXVlbmNlLmluY2x1ZGVzID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBjb2xsZWN0aW9uLmluY2x1ZGVzKHZhbHVlKTsgfTtcbiAgICByZXZlcnNlZFNlcXVlbmNlLmNhY2hlUmVzdWx0ID0gY2FjaGVSZXN1bHRUaHJvdWdoO1xuICAgIHJldmVyc2VkU2VxdWVuY2UuX19pdGVyYXRlID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgcmV2ZXJzZSAmJiBlbnN1cmVTaXplKGNvbGxlY3Rpb24pO1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uX19pdGVyYXRlKFxuICAgICAgICBmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gZm4odiwgdXNlS2V5cyA/IGsgOiByZXZlcnNlID8gdGhpcyQxLnNpemUgLSArK2kgOiBpKyssIHRoaXMkMSk7IH0sXG4gICAgICAgICFyZXZlcnNlXG4gICAgICApO1xuICAgIH07XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHJldmVyc2UgJiYgZW5zdXJlU2l6ZShjb2xsZWN0aW9uKTtcbiAgICAgIHZhciBpdGVyYXRvciA9IGNvbGxlY3Rpb24uX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMsICFyZXZlcnNlKTtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgdXNlS2V5cyA/IGVudHJ5WzBdIDogcmV2ZXJzZSA/IHRoaXMkMS5zaXplIC0gKytpIDogaSsrLFxuICAgICAgICAgIGVudHJ5WzFdLFxuICAgICAgICAgIHN0ZXBcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHJldmVyc2VkU2VxdWVuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBmaWx0ZXJGYWN0b3J5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgY29udGV4dCwgdXNlS2V5cykge1xuICAgIHZhciBmaWx0ZXJTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcbiAgICBpZiAodXNlS2V5cykge1xuICAgICAgZmlsdGVyU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdiA9IGNvbGxlY3Rpb24uZ2V0KGtleSwgTk9UX1NFVCk7XG4gICAgICAgIHJldHVybiB2ICE9PSBOT1RfU0VUICYmICEhcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgICBmaWx0ZXJTZXF1ZW5jZS5nZXQgPSBmdW5jdGlvbiAoa2V5LCBub3RTZXRWYWx1ZSkge1xuICAgICAgICB2YXIgdiA9IGNvbGxlY3Rpb24uZ2V0KGtleSwgTk9UX1NFVCk7XG4gICAgICAgIHJldHVybiB2ICE9PSBOT1RfU0VUICYmIHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGtleSwgY29sbGVjdGlvbilcbiAgICAgICAgICA/IHZcbiAgICAgICAgICA6IG5vdFNldFZhbHVlO1xuICAgICAgfTtcbiAgICB9XG4gICAgZmlsdGVyU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICBjb2xsZWN0aW9uLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaywgYykge1xuICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgYykpIHtcbiAgICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgICAgcmV0dXJuIGZuKHYsIHVzZUtleXMgPyBrIDogaXRlcmF0aW9ucyAtIDEsIHRoaXMkMSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHJldmVyc2UpO1xuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcbiAgICBmaWx0ZXJTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbiAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIga2V5ID0gZW50cnlbMF07XG4gICAgICAgICAgdmFyIHZhbHVlID0gZW50cnlbMV07XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCB1c2VLZXlzID8ga2V5IDogaXRlcmF0aW9ucysrLCB2YWx1ZSwgc3RlcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBmaWx0ZXJTZXF1ZW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvdW50QnlGYWN0b3J5KGNvbGxlY3Rpb24sIGdyb3VwZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgZ3JvdXBzID0gTWFwKCkuYXNNdXRhYmxlKCk7XG4gICAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgIGdyb3Vwcy51cGRhdGUoZ3JvdXBlci5jYWxsKGNvbnRleHQsIHYsIGssIGNvbGxlY3Rpb24pLCAwLCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSArIDE7IH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBncm91cHMuYXNJbW11dGFibGUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdyb3VwQnlGYWN0b3J5KGNvbGxlY3Rpb24sIGdyb3VwZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgaXNLZXllZEl0ZXIgPSBpc0tleWVkKGNvbGxlY3Rpb24pO1xuICAgIHZhciBncm91cHMgPSAoaXNPcmRlcmVkKGNvbGxlY3Rpb24pID8gT3JkZXJlZE1hcCgpIDogTWFwKCkpLmFzTXV0YWJsZSgpO1xuICAgIGNvbGxlY3Rpb24uX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICBncm91cHMudXBkYXRlKFxuICAgICAgICBncm91cGVyLmNhbGwoY29udGV4dCwgdiwgaywgY29sbGVjdGlvbiksXG4gICAgICAgIGZ1bmN0aW9uIChhKSB7IHJldHVybiAoKGEgPSBhIHx8IFtdKSwgYS5wdXNoKGlzS2V5ZWRJdGVyID8gW2ssIHZdIDogdiksIGEpOyB9XG4gICAgICApO1xuICAgIH0pO1xuICAgIHZhciBjb2VyY2UgPSBjb2xsZWN0aW9uQ2xhc3MoY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIGdyb3Vwcy5tYXAoZnVuY3Rpb24gKGFycikgeyByZXR1cm4gcmVpZnkoY29sbGVjdGlvbiwgY29lcmNlKGFycikpOyB9KS5hc0ltbXV0YWJsZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2xpY2VGYWN0b3J5KGNvbGxlY3Rpb24sIGJlZ2luLCBlbmQsIHVzZUtleXMpIHtcbiAgICB2YXIgb3JpZ2luYWxTaXplID0gY29sbGVjdGlvbi5zaXplO1xuXG4gICAgaWYgKHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgb3JpZ2luYWxTaXplKSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuXG4gICAgdmFyIHJlc29sdmVkQmVnaW4gPSByZXNvbHZlQmVnaW4oYmVnaW4sIG9yaWdpbmFsU2l6ZSk7XG4gICAgdmFyIHJlc29sdmVkRW5kID0gcmVzb2x2ZUVuZChlbmQsIG9yaWdpbmFsU2l6ZSk7XG5cbiAgICAvLyBiZWdpbiBvciBlbmQgd2lsbCBiZSBOYU4gaWYgdGhleSB3ZXJlIHByb3ZpZGVkIGFzIG5lZ2F0aXZlIG51bWJlcnMgYW5kXG4gICAgLy8gdGhpcyBjb2xsZWN0aW9uJ3Mgc2l6ZSBpcyB1bmtub3duLiBJbiB0aGF0IGNhc2UsIGNhY2hlIGZpcnN0IHNvIHRoZXJlIGlzXG4gICAgLy8gYSBrbm93biBzaXplIGFuZCB0aGVzZSBkbyBub3QgcmVzb2x2ZSB0byBOYU4uXG4gICAgaWYgKHJlc29sdmVkQmVnaW4gIT09IHJlc29sdmVkQmVnaW4gfHwgcmVzb2x2ZWRFbmQgIT09IHJlc29sdmVkRW5kKSB7XG4gICAgICByZXR1cm4gc2xpY2VGYWN0b3J5KGNvbGxlY3Rpb24udG9TZXEoKS5jYWNoZVJlc3VsdCgpLCBiZWdpbiwgZW5kLCB1c2VLZXlzKTtcbiAgICB9XG5cbiAgICAvLyBOb3RlOiByZXNvbHZlZEVuZCBpcyB1bmRlZmluZWQgd2hlbiB0aGUgb3JpZ2luYWwgc2VxdWVuY2UncyBsZW5ndGggaXNcbiAgICAvLyB1bmtub3duIGFuZCB0aGlzIHNsaWNlIGRpZCBub3Qgc3VwcGx5IGFuIGVuZCBhbmQgc2hvdWxkIGNvbnRhaW4gYWxsXG4gICAgLy8gZWxlbWVudHMgYWZ0ZXIgcmVzb2x2ZWRCZWdpbi5cbiAgICAvLyBJbiB0aGF0IGNhc2UsIHJlc29sdmVkU2l6ZSB3aWxsIGJlIE5hTiBhbmQgc2xpY2VTaXplIHdpbGwgcmVtYWluIHVuZGVmaW5lZC5cbiAgICB2YXIgcmVzb2x2ZWRTaXplID0gcmVzb2x2ZWRFbmQgLSByZXNvbHZlZEJlZ2luO1xuICAgIHZhciBzbGljZVNpemU7XG4gICAgaWYgKHJlc29sdmVkU2l6ZSA9PT0gcmVzb2x2ZWRTaXplKSB7XG4gICAgICBzbGljZVNpemUgPSByZXNvbHZlZFNpemUgPCAwID8gMCA6IHJlc29sdmVkU2l6ZTtcbiAgICB9XG5cbiAgICB2YXIgc2xpY2VTZXEgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG5cbiAgICAvLyBJZiBjb2xsZWN0aW9uLnNpemUgaXMgdW5kZWZpbmVkLCB0aGUgc2l6ZSBvZiB0aGUgcmVhbGl6ZWQgc2xpY2VTZXEgaXNcbiAgICAvLyB1bmtub3duIGF0IHRoaXMgcG9pbnQgdW5sZXNzIHRoZSBudW1iZXIgb2YgaXRlbXMgdG8gc2xpY2UgaXMgMFxuICAgIHNsaWNlU2VxLnNpemUgPVxuICAgICAgc2xpY2VTaXplID09PSAwID8gc2xpY2VTaXplIDogKGNvbGxlY3Rpb24uc2l6ZSAmJiBzbGljZVNpemUpIHx8IHVuZGVmaW5lZDtcblxuICAgIGlmICghdXNlS2V5cyAmJiBpc1NlcShjb2xsZWN0aW9uKSAmJiBzbGljZVNpemUgPj0gMCkge1xuICAgICAgc2xpY2VTZXEuZ2V0ID0gZnVuY3Rpb24gKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgICAgICBpbmRleCA9IHdyYXBJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4IDwgc2xpY2VTaXplXG4gICAgICAgICAgPyBjb2xsZWN0aW9uLmdldChpbmRleCArIHJlc29sdmVkQmVnaW4sIG5vdFNldFZhbHVlKVxuICAgICAgICAgIDogbm90U2V0VmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHNsaWNlU2VxLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgaWYgKHNsaWNlU2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBza2lwcGVkID0gMDtcbiAgICAgIHZhciBpc1NraXBwaW5nID0gdHJ1ZTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIGNvbGxlY3Rpb24uX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgIGlmICghKGlzU2tpcHBpbmcgJiYgKGlzU2tpcHBpbmcgPSBza2lwcGVkKysgPCByZXNvbHZlZEJlZ2luKSkpIHtcbiAgICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGZuKHYsIHVzZUtleXMgPyBrIDogaXRlcmF0aW9ucyAtIDEsIHRoaXMkMSkgIT09IGZhbHNlICYmXG4gICAgICAgICAgICBpdGVyYXRpb25zICE9PSBzbGljZVNpemVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG5cbiAgICBzbGljZVNlcS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbiAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHNsaWNlU2l6ZSAhPT0gMCAmJiByZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIC8vIERvbid0IGJvdGhlciBpbnN0YW50aWF0aW5nIHBhcmVudCBpdGVyYXRvciBpZiB0YWtpbmcgMC5cbiAgICAgIGlmIChzbGljZVNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihpdGVyYXRvckRvbmUpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgdmFyIHNraXBwZWQgPSAwO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlIChza2lwcGVkKysgPCByZXNvbHZlZEJlZ2luKSB7XG4gICAgICAgICAgaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgrK2l0ZXJhdGlvbnMgPiBzbGljZVNpemUpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmICh1c2VLZXlzIHx8IHR5cGUgPT09IElURVJBVEVfVkFMVUVTIHx8IHN0ZXAuZG9uZSkge1xuICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBJVEVSQVRFX0tFWVMpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zIC0gMSwgdW5kZWZpbmVkLCBzdGVwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zIC0gMSwgc3RlcC52YWx1ZVsxXSwgc3RlcCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHNsaWNlU2VxO1xuICB9XG5cbiAgZnVuY3Rpb24gdGFrZVdoaWxlRmFjdG9yeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgdGFrZVNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGNvbGxlY3Rpb24pO1xuICAgIHRha2VTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIGNvbGxlY3Rpb24uX19pdGVyYXRlKFxuICAgICAgICBmdW5jdGlvbiAodiwgaywgYykgeyByZXR1cm4gcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgYykgJiYgKytpdGVyYXRpb25zICYmIGZuKHYsIGssIHRoaXMkMSk7IH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuICAgIHRha2VTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbiAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRvciA9IGNvbGxlY3Rpb24uX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMsIHJldmVyc2UpO1xuICAgICAgdmFyIGl0ZXJhdGluZyA9IHRydWU7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpdGVyYXRpbmcpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICB2YXIgayA9IGVudHJ5WzBdO1xuICAgICAgICB2YXIgdiA9IGVudHJ5WzFdO1xuICAgICAgICBpZiAoIXByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIHRoaXMkMSkpIHtcbiAgICAgICAgICBpdGVyYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IElURVJBVEVfRU5UUklFUyA/IHN0ZXAgOiBpdGVyYXRvclZhbHVlKHR5cGUsIGssIHYsIHN0ZXApO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gdGFrZVNlcXVlbmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2tpcFdoaWxlRmFjdG9yeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGNvbnRleHQsIHVzZUtleXMpIHtcbiAgICB2YXIgc2tpcFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGNvbGxlY3Rpb24pO1xuICAgIHNraXBTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1NraXBwaW5nID0gdHJ1ZTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIGNvbGxlY3Rpb24uX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrLCBjKSB7XG4gICAgICAgIGlmICghKGlzU2tpcHBpbmcgJiYgKGlzU2tpcHBpbmcgPSBwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCBjKSkpKSB7XG4gICAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICAgIHJldHVybiBmbih2LCB1c2VLZXlzID8gayA6IGl0ZXJhdGlvbnMgLSAxLCB0aGlzJDEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG4gICAgc2tpcFNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG4gICAgICB2YXIgc2tpcHBpbmcgPSB0cnVlO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICB2YXIgaztcbiAgICAgICAgdmFyIHY7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICAgIGlmICh1c2VLZXlzIHx8IHR5cGUgPT09IElURVJBVEVfVkFMVUVTKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IElURVJBVEVfS0VZUykge1xuICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHVuZGVmaW5lZCwgc3RlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHN0ZXAudmFsdWVbMV0sIHN0ZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIGsgPSBlbnRyeVswXTtcbiAgICAgICAgICB2ID0gZW50cnlbMV07XG4gICAgICAgICAgc2tpcHBpbmcgJiYgKHNraXBwaW5nID0gcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgdGhpcyQxKSk7XG4gICAgICAgIH0gd2hpbGUgKHNraXBwaW5nKTtcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IElURVJBVEVfRU5UUklFUyA/IHN0ZXAgOiBpdGVyYXRvclZhbHVlKHR5cGUsIGssIHYsIHN0ZXApO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gc2tpcFNlcXVlbmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uY2F0RmFjdG9yeShjb2xsZWN0aW9uLCB2YWx1ZXMpIHtcbiAgICB2YXIgaXNLZXllZENvbGxlY3Rpb24gPSBpc0tleWVkKGNvbGxlY3Rpb24pO1xuICAgIHZhciBpdGVycyA9IFtjb2xsZWN0aW9uXVxuICAgICAgLmNvbmNhdCh2YWx1ZXMpXG4gICAgICAubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICghaXNDb2xsZWN0aW9uKHYpKSB7XG4gICAgICAgICAgdiA9IGlzS2V5ZWRDb2xsZWN0aW9uXG4gICAgICAgICAgICA/IGtleWVkU2VxRnJvbVZhbHVlKHYpXG4gICAgICAgICAgICA6IGluZGV4ZWRTZXFGcm9tVmFsdWUoQXJyYXkuaXNBcnJheSh2KSA/IHYgOiBbdl0pO1xuICAgICAgICB9IGVsc2UgaWYgKGlzS2V5ZWRDb2xsZWN0aW9uKSB7XG4gICAgICAgICAgdiA9IEtleWVkQ29sbGVjdGlvbih2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LnNpemUgIT09IDA7IH0pO1xuXG4gICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuXG4gICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIHNpbmdsZXRvbiA9IGl0ZXJzWzBdO1xuICAgICAgaWYgKFxuICAgICAgICBzaW5nbGV0b24gPT09IGNvbGxlY3Rpb24gfHxcbiAgICAgICAgKGlzS2V5ZWRDb2xsZWN0aW9uICYmIGlzS2V5ZWQoc2luZ2xldG9uKSkgfHxcbiAgICAgICAgKGlzSW5kZXhlZChjb2xsZWN0aW9uKSAmJiBpc0luZGV4ZWQoc2luZ2xldG9uKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gc2luZ2xldG9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjb25jYXRTZXEgPSBuZXcgQXJyYXlTZXEoaXRlcnMpO1xuICAgIGlmIChpc0tleWVkQ29sbGVjdGlvbikge1xuICAgICAgY29uY2F0U2VxID0gY29uY2F0U2VxLnRvS2V5ZWRTZXEoKTtcbiAgICB9IGVsc2UgaWYgKCFpc0luZGV4ZWQoY29sbGVjdGlvbikpIHtcbiAgICAgIGNvbmNhdFNlcSA9IGNvbmNhdFNlcS50b1NldFNlcSgpO1xuICAgIH1cbiAgICBjb25jYXRTZXEgPSBjb25jYXRTZXEuZmxhdHRlbih0cnVlKTtcbiAgICBjb25jYXRTZXEuc2l6ZSA9IGl0ZXJzLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBzZXEpIHtcbiAgICAgIGlmIChzdW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgc2l6ZSA9IHNlcS5zaXplO1xuICAgICAgICBpZiAoc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHN1bSArIHNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCAwKTtcbiAgICByZXR1cm4gY29uY2F0U2VxO1xuICB9XG5cbiAgZnVuY3Rpb24gZmxhdHRlbkZhY3RvcnkoY29sbGVjdGlvbiwgZGVwdGgsIHVzZUtleXMpIHtcbiAgICB2YXIgZmxhdFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGNvbGxlY3Rpb24pO1xuICAgIGZsYXRTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIHN0b3BwZWQgPSBmYWxzZTtcbiAgICAgIGZ1bmN0aW9uIGZsYXREZWVwKGl0ZXIsIGN1cnJlbnREZXB0aCkge1xuICAgICAgICBpdGVyLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykge1xuICAgICAgICAgIGlmICgoIWRlcHRoIHx8IGN1cnJlbnREZXB0aCA8IGRlcHRoKSAmJiBpc0NvbGxlY3Rpb24odikpIHtcbiAgICAgICAgICAgIGZsYXREZWVwKHYsIGN1cnJlbnREZXB0aCArIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgICAgICBpZiAoZm4odiwgdXNlS2V5cyA/IGsgOiBpdGVyYXRpb25zIC0gMSwgZmxhdFNlcXVlbmNlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAhc3RvcHBlZDtcbiAgICAgICAgfSwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICBmbGF0RGVlcChjb2xsZWN0aW9uLCAwKTtcbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG4gICAgZmxhdFNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAoaXRlcmF0b3IpIHtcbiAgICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoc3RlcC5kb25lICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaXRlcmF0b3IgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdiA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IElURVJBVEVfRU5UUklFUykge1xuICAgICAgICAgICAgdiA9IHZbMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgoIWRlcHRoIHx8IHN0YWNrLmxlbmd0aCA8IGRlcHRoKSAmJiBpc0NvbGxlY3Rpb24odikpIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goaXRlcmF0b3IpO1xuICAgICAgICAgICAgaXRlcmF0b3IgPSB2Ll9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VLZXlzID8gc3RlcCA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCB2LCBzdGVwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gZmxhdFNlcXVlbmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZmxhdE1hcEZhY3RvcnkoY29sbGVjdGlvbiwgbWFwcGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIGNvZXJjZSA9IGNvbGxlY3Rpb25DbGFzcyhjb2xsZWN0aW9uKTtcbiAgICByZXR1cm4gY29sbGVjdGlvblxuICAgICAgLnRvU2VxKClcbiAgICAgIC5tYXAoZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIGNvZXJjZShtYXBwZXIuY2FsbChjb250ZXh0LCB2LCBrLCBjb2xsZWN0aW9uKSk7IH0pXG4gICAgICAuZmxhdHRlbih0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVycG9zZUZhY3RvcnkoY29sbGVjdGlvbiwgc2VwYXJhdG9yKSB7XG4gICAgdmFyIGludGVycG9zZWRTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcbiAgICBpbnRlcnBvc2VkU2VxdWVuY2Uuc2l6ZSA9IGNvbGxlY3Rpb24uc2l6ZSAmJiBjb2xsZWN0aW9uLnNpemUgKiAyIC0gMTtcbiAgICBpbnRlcnBvc2VkU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICBjb2xsZWN0aW9uLl9faXRlcmF0ZShcbiAgICAgICAgZnVuY3Rpb24gKHYpIHsgcmV0dXJuICghaXRlcmF0aW9ucyB8fCBmbihzZXBhcmF0b3IsIGl0ZXJhdGlvbnMrKywgdGhpcyQxKSAhPT0gZmFsc2UpICYmXG4gICAgICAgICAgZm4odiwgaXRlcmF0aW9ucysrLCB0aGlzJDEpICE9PSBmYWxzZTsgfSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgKTtcbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG4gICAgaW50ZXJwb3NlZFNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMsIHJldmVyc2UpO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFzdGVwIHx8IGl0ZXJhdGlvbnMgJSAyKSB7XG4gICAgICAgICAgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZXJhdGlvbnMgJSAyXG4gICAgICAgICAgPyBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgc2VwYXJhdG9yKVxuICAgICAgICAgIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHN0ZXAudmFsdWUsIHN0ZXApO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gaW50ZXJwb3NlZFNlcXVlbmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gc29ydEZhY3RvcnkoY29sbGVjdGlvbiwgY29tcGFyYXRvciwgbWFwcGVyKSB7XG4gICAgaWYgKCFjb21wYXJhdG9yKSB7XG4gICAgICBjb21wYXJhdG9yID0gZGVmYXVsdENvbXBhcmF0b3I7XG4gICAgfVxuICAgIHZhciBpc0tleWVkQ29sbGVjdGlvbiA9IGlzS2V5ZWQoY29sbGVjdGlvbik7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgZW50cmllcyA9IGNvbGxlY3Rpb25cbiAgICAgIC50b1NlcSgpXG4gICAgICAubWFwKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBbaywgdiwgaW5kZXgrKywgbWFwcGVyID8gbWFwcGVyKHYsIGssIGNvbGxlY3Rpb24pIDogdl07IH0pXG4gICAgICAudmFsdWVTZXEoKVxuICAgICAgLnRvQXJyYXkoKTtcbiAgICBlbnRyaWVzXG4gICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gY29tcGFyYXRvcihhWzNdLCBiWzNdKSB8fCBhWzJdIC0gYlsyXTsgfSlcbiAgICAgIC5mb3JFYWNoKFxuICAgICAgICBpc0tleWVkQ29sbGVjdGlvblxuICAgICAgICAgID8gZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgICAgICAgICAgZW50cmllc1tpXS5sZW5ndGggPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIDogZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgICAgICAgICAgZW50cmllc1tpXSA9IHZbMV07XG4gICAgICAgICAgICB9XG4gICAgICApO1xuICAgIHJldHVybiBpc0tleWVkQ29sbGVjdGlvblxuICAgICAgPyBLZXllZFNlcShlbnRyaWVzKVxuICAgICAgOiBpc0luZGV4ZWQoY29sbGVjdGlvbilcbiAgICAgID8gSW5kZXhlZFNlcShlbnRyaWVzKVxuICAgICAgOiBTZXRTZXEoZW50cmllcyk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXhGYWN0b3J5KGNvbGxlY3Rpb24sIGNvbXBhcmF0b3IsIG1hcHBlcikge1xuICAgIGlmICghY29tcGFyYXRvcikge1xuICAgICAgY29tcGFyYXRvciA9IGRlZmF1bHRDb21wYXJhdG9yO1xuICAgIH1cbiAgICBpZiAobWFwcGVyKSB7XG4gICAgICB2YXIgZW50cnkgPSBjb2xsZWN0aW9uXG4gICAgICAgIC50b1NlcSgpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIFt2LCBtYXBwZXIodiwgaywgY29sbGVjdGlvbildOyB9KVxuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAobWF4Q29tcGFyZShjb21wYXJhdG9yLCBhWzFdLCBiWzFdKSA/IGIgOiBhKTsgfSk7XG4gICAgICByZXR1cm4gZW50cnkgJiYgZW50cnlbMF07XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gKG1heENvbXBhcmUoY29tcGFyYXRvciwgYSwgYikgPyBiIDogYSk7IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF4Q29tcGFyZShjb21wYXJhdG9yLCBhLCBiKSB7XG4gICAgdmFyIGNvbXAgPSBjb21wYXJhdG9yKGIsIGEpO1xuICAgIC8vIGIgaXMgY29uc2lkZXJlZCB0aGUgbmV3IG1heCBpZiB0aGUgY29tcGFyYXRvciBkZWNsYXJlcyB0aGVtIGVxdWFsLCBidXRcbiAgICAvLyB0aGV5IGFyZSBub3QgZXF1YWwgYW5kIGIgaXMgaW4gZmFjdCBhIG51bGxpc2ggdmFsdWUuXG4gICAgcmV0dXJuIChcbiAgICAgIChjb21wID09PSAwICYmIGIgIT09IGEgJiYgKGIgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgIT09IGIpKSB8fFxuICAgICAgY29tcCA+IDBcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gemlwV2l0aEZhY3Rvcnkoa2V5SXRlciwgemlwcGVyLCBpdGVycywgemlwQWxsKSB7XG4gICAgdmFyIHppcFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGtleUl0ZXIpO1xuICAgIHZhciBzaXplcyA9IG5ldyBBcnJheVNlcShpdGVycykubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBpLnNpemU7IH0pO1xuICAgIHppcFNlcXVlbmNlLnNpemUgPSB6aXBBbGwgPyBzaXplcy5tYXgoKSA6IHNpemVzLm1pbigpO1xuICAgIC8vIE5vdGU6IHRoaXMgYSBnZW5lcmljIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgX19pdGVyYXRlIGluIHRlcm1zIG9mXG4gICAgLy8gX19pdGVyYXRvciB3aGljaCBtYXkgYmUgbW9yZSBnZW5lcmljYWxseSB1c2VmdWwgaW4gdGhlIGZ1dHVyZS5cbiAgICB6aXBTZXF1ZW5jZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgICAgIC8qIGdlbmVyaWM6XG4gICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCByZXZlcnNlKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgIGlmIChmbihzdGVwLnZhbHVlWzFdLCBzdGVwLnZhbHVlWzBdLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgICAqL1xuICAgICAgLy8gaW5kZXhlZDpcbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUywgcmV2ZXJzZSk7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgaWYgKGZuKHN0ZXAudmFsdWUsIGl0ZXJhdGlvbnMrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG4gICAgemlwU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24gKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBpdGVyYXRvcnMgPSBpdGVycy5tYXAoXG4gICAgICAgIGZ1bmN0aW9uIChpKSB7IHJldHVybiAoKGkgPSBDb2xsZWN0aW9uKGkpKSwgZ2V0SXRlcmF0b3IocmV2ZXJzZSA/IGkucmV2ZXJzZSgpIDogaSkpOyB9XG4gICAgICApO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIGlzRG9uZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGVwcztcbiAgICAgICAgaWYgKCFpc0RvbmUpIHtcbiAgICAgICAgICBzdGVwcyA9IGl0ZXJhdG9ycy5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkubmV4dCgpOyB9KTtcbiAgICAgICAgICBpc0RvbmUgPSB6aXBBbGwgPyBzdGVwcy5ldmVyeShmdW5jdGlvbiAocykgeyByZXR1cm4gcy5kb25lOyB9KSA6IHN0ZXBzLnNvbWUoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMuZG9uZTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRG9uZSkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZShcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGl0ZXJhdGlvbnMrKyxcbiAgICAgICAgICB6aXBwZXIuYXBwbHkoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgc3RlcHMubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnZhbHVlOyB9KVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHppcFNlcXVlbmNlO1xuICB9XG5cbiAgLy8gI3ByYWdtYSBIZWxwZXIgRnVuY3Rpb25zXG5cbiAgZnVuY3Rpb24gcmVpZnkoaXRlciwgc2VxKSB7XG4gICAgcmV0dXJuIGl0ZXIgPT09IHNlcSA/IGl0ZXIgOiBpc1NlcShpdGVyKSA/IHNlcSA6IGl0ZXIuY29uc3RydWN0b3Ioc2VxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlRW50cnkoZW50cnkpIHtcbiAgICBpZiAoZW50cnkgIT09IE9iamVjdChlbnRyeSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFtLLCBWXSB0dXBsZTogJyArIGVudHJ5KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb2xsZWN0aW9uQ2xhc3MoY29sbGVjdGlvbikge1xuICAgIHJldHVybiBpc0tleWVkKGNvbGxlY3Rpb24pXG4gICAgICA/IEtleWVkQ29sbGVjdGlvblxuICAgICAgOiBpc0luZGV4ZWQoY29sbGVjdGlvbilcbiAgICAgID8gSW5kZXhlZENvbGxlY3Rpb25cbiAgICAgIDogU2V0Q29sbGVjdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKSB7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUoXG4gICAgICAoaXNLZXllZChjb2xsZWN0aW9uKVxuICAgICAgICA/IEtleWVkU2VxXG4gICAgICAgIDogaXNJbmRleGVkKGNvbGxlY3Rpb24pXG4gICAgICAgID8gSW5kZXhlZFNlcVxuICAgICAgICA6IFNldFNlcVxuICAgICAgKS5wcm90b3R5cGVcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FjaGVSZXN1bHRUaHJvdWdoKCkge1xuICAgIGlmICh0aGlzLl9pdGVyLmNhY2hlUmVzdWx0KSB7XG4gICAgICB0aGlzLl9pdGVyLmNhY2hlUmVzdWx0KCk7XG4gICAgICB0aGlzLnNpemUgPSB0aGlzLl9pdGVyLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFNlcS5wcm90b3R5cGUuY2FjaGVSZXN1bHQuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHRDb21wYXJhdG9yKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFyckNvcHkoYXJyLCBvZmZzZXQpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICB2YXIgbGVuID0gTWF0aC5tYXgoMCwgYXJyLmxlbmd0aCAtIG9mZnNldCk7XG4gICAgdmFyIG5ld0FyciA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBsZW47IGlpKyspIHtcbiAgICAgIG5ld0FycltpaV0gPSBhcnJbaWkgKyBvZmZzZXRdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3QXJyO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZXJyb3IpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikgeyB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb3RJbmZpbml0ZShzaXplKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgc2l6ZSAhPT0gSW5maW5pdHksXG4gICAgICAnQ2Fubm90IHBlcmZvcm0gdGhpcyBhY3Rpb24gd2l0aCBhbiBpbmZpbml0ZSBzaXplLidcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY29lcmNlS2V5UGF0aChrZXlQYXRoKSB7XG4gICAgaWYgKGlzQXJyYXlMaWtlKGtleVBhdGgpICYmIHR5cGVvZiBrZXlQYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGtleVBhdGg7XG4gICAgfVxuICAgIGlmIChpc09yZGVyZWQoa2V5UGF0aCkpIHtcbiAgICAgIHJldHVybiBrZXlQYXRoLnRvQXJyYXkoKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdJbnZhbGlkIGtleVBhdGg6IGV4cGVjdGVkIE9yZGVyZWQgQ29sbGVjdGlvbiBvciBBcnJheTogJyArIGtleVBhdGhcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNQbGFpbk9iaih2YWx1ZSkge1xuICAgIHJldHVybiAoXG4gICAgICB2YWx1ZSAmJlxuICAgICAgKHR5cGVvZiB2YWx1ZS5jb25zdHJ1Y3RvciAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0JylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBwb3RlbnRpYWxseS1wZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJlLCBlaXRoZXJcbiAgICogcHJvdmlkZWQgYnkgSW1tdXRhYmxlLmpzIG9yIGEgcGxhaW4gQXJyYXkgb3IgT2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gaXNEYXRhU3RydWN0dXJlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIChpc0ltbXV0YWJsZSh2YWx1ZSkgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iaih2YWx1ZSkpXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHF1b3RlU3RyaW5nKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogU3RyaW5nKHZhbHVlKTtcbiAgICB9IGNhdGNoIChfaWdub3JlRXJyb3IpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFzKGNvbGxlY3Rpb24sIGtleSkge1xuICAgIHJldHVybiBpc0ltbXV0YWJsZShjb2xsZWN0aW9uKVxuICAgICAgPyBjb2xsZWN0aW9uLmhhcyhrZXkpXG4gICAgICA6IGlzRGF0YVN0cnVjdHVyZShjb2xsZWN0aW9uKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbGxlY3Rpb24sIGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXQoY29sbGVjdGlvbiwga2V5LCBub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiBpc0ltbXV0YWJsZShjb2xsZWN0aW9uKVxuICAgICAgPyBjb2xsZWN0aW9uLmdldChrZXksIG5vdFNldFZhbHVlKVxuICAgICAgOiAhaGFzKGNvbGxlY3Rpb24sIGtleSlcbiAgICAgID8gbm90U2V0VmFsdWVcbiAgICAgIDogdHlwZW9mIGNvbGxlY3Rpb24uZ2V0ID09PSAnZnVuY3Rpb24nXG4gICAgICA/IGNvbGxlY3Rpb24uZ2V0KGtleSlcbiAgICAgIDogY29sbGVjdGlvbltrZXldO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hhbGxvd0NvcHkoZnJvbSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZyb20pKSB7XG4gICAgICByZXR1cm4gYXJyQ29weShmcm9tKTtcbiAgICB9XG4gICAgdmFyIHRvID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcbiAgICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlKGNvbGxlY3Rpb24sIGtleSkge1xuICAgIGlmICghaXNEYXRhU3RydWN0dXJlKGNvbGxlY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnQ2Fubm90IHVwZGF0ZSBub24tZGF0YS1zdHJ1Y3R1cmUgdmFsdWU6ICcgKyBjb2xsZWN0aW9uXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoaXNJbW11dGFibGUoY29sbGVjdGlvbikpIHtcbiAgICAgIGlmICghY29sbGVjdGlvbi5yZW1vdmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnQ2Fubm90IHVwZGF0ZSBpbW11dGFibGUgdmFsdWUgd2l0aG91dCAucmVtb3ZlKCkgbWV0aG9kOiAnICsgY29sbGVjdGlvblxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24ucmVtb3ZlKGtleSk7XG4gICAgfVxuICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChjb2xsZWN0aW9uLCBrZXkpKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgdmFyIGNvbGxlY3Rpb25Db3B5ID0gc2hhbGxvd0NvcHkoY29sbGVjdGlvbik7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29sbGVjdGlvbkNvcHkpKSB7XG4gICAgICBjb2xsZWN0aW9uQ29weS5zcGxpY2Uoa2V5LCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIGNvbGxlY3Rpb25Db3B5W2tleV07XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uQ29weTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldChjb2xsZWN0aW9uLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKCFpc0RhdGFTdHJ1Y3R1cmUoY29sbGVjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdDYW5ub3QgdXBkYXRlIG5vbi1kYXRhLXN0cnVjdHVyZSB2YWx1ZTogJyArIGNvbGxlY3Rpb25cbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpc0ltbXV0YWJsZShjb2xsZWN0aW9uKSkge1xuICAgICAgaWYgKCFjb2xsZWN0aW9uLnNldCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdDYW5ub3QgdXBkYXRlIGltbXV0YWJsZSB2YWx1ZSB3aXRob3V0IC5zZXQoKSBtZXRob2Q6ICcgKyBjb2xsZWN0aW9uXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbGxlY3Rpb24sIGtleSkgJiYgdmFsdWUgPT09IGNvbGxlY3Rpb25ba2V5XSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIHZhciBjb2xsZWN0aW9uQ29weSA9IHNoYWxsb3dDb3B5KGNvbGxlY3Rpb24pO1xuICAgIGNvbGxlY3Rpb25Db3B5W2tleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gY29sbGVjdGlvbkNvcHk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVJbihjb2xsZWN0aW9uLCBrZXlQYXRoLCBub3RTZXRWYWx1ZSwgdXBkYXRlcikge1xuICAgIGlmICghdXBkYXRlcikge1xuICAgICAgdXBkYXRlciA9IG5vdFNldFZhbHVlO1xuICAgICAgbm90U2V0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHZhciB1cGRhdGVkVmFsdWUgPSB1cGRhdGVJbkRlZXBseShcbiAgICAgIGlzSW1tdXRhYmxlKGNvbGxlY3Rpb24pLFxuICAgICAgY29sbGVjdGlvbixcbiAgICAgIGNvZXJjZUtleVBhdGgoa2V5UGF0aCksXG4gICAgICAwLFxuICAgICAgbm90U2V0VmFsdWUsXG4gICAgICB1cGRhdGVyXG4gICAgKTtcbiAgICByZXR1cm4gdXBkYXRlZFZhbHVlID09PSBOT1RfU0VUID8gbm90U2V0VmFsdWUgOiB1cGRhdGVkVmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVJbkRlZXBseShcbiAgICBpbkltbXV0YWJsZSxcbiAgICBleGlzdGluZyxcbiAgICBrZXlQYXRoLFxuICAgIGksXG4gICAgbm90U2V0VmFsdWUsXG4gICAgdXBkYXRlclxuICApIHtcbiAgICB2YXIgd2FzTm90U2V0ID0gZXhpc3RpbmcgPT09IE5PVF9TRVQ7XG4gICAgaWYgKGkgPT09IGtleVBhdGgubGVuZ3RoKSB7XG4gICAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IHdhc05vdFNldCA/IG5vdFNldFZhbHVlIDogZXhpc3Rpbmc7XG4gICAgICB2YXIgbmV3VmFsdWUgPSB1cGRhdGVyKGV4aXN0aW5nVmFsdWUpO1xuICAgICAgcmV0dXJuIG5ld1ZhbHVlID09PSBleGlzdGluZ1ZhbHVlID8gZXhpc3RpbmcgOiBuZXdWYWx1ZTtcbiAgICB9XG4gICAgaWYgKCF3YXNOb3RTZXQgJiYgIWlzRGF0YVN0cnVjdHVyZShleGlzdGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdDYW5ub3QgdXBkYXRlIHdpdGhpbiBub24tZGF0YS1zdHJ1Y3R1cmUgdmFsdWUgaW4gcGF0aCBbJyArXG4gICAgICAgICAga2V5UGF0aC5zbGljZSgwLCBpKS5tYXAocXVvdGVTdHJpbmcpICtcbiAgICAgICAgICAnXTogJyArXG4gICAgICAgICAgZXhpc3RpbmdcbiAgICAgICk7XG4gICAgfVxuICAgIHZhciBrZXkgPSBrZXlQYXRoW2ldO1xuICAgIHZhciBuZXh0RXhpc3RpbmcgPSB3YXNOb3RTZXQgPyBOT1RfU0VUIDogZ2V0KGV4aXN0aW5nLCBrZXksIE5PVF9TRVQpO1xuICAgIHZhciBuZXh0VXBkYXRlZCA9IHVwZGF0ZUluRGVlcGx5KFxuICAgICAgbmV4dEV4aXN0aW5nID09PSBOT1RfU0VUID8gaW5JbW11dGFibGUgOiBpc0ltbXV0YWJsZShuZXh0RXhpc3RpbmcpLFxuICAgICAgbmV4dEV4aXN0aW5nLFxuICAgICAga2V5UGF0aCxcbiAgICAgIGkgKyAxLFxuICAgICAgbm90U2V0VmFsdWUsXG4gICAgICB1cGRhdGVyXG4gICAgKTtcbiAgICByZXR1cm4gbmV4dFVwZGF0ZWQgPT09IG5leHRFeGlzdGluZ1xuICAgICAgPyBleGlzdGluZ1xuICAgICAgOiBuZXh0VXBkYXRlZCA9PT0gTk9UX1NFVFxuICAgICAgPyByZW1vdmUoZXhpc3RpbmcsIGtleSlcbiAgICAgIDogc2V0KFxuICAgICAgICAgIHdhc05vdFNldCA/IChpbkltbXV0YWJsZSA/IGVtcHR5TWFwKCkgOiB7fSkgOiBleGlzdGluZyxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgbmV4dFVwZGF0ZWRcbiAgICAgICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEluKGNvbGxlY3Rpb24sIGtleVBhdGgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHVwZGF0ZUluKGNvbGxlY3Rpb24sIGtleVBhdGgsIE5PVF9TRVQsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEluJDEoa2V5UGF0aCwgdikge1xuICAgIHJldHVybiBzZXRJbih0aGlzLCBrZXlQYXRoLCB2KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUluKGNvbGxlY3Rpb24sIGtleVBhdGgpIHtcbiAgICByZXR1cm4gdXBkYXRlSW4oY29sbGVjdGlvbiwga2V5UGF0aCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gTk9UX1NFVDsgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVJbihrZXlQYXRoKSB7XG4gICAgcmV0dXJuIHJlbW92ZUluKHRoaXMsIGtleVBhdGgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlKGNvbGxlY3Rpb24sIGtleSwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpIHtcbiAgICByZXR1cm4gdXBkYXRlSW4oY29sbGVjdGlvbiwgW2tleV0sIG5vdFNldFZhbHVlLCB1cGRhdGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZSQxKGtleSwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgICAgPyBrZXkodGhpcylcbiAgICAgIDogdXBkYXRlKHRoaXMsIGtleSwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlSW4kMShrZXlQYXRoLCBub3RTZXRWYWx1ZSwgdXBkYXRlcikge1xuICAgIHJldHVybiB1cGRhdGVJbih0aGlzLCBrZXlQYXRoLCBub3RTZXRWYWx1ZSwgdXBkYXRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZSgpIHtcbiAgICB2YXIgaXRlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHJldHVybiBtZXJnZUludG9LZXllZFdpdGgodGhpcywgaXRlcnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VXaXRoKG1lcmdlcikge1xuICAgIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoIGxlbi0tID4gMCApIGl0ZXJzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gICAgaWYgKHR5cGVvZiBtZXJnZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWVyZ2VyIGZ1bmN0aW9uOiAnICsgbWVyZ2VyKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlSW50b0tleWVkV2l0aCh0aGlzLCBpdGVycywgbWVyZ2VyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlSW50b0tleWVkV2l0aChjb2xsZWN0aW9uLCBjb2xsZWN0aW9ucywgbWVyZ2VyKSB7XG4gICAgdmFyIGl0ZXJzID0gW107XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGNvbGxlY3Rpb25zLmxlbmd0aDsgaWkrKykge1xuICAgICAgdmFyIGNvbGxlY3Rpb24kMSA9IEtleWVkQ29sbGVjdGlvbihjb2xsZWN0aW9uc1tpaV0pO1xuICAgICAgaWYgKGNvbGxlY3Rpb24kMS5zaXplICE9PSAwKSB7XG4gICAgICAgIGl0ZXJzLnB1c2goY29sbGVjdGlvbiQxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmIChcbiAgICAgIGNvbGxlY3Rpb24udG9TZXEoKS5zaXplID09PSAwICYmXG4gICAgICAhY29sbGVjdGlvbi5fX293bmVySUQgJiZcbiAgICAgIGl0ZXJzLmxlbmd0aCA9PT0gMVxuICAgICkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uY29uc3RydWN0b3IoaXRlcnNbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbi53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgbWVyZ2VJbnRvQ29sbGVjdGlvbiA9IG1lcmdlclxuICAgICAgICA/IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICB1cGRhdGUoY29sbGVjdGlvbiwga2V5LCBOT1RfU0VULCBmdW5jdGlvbiAob2xkVmFsKSB7IHJldHVybiBvbGRWYWwgPT09IE5PVF9TRVQgPyB2YWx1ZSA6IG1lcmdlcihvbGRWYWwsIHZhbHVlLCBrZXkpOyB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgOiBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgY29sbGVjdGlvbi5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfTtcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBpdGVycy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgaXRlcnNbaWldLmZvckVhY2gobWVyZ2VJbnRvQ29sbGVjdGlvbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZSQxKGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgc291cmNlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoIGxlbi0tID4gMCApIHNvdXJjZXNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgICByZXR1cm4gbWVyZ2VXaXRoU291cmNlcyhjb2xsZWN0aW9uLCBzb3VyY2VzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlV2l0aCQxKG1lcmdlciwgY29sbGVjdGlvbikge1xuICAgIHZhciBzb3VyY2VzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgIHdoaWxlICggbGVuLS0gPiAwICkgc291cmNlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDIgXTtcblxuICAgIHJldHVybiBtZXJnZVdpdGhTb3VyY2VzKGNvbGxlY3Rpb24sIHNvdXJjZXMsIG1lcmdlcik7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZURlZXAoY29sbGVjdGlvbikge1xuICAgIHZhciBzb3VyY2VzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgIHdoaWxlICggbGVuLS0gPiAwICkgc291cmNlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICAgIHJldHVybiBtZXJnZURlZXBXaXRoU291cmNlcyhjb2xsZWN0aW9uLCBzb3VyY2VzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcFdpdGgobWVyZ2VyLCBjb2xsZWN0aW9uKSB7XG4gICAgdmFyIHNvdXJjZXMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgd2hpbGUgKCBsZW4tLSA+IDAgKSBzb3VyY2VzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMiBdO1xuXG4gICAgcmV0dXJuIG1lcmdlRGVlcFdpdGhTb3VyY2VzKGNvbGxlY3Rpb24sIHNvdXJjZXMsIG1lcmdlcik7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZURlZXBXaXRoU291cmNlcyhjb2xsZWN0aW9uLCBzb3VyY2VzLCBtZXJnZXIpIHtcbiAgICByZXR1cm4gbWVyZ2VXaXRoU291cmNlcyhjb2xsZWN0aW9uLCBzb3VyY2VzLCBkZWVwTWVyZ2VyV2l0aChtZXJnZXIpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlV2l0aFNvdXJjZXMoY29sbGVjdGlvbiwgc291cmNlcywgbWVyZ2VyKSB7XG4gICAgaWYgKCFpc0RhdGFTdHJ1Y3R1cmUoY29sbGVjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdDYW5ub3QgbWVyZ2UgaW50byBub24tZGF0YS1zdHJ1Y3R1cmUgdmFsdWU6ICcgKyBjb2xsZWN0aW9uXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoaXNJbW11dGFibGUoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgbWVyZ2VyID09PSAnZnVuY3Rpb24nICYmIGNvbGxlY3Rpb24ubWVyZ2VXaXRoXG4gICAgICAgID8gY29sbGVjdGlvbi5tZXJnZVdpdGguYXBwbHkoY29sbGVjdGlvbiwgWyBtZXJnZXIgXS5jb25jYXQoIHNvdXJjZXMgKSlcbiAgICAgICAgOiBjb2xsZWN0aW9uLm1lcmdlXG4gICAgICAgID8gY29sbGVjdGlvbi5tZXJnZS5hcHBseShjb2xsZWN0aW9uLCBzb3VyY2VzKVxuICAgICAgICA6IGNvbGxlY3Rpb24uY29uY2F0LmFwcGx5KGNvbGxlY3Rpb24sIHNvdXJjZXMpO1xuICAgIH1cbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoY29sbGVjdGlvbik7XG4gICAgdmFyIG1lcmdlZCA9IGNvbGxlY3Rpb247XG4gICAgdmFyIENvbGxlY3Rpb24gPSBpc0FycmF5ID8gSW5kZXhlZENvbGxlY3Rpb24gOiBLZXllZENvbGxlY3Rpb247XG4gICAgdmFyIG1lcmdlSXRlbSA9IGlzQXJyYXlcbiAgICAgID8gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgLy8gQ29weSBvbiB3cml0ZVxuICAgICAgICAgIGlmIChtZXJnZWQgPT09IGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIG1lcmdlZCA9IHNoYWxsb3dDb3B5KG1lcmdlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1lcmdlZC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgOiBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgIHZhciBoYXNWYWwgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG1lcmdlZCwga2V5KTtcbiAgICAgICAgICB2YXIgbmV4dFZhbCA9XG4gICAgICAgICAgICBoYXNWYWwgJiYgbWVyZ2VyID8gbWVyZ2VyKG1lcmdlZFtrZXldLCB2YWx1ZSwga2V5KSA6IHZhbHVlO1xuICAgICAgICAgIGlmICghaGFzVmFsIHx8IG5leHRWYWwgIT09IG1lcmdlZFtrZXldKSB7XG4gICAgICAgICAgICAvLyBDb3B5IG9uIHdyaXRlXG4gICAgICAgICAgICBpZiAobWVyZ2VkID09PSBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgIG1lcmdlZCA9IHNoYWxsb3dDb3B5KG1lcmdlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXJnZWRba2V5XSA9IG5leHRWYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgQ29sbGVjdGlvbihzb3VyY2VzW2ldKS5mb3JFYWNoKG1lcmdlSXRlbSk7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBkZWVwTWVyZ2VyV2l0aChtZXJnZXIpIHtcbiAgICBmdW5jdGlvbiBkZWVwTWVyZ2VyKG9sZFZhbHVlLCBuZXdWYWx1ZSwga2V5KSB7XG4gICAgICByZXR1cm4gaXNEYXRhU3RydWN0dXJlKG9sZFZhbHVlKSAmJiBpc0RhdGFTdHJ1Y3R1cmUobmV3VmFsdWUpXG4gICAgICAgID8gbWVyZ2VXaXRoU291cmNlcyhvbGRWYWx1ZSwgW25ld1ZhbHVlXSwgZGVlcE1lcmdlcilcbiAgICAgICAgOiBtZXJnZXJcbiAgICAgICAgPyBtZXJnZXIob2xkVmFsdWUsIG5ld1ZhbHVlLCBrZXkpXG4gICAgICAgIDogbmV3VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBkZWVwTWVyZ2VyO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VEZWVwJDEoKSB7XG4gICAgdmFyIGl0ZXJzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGl0ZXJzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICByZXR1cm4gbWVyZ2VEZWVwV2l0aFNvdXJjZXModGhpcywgaXRlcnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VEZWVwV2l0aCQxKG1lcmdlcikge1xuICAgIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoIGxlbi0tID4gMCApIGl0ZXJzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gICAgcmV0dXJuIG1lcmdlRGVlcFdpdGhTb3VyY2VzKHRoaXMsIGl0ZXJzLCBtZXJnZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VJbihrZXlQYXRoKSB7XG4gICAgdmFyIGl0ZXJzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgIHdoaWxlICggbGVuLS0gPiAwICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgICByZXR1cm4gdXBkYXRlSW4odGhpcywga2V5UGF0aCwgZW1wdHlNYXAoKSwgZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1lcmdlV2l0aFNvdXJjZXMobSwgaXRlcnMpOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcEluKGtleVBhdGgpIHtcbiAgICB2YXIgaXRlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKCBsZW4tLSA+IDAgKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICAgIHJldHVybiB1cGRhdGVJbih0aGlzLCBrZXlQYXRoLCBlbXB0eU1hcCgpLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gbWVyZ2VEZWVwV2l0aFNvdXJjZXMobSwgaXRlcnMpOyB9XG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpdGhNdXRhdGlvbnMoZm4pIHtcbiAgICB2YXIgbXV0YWJsZSA9IHRoaXMuYXNNdXRhYmxlKCk7XG4gICAgZm4obXV0YWJsZSk7XG4gICAgcmV0dXJuIG11dGFibGUud2FzQWx0ZXJlZCgpID8gbXV0YWJsZS5fX2Vuc3VyZU93bmVyKHRoaXMuX19vd25lcklEKSA6IHRoaXM7XG4gIH1cblxuICBmdW5jdGlvbiBhc011dGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19vd25lcklEID8gdGhpcyA6IHRoaXMuX19lbnN1cmVPd25lcihuZXcgT3duZXJJRCgpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9fZW5zdXJlT3duZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhc0FsdGVyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19hbHRlcmVkO1xuICB9XG5cbiAgdmFyIE1hcCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEtleWVkQ29sbGVjdGlvbikge1xuICAgIGZ1bmN0aW9uIE1hcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBlbXB0eU1hcCgpXG4gICAgICAgIDogaXNNYXAodmFsdWUpICYmICFpc09yZGVyZWQodmFsdWUpXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiBlbXB0eU1hcCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgdmFyIGl0ZXIgPSBLZXllZENvbGxlY3Rpb24odmFsdWUpO1xuICAgICAgICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICAgICAgICAgIGl0ZXIuZm9yRWFjaChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gbWFwLnNldChrLCB2KTsgfSk7XG4gICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCBLZXllZENvbGxlY3Rpb24gKSBNYXAuX19wcm90b19fID0gS2V5ZWRDb2xsZWN0aW9uO1xuICAgIE1hcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBLZXllZENvbGxlY3Rpb24gJiYgS2V5ZWRDb2xsZWN0aW9uLnByb3RvdHlwZSApO1xuICAgIE1hcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNYXA7XG5cbiAgICBNYXAub2YgPSBmdW5jdGlvbiBvZiAoKSB7XG4gICAgICB2YXIga2V5VmFsdWVzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkga2V5VmFsdWVzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgIHJldHVybiBlbXB0eU1hcCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleVZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgIGlmIChpICsgMSA+PSBrZXlWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdmFsdWUgZm9yIGtleTogJyArIGtleVZhbHVlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcC5zZXQoa2V5VmFsdWVzW2ldLCBrZXlWYWx1ZXNbaSArIDFdKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdNYXAgeycsICd9Jyk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgICBNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaywgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yb290XG4gICAgICAgID8gdGhpcy5fcm9vdC5nZXQoMCwgdW5kZWZpbmVkLCBrLCBub3RTZXRWYWx1ZSlcbiAgICAgICAgOiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICAgIE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0IChrLCB2KSB7XG4gICAgICByZXR1cm4gdXBkYXRlTWFwKHRoaXMsIGssIHYpO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoaykge1xuICAgICAgcmV0dXJuIHVwZGF0ZU1hcCh0aGlzLCBrLCBOT1RfU0VUKTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5kZWxldGVBbGwgPSBmdW5jdGlvbiBkZWxldGVBbGwgKGtleXMpIHtcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gQ29sbGVjdGlvbihrZXlzKTtcblxuICAgICAgaWYgKGNvbGxlY3Rpb24uc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgIGNvbGxlY3Rpb24uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBtYXAucmVtb3ZlKGtleSk7IH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eU1hcCgpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIENvbXBvc2l0aW9uXG5cbiAgICBNYXAucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbiBzb3J0IChjb21wYXJhdG9yKSB7XG4gICAgICAvLyBMYXRlIGJpbmRpbmdcbiAgICAgIHJldHVybiBPcmRlcmVkTWFwKHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IpKTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5zb3J0QnkgPSBmdW5jdGlvbiBzb3J0QnkgKG1hcHBlciwgY29tcGFyYXRvcikge1xuICAgICAgLy8gTGF0ZSBiaW5kaW5nXG4gICAgICByZXR1cm4gT3JkZXJlZE1hcChzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yLCBtYXBwZXIpKTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKG1hcHBlciwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgbWFwLnNldChrZXksIG1hcHBlci5jYWxsKGNvbnRleHQsIHZhbHVlLCBrZXksIG1hcCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIE11dGFiaWxpdHlcblxuICAgIE1hcC5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcywgdHlwZSwgcmV2ZXJzZSk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHRoaXMuX3Jvb3QgJiZcbiAgICAgICAgdGhpcy5fcm9vdC5pdGVyYXRlKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgICByZXR1cm4gZm4oZW50cnlbMV0sIGVudHJ5WzBdLCB0aGlzJDEpO1xuICAgICAgICB9LCByZXZlcnNlKTtcbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbiBfX2Vuc3VyZU93bmVyIChvd25lcklEKSB7XG4gICAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBlbXB0eU1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFrZU1hcCh0aGlzLnNpemUsIHRoaXMuX3Jvb3QsIG93bmVySUQsIHRoaXMuX19oYXNoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1hcDtcbiAgfShLZXllZENvbGxlY3Rpb24pKTtcblxuICBNYXAuaXNNYXAgPSBpc01hcDtcblxuICB2YXIgTWFwUHJvdG90eXBlID0gTWFwLnByb3RvdHlwZTtcbiAgTWFwUHJvdG90eXBlW0lTX01BUF9TWU1CT0xdID0gdHJ1ZTtcbiAgTWFwUHJvdG90eXBlW0RFTEVURV0gPSBNYXBQcm90b3R5cGUucmVtb3ZlO1xuICBNYXBQcm90b3R5cGUucmVtb3ZlQWxsID0gTWFwUHJvdG90eXBlLmRlbGV0ZUFsbDtcbiAgTWFwUHJvdG90eXBlLnNldEluID0gc2V0SW4kMTtcbiAgTWFwUHJvdG90eXBlLnJlbW92ZUluID0gTWFwUHJvdG90eXBlLmRlbGV0ZUluID0gZGVsZXRlSW47XG4gIE1hcFByb3RvdHlwZS51cGRhdGUgPSB1cGRhdGUkMTtcbiAgTWFwUHJvdG90eXBlLnVwZGF0ZUluID0gdXBkYXRlSW4kMTtcbiAgTWFwUHJvdG90eXBlLm1lcmdlID0gTWFwUHJvdG90eXBlLmNvbmNhdCA9IG1lcmdlO1xuICBNYXBQcm90b3R5cGUubWVyZ2VXaXRoID0gbWVyZ2VXaXRoO1xuICBNYXBQcm90b3R5cGUubWVyZ2VEZWVwID0gbWVyZ2VEZWVwJDE7XG4gIE1hcFByb3RvdHlwZS5tZXJnZURlZXBXaXRoID0gbWVyZ2VEZWVwV2l0aCQxO1xuICBNYXBQcm90b3R5cGUubWVyZ2VJbiA9IG1lcmdlSW47XG4gIE1hcFByb3RvdHlwZS5tZXJnZURlZXBJbiA9IG1lcmdlRGVlcEluO1xuICBNYXBQcm90b3R5cGUud2l0aE11dGF0aW9ucyA9IHdpdGhNdXRhdGlvbnM7XG4gIE1hcFByb3RvdHlwZS53YXNBbHRlcmVkID0gd2FzQWx0ZXJlZDtcbiAgTWFwUHJvdG90eXBlLmFzSW1tdXRhYmxlID0gYXNJbW11dGFibGU7XG4gIE1hcFByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IE1hcFByb3RvdHlwZS5hc011dGFibGUgPSBhc011dGFibGU7XG4gIE1hcFByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGFycikge1xuICAgIHJldHVybiByZXN1bHQuc2V0KGFyclswXSwgYXJyWzFdKTtcbiAgfTtcbiAgTWFwUHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iai5hc0ltbXV0YWJsZSgpO1xuICB9O1xuXG4gIC8vICNwcmFnbWEgVHJpZSBOb2Rlc1xuXG4gIHZhciBBcnJheU1hcE5vZGUgPSBmdW5jdGlvbiBBcnJheU1hcE5vZGUob3duZXJJRCwgZW50cmllcykge1xuICAgIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gICAgdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgfTtcblxuICBBcnJheU1hcE5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoc2hpZnQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgICBmb3IgKHZhciBpaSA9IDAsIGxlbiA9IGVudHJpZXMubGVuZ3RoOyBpaSA8IGxlbjsgaWkrKykge1xuICAgICAgaWYgKGlzKGtleSwgZW50cmllc1tpaV1bMF0pKSB7XG4gICAgICAgIHJldHVybiBlbnRyaWVzW2lpXVsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICB9O1xuXG4gIEFycmF5TWFwTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgICB2YXIgcmVtb3ZlZCA9IHZhbHVlID09PSBOT1RfU0VUO1xuXG4gICAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgdmFyIGxlbiA9IGVudHJpZXMubGVuZ3RoO1xuICAgIGZvciAoOyBpZHggPCBsZW47IGlkeCsrKSB7XG4gICAgICBpZiAoaXMoa2V5LCBlbnRyaWVzW2lkeF1bMF0pKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZXhpc3RzID0gaWR4IDwgbGVuO1xuXG4gICAgaWYgKGV4aXN0cyA/IGVudHJpZXNbaWR4XVsxXSA9PT0gdmFsdWUgOiByZW1vdmVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBTZXRSZWYoZGlkQWx0ZXIpO1xuICAgIChyZW1vdmVkIHx8ICFleGlzdHMpICYmIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcblxuICAgIGlmIChyZW1vdmVkICYmIGVudHJpZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGlmICghZXhpc3RzICYmICFyZW1vdmVkICYmIGVudHJpZXMubGVuZ3RoID49IE1BWF9BUlJBWV9NQVBfU0laRSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZU5vZGVzKG93bmVySUQsIGVudHJpZXMsIGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHZhciBpc0VkaXRhYmxlID0gb3duZXJJRCAmJiBvd25lcklEID09PSB0aGlzLm93bmVySUQ7XG4gICAgdmFyIG5ld0VudHJpZXMgPSBpc0VkaXRhYmxlID8gZW50cmllcyA6IGFyckNvcHkoZW50cmllcyk7XG5cbiAgICBpZiAoZXhpc3RzKSB7XG4gICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICBpZHggPT09IGxlbiAtIDFcbiAgICAgICAgICA/IG5ld0VudHJpZXMucG9wKClcbiAgICAgICAgICA6IChuZXdFbnRyaWVzW2lkeF0gPSBuZXdFbnRyaWVzLnBvcCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0VudHJpZXNbaWR4XSA9IFtrZXksIHZhbHVlXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3RW50cmllcy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfVxuXG4gICAgaWYgKGlzRWRpdGFibGUpIHtcbiAgICAgIHRoaXMuZW50cmllcyA9IG5ld0VudHJpZXM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEFycmF5TWFwTm9kZShvd25lcklELCBuZXdFbnRyaWVzKTtcbiAgfTtcblxuICB2YXIgQml0bWFwSW5kZXhlZE5vZGUgPSBmdW5jdGlvbiBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCBiaXRtYXAsIG5vZGVzKSB7XG4gICAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgICB0aGlzLmJpdG1hcCA9IGJpdG1hcDtcbiAgICB0aGlzLm5vZGVzID0gbm9kZXM7XG4gIH07XG5cbiAgQml0bWFwSW5kZXhlZE5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoc2hpZnQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXlIYXNoID0gaGFzaChrZXkpO1xuICAgIH1cbiAgICB2YXIgYml0ID0gMSA8PCAoKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0spO1xuICAgIHZhciBiaXRtYXAgPSB0aGlzLmJpdG1hcDtcbiAgICByZXR1cm4gKGJpdG1hcCAmIGJpdCkgPT09IDBcbiAgICAgID8gbm90U2V0VmFsdWVcbiAgICAgIDogdGhpcy5ub2Rlc1twb3BDb3VudChiaXRtYXAgJiAoYml0IC0gMSkpXS5nZXQoXG4gICAgICAgICAgc2hpZnQgKyBTSElGVCxcbiAgICAgICAgICBrZXlIYXNoLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBub3RTZXRWYWx1ZVxuICAgICAgICApO1xuICB9O1xuXG4gIEJpdG1hcEluZGV4ZWROb2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcikge1xuICAgIGlmIChrZXlIYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG4gICAgfVxuICAgIHZhciBrZXlIYXNoRnJhZyA9IChzaGlmdCA9PT0gMCA/IGtleUhhc2ggOiBrZXlIYXNoID4+PiBzaGlmdCkgJiBNQVNLO1xuICAgIHZhciBiaXQgPSAxIDw8IGtleUhhc2hGcmFnO1xuICAgIHZhciBiaXRtYXAgPSB0aGlzLmJpdG1hcDtcbiAgICB2YXIgZXhpc3RzID0gKGJpdG1hcCAmIGJpdCkgIT09IDA7XG5cbiAgICBpZiAoIWV4aXN0cyAmJiB2YWx1ZSA9PT0gTk9UX1NFVCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGlkeCA9IHBvcENvdW50KGJpdG1hcCAmIChiaXQgLSAxKSk7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgICB2YXIgbm9kZSA9IGV4aXN0cyA/IG5vZGVzW2lkeF0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIG5ld05vZGUgPSB1cGRhdGVOb2RlKFxuICAgICAgbm9kZSxcbiAgICAgIG93bmVySUQsXG4gICAgICBzaGlmdCArIFNISUZULFxuICAgICAga2V5SGFzaCxcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlLFxuICAgICAgZGlkQ2hhbmdlU2l6ZSxcbiAgICAgIGRpZEFsdGVyXG4gICAgKTtcblxuICAgIGlmIChuZXdOb2RlID09PSBub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoIWV4aXN0cyAmJiBuZXdOb2RlICYmIG5vZGVzLmxlbmd0aCA+PSBNQVhfQklUTUFQX0lOREVYRURfU0laRSkge1xuICAgICAgcmV0dXJuIGV4cGFuZE5vZGVzKG93bmVySUQsIG5vZGVzLCBiaXRtYXAsIGtleUhhc2hGcmFnLCBuZXdOb2RlKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBleGlzdHMgJiZcbiAgICAgICFuZXdOb2RlICYmXG4gICAgICBub2Rlcy5sZW5ndGggPT09IDIgJiZcbiAgICAgIGlzTGVhZk5vZGUobm9kZXNbaWR4IF4gMV0pXG4gICAgKSB7XG4gICAgICByZXR1cm4gbm9kZXNbaWR4IF4gMV07XG4gICAgfVxuXG4gICAgaWYgKGV4aXN0cyAmJiBuZXdOb2RlICYmIG5vZGVzLmxlbmd0aCA9PT0gMSAmJiBpc0xlYWZOb2RlKG5ld05vZGUpKSB7XG4gICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICB9XG5cbiAgICB2YXIgaXNFZGl0YWJsZSA9IG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEO1xuICAgIHZhciBuZXdCaXRtYXAgPSBleGlzdHMgPyAobmV3Tm9kZSA/IGJpdG1hcCA6IGJpdG1hcCBeIGJpdCkgOiBiaXRtYXAgfCBiaXQ7XG4gICAgdmFyIG5ld05vZGVzID0gZXhpc3RzXG4gICAgICA/IG5ld05vZGVcbiAgICAgICAgPyBzZXRBdChub2RlcywgaWR4LCBuZXdOb2RlLCBpc0VkaXRhYmxlKVxuICAgICAgICA6IHNwbGljZU91dChub2RlcywgaWR4LCBpc0VkaXRhYmxlKVxuICAgICAgOiBzcGxpY2VJbihub2RlcywgaWR4LCBuZXdOb2RlLCBpc0VkaXRhYmxlKTtcblxuICAgIGlmIChpc0VkaXRhYmxlKSB7XG4gICAgICB0aGlzLmJpdG1hcCA9IG5ld0JpdG1hcDtcbiAgICAgIHRoaXMubm9kZXMgPSBuZXdOb2RlcztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQml0bWFwSW5kZXhlZE5vZGUob3duZXJJRCwgbmV3Qml0bWFwLCBuZXdOb2Rlcyk7XG4gIH07XG5cbiAgdmFyIEhhc2hBcnJheU1hcE5vZGUgPSBmdW5jdGlvbiBIYXNoQXJyYXlNYXBOb2RlKG93bmVySUQsIGNvdW50LCBub2Rlcykge1xuICAgIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgfTtcblxuICBIYXNoQXJyYXlNYXBOb2RlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKHNoaWZ0LCBrZXlIYXNoLCBrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgaWYgKGtleUhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5SGFzaCA9IGhhc2goa2V5KTtcbiAgICB9XG4gICAgdmFyIGlkeCA9IChzaGlmdCA9PT0gMCA/IGtleUhhc2ggOiBrZXlIYXNoID4+PiBzaGlmdCkgJiBNQVNLO1xuICAgIHZhciBub2RlID0gdGhpcy5ub2Rlc1tpZHhdO1xuICAgIHJldHVybiBub2RlXG4gICAgICA/IG5vZGUuZ2V0KHNoaWZ0ICsgU0hJRlQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpXG4gICAgICA6IG5vdFNldFZhbHVlO1xuICB9O1xuXG4gIEhhc2hBcnJheU1hcE5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAob3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKSB7XG4gICAgaWYgKGtleUhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5SGFzaCA9IGhhc2goa2V5KTtcbiAgICB9XG4gICAgdmFyIGlkeCA9IChzaGlmdCA9PT0gMCA/IGtleUhhc2ggOiBrZXlIYXNoID4+PiBzaGlmdCkgJiBNQVNLO1xuICAgIHZhciByZW1vdmVkID0gdmFsdWUgPT09IE5PVF9TRVQ7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgICB2YXIgbm9kZSA9IG5vZGVzW2lkeF07XG5cbiAgICBpZiAocmVtb3ZlZCAmJiAhbm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIG5ld05vZGUgPSB1cGRhdGVOb2RlKFxuICAgICAgbm9kZSxcbiAgICAgIG93bmVySUQsXG4gICAgICBzaGlmdCArIFNISUZULFxuICAgICAga2V5SGFzaCxcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlLFxuICAgICAgZGlkQ2hhbmdlU2l6ZSxcbiAgICAgIGRpZEFsdGVyXG4gICAgKTtcbiAgICBpZiAobmV3Tm9kZSA9PT0gbm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIG5ld0NvdW50ID0gdGhpcy5jb3VudDtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIG5ld0NvdW50Kys7XG4gICAgfSBlbHNlIGlmICghbmV3Tm9kZSkge1xuICAgICAgbmV3Q291bnQtLTtcbiAgICAgIGlmIChuZXdDb3VudCA8IE1JTl9IQVNIX0FSUkFZX01BUF9TSVpFKSB7XG4gICAgICAgIHJldHVybiBwYWNrTm9kZXMob3duZXJJRCwgbm9kZXMsIG5ld0NvdW50LCBpZHgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpc0VkaXRhYmxlID0gb3duZXJJRCAmJiBvd25lcklEID09PSB0aGlzLm93bmVySUQ7XG4gICAgdmFyIG5ld05vZGVzID0gc2V0QXQobm9kZXMsIGlkeCwgbmV3Tm9kZSwgaXNFZGl0YWJsZSk7XG5cbiAgICBpZiAoaXNFZGl0YWJsZSkge1xuICAgICAgdGhpcy5jb3VudCA9IG5ld0NvdW50O1xuICAgICAgdGhpcy5ub2RlcyA9IG5ld05vZGVzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBIYXNoQXJyYXlNYXBOb2RlKG93bmVySUQsIG5ld0NvdW50LCBuZXdOb2Rlcyk7XG4gIH07XG5cbiAgdmFyIEhhc2hDb2xsaXNpb25Ob2RlID0gZnVuY3Rpb24gSGFzaENvbGxpc2lvbk5vZGUob3duZXJJRCwga2V5SGFzaCwgZW50cmllcykge1xuICAgIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gICAgdGhpcy5rZXlIYXNoID0ga2V5SGFzaDtcbiAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICB9O1xuXG4gIEhhc2hDb2xsaXNpb25Ob2RlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKHNoaWZ0LCBrZXlIYXNoLCBrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG4gICAgZm9yICh2YXIgaWkgPSAwLCBsZW4gPSBlbnRyaWVzLmxlbmd0aDsgaWkgPCBsZW47IGlpKyspIHtcbiAgICAgIGlmIChpcyhrZXksIGVudHJpZXNbaWldWzBdKSkge1xuICAgICAgICByZXR1cm4gZW50cmllc1tpaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub3RTZXRWYWx1ZTtcbiAgfTtcblxuICBIYXNoQ29sbGlzaW9uTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXlIYXNoID0gaGFzaChrZXkpO1xuICAgIH1cblxuICAgIHZhciByZW1vdmVkID0gdmFsdWUgPT09IE5PVF9TRVQ7XG5cbiAgICBpZiAoa2V5SGFzaCAhPT0gdGhpcy5rZXlIYXNoKSB7XG4gICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIFNldFJlZihkaWRBbHRlcik7XG4gICAgICBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG4gICAgICByZXR1cm4gbWVyZ2VJbnRvTm9kZSh0aGlzLCBvd25lcklELCBzaGlmdCwga2V5SGFzaCwgW2tleSwgdmFsdWVdKTtcbiAgICB9XG5cbiAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgICB2YXIgaWR4ID0gMDtcbiAgICB2YXIgbGVuID0gZW50cmllcy5sZW5ndGg7XG4gICAgZm9yICg7IGlkeCA8IGxlbjsgaWR4KyspIHtcbiAgICAgIGlmIChpcyhrZXksIGVudHJpZXNbaWR4XVswXSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBleGlzdHMgPSBpZHggPCBsZW47XG5cbiAgICBpZiAoZXhpc3RzID8gZW50cmllc1tpZHhdWzFdID09PSB2YWx1ZSA6IHJlbW92ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIFNldFJlZihkaWRBbHRlcik7XG4gICAgKHJlbW92ZWQgfHwgIWV4aXN0cykgJiYgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuXG4gICAgaWYgKHJlbW92ZWQgJiYgbGVuID09PSAyKSB7XG4gICAgICByZXR1cm4gbmV3IFZhbHVlTm9kZShvd25lcklELCB0aGlzLmtleUhhc2gsIGVudHJpZXNbaWR4IF4gMV0pO1xuICAgIH1cblxuICAgIHZhciBpc0VkaXRhYmxlID0gb3duZXJJRCAmJiBvd25lcklEID09PSB0aGlzLm93bmVySUQ7XG4gICAgdmFyIG5ld0VudHJpZXMgPSBpc0VkaXRhYmxlID8gZW50cmllcyA6IGFyckNvcHkoZW50cmllcyk7XG5cbiAgICBpZiAoZXhpc3RzKSB7XG4gICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICBpZHggPT09IGxlbiAtIDFcbiAgICAgICAgICA/IG5ld0VudHJpZXMucG9wKClcbiAgICAgICAgICA6IChuZXdFbnRyaWVzW2lkeF0gPSBuZXdFbnRyaWVzLnBvcCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0VudHJpZXNbaWR4XSA9IFtrZXksIHZhbHVlXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3RW50cmllcy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfVxuXG4gICAgaWYgKGlzRWRpdGFibGUpIHtcbiAgICAgIHRoaXMuZW50cmllcyA9IG5ld0VudHJpZXM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEhhc2hDb2xsaXNpb25Ob2RlKG93bmVySUQsIHRoaXMua2V5SGFzaCwgbmV3RW50cmllcyk7XG4gIH07XG5cbiAgdmFyIFZhbHVlTm9kZSA9IGZ1bmN0aW9uIFZhbHVlTm9kZShvd25lcklELCBrZXlIYXNoLCBlbnRyeSkge1xuICAgIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gICAgdGhpcy5rZXlIYXNoID0ga2V5SGFzaDtcbiAgICB0aGlzLmVudHJ5ID0gZW50cnk7XG4gIH07XG5cbiAgVmFsdWVOb2RlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKHNoaWZ0LCBrZXlIYXNoLCBrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgcmV0dXJuIGlzKGtleSwgdGhpcy5lbnRyeVswXSkgPyB0aGlzLmVudHJ5WzFdIDogbm90U2V0VmFsdWU7XG4gIH07XG5cbiAgVmFsdWVOb2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcikge1xuICAgIHZhciByZW1vdmVkID0gdmFsdWUgPT09IE5PVF9TRVQ7XG4gICAgdmFyIGtleU1hdGNoID0gaXMoa2V5LCB0aGlzLmVudHJ5WzBdKTtcbiAgICBpZiAoa2V5TWF0Y2ggPyB2YWx1ZSA9PT0gdGhpcy5lbnRyeVsxXSA6IHJlbW92ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIFNldFJlZihkaWRBbHRlcik7XG5cbiAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuICAgICAgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBpZiAoa2V5TWF0Y2gpIHtcbiAgICAgIGlmIChvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRCkge1xuICAgICAgICB0aGlzLmVudHJ5WzFdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBWYWx1ZU5vZGUob3duZXJJRCwgdGhpcy5rZXlIYXNoLCBba2V5LCB2YWx1ZV0pO1xuICAgIH1cblxuICAgIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcbiAgICByZXR1cm4gbWVyZ2VJbnRvTm9kZSh0aGlzLCBvd25lcklELCBzaGlmdCwgaGFzaChrZXkpLCBba2V5LCB2YWx1ZV0pO1xuICB9O1xuXG4gIC8vICNwcmFnbWEgSXRlcmF0b3JzXG5cbiAgQXJyYXlNYXBOb2RlLnByb3RvdHlwZS5pdGVyYXRlID0gSGFzaENvbGxpc2lvbk5vZGUucHJvdG90eXBlLml0ZXJhdGUgPVxuICAgIGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG4gICAgICBmb3IgKHZhciBpaSA9IDAsIG1heEluZGV4ID0gZW50cmllcy5sZW5ndGggLSAxOyBpaSA8PSBtYXhJbmRleDsgaWkrKykge1xuICAgICAgICBpZiAoZm4oZW50cmllc1tyZXZlcnNlID8gbWF4SW5kZXggLSBpaSA6IGlpXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICBCaXRtYXBJbmRleGVkTm9kZS5wcm90b3R5cGUuaXRlcmF0ZSA9IEhhc2hBcnJheU1hcE5vZGUucHJvdG90eXBlLml0ZXJhdGUgPVxuICAgIGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgICAgIGZvciAodmFyIGlpID0gMCwgbWF4SW5kZXggPSBub2Rlcy5sZW5ndGggLSAxOyBpaSA8PSBtYXhJbmRleDsgaWkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW3JldmVyc2UgPyBtYXhJbmRleCAtIGlpIDogaWldO1xuICAgICAgICBpZiAobm9kZSAmJiBub2RlLml0ZXJhdGUoZm4sIHJldmVyc2UpID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIFZhbHVlTm9kZS5wcm90b3R5cGUuaXRlcmF0ZSA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgIHJldHVybiBmbih0aGlzLmVudHJ5KTtcbiAgfTtcblxuICB2YXIgTWFwSXRlcmF0b3IgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJdGVyYXRvcikge1xuICAgIGZ1bmN0aW9uIE1hcEl0ZXJhdG9yKG1hcCwgdHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgICB0aGlzLl9yZXZlcnNlID0gcmV2ZXJzZTtcbiAgICAgIHRoaXMuX3N0YWNrID0gbWFwLl9yb290ICYmIG1hcEl0ZXJhdG9yRnJhbWUobWFwLl9yb290KTtcbiAgICB9XG5cbiAgICBpZiAoIEl0ZXJhdG9yICkgTWFwSXRlcmF0b3IuX19wcm90b19fID0gSXRlcmF0b3I7XG4gICAgTWFwSXRlcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSXRlcmF0b3IgJiYgSXRlcmF0b3IucHJvdG90eXBlICk7XG4gICAgTWFwSXRlcmF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWFwSXRlcmF0b3I7XG5cbiAgICBNYXBJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIG5leHQgKCkge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLl90eXBlO1xuICAgICAgdmFyIHN0YWNrID0gdGhpcy5fc3RhY2s7XG4gICAgICB3aGlsZSAoc3RhY2spIHtcbiAgICAgICAgdmFyIG5vZGUgPSBzdGFjay5ub2RlO1xuICAgICAgICB2YXIgaW5kZXggPSBzdGFjay5pbmRleCsrO1xuICAgICAgICB2YXIgbWF4SW5kZXggPSAodm9pZCAwKTtcbiAgICAgICAgaWYgKG5vZGUuZW50cnkpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBtYXBJdGVyYXRvclZhbHVlKHR5cGUsIG5vZGUuZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICBtYXhJbmRleCA9IG5vZGUuZW50cmllcy5sZW5ndGggLSAxO1xuICAgICAgICAgIGlmIChpbmRleCA8PSBtYXhJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcEl0ZXJhdG9yVmFsdWUoXG4gICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIG5vZGUuZW50cmllc1t0aGlzLl9yZXZlcnNlID8gbWF4SW5kZXggLSBpbmRleCA6IGluZGV4XVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF4SW5kZXggPSBub2RlLm5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgaWYgKGluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgc3ViTm9kZSA9IG5vZGUubm9kZXNbdGhpcy5fcmV2ZXJzZSA/IG1heEluZGV4IC0gaW5kZXggOiBpbmRleF07XG4gICAgICAgICAgICBpZiAoc3ViTm9kZSkge1xuICAgICAgICAgICAgICBpZiAoc3ViTm9kZS5lbnRyeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXBJdGVyYXRvclZhbHVlKHR5cGUsIHN1Yk5vZGUuZW50cnkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0YWNrID0gdGhpcy5fc3RhY2sgPSBtYXBJdGVyYXRvckZyYW1lKHN1Yk5vZGUsIHN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFjayA9IHRoaXMuX3N0YWNrID0gdGhpcy5fc3RhY2suX19wcmV2O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gTWFwSXRlcmF0b3I7XG4gIH0oSXRlcmF0b3IpKTtcblxuICBmdW5jdGlvbiBtYXBJdGVyYXRvclZhbHVlKHR5cGUsIGVudHJ5KSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcEl0ZXJhdG9yRnJhbWUobm9kZSwgcHJldikge1xuICAgIHJldHVybiB7XG4gICAgICBub2RlOiBub2RlLFxuICAgICAgaW5kZXg6IDAsXG4gICAgICBfX3ByZXY6IHByZXYsXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VNYXAoc2l6ZSwgcm9vdCwgb3duZXJJRCwgaGFzaCkge1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKE1hcFByb3RvdHlwZSk7XG4gICAgbWFwLnNpemUgPSBzaXplO1xuICAgIG1hcC5fcm9vdCA9IHJvb3Q7XG4gICAgbWFwLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgbWFwLl9faGFzaCA9IGhhc2g7XG4gICAgbWFwLl9fYWx0ZXJlZCA9IGZhbHNlO1xuICAgIHJldHVybiBtYXA7XG4gIH1cblxuICB2YXIgRU1QVFlfTUFQO1xuICBmdW5jdGlvbiBlbXB0eU1hcCgpIHtcbiAgICByZXR1cm4gRU1QVFlfTUFQIHx8IChFTVBUWV9NQVAgPSBtYWtlTWFwKDApKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZU1hcChtYXAsIGssIHYpIHtcbiAgICB2YXIgbmV3Um9vdDtcbiAgICB2YXIgbmV3U2l6ZTtcbiAgICBpZiAoIW1hcC5fcm9vdCkge1xuICAgICAgaWYgKHYgPT09IE5PVF9TRVQpIHtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgIH1cbiAgICAgIG5ld1NpemUgPSAxO1xuICAgICAgbmV3Um9vdCA9IG5ldyBBcnJheU1hcE5vZGUobWFwLl9fb3duZXJJRCwgW1trLCB2XV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGlkQ2hhbmdlU2l6ZSA9IE1ha2VSZWYoKTtcbiAgICAgIHZhciBkaWRBbHRlciA9IE1ha2VSZWYoKTtcbiAgICAgIG5ld1Jvb3QgPSB1cGRhdGVOb2RlKFxuICAgICAgICBtYXAuX3Jvb3QsXG4gICAgICAgIG1hcC5fX293bmVySUQsXG4gICAgICAgIDAsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgayxcbiAgICAgICAgdixcbiAgICAgICAgZGlkQ2hhbmdlU2l6ZSxcbiAgICAgICAgZGlkQWx0ZXJcbiAgICAgICk7XG4gICAgICBpZiAoIWRpZEFsdGVyLnZhbHVlKSB7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgICB9XG4gICAgICBuZXdTaXplID0gbWFwLnNpemUgKyAoZGlkQ2hhbmdlU2l6ZS52YWx1ZSA/ICh2ID09PSBOT1RfU0VUID8gLTEgOiAxKSA6IDApO1xuICAgIH1cbiAgICBpZiAobWFwLl9fb3duZXJJRCkge1xuICAgICAgbWFwLnNpemUgPSBuZXdTaXplO1xuICAgICAgbWFwLl9yb290ID0gbmV3Um9vdDtcbiAgICAgIG1hcC5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICBtYXAuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIHJldHVybiBuZXdSb290ID8gbWFrZU1hcChuZXdTaXplLCBuZXdSb290KSA6IGVtcHR5TWFwKCk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVOb2RlKFxuICAgIG5vZGUsXG4gICAgb3duZXJJRCxcbiAgICBzaGlmdCxcbiAgICBrZXlIYXNoLFxuICAgIGtleSxcbiAgICB2YWx1ZSxcbiAgICBkaWRDaGFuZ2VTaXplLFxuICAgIGRpZEFsdGVyXG4gICkge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgaWYgKHZhbHVlID09PSBOT1RfU0VUKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgICAgU2V0UmVmKGRpZEFsdGVyKTtcbiAgICAgIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcbiAgICAgIHJldHVybiBuZXcgVmFsdWVOb2RlKG93bmVySUQsIGtleUhhc2gsIFtrZXksIHZhbHVlXSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlLnVwZGF0ZShcbiAgICAgIG93bmVySUQsXG4gICAgICBzaGlmdCxcbiAgICAgIGtleUhhc2gsXG4gICAgICBrZXksXG4gICAgICB2YWx1ZSxcbiAgICAgIGRpZENoYW5nZVNpemUsXG4gICAgICBkaWRBbHRlclxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0xlYWZOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgbm9kZS5jb25zdHJ1Y3RvciA9PT0gVmFsdWVOb2RlIHx8IG5vZGUuY29uc3RydWN0b3IgPT09IEhhc2hDb2xsaXNpb25Ob2RlXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlSW50b05vZGUobm9kZSwgb3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGVudHJ5KSB7XG4gICAgaWYgKG5vZGUua2V5SGFzaCA9PT0ga2V5SGFzaCkge1xuICAgICAgcmV0dXJuIG5ldyBIYXNoQ29sbGlzaW9uTm9kZShvd25lcklELCBrZXlIYXNoLCBbbm9kZS5lbnRyeSwgZW50cnldKTtcbiAgICB9XG5cbiAgICB2YXIgaWR4MSA9IChzaGlmdCA9PT0gMCA/IG5vZGUua2V5SGFzaCA6IG5vZGUua2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcbiAgICB2YXIgaWR4MiA9IChzaGlmdCA9PT0gMCA/IGtleUhhc2ggOiBrZXlIYXNoID4+PiBzaGlmdCkgJiBNQVNLO1xuXG4gICAgdmFyIG5ld05vZGU7XG4gICAgdmFyIG5vZGVzID1cbiAgICAgIGlkeDEgPT09IGlkeDJcbiAgICAgICAgPyBbbWVyZ2VJbnRvTm9kZShub2RlLCBvd25lcklELCBzaGlmdCArIFNISUZULCBrZXlIYXNoLCBlbnRyeSldXG4gICAgICAgIDogKChuZXdOb2RlID0gbmV3IFZhbHVlTm9kZShvd25lcklELCBrZXlIYXNoLCBlbnRyeSkpLFxuICAgICAgICAgIGlkeDEgPCBpZHgyID8gW25vZGUsIG5ld05vZGVdIDogW25ld05vZGUsIG5vZGVdKTtcblxuICAgIHJldHVybiBuZXcgQml0bWFwSW5kZXhlZE5vZGUob3duZXJJRCwgKDEgPDwgaWR4MSkgfCAoMSA8PCBpZHgyKSwgbm9kZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZXMob3duZXJJRCwgZW50cmllcywga2V5LCB2YWx1ZSkge1xuICAgIGlmICghb3duZXJJRCkge1xuICAgICAgb3duZXJJRCA9IG5ldyBPd25lcklEKCk7XG4gICAgfVxuICAgIHZhciBub2RlID0gbmV3IFZhbHVlTm9kZShvd25lcklELCBoYXNoKGtleSksIFtrZXksIHZhbHVlXSk7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGVudHJpZXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2lpXTtcbiAgICAgIG5vZGUgPSBub2RlLnVwZGF0ZShvd25lcklELCAwLCB1bmRlZmluZWQsIGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFja05vZGVzKG93bmVySUQsIG5vZGVzLCBjb3VudCwgZXhjbHVkaW5nKSB7XG4gICAgdmFyIGJpdG1hcCA9IDA7XG4gICAgdmFyIHBhY2tlZElJID0gMDtcbiAgICB2YXIgcGFja2VkTm9kZXMgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAodmFyIGlpID0gMCwgYml0ID0gMSwgbGVuID0gbm9kZXMubGVuZ3RoOyBpaSA8IGxlbjsgaWkrKywgYml0IDw8PSAxKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2lpXTtcbiAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgaWkgIT09IGV4Y2x1ZGluZykge1xuICAgICAgICBiaXRtYXAgfD0gYml0O1xuICAgICAgICBwYWNrZWROb2Rlc1twYWNrZWRJSSsrXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQml0bWFwSW5kZXhlZE5vZGUob3duZXJJRCwgYml0bWFwLCBwYWNrZWROb2Rlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBleHBhbmROb2Rlcyhvd25lcklELCBub2RlcywgYml0bWFwLCBpbmNsdWRpbmcsIG5vZGUpIHtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBleHBhbmRlZE5vZGVzID0gbmV3IEFycmF5KFNJWkUpO1xuICAgIGZvciAodmFyIGlpID0gMDsgYml0bWFwICE9PSAwOyBpaSsrLCBiaXRtYXAgPj4+PSAxKSB7XG4gICAgICBleHBhbmRlZE5vZGVzW2lpXSA9IGJpdG1hcCAmIDEgPyBub2Rlc1tjb3VudCsrXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZXhwYW5kZWROb2Rlc1tpbmNsdWRpbmddID0gbm9kZTtcbiAgICByZXR1cm4gbmV3IEhhc2hBcnJheU1hcE5vZGUob3duZXJJRCwgY291bnQgKyAxLCBleHBhbmRlZE5vZGVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcENvdW50KHgpIHtcbiAgICB4IC09ICh4ID4+IDEpICYgMHg1NTU1NTU1NTtcbiAgICB4ID0gKHggJiAweDMzMzMzMzMzKSArICgoeCA+PiAyKSAmIDB4MzMzMzMzMzMpO1xuICAgIHggPSAoeCArICh4ID4+IDQpKSAmIDB4MGYwZjBmMGY7XG4gICAgeCArPSB4ID4+IDg7XG4gICAgeCArPSB4ID4+IDE2O1xuICAgIHJldHVybiB4ICYgMHg3ZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEF0KGFycmF5LCBpZHgsIHZhbCwgY2FuRWRpdCkge1xuICAgIHZhciBuZXdBcnJheSA9IGNhbkVkaXQgPyBhcnJheSA6IGFyckNvcHkoYXJyYXkpO1xuICAgIG5ld0FycmF5W2lkeF0gPSB2YWw7XG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9XG5cbiAgZnVuY3Rpb24gc3BsaWNlSW4oYXJyYXksIGlkeCwgdmFsLCBjYW5FZGl0KSB7XG4gICAgdmFyIG5ld0xlbiA9IGFycmF5Lmxlbmd0aCArIDE7XG4gICAgaWYgKGNhbkVkaXQgJiYgaWR4ICsgMSA9PT0gbmV3TGVuKSB7XG4gICAgICBhcnJheVtpZHhdID0gdmFsO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgICB2YXIgbmV3QXJyYXkgPSBuZXcgQXJyYXkobmV3TGVuKTtcbiAgICB2YXIgYWZ0ZXIgPSAwO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBuZXdMZW47IGlpKyspIHtcbiAgICAgIGlmIChpaSA9PT0gaWR4KSB7XG4gICAgICAgIG5ld0FycmF5W2lpXSA9IHZhbDtcbiAgICAgICAgYWZ0ZXIgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0FycmF5W2lpXSA9IGFycmF5W2lpICsgYWZ0ZXJdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3QXJyYXk7XG4gIH1cblxuICBmdW5jdGlvbiBzcGxpY2VPdXQoYXJyYXksIGlkeCwgY2FuRWRpdCkge1xuICAgIHZhciBuZXdMZW4gPSBhcnJheS5sZW5ndGggLSAxO1xuICAgIGlmIChjYW5FZGl0ICYmIGlkeCA9PT0gbmV3TGVuKSB7XG4gICAgICBhcnJheS5wb3AoKTtcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG4gICAgdmFyIG5ld0FycmF5ID0gbmV3IEFycmF5KG5ld0xlbik7XG4gICAgdmFyIGFmdGVyID0gMDtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbmV3TGVuOyBpaSsrKSB7XG4gICAgICBpZiAoaWkgPT09IGlkeCkge1xuICAgICAgICBhZnRlciA9IDE7XG4gICAgICB9XG4gICAgICBuZXdBcnJheVtpaV0gPSBhcnJheVtpaSArIGFmdGVyXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9XG5cbiAgdmFyIE1BWF9BUlJBWV9NQVBfU0laRSA9IFNJWkUgLyA0O1xuICB2YXIgTUFYX0JJVE1BUF9JTkRFWEVEX1NJWkUgPSBTSVpFIC8gMjtcbiAgdmFyIE1JTl9IQVNIX0FSUkFZX01BUF9TSVpFID0gU0laRSAvIDQ7XG5cbiAgdmFyIElTX0xJU1RfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfTElTVF9fQEAnO1xuXG4gIGZ1bmN0aW9uIGlzTGlzdChtYXliZUxpc3QpIHtcbiAgICByZXR1cm4gQm9vbGVhbihtYXliZUxpc3QgJiYgbWF5YmVMaXN0W0lTX0xJU1RfU1lNQk9MXSk7XG4gIH1cblxuICB2YXIgTGlzdCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEluZGV4ZWRDb2xsZWN0aW9uKSB7XG4gICAgZnVuY3Rpb24gTGlzdCh2YWx1ZSkge1xuICAgICAgdmFyIGVtcHR5ID0gZW1wdHlMaXN0KCk7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgICB9XG4gICAgICBpZiAoaXNMaXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgaXRlciA9IEluZGV4ZWRDb2xsZWN0aW9uKHZhbHVlKTtcbiAgICAgIHZhciBzaXplID0gaXRlci5zaXplO1xuICAgICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgICAgfVxuICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoc2l6ZSk7XG4gICAgICBpZiAoc2l6ZSA+IDAgJiYgc2l6ZSA8IFNJWkUpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VMaXN0KDAsIHNpemUsIFNISUZULCBudWxsLCBuZXcgVk5vZGUoaXRlci50b0FycmF5KCkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eS53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgIGxpc3Quc2V0U2l6ZShzaXplKTtcbiAgICAgICAgaXRlci5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7IHJldHVybiBsaXN0LnNldChpLCB2KTsgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIEluZGV4ZWRDb2xsZWN0aW9uICkgTGlzdC5fX3Byb3RvX18gPSBJbmRleGVkQ29sbGVjdGlvbjtcbiAgICBMaXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEluZGV4ZWRDb2xsZWN0aW9uICYmIEluZGV4ZWRDb2xsZWN0aW9uLnByb3RvdHlwZSApO1xuICAgIExpc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGlzdDtcblxuICAgIExpc3Qub2YgPSBmdW5jdGlvbiBvZiAoLyouLi52YWx1ZXMqLykge1xuICAgICAgcmV0dXJuIHRoaXMoYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdMaXN0IFsnLCAnXScpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIEFjY2Vzc1xuXG4gICAgTGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5zaXplKSB7XG4gICAgICAgIGluZGV4ICs9IHRoaXMuX29yaWdpbjtcbiAgICAgICAgdmFyIG5vZGUgPSBsaXN0Tm9kZUZvcih0aGlzLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBub2RlICYmIG5vZGUuYXJyYXlbaW5kZXggJiBNQVNLXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICAgIExpc3QucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoaW5kZXgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdXBkYXRlTGlzdCh0aGlzLCBpbmRleCwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKGluZGV4KSB7XG4gICAgICByZXR1cm4gIXRoaXMuaGFzKGluZGV4KVxuICAgICAgICA/IHRoaXNcbiAgICAgICAgOiBpbmRleCA9PT0gMFxuICAgICAgICA/IHRoaXMuc2hpZnQoKVxuICAgICAgICA6IGluZGV4ID09PSB0aGlzLnNpemUgLSAxXG4gICAgICAgID8gdGhpcy5wb3AoKVxuICAgICAgICA6IHRoaXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gaW5zZXJ0IChpbmRleCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnNwbGljZShpbmRleCwgMCwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5fb3JpZ2luID0gdGhpcy5fY2FwYWNpdHkgPSAwO1xuICAgICAgICB0aGlzLl9sZXZlbCA9IFNISUZUO1xuICAgICAgICB0aGlzLl9yb290ID0gdGhpcy5fdGFpbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5TGlzdCgpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAoLyouLi52YWx1ZXMqLykge1xuICAgICAgdmFyIHZhbHVlcyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBvbGRTaXplID0gdGhpcy5zaXplO1xuICAgICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICBzZXRMaXN0Qm91bmRzKGxpc3QsIDAsIG9sZFNpemUgKyB2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHZhbHVlcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICBsaXN0LnNldChvbGRTaXplICsgaWksIHZhbHVlc1tpaV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gcG9wICgpIHtcbiAgICAgIHJldHVybiBzZXRMaXN0Qm91bmRzKHRoaXMsIDAsIC0xKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIHVuc2hpZnQgKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBhcmd1bWVudHM7XG4gICAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgIHNldExpc3RCb3VuZHMobGlzdCwgLXZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgdmFsdWVzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgIGxpc3Quc2V0KGlpLCB2YWx1ZXNbaWldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gc2hpZnQgKCkge1xuICAgICAgcmV0dXJuIHNldExpc3RCb3VuZHModGhpcywgMSk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQ29tcG9zaXRpb25cblxuICAgIExpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAoLyouLi5jb2xsZWN0aW9ucyovKSB7XG4gICAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICAgIHZhciBzZXFzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXJndW1lbnQgPSBhcmd1bWVudHMkMVtpXTtcbiAgICAgICAgdmFyIHNlcSA9IEluZGV4ZWRDb2xsZWN0aW9uKFxuICAgICAgICAgIHR5cGVvZiBhcmd1bWVudCAhPT0gJ3N0cmluZycgJiYgaGFzSXRlcmF0b3IoYXJndW1lbnQpXG4gICAgICAgICAgICA/IGFyZ3VtZW50XG4gICAgICAgICAgICA6IFthcmd1bWVudF1cbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHNlcS5zaXplICE9PSAwKSB7XG4gICAgICAgICAgc2Vxcy5wdXNoKHNlcSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZXFzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDAgJiYgIXRoaXMuX19vd25lcklEICYmIHNlcXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKHNlcXNbMF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICBzZXFzLmZvckVhY2goZnVuY3Rpb24gKHNlcSkgeyByZXR1cm4gc2VxLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBsaXN0LnB1c2godmFsdWUpOyB9KTsgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uIHNldFNpemUgKHNpemUpIHtcbiAgICAgIHJldHVybiBzZXRMaXN0Qm91bmRzKHRoaXMsIDAsIHNpemUpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKG1hcHBlciwgY29udGV4dCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzJDEuc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgbGlzdC5zZXQoaSwgbWFwcGVyLmNhbGwoY29udGV4dCwgbGlzdC5nZXQoaSksIGksIGxpc3QpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgSXRlcmF0aW9uXG5cbiAgICBMaXN0LnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChiZWdpbiwgZW5kKSB7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgIGlmICh3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIHNpemUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldExpc3RCb3VuZHMoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHJlc29sdmVCZWdpbihiZWdpbiwgc2l6ZSksXG4gICAgICAgIHJlc29sdmVFbmQoZW5kLCBzaXplKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBpbmRleCA9IHJldmVyc2UgPyB0aGlzLnNpemUgOiAwO1xuICAgICAgdmFyIHZhbHVlcyA9IGl0ZXJhdGVMaXN0KHRoaXMsIHJldmVyc2UpO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlcygpO1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IERPTkVcbiAgICAgICAgICA/IGl0ZXJhdG9yRG9uZSgpXG4gICAgICAgICAgOiBpdGVyYXRvclZhbHVlKHR5cGUsIHJldmVyc2UgPyAtLWluZGV4IDogaW5kZXgrKywgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciBpbmRleCA9IHJldmVyc2UgPyB0aGlzLnNpemUgOiAwO1xuICAgICAgdmFyIHZhbHVlcyA9IGl0ZXJhdGVMaXN0KHRoaXMsIHJldmVyc2UpO1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgd2hpbGUgKCh2YWx1ZSA9IHZhbHVlcygpKSAhPT0gRE9ORSkge1xuICAgICAgICBpZiAoZm4odmFsdWUsIHJldmVyc2UgPyAtLWluZGV4IDogaW5kZXgrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uIF9fZW5zdXJlT3duZXIgKG93bmVySUQpIHtcbiAgICAgIGlmIChvd25lcklEID09PSB0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICghb3duZXJJRCkge1xuICAgICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGVtcHR5TGlzdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFrZUxpc3QoXG4gICAgICAgIHRoaXMuX29yaWdpbixcbiAgICAgICAgdGhpcy5fY2FwYWNpdHksXG4gICAgICAgIHRoaXMuX2xldmVsLFxuICAgICAgICB0aGlzLl9yb290LFxuICAgICAgICB0aGlzLl90YWlsLFxuICAgICAgICBvd25lcklELFxuICAgICAgICB0aGlzLl9faGFzaFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIExpc3Q7XG4gIH0oSW5kZXhlZENvbGxlY3Rpb24pKTtcblxuICBMaXN0LmlzTGlzdCA9IGlzTGlzdDtcblxuICB2YXIgTGlzdFByb3RvdHlwZSA9IExpc3QucHJvdG90eXBlO1xuICBMaXN0UHJvdG90eXBlW0lTX0xJU1RfU1lNQk9MXSA9IHRydWU7XG4gIExpc3RQcm90b3R5cGVbREVMRVRFXSA9IExpc3RQcm90b3R5cGUucmVtb3ZlO1xuICBMaXN0UHJvdG90eXBlLm1lcmdlID0gTGlzdFByb3RvdHlwZS5jb25jYXQ7XG4gIExpc3RQcm90b3R5cGUuc2V0SW4gPSBzZXRJbiQxO1xuICBMaXN0UHJvdG90eXBlLmRlbGV0ZUluID0gTGlzdFByb3RvdHlwZS5yZW1vdmVJbiA9IGRlbGV0ZUluO1xuICBMaXN0UHJvdG90eXBlLnVwZGF0ZSA9IHVwZGF0ZSQxO1xuICBMaXN0UHJvdG90eXBlLnVwZGF0ZUluID0gdXBkYXRlSW4kMTtcbiAgTGlzdFByb3RvdHlwZS5tZXJnZUluID0gbWVyZ2VJbjtcbiAgTGlzdFByb3RvdHlwZS5tZXJnZURlZXBJbiA9IG1lcmdlRGVlcEluO1xuICBMaXN0UHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSB3aXRoTXV0YXRpb25zO1xuICBMaXN0UHJvdG90eXBlLndhc0FsdGVyZWQgPSB3YXNBbHRlcmVkO1xuICBMaXN0UHJvdG90eXBlLmFzSW1tdXRhYmxlID0gYXNJbW11dGFibGU7XG4gIExpc3RQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBMaXN0UHJvdG90eXBlLmFzTXV0YWJsZSA9IGFzTXV0YWJsZTtcbiAgTGlzdFByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGFycikge1xuICAgIHJldHVybiByZXN1bHQucHVzaChhcnIpO1xuICB9O1xuICBMaXN0UHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iai5hc0ltbXV0YWJsZSgpO1xuICB9O1xuXG4gIHZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlKGFycmF5LCBvd25lcklEKSB7XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICAgIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gIH07XG5cbiAgLy8gVE9ETzogc2VlbXMgbGlrZSB0aGVzZSBtZXRob2RzIGFyZSB2ZXJ5IHNpbWlsYXJcblxuICBWTm9kZS5wcm90b3R5cGUucmVtb3ZlQmVmb3JlID0gZnVuY3Rpb24gcmVtb3ZlQmVmb3JlIChvd25lcklELCBsZXZlbCwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPT09IGxldmVsID8gMSA8PCBsZXZlbCA6ICB0aGlzLmFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBvcmlnaW5JbmRleCA9IChpbmRleCA+Pj4gbGV2ZWwpICYgTUFTSztcbiAgICBpZiAob3JpZ2luSW5kZXggPj0gdGhpcy5hcnJheS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBuZXcgVk5vZGUoW10sIG93bmVySUQpO1xuICAgIH1cbiAgICB2YXIgcmVtb3ZpbmdGaXJzdCA9IG9yaWdpbkluZGV4ID09PSAwO1xuICAgIHZhciBuZXdDaGlsZDtcbiAgICBpZiAobGV2ZWwgPiAwKSB7XG4gICAgICB2YXIgb2xkQ2hpbGQgPSB0aGlzLmFycmF5W29yaWdpbkluZGV4XTtcbiAgICAgIG5ld0NoaWxkID1cbiAgICAgICAgb2xkQ2hpbGQgJiYgb2xkQ2hpbGQucmVtb3ZlQmVmb3JlKG93bmVySUQsIGxldmVsIC0gU0hJRlQsIGluZGV4KTtcbiAgICAgIGlmIChuZXdDaGlsZCA9PT0gb2xkQ2hpbGQgJiYgcmVtb3ZpbmdGaXJzdCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlbW92aW5nRmlyc3QgJiYgIW5ld0NoaWxkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIGVkaXRhYmxlID0gZWRpdGFibGVWTm9kZSh0aGlzLCBvd25lcklEKTtcbiAgICBpZiAoIXJlbW92aW5nRmlyc3QpIHtcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBvcmlnaW5JbmRleDsgaWkrKykge1xuICAgICAgICBlZGl0YWJsZS5hcnJheVtpaV0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXdDaGlsZCkge1xuICAgICAgZWRpdGFibGUuYXJyYXlbb3JpZ2luSW5kZXhdID0gbmV3Q2hpbGQ7XG4gICAgfVxuICAgIHJldHVybiBlZGl0YWJsZTtcbiAgfTtcblxuICBWTm9kZS5wcm90b3R5cGUucmVtb3ZlQWZ0ZXIgPSBmdW5jdGlvbiByZW1vdmVBZnRlciAob3duZXJJRCwgbGV2ZWwsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSAobGV2ZWwgPyAxIDw8IGxldmVsIDogMCkgfHwgdGhpcy5hcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgc2l6ZUluZGV4ID0gKChpbmRleCAtIDEpID4+PiBsZXZlbCkgJiBNQVNLO1xuICAgIGlmIChzaXplSW5kZXggPj0gdGhpcy5hcnJheS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBuZXdDaGlsZDtcbiAgICBpZiAobGV2ZWwgPiAwKSB7XG4gICAgICB2YXIgb2xkQ2hpbGQgPSB0aGlzLmFycmF5W3NpemVJbmRleF07XG4gICAgICBuZXdDaGlsZCA9XG4gICAgICAgIG9sZENoaWxkICYmIG9sZENoaWxkLnJlbW92ZUFmdGVyKG93bmVySUQsIGxldmVsIC0gU0hJRlQsIGluZGV4KTtcbiAgICAgIGlmIChuZXdDaGlsZCA9PT0gb2xkQ2hpbGQgJiYgc2l6ZUluZGV4ID09PSB0aGlzLmFycmF5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVkaXRhYmxlID0gZWRpdGFibGVWTm9kZSh0aGlzLCBvd25lcklEKTtcbiAgICBlZGl0YWJsZS5hcnJheS5zcGxpY2Uoc2l6ZUluZGV4ICsgMSk7XG4gICAgaWYgKG5ld0NoaWxkKSB7XG4gICAgICBlZGl0YWJsZS5hcnJheVtzaXplSW5kZXhdID0gbmV3Q2hpbGQ7XG4gICAgfVxuICAgIHJldHVybiBlZGl0YWJsZTtcbiAgfTtcblxuICB2YXIgRE9ORSA9IHt9O1xuXG4gIGZ1bmN0aW9uIGl0ZXJhdGVMaXN0KGxpc3QsIHJldmVyc2UpIHtcbiAgICB2YXIgbGVmdCA9IGxpc3QuX29yaWdpbjtcbiAgICB2YXIgcmlnaHQgPSBsaXN0Ll9jYXBhY2l0eTtcbiAgICB2YXIgdGFpbFBvcyA9IGdldFRhaWxPZmZzZXQocmlnaHQpO1xuICAgIHZhciB0YWlsID0gbGlzdC5fdGFpbDtcblxuICAgIHJldHVybiBpdGVyYXRlTm9kZU9yTGVhZihsaXN0Ll9yb290LCBsaXN0Ll9sZXZlbCwgMCk7XG5cbiAgICBmdW5jdGlvbiBpdGVyYXRlTm9kZU9yTGVhZihub2RlLCBsZXZlbCwgb2Zmc2V0KSB7XG4gICAgICByZXR1cm4gbGV2ZWwgPT09IDBcbiAgICAgICAgPyBpdGVyYXRlTGVhZihub2RlLCBvZmZzZXQpXG4gICAgICAgIDogaXRlcmF0ZU5vZGUobm9kZSwgbGV2ZWwsIG9mZnNldCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXRlcmF0ZUxlYWYobm9kZSwgb2Zmc2V0KSB7XG4gICAgICB2YXIgYXJyYXkgPSBvZmZzZXQgPT09IHRhaWxQb3MgPyB0YWlsICYmIHRhaWwuYXJyYXkgOiBub2RlICYmIG5vZGUuYXJyYXk7XG4gICAgICB2YXIgZnJvbSA9IG9mZnNldCA+IGxlZnQgPyAwIDogbGVmdCAtIG9mZnNldDtcbiAgICAgIHZhciB0byA9IHJpZ2h0IC0gb2Zmc2V0O1xuICAgICAgaWYgKHRvID4gU0laRSkge1xuICAgICAgICB0byA9IFNJWkU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgICByZXR1cm4gRE9ORTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWR4ID0gcmV2ZXJzZSA/IC0tdG8gOiBmcm9tKys7XG4gICAgICAgIHJldHVybiBhcnJheSAmJiBhcnJheVtpZHhdO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpdGVyYXRlTm9kZShub2RlLCBsZXZlbCwgb2Zmc2V0KSB7XG4gICAgICB2YXIgdmFsdWVzO1xuICAgICAgdmFyIGFycmF5ID0gbm9kZSAmJiBub2RlLmFycmF5O1xuICAgICAgdmFyIGZyb20gPSBvZmZzZXQgPiBsZWZ0ID8gMCA6IChsZWZ0IC0gb2Zmc2V0KSA+PiBsZXZlbDtcbiAgICAgIHZhciB0byA9ICgocmlnaHQgLSBvZmZzZXQpID4+IGxldmVsKSArIDE7XG4gICAgICBpZiAodG8gPiBTSVpFKSB7XG4gICAgICAgIHRvID0gU0laRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IERPTkUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAgICAgICByZXR1cm4gRE9ORTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGlkeCA9IHJldmVyc2UgPyAtLXRvIDogZnJvbSsrO1xuICAgICAgICAgIHZhbHVlcyA9IGl0ZXJhdGVOb2RlT3JMZWFmKFxuICAgICAgICAgICAgYXJyYXkgJiYgYXJyYXlbaWR4XSxcbiAgICAgICAgICAgIGxldmVsIC0gU0hJRlQsXG4gICAgICAgICAgICBvZmZzZXQgKyAoaWR4IDw8IGxldmVsKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFrZUxpc3Qob3JpZ2luLCBjYXBhY2l0eSwgbGV2ZWwsIHJvb3QsIHRhaWwsIG93bmVySUQsIGhhc2gpIHtcbiAgICB2YXIgbGlzdCA9IE9iamVjdC5jcmVhdGUoTGlzdFByb3RvdHlwZSk7XG4gICAgbGlzdC5zaXplID0gY2FwYWNpdHkgLSBvcmlnaW47XG4gICAgbGlzdC5fb3JpZ2luID0gb3JpZ2luO1xuICAgIGxpc3QuX2NhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgbGlzdC5fbGV2ZWwgPSBsZXZlbDtcbiAgICBsaXN0Ll9yb290ID0gcm9vdDtcbiAgICBsaXN0Ll90YWlsID0gdGFpbDtcbiAgICBsaXN0Ll9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgbGlzdC5fX2hhc2ggPSBoYXNoO1xuICAgIGxpc3QuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cblxuICB2YXIgRU1QVFlfTElTVDtcbiAgZnVuY3Rpb24gZW1wdHlMaXN0KCkge1xuICAgIHJldHVybiBFTVBUWV9MSVNUIHx8IChFTVBUWV9MSVNUID0gbWFrZUxpc3QoMCwgMCwgU0hJRlQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpc3QobGlzdCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgaW5kZXggPSB3cmFwSW5kZXgobGlzdCwgaW5kZXgpO1xuXG4gICAgaWYgKGluZGV4ICE9PSBpbmRleCkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ID49IGxpc3Quc2l6ZSB8fCBpbmRleCA8IDApIHtcbiAgICAgIHJldHVybiBsaXN0LndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgaW5kZXggPCAwXG4gICAgICAgICAgPyBzZXRMaXN0Qm91bmRzKGxpc3QsIGluZGV4KS5zZXQoMCwgdmFsdWUpXG4gICAgICAgICAgOiBzZXRMaXN0Qm91bmRzKGxpc3QsIDAsIGluZGV4ICsgMSkuc2V0KGluZGV4LCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpbmRleCArPSBsaXN0Ll9vcmlnaW47XG5cbiAgICB2YXIgbmV3VGFpbCA9IGxpc3QuX3RhaWw7XG4gICAgdmFyIG5ld1Jvb3QgPSBsaXN0Ll9yb290O1xuICAgIHZhciBkaWRBbHRlciA9IE1ha2VSZWYoKTtcbiAgICBpZiAoaW5kZXggPj0gZ2V0VGFpbE9mZnNldChsaXN0Ll9jYXBhY2l0eSkpIHtcbiAgICAgIG5ld1RhaWwgPSB1cGRhdGVWTm9kZShuZXdUYWlsLCBsaXN0Ll9fb3duZXJJRCwgMCwgaW5kZXgsIHZhbHVlLCBkaWRBbHRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1Jvb3QgPSB1cGRhdGVWTm9kZShcbiAgICAgICAgbmV3Um9vdCxcbiAgICAgICAgbGlzdC5fX293bmVySUQsXG4gICAgICAgIGxpc3QuX2xldmVsLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRpZEFsdGVyXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghZGlkQWx0ZXIudmFsdWUpIHtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cblxuICAgIGlmIChsaXN0Ll9fb3duZXJJRCkge1xuICAgICAgbGlzdC5fcm9vdCA9IG5ld1Jvb3Q7XG4gICAgICBsaXN0Ll90YWlsID0gbmV3VGFpbDtcbiAgICAgIGxpc3QuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgbGlzdC5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICAgIHJldHVybiBtYWtlTGlzdChsaXN0Ll9vcmlnaW4sIGxpc3QuX2NhcGFjaXR5LCBsaXN0Ll9sZXZlbCwgbmV3Um9vdCwgbmV3VGFpbCk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVWTm9kZShub2RlLCBvd25lcklELCBsZXZlbCwgaW5kZXgsIHZhbHVlLCBkaWRBbHRlcikge1xuICAgIHZhciBpZHggPSAoaW5kZXggPj4+IGxldmVsKSAmIE1BU0s7XG4gICAgdmFyIG5vZGVIYXMgPSBub2RlICYmIGlkeCA8IG5vZGUuYXJyYXkubGVuZ3RoO1xuICAgIGlmICghbm9kZUhhcyAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICB2YXIgbmV3Tm9kZTtcblxuICAgIGlmIChsZXZlbCA+IDApIHtcbiAgICAgIHZhciBsb3dlck5vZGUgPSBub2RlICYmIG5vZGUuYXJyYXlbaWR4XTtcbiAgICAgIHZhciBuZXdMb3dlck5vZGUgPSB1cGRhdGVWTm9kZShcbiAgICAgICAgbG93ZXJOb2RlLFxuICAgICAgICBvd25lcklELFxuICAgICAgICBsZXZlbCAtIFNISUZULFxuICAgICAgICBpbmRleCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRpZEFsdGVyXG4gICAgICApO1xuICAgICAgaWYgKG5ld0xvd2VyTm9kZSA9PT0gbG93ZXJOb2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgICAgbmV3Tm9kZSA9IGVkaXRhYmxlVk5vZGUobm9kZSwgb3duZXJJRCk7XG4gICAgICBuZXdOb2RlLmFycmF5W2lkeF0gPSBuZXdMb3dlck5vZGU7XG4gICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZUhhcyAmJiBub2RlLmFycmF5W2lkeF0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICBpZiAoZGlkQWx0ZXIpIHtcbiAgICAgIFNldFJlZihkaWRBbHRlcik7XG4gICAgfVxuXG4gICAgbmV3Tm9kZSA9IGVkaXRhYmxlVk5vZGUobm9kZSwgb3duZXJJRCk7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgaWR4ID09PSBuZXdOb2RlLmFycmF5Lmxlbmd0aCAtIDEpIHtcbiAgICAgIG5ld05vZGUuYXJyYXkucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld05vZGUuYXJyYXlbaWR4XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3Tm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVkaXRhYmxlVk5vZGUobm9kZSwgb3duZXJJRCkge1xuICAgIGlmIChvd25lcklEICYmIG5vZGUgJiYgb3duZXJJRCA9PT0gbm9kZS5vd25lcklEKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBWTm9kZShub2RlID8gbm9kZS5hcnJheS5zbGljZSgpIDogW10sIG93bmVySUQpO1xuICB9XG5cbiAgZnVuY3Rpb24gbGlzdE5vZGVGb3IobGlzdCwgcmF3SW5kZXgpIHtcbiAgICBpZiAocmF3SW5kZXggPj0gZ2V0VGFpbE9mZnNldChsaXN0Ll9jYXBhY2l0eSkpIHtcbiAgICAgIHJldHVybiBsaXN0Ll90YWlsO1xuICAgIH1cbiAgICBpZiAocmF3SW5kZXggPCAxIDw8IChsaXN0Ll9sZXZlbCArIFNISUZUKSkge1xuICAgICAgdmFyIG5vZGUgPSBsaXN0Ll9yb290O1xuICAgICAgdmFyIGxldmVsID0gbGlzdC5fbGV2ZWw7XG4gICAgICB3aGlsZSAobm9kZSAmJiBsZXZlbCA+IDApIHtcbiAgICAgICAgbm9kZSA9IG5vZGUuYXJyYXlbKHJhd0luZGV4ID4+PiBsZXZlbCkgJiBNQVNLXTtcbiAgICAgICAgbGV2ZWwgLT0gU0hJRlQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRMaXN0Qm91bmRzKGxpc3QsIGJlZ2luLCBlbmQpIHtcbiAgICAvLyBTYW5pdGl6ZSBiZWdpbiAmIGVuZCB1c2luZyB0aGlzIHNob3J0aGFuZCBmb3IgVG9JbnQzMihhcmd1bWVudClcbiAgICAvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9pbnQzMlxuICAgIGlmIChiZWdpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBiZWdpbiB8PSAwO1xuICAgIH1cbiAgICBpZiAoZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuZCB8PSAwO1xuICAgIH1cbiAgICB2YXIgb3duZXIgPSBsaXN0Ll9fb3duZXJJRCB8fCBuZXcgT3duZXJJRCgpO1xuICAgIHZhciBvbGRPcmlnaW4gPSBsaXN0Ll9vcmlnaW47XG4gICAgdmFyIG9sZENhcGFjaXR5ID0gbGlzdC5fY2FwYWNpdHk7XG4gICAgdmFyIG5ld09yaWdpbiA9IG9sZE9yaWdpbiArIGJlZ2luO1xuICAgIHZhciBuZXdDYXBhY2l0eSA9XG4gICAgICBlbmQgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9sZENhcGFjaXR5XG4gICAgICAgIDogZW5kIDwgMFxuICAgICAgICA/IG9sZENhcGFjaXR5ICsgZW5kXG4gICAgICAgIDogb2xkT3JpZ2luICsgZW5kO1xuICAgIGlmIChuZXdPcmlnaW4gPT09IG9sZE9yaWdpbiAmJiBuZXdDYXBhY2l0eSA9PT0gb2xkQ2FwYWNpdHkpIHtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cblxuICAgIC8vIElmIGl0J3MgZ29pbmcgdG8gZW5kIGFmdGVyIGl0IHN0YXJ0cywgaXQncyBlbXB0eS5cbiAgICBpZiAobmV3T3JpZ2luID49IG5ld0NhcGFjaXR5KSB7XG4gICAgICByZXR1cm4gbGlzdC5jbGVhcigpO1xuICAgIH1cblxuICAgIHZhciBuZXdMZXZlbCA9IGxpc3QuX2xldmVsO1xuICAgIHZhciBuZXdSb290ID0gbGlzdC5fcm9vdDtcblxuICAgIC8vIE5ldyBvcmlnaW4gbWlnaHQgbmVlZCBjcmVhdGluZyBhIGhpZ2hlciByb290LlxuICAgIHZhciBvZmZzZXRTaGlmdCA9IDA7XG4gICAgd2hpbGUgKG5ld09yaWdpbiArIG9mZnNldFNoaWZ0IDwgMCkge1xuICAgICAgbmV3Um9vdCA9IG5ldyBWTm9kZShcbiAgICAgICAgbmV3Um9vdCAmJiBuZXdSb290LmFycmF5Lmxlbmd0aCA/IFt1bmRlZmluZWQsIG5ld1Jvb3RdIDogW10sXG4gICAgICAgIG93bmVyXG4gICAgICApO1xuICAgICAgbmV3TGV2ZWwgKz0gU0hJRlQ7XG4gICAgICBvZmZzZXRTaGlmdCArPSAxIDw8IG5ld0xldmVsO1xuICAgIH1cbiAgICBpZiAob2Zmc2V0U2hpZnQpIHtcbiAgICAgIG5ld09yaWdpbiArPSBvZmZzZXRTaGlmdDtcbiAgICAgIG9sZE9yaWdpbiArPSBvZmZzZXRTaGlmdDtcbiAgICAgIG5ld0NhcGFjaXR5ICs9IG9mZnNldFNoaWZ0O1xuICAgICAgb2xkQ2FwYWNpdHkgKz0gb2Zmc2V0U2hpZnQ7XG4gICAgfVxuXG4gICAgdmFyIG9sZFRhaWxPZmZzZXQgPSBnZXRUYWlsT2Zmc2V0KG9sZENhcGFjaXR5KTtcbiAgICB2YXIgbmV3VGFpbE9mZnNldCA9IGdldFRhaWxPZmZzZXQobmV3Q2FwYWNpdHkpO1xuXG4gICAgLy8gTmV3IHNpemUgbWlnaHQgbmVlZCBjcmVhdGluZyBhIGhpZ2hlciByb290LlxuICAgIHdoaWxlIChuZXdUYWlsT2Zmc2V0ID49IDEgPDwgKG5ld0xldmVsICsgU0hJRlQpKSB7XG4gICAgICBuZXdSb290ID0gbmV3IFZOb2RlKFxuICAgICAgICBuZXdSb290ICYmIG5ld1Jvb3QuYXJyYXkubGVuZ3RoID8gW25ld1Jvb3RdIDogW10sXG4gICAgICAgIG93bmVyXG4gICAgICApO1xuICAgICAgbmV3TGV2ZWwgKz0gU0hJRlQ7XG4gICAgfVxuXG4gICAgLy8gTG9jYXRlIG9yIGNyZWF0ZSB0aGUgbmV3IHRhaWwuXG4gICAgdmFyIG9sZFRhaWwgPSBsaXN0Ll90YWlsO1xuICAgIHZhciBuZXdUYWlsID1cbiAgICAgIG5ld1RhaWxPZmZzZXQgPCBvbGRUYWlsT2Zmc2V0XG4gICAgICAgID8gbGlzdE5vZGVGb3IobGlzdCwgbmV3Q2FwYWNpdHkgLSAxKVxuICAgICAgICA6IG5ld1RhaWxPZmZzZXQgPiBvbGRUYWlsT2Zmc2V0XG4gICAgICAgID8gbmV3IFZOb2RlKFtdLCBvd25lcilcbiAgICAgICAgOiBvbGRUYWlsO1xuXG4gICAgLy8gTWVyZ2UgVGFpbCBpbnRvIHRyZWUuXG4gICAgaWYgKFxuICAgICAgb2xkVGFpbCAmJlxuICAgICAgbmV3VGFpbE9mZnNldCA+IG9sZFRhaWxPZmZzZXQgJiZcbiAgICAgIG5ld09yaWdpbiA8IG9sZENhcGFjaXR5ICYmXG4gICAgICBvbGRUYWlsLmFycmF5Lmxlbmd0aFxuICAgICkge1xuICAgICAgbmV3Um9vdCA9IGVkaXRhYmxlVk5vZGUobmV3Um9vdCwgb3duZXIpO1xuICAgICAgdmFyIG5vZGUgPSBuZXdSb290O1xuICAgICAgZm9yICh2YXIgbGV2ZWwgPSBuZXdMZXZlbDsgbGV2ZWwgPiBTSElGVDsgbGV2ZWwgLT0gU0hJRlQpIHtcbiAgICAgICAgdmFyIGlkeCA9IChvbGRUYWlsT2Zmc2V0ID4+PiBsZXZlbCkgJiBNQVNLO1xuICAgICAgICBub2RlID0gbm9kZS5hcnJheVtpZHhdID0gZWRpdGFibGVWTm9kZShub2RlLmFycmF5W2lkeF0sIG93bmVyKTtcbiAgICAgIH1cbiAgICAgIG5vZGUuYXJyYXlbKG9sZFRhaWxPZmZzZXQgPj4+IFNISUZUKSAmIE1BU0tdID0gb2xkVGFpbDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgc2l6ZSBoYXMgYmVlbiByZWR1Y2VkLCB0aGVyZSdzIGEgY2hhbmNlIHRoZSB0YWlsIG5lZWRzIHRvIGJlIHRyaW1tZWQuXG4gICAgaWYgKG5ld0NhcGFjaXR5IDwgb2xkQ2FwYWNpdHkpIHtcbiAgICAgIG5ld1RhaWwgPSBuZXdUYWlsICYmIG5ld1RhaWwucmVtb3ZlQWZ0ZXIob3duZXIsIDAsIG5ld0NhcGFjaXR5KTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbmV3IG9yaWdpbiBpcyB3aXRoaW4gdGhlIHRhaWwsIHRoZW4gd2UgZG8gbm90IG5lZWQgYSByb290LlxuICAgIGlmIChuZXdPcmlnaW4gPj0gbmV3VGFpbE9mZnNldCkge1xuICAgICAgbmV3T3JpZ2luIC09IG5ld1RhaWxPZmZzZXQ7XG4gICAgICBuZXdDYXBhY2l0eSAtPSBuZXdUYWlsT2Zmc2V0O1xuICAgICAgbmV3TGV2ZWwgPSBTSElGVDtcbiAgICAgIG5ld1Jvb3QgPSBudWxsO1xuICAgICAgbmV3VGFpbCA9IG5ld1RhaWwgJiYgbmV3VGFpbC5yZW1vdmVCZWZvcmUob3duZXIsIDAsIG5ld09yaWdpbik7XG5cbiAgICAgIC8vIE90aGVyd2lzZSwgaWYgdGhlIHJvb3QgaGFzIGJlZW4gdHJpbW1lZCwgZ2FyYmFnZSBjb2xsZWN0LlxuICAgIH0gZWxzZSBpZiAobmV3T3JpZ2luID4gb2xkT3JpZ2luIHx8IG5ld1RhaWxPZmZzZXQgPCBvbGRUYWlsT2Zmc2V0KSB7XG4gICAgICBvZmZzZXRTaGlmdCA9IDA7XG5cbiAgICAgIC8vIElkZW50aWZ5IHRoZSBuZXcgdG9wIHJvb3Qgbm9kZSBvZiB0aGUgc3VidHJlZSBvZiB0aGUgb2xkIHJvb3QuXG4gICAgICB3aGlsZSAobmV3Um9vdCkge1xuICAgICAgICB2YXIgYmVnaW5JbmRleCA9IChuZXdPcmlnaW4gPj4+IG5ld0xldmVsKSAmIE1BU0s7XG4gICAgICAgIGlmICgoYmVnaW5JbmRleCAhPT0gbmV3VGFpbE9mZnNldCA+Pj4gbmV3TGV2ZWwpICYgTUFTSykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiZWdpbkluZGV4KSB7XG4gICAgICAgICAgb2Zmc2V0U2hpZnQgKz0gKDEgPDwgbmV3TGV2ZWwpICogYmVnaW5JbmRleDtcbiAgICAgICAgfVxuICAgICAgICBuZXdMZXZlbCAtPSBTSElGVDtcbiAgICAgICAgbmV3Um9vdCA9IG5ld1Jvb3QuYXJyYXlbYmVnaW5JbmRleF07XG4gICAgICB9XG5cbiAgICAgIC8vIFRyaW0gdGhlIG5ldyBzaWRlcyBvZiB0aGUgbmV3IHJvb3QuXG4gICAgICBpZiAobmV3Um9vdCAmJiBuZXdPcmlnaW4gPiBvbGRPcmlnaW4pIHtcbiAgICAgICAgbmV3Um9vdCA9IG5ld1Jvb3QucmVtb3ZlQmVmb3JlKG93bmVyLCBuZXdMZXZlbCwgbmV3T3JpZ2luIC0gb2Zmc2V0U2hpZnQpO1xuICAgICAgfVxuICAgICAgaWYgKG5ld1Jvb3QgJiYgbmV3VGFpbE9mZnNldCA8IG9sZFRhaWxPZmZzZXQpIHtcbiAgICAgICAgbmV3Um9vdCA9IG5ld1Jvb3QucmVtb3ZlQWZ0ZXIoXG4gICAgICAgICAgb3duZXIsXG4gICAgICAgICAgbmV3TGV2ZWwsXG4gICAgICAgICAgbmV3VGFpbE9mZnNldCAtIG9mZnNldFNoaWZ0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAob2Zmc2V0U2hpZnQpIHtcbiAgICAgICAgbmV3T3JpZ2luIC09IG9mZnNldFNoaWZ0O1xuICAgICAgICBuZXdDYXBhY2l0eSAtPSBvZmZzZXRTaGlmdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGlzdC5fX293bmVySUQpIHtcbiAgICAgIGxpc3Quc2l6ZSA9IG5ld0NhcGFjaXR5IC0gbmV3T3JpZ2luO1xuICAgICAgbGlzdC5fb3JpZ2luID0gbmV3T3JpZ2luO1xuICAgICAgbGlzdC5fY2FwYWNpdHkgPSBuZXdDYXBhY2l0eTtcbiAgICAgIGxpc3QuX2xldmVsID0gbmV3TGV2ZWw7XG4gICAgICBsaXN0Ll9yb290ID0gbmV3Um9vdDtcbiAgICAgIGxpc3QuX3RhaWwgPSBuZXdUYWlsO1xuICAgICAgbGlzdC5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICBsaXN0Ll9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VMaXN0KG5ld09yaWdpbiwgbmV3Q2FwYWNpdHksIG5ld0xldmVsLCBuZXdSb290LCBuZXdUYWlsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRhaWxPZmZzZXQoc2l6ZSkge1xuICAgIHJldHVybiBzaXplIDwgU0laRSA/IDAgOiAoKHNpemUgLSAxKSA+Pj4gU0hJRlQpIDw8IFNISUZUO1xuICB9XG5cbiAgdmFyIE9yZGVyZWRNYXAgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChNYXApIHtcbiAgICBmdW5jdGlvbiBPcmRlcmVkTWFwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IGVtcHR5T3JkZXJlZE1hcCgpXG4gICAgICAgIDogaXNPcmRlcmVkTWFwKHZhbHVlKVxuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogZW1wdHlPcmRlcmVkTWFwKCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICB2YXIgaXRlciA9IEtleWVkQ29sbGVjdGlvbih2YWx1ZSk7XG4gICAgICAgICAgICBhc3NlcnROb3RJbmZpbml0ZShpdGVyLnNpemUpO1xuICAgICAgICAgICAgaXRlci5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBtYXAuc2V0KGssIHYpOyB9KTtcbiAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIE1hcCApIE9yZGVyZWRNYXAuX19wcm90b19fID0gTWFwO1xuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWFwICYmIE1hcC5wcm90b3R5cGUgKTtcbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE9yZGVyZWRNYXA7XG5cbiAgICBPcmRlcmVkTWFwLm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnT3JkZXJlZE1hcCB7JywgJ30nKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaywgbm90U2V0VmFsdWUpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX21hcC5nZXQoayk7XG4gICAgICByZXR1cm4gaW5kZXggIT09IHVuZGVmaW5lZCA/IHRoaXMuX2xpc3QuZ2V0KGluZGV4KVsxXSA6IG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX21hcC5jbGVhcigpO1xuICAgICAgICB0aGlzLl9saXN0LmNsZWFyKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5T3JkZXJlZE1hcCgpO1xuICAgIH07XG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKGssIHYpIHtcbiAgICAgIHJldHVybiB1cGRhdGVPcmRlcmVkTWFwKHRoaXMsIGssIHYpO1xuICAgIH07XG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKGspIHtcbiAgICAgIHJldHVybiB1cGRhdGVPcmRlcmVkTWFwKHRoaXMsIGssIE5PVF9TRVQpO1xuICAgIH07XG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS53YXNBbHRlcmVkID0gZnVuY3Rpb24gd2FzQWx0ZXJlZCAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwLndhc0FsdGVyZWQoKSB8fCB0aGlzLl9saXN0Lndhc0FsdGVyZWQoKTtcbiAgICB9O1xuXG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLl9saXN0Ll9faXRlcmF0ZShcbiAgICAgICAgZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeSAmJiBmbihlbnRyeVsxXSwgZW50cnlbMF0sIHRoaXMkMSk7IH0sXG4gICAgICAgIHJldmVyc2VcbiAgICAgICk7XG4gICAgfTtcblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGlzdC5mcm9tRW50cnlTZXEoKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24gX19lbnN1cmVPd25lciAob3duZXJJRCkge1xuICAgICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIG5ld01hcCA9IHRoaXMuX21hcC5fX2Vuc3VyZU93bmVyKG93bmVySUQpO1xuICAgICAgdmFyIG5ld0xpc3QgPSB0aGlzLl9saXN0Ll9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gICAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBlbXB0eU9yZGVyZWRNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ld01hcDtcbiAgICAgICAgdGhpcy5fbGlzdCA9IG5ld0xpc3Q7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ha2VPcmRlcmVkTWFwKG5ld01hcCwgbmV3TGlzdCwgb3duZXJJRCwgdGhpcy5fX2hhc2gpO1xuICAgIH07XG5cbiAgICByZXR1cm4gT3JkZXJlZE1hcDtcbiAgfShNYXApKTtcblxuICBPcmRlcmVkTWFwLmlzT3JkZXJlZE1hcCA9IGlzT3JkZXJlZE1hcDtcblxuICBPcmRlcmVkTWFwLnByb3RvdHlwZVtJU19PUkRFUkVEX1NZTUJPTF0gPSB0cnVlO1xuICBPcmRlcmVkTWFwLnByb3RvdHlwZVtERUxFVEVdID0gT3JkZXJlZE1hcC5wcm90b3R5cGUucmVtb3ZlO1xuXG4gIGZ1bmN0aW9uIG1ha2VPcmRlcmVkTWFwKG1hcCwgbGlzdCwgb3duZXJJRCwgaGFzaCkge1xuICAgIHZhciBvbWFwID0gT2JqZWN0LmNyZWF0ZShPcmRlcmVkTWFwLnByb3RvdHlwZSk7XG4gICAgb21hcC5zaXplID0gbWFwID8gbWFwLnNpemUgOiAwO1xuICAgIG9tYXAuX21hcCA9IG1hcDtcbiAgICBvbWFwLl9saXN0ID0gbGlzdDtcbiAgICBvbWFwLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgb21hcC5fX2hhc2ggPSBoYXNoO1xuICAgIHJldHVybiBvbWFwO1xuICB9XG5cbiAgdmFyIEVNUFRZX09SREVSRURfTUFQO1xuICBmdW5jdGlvbiBlbXB0eU9yZGVyZWRNYXAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIEVNUFRZX09SREVSRURfTUFQIHx8XG4gICAgICAoRU1QVFlfT1JERVJFRF9NQVAgPSBtYWtlT3JkZXJlZE1hcChlbXB0eU1hcCgpLCBlbXB0eUxpc3QoKSkpXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZU9yZGVyZWRNYXAob21hcCwgaywgdikge1xuICAgIHZhciBtYXAgPSBvbWFwLl9tYXA7XG4gICAgdmFyIGxpc3QgPSBvbWFwLl9saXN0O1xuICAgIHZhciBpID0gbWFwLmdldChrKTtcbiAgICB2YXIgaGFzID0gaSAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBuZXdNYXA7XG4gICAgdmFyIG5ld0xpc3Q7XG4gICAgaWYgKHYgPT09IE5PVF9TRVQpIHtcbiAgICAgIC8vIHJlbW92ZWRcbiAgICAgIGlmICghaGFzKSB7XG4gICAgICAgIHJldHVybiBvbWFwO1xuICAgICAgfVxuICAgICAgaWYgKGxpc3Quc2l6ZSA+PSBTSVpFICYmIGxpc3Quc2l6ZSA+PSBtYXAuc2l6ZSAqIDIpIHtcbiAgICAgICAgbmV3TGlzdCA9IGxpc3QuZmlsdGVyKGZ1bmN0aW9uIChlbnRyeSwgaWR4KSB7IHJldHVybiBlbnRyeSAhPT0gdW5kZWZpbmVkICYmIGkgIT09IGlkeDsgfSk7XG4gICAgICAgIG5ld01hcCA9IG5ld0xpc3RcbiAgICAgICAgICAudG9LZXllZFNlcSgpXG4gICAgICAgICAgLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5WzBdOyB9KVxuICAgICAgICAgIC5mbGlwKClcbiAgICAgICAgICAudG9NYXAoKTtcbiAgICAgICAgaWYgKG9tYXAuX19vd25lcklEKSB7XG4gICAgICAgICAgbmV3TWFwLl9fb3duZXJJRCA9IG5ld0xpc3QuX19vd25lcklEID0gb21hcC5fX293bmVySUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld01hcCA9IG1hcC5yZW1vdmUoayk7XG4gICAgICAgIG5ld0xpc3QgPSBpID09PSBsaXN0LnNpemUgLSAxID8gbGlzdC5wb3AoKSA6IGxpc3Quc2V0KGksIHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYXMpIHtcbiAgICAgIGlmICh2ID09PSBsaXN0LmdldChpKVsxXSkge1xuICAgICAgICByZXR1cm4gb21hcDtcbiAgICAgIH1cbiAgICAgIG5ld01hcCA9IG1hcDtcbiAgICAgIG5ld0xpc3QgPSBsaXN0LnNldChpLCBbaywgdl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdNYXAgPSBtYXAuc2V0KGssIGxpc3Quc2l6ZSk7XG4gICAgICBuZXdMaXN0ID0gbGlzdC5zZXQobGlzdC5zaXplLCBbaywgdl0pO1xuICAgIH1cbiAgICBpZiAob21hcC5fX293bmVySUQpIHtcbiAgICAgIG9tYXAuc2l6ZSA9IG5ld01hcC5zaXplO1xuICAgICAgb21hcC5fbWFwID0gbmV3TWFwO1xuICAgICAgb21hcC5fbGlzdCA9IG5ld0xpc3Q7XG4gICAgICBvbWFwLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBvbWFwO1xuICAgIH1cbiAgICByZXR1cm4gbWFrZU9yZGVyZWRNYXAobmV3TWFwLCBuZXdMaXN0KTtcbiAgfVxuXG4gIHZhciBJU19TVEFDS19TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9TVEFDS19fQEAnO1xuXG4gIGZ1bmN0aW9uIGlzU3RhY2sobWF5YmVTdGFjaykge1xuICAgIHJldHVybiBCb29sZWFuKG1heWJlU3RhY2sgJiYgbWF5YmVTdGFja1tJU19TVEFDS19TWU1CT0xdKTtcbiAgfVxuXG4gIHZhciBTdGFjayA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEluZGV4ZWRDb2xsZWN0aW9uKSB7XG4gICAgZnVuY3Rpb24gU3RhY2sodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gZW1wdHlTdGFjaygpXG4gICAgICAgIDogaXNTdGFjayh2YWx1ZSlcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IGVtcHR5U3RhY2soKS5wdXNoQWxsKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoIEluZGV4ZWRDb2xsZWN0aW9uICkgU3RhY2suX19wcm90b19fID0gSW5kZXhlZENvbGxlY3Rpb247XG4gICAgU3RhY2sucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW5kZXhlZENvbGxlY3Rpb24gJiYgSW5kZXhlZENvbGxlY3Rpb24ucHJvdG90eXBlICk7XG4gICAgU3RhY2sucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3RhY2s7XG5cbiAgICBTdGFjay5vZiA9IGZ1bmN0aW9uIG9mICgvKi4uLnZhbHVlcyovKSB7XG4gICAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBTdGFjay5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdTdGFjayBbJywgJ10nKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICAgIFN0YWNrLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgICAgdmFyIGhlYWQgPSB0aGlzLl9oZWFkO1xuICAgICAgaW5kZXggPSB3cmFwSW5kZXgodGhpcywgaW5kZXgpO1xuICAgICAgd2hpbGUgKGhlYWQgJiYgaW5kZXgtLSkge1xuICAgICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhlYWQgPyBoZWFkLnZhbHVlIDogbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIFN0YWNrLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24gcGVlayAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faGVhZCAmJiB0aGlzLl9oZWFkLnZhbHVlO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG4gICAgU3RhY2sucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoICgvKi4uLnZhbHVlcyovKSB7XG4gICAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1NpemUgPSB0aGlzLnNpemUgKyBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgdmFyIGhlYWQgPSB0aGlzLl9oZWFkO1xuICAgICAgZm9yICh2YXIgaWkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaWkgPj0gMDsgaWktLSkge1xuICAgICAgICBoZWFkID0ge1xuICAgICAgICAgIHZhbHVlOiBhcmd1bWVudHMkMVtpaV0sXG4gICAgICAgICAgbmV4dDogaGVhZCxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICB0aGlzLnNpemUgPSBuZXdTaXplO1xuICAgICAgICB0aGlzLl9oZWFkID0gaGVhZDtcbiAgICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFrZVN0YWNrKG5ld1NpemUsIGhlYWQpO1xuICAgIH07XG5cbiAgICBTdGFjay5wcm90b3R5cGUucHVzaEFsbCA9IGZ1bmN0aW9uIHB1c2hBbGwgKGl0ZXIpIHtcbiAgICAgIGl0ZXIgPSBJbmRleGVkQ29sbGVjdGlvbihpdGVyKTtcbiAgICAgIGlmIChpdGVyLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwICYmIGlzU3RhY2soaXRlcikpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXI7XG4gICAgICB9XG4gICAgICBhc3NlcnROb3RJbmZpbml0ZShpdGVyLnNpemUpO1xuICAgICAgdmFyIG5ld1NpemUgPSB0aGlzLnNpemU7XG4gICAgICB2YXIgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgICBpdGVyLl9faXRlcmF0ZShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgbmV3U2l6ZSsrO1xuICAgICAgICBoZWFkID0ge1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBuZXh0OiBoZWFkLFxuICAgICAgICB9O1xuICAgICAgfSwgLyogcmV2ZXJzZSAqLyB0cnVlKTtcbiAgICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICB0aGlzLnNpemUgPSBuZXdTaXplO1xuICAgICAgICB0aGlzLl9oZWFkID0gaGVhZDtcbiAgICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFrZVN0YWNrKG5ld1NpemUsIGhlYWQpO1xuICAgIH07XG5cbiAgICBTdGFjay5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gcG9wICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNsaWNlKDEpO1xuICAgIH07XG5cbiAgICBTdGFjay5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5U3RhY2soKTtcbiAgICB9O1xuXG4gICAgU3RhY2sucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKGJlZ2luLCBlbmQpIHtcbiAgICAgIGlmICh3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIHRoaXMuc2l6ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgcmVzb2x2ZWRCZWdpbiA9IHJlc29sdmVCZWdpbihiZWdpbiwgdGhpcy5zaXplKTtcbiAgICAgIHZhciByZXNvbHZlZEVuZCA9IHJlc29sdmVFbmQoZW5kLCB0aGlzLnNpemUpO1xuICAgICAgaWYgKHJlc29sdmVkRW5kICE9PSB0aGlzLnNpemUpIHtcbiAgICAgICAgLy8gc3VwZXIuc2xpY2UoYmVnaW4sIGVuZCk7XG4gICAgICAgIHJldHVybiBJbmRleGVkQ29sbGVjdGlvbi5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdTaXplID0gdGhpcy5zaXplIC0gcmVzb2x2ZWRCZWdpbjtcbiAgICAgIHZhciBoZWFkID0gdGhpcy5faGVhZDtcbiAgICAgIHdoaWxlIChyZXNvbHZlZEJlZ2luLS0pIHtcbiAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICB0aGlzLnNpemUgPSBuZXdTaXplO1xuICAgICAgICB0aGlzLl9oZWFkID0gaGVhZDtcbiAgICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFrZVN0YWNrKG5ld1NpemUsIGhlYWQpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIE11dGFiaWxpdHlcblxuICAgIFN0YWNrLnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24gX19lbnN1cmVPd25lciAob3duZXJJRCkge1xuICAgICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKCFvd25lcklEKSB7XG4gICAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZW1wdHlTdGFjaygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFrZVN0YWNrKHRoaXMuc2l6ZSwgdGhpcy5faGVhZCwgb3duZXJJRCwgdGhpcy5fX2hhc2gpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIEl0ZXJhdGlvblxuXG4gICAgU3RhY2sucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5U2VxKHRoaXMudG9BcnJheSgpKS5fX2l0ZXJhdGUoXG4gICAgICAgICAgZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIGZuKHYsIGssIHRoaXMkMSk7IH0sXG4gICAgICAgICAgcmV2ZXJzZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLl9oZWFkO1xuICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKGZuKG5vZGUudmFsdWUsIGl0ZXJhdGlvbnMrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG5cbiAgICBTdGFjay5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlTZXEodGhpcy50b0FycmF5KCkpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuX2hlYWQ7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBub2RlLnZhbHVlO1xuICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBTdGFjaztcbiAgfShJbmRleGVkQ29sbGVjdGlvbikpO1xuXG4gIFN0YWNrLmlzU3RhY2sgPSBpc1N0YWNrO1xuXG4gIHZhciBTdGFja1Byb3RvdHlwZSA9IFN0YWNrLnByb3RvdHlwZTtcbiAgU3RhY2tQcm90b3R5cGVbSVNfU1RBQ0tfU1lNQk9MXSA9IHRydWU7XG4gIFN0YWNrUHJvdG90eXBlLnNoaWZ0ID0gU3RhY2tQcm90b3R5cGUucG9wO1xuICBTdGFja1Byb3RvdHlwZS51bnNoaWZ0ID0gU3RhY2tQcm90b3R5cGUucHVzaDtcbiAgU3RhY2tQcm90b3R5cGUudW5zaGlmdEFsbCA9IFN0YWNrUHJvdG90eXBlLnB1c2hBbGw7XG4gIFN0YWNrUHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSB3aXRoTXV0YXRpb25zO1xuICBTdGFja1Byb3RvdHlwZS53YXNBbHRlcmVkID0gd2FzQWx0ZXJlZDtcbiAgU3RhY2tQcm90b3R5cGUuYXNJbW11dGFibGUgPSBhc0ltbXV0YWJsZTtcbiAgU3RhY2tQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBTdGFja1Byb3RvdHlwZS5hc011dGFibGUgPSBhc011dGFibGU7XG4gIFN0YWNrUHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgYXJyKSB7XG4gICAgcmV0dXJuIHJlc3VsdC51bnNoaWZ0KGFycik7XG4gIH07XG4gIFN0YWNrUHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iai5hc0ltbXV0YWJsZSgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VTdGFjayhzaXplLCBoZWFkLCBvd25lcklELCBoYXNoKSB7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUoU3RhY2tQcm90b3R5cGUpO1xuICAgIG1hcC5zaXplID0gc2l6ZTtcbiAgICBtYXAuX2hlYWQgPSBoZWFkO1xuICAgIG1hcC5fX293bmVySUQgPSBvd25lcklEO1xuICAgIG1hcC5fX2hhc2ggPSBoYXNoO1xuICAgIG1hcC5fX2FsdGVyZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gbWFwO1xuICB9XG5cbiAgdmFyIEVNUFRZX1NUQUNLO1xuICBmdW5jdGlvbiBlbXB0eVN0YWNrKCkge1xuICAgIHJldHVybiBFTVBUWV9TVEFDSyB8fCAoRU1QVFlfU1RBQ0sgPSBtYWtlU3RhY2soMCkpO1xuICB9XG5cbiAgdmFyIElTX1NFVF9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9TRVRfX0BAJztcblxuICBmdW5jdGlvbiBpc1NldChtYXliZVNldCkge1xuICAgIHJldHVybiBCb29sZWFuKG1heWJlU2V0ICYmIG1heWJlU2V0W0lTX1NFVF9TWU1CT0xdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT3JkZXJlZFNldChtYXliZU9yZGVyZWRTZXQpIHtcbiAgICByZXR1cm4gaXNTZXQobWF5YmVPcmRlcmVkU2V0KSAmJiBpc09yZGVyZWQobWF5YmVPcmRlcmVkU2V0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICFpc0NvbGxlY3Rpb24oYikgfHxcbiAgICAgIChhLnNpemUgIT09IHVuZGVmaW5lZCAmJiBiLnNpemUgIT09IHVuZGVmaW5lZCAmJiBhLnNpemUgIT09IGIuc2l6ZSkgfHxcbiAgICAgIChhLl9faGFzaCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGIuX19oYXNoICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgYS5fX2hhc2ggIT09IGIuX19oYXNoKSB8fFxuICAgICAgaXNLZXllZChhKSAhPT0gaXNLZXllZChiKSB8fFxuICAgICAgaXNJbmRleGVkKGEpICE9PSBpc0luZGV4ZWQoYikgfHxcbiAgICAgIGlzT3JkZXJlZChhKSAhPT0gaXNPcmRlcmVkKGIpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGEuc2l6ZSA9PT0gMCAmJiBiLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBub3RBc3NvY2lhdGl2ZSA9ICFpc0Fzc29jaWF0aXZlKGEpO1xuXG4gICAgaWYgKGlzT3JkZXJlZChhKSkge1xuICAgICAgdmFyIGVudHJpZXMgPSBhLmVudHJpZXMoKTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGIuZXZlcnkoZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzLm5leHQoKS52YWx1ZTtcbiAgICAgICAgICByZXR1cm4gZW50cnkgJiYgaXMoZW50cnlbMV0sIHYpICYmIChub3RBc3NvY2lhdGl2ZSB8fCBpcyhlbnRyeVswXSwgaykpO1xuICAgICAgICB9KSAmJiBlbnRyaWVzLm5leHQoKS5kb25lXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBmbGlwcGVkID0gZmFsc2U7XG5cbiAgICBpZiAoYS5zaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChiLnNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIGEuY2FjaGVSZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBhLmNhY2hlUmVzdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZsaXBwZWQgPSB0cnVlO1xuICAgICAgICB2YXIgXyA9IGE7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBiID0gXztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWxsRXF1YWwgPSB0cnVlO1xuICAgIHZhciBiU2l6ZSA9IGIuX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIG5vdEFzc29jaWF0aXZlXG4gICAgICAgICAgPyAhYS5oYXModilcbiAgICAgICAgICA6IGZsaXBwZWRcbiAgICAgICAgICA/ICFpcyh2LCBhLmdldChrLCBOT1RfU0VUKSlcbiAgICAgICAgICA6ICFpcyhhLmdldChrLCBOT1RfU0VUKSwgdilcbiAgICAgICkge1xuICAgICAgICBhbGxFcXVhbCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYWxsRXF1YWwgJiYgYS5zaXplID09PSBiU2l6ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1peGluKGN0b3IsIG1ldGhvZHMpIHtcbiAgICB2YXIga2V5Q29waWVyID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgY3Rvci5wcm90b3R5cGVba2V5XSA9IG1ldGhvZHNba2V5XTtcbiAgICB9O1xuICAgIE9iamVjdC5rZXlzKG1ldGhvZHMpLmZvckVhY2goa2V5Q29waWVyKTtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmXG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG1ldGhvZHMpLmZvckVhY2goa2V5Q29waWVyKTtcbiAgICByZXR1cm4gY3RvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvSlModmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKCFpc0NvbGxlY3Rpb24odmFsdWUpKSB7XG4gICAgICBpZiAoIWlzRGF0YVN0cnVjdHVyZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBTZXEodmFsdWUpO1xuICAgIH1cbiAgICBpZiAoaXNLZXllZCh2YWx1ZSkpIHtcbiAgICAgIHZhciByZXN1bHQkMSA9IHt9O1xuICAgICAgdmFsdWUuX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgIHJlc3VsdCQxW2tdID0gdG9KUyh2KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdCQxO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFsdWUuX19pdGVyYXRlKGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXN1bHQucHVzaCh0b0pTKHYpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIFNldCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNldENvbGxlY3Rpb24pIHtcbiAgICBmdW5jdGlvbiBTZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gZW1wdHlTZXQoKVxuICAgICAgICA6IGlzU2V0KHZhbHVlKSAmJiAhaXNPcmRlcmVkKHZhbHVlKVxuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogZW1wdHlTZXQoKS53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgICAgICAgIHZhciBpdGVyID0gU2V0Q29sbGVjdGlvbih2YWx1ZSk7XG4gICAgICAgICAgICBhc3NlcnROb3RJbmZpbml0ZShpdGVyLnNpemUpO1xuICAgICAgICAgICAgaXRlci5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHJldHVybiBzZXQuYWRkKHYpOyB9KTtcbiAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIFNldENvbGxlY3Rpb24gKSBTZXQuX19wcm90b19fID0gU2V0Q29sbGVjdGlvbjtcbiAgICBTZXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2V0Q29sbGVjdGlvbiAmJiBTZXRDb2xsZWN0aW9uLnByb3RvdHlwZSApO1xuICAgIFNldC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXQ7XG5cbiAgICBTZXQub2YgPSBmdW5jdGlvbiBvZiAoLyouLi52YWx1ZXMqLykge1xuICAgICAgcmV0dXJuIHRoaXMoYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgU2V0LmZyb21LZXlzID0gZnVuY3Rpb24gZnJvbUtleXMgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcyhLZXllZENvbGxlY3Rpb24odmFsdWUpLmtleVNlcSgpKTtcbiAgICB9O1xuXG4gICAgU2V0LmludGVyc2VjdCA9IGZ1bmN0aW9uIGludGVyc2VjdCAoc2V0cykge1xuICAgICAgc2V0cyA9IENvbGxlY3Rpb24oc2V0cykudG9BcnJheSgpO1xuICAgICAgcmV0dXJuIHNldHMubGVuZ3RoXG4gICAgICAgID8gU2V0UHJvdG90eXBlLmludGVyc2VjdC5hcHBseShTZXQoc2V0cy5wb3AoKSksIHNldHMpXG4gICAgICAgIDogZW1wdHlTZXQoKTtcbiAgICB9O1xuXG4gICAgU2V0LnVuaW9uID0gZnVuY3Rpb24gdW5pb24gKHNldHMpIHtcbiAgICAgIHNldHMgPSBDb2xsZWN0aW9uKHNldHMpLnRvQXJyYXkoKTtcbiAgICAgIHJldHVybiBzZXRzLmxlbmd0aFxuICAgICAgICA/IFNldFByb3RvdHlwZS51bmlvbi5hcHBseShTZXQoc2V0cy5wb3AoKSksIHNldHMpXG4gICAgICAgIDogZW1wdHlTZXQoKTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ1NldCB7JywgJ30nKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hcC5oYXModmFsdWUpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG4gICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdXBkYXRlU2V0KHRoaXMsIHRoaXMuX21hcC5zZXQodmFsdWUsIHZhbHVlKSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHVwZGF0ZVNldCh0aGlzLCB0aGlzLl9tYXAucmVtb3ZlKHZhbHVlKSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICByZXR1cm4gdXBkYXRlU2V0KHRoaXMsIHRoaXMuX21hcC5jbGVhcigpKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBDb21wb3NpdGlvblxuXG4gICAgU2V0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKG1hcHBlciwgY29udGV4dCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHZhciByZW1vdmVzID0gW107XG4gICAgICB2YXIgYWRkcyA9IFtdO1xuICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgbWFwcGVkID0gbWFwcGVyLmNhbGwoY29udGV4dCwgdmFsdWUsIHZhbHVlLCB0aGlzJDEpO1xuICAgICAgICBpZiAobWFwcGVkICE9PSB2YWx1ZSkge1xuICAgICAgICAgIHJlbW92ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgYWRkcy5wdXNoKG1hcHBlZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgIHJlbW92ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHNldC5yZW1vdmUodmFsdWUpOyB9KTtcbiAgICAgICAgYWRkcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gc2V0LmFkZCh2YWx1ZSk7IH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUudW5pb24gPSBmdW5jdGlvbiB1bmlvbiAoKSB7XG4gICAgICB2YXIgaXRlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICBpdGVycyA9IGl0ZXJzLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5zaXplICE9PSAwOyB9KTtcbiAgICAgIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwICYmICF0aGlzLl9fb3duZXJJRCAmJiBpdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IoaXRlcnNbMF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBpdGVycy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICBTZXRDb2xsZWN0aW9uKGl0ZXJzW2lpXSkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHNldC5hZGQodmFsdWUpOyB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24gaW50ZXJzZWN0ICgpIHtcbiAgICAgIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIGl0ZXJzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpdGVycyA9IGl0ZXJzLm1hcChmdW5jdGlvbiAoaXRlcikgeyByZXR1cm4gU2V0Q29sbGVjdGlvbihpdGVyKTsgfSk7XG4gICAgICB2YXIgdG9SZW1vdmUgPSBbXTtcbiAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCFpdGVycy5ldmVyeShmdW5jdGlvbiAoaXRlcikgeyByZXR1cm4gaXRlci5pbmNsdWRlcyh2YWx1ZSk7IH0pKSB7XG4gICAgICAgICAgdG9SZW1vdmUucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgIHRvUmVtb3ZlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgc2V0LnJlbW92ZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdCAoKSB7XG4gICAgICB2YXIgaXRlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICBpZiAoaXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaXRlcnMgPSBpdGVycy5tYXAoZnVuY3Rpb24gKGl0ZXIpIHsgcmV0dXJuIFNldENvbGxlY3Rpb24oaXRlcik7IH0pO1xuICAgICAgdmFyIHRvUmVtb3ZlID0gW107XG4gICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChpdGVycy5zb21lKGZ1bmN0aW9uIChpdGVyKSB7IHJldHVybiBpdGVyLmluY2x1ZGVzKHZhbHVlKTsgfSkpIHtcbiAgICAgICAgICB0b1JlbW92ZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgICAgdG9SZW1vdmUuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBzZXQucmVtb3ZlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gc29ydCAoY29tcGFyYXRvcikge1xuICAgICAgLy8gTGF0ZSBiaW5kaW5nXG4gICAgICByZXR1cm4gT3JkZXJlZFNldChzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yKSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuc29ydEJ5ID0gZnVuY3Rpb24gc29ydEJ5IChtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICAgIC8vIExhdGUgYmluZGluZ1xuICAgICAgcmV0dXJuIE9yZGVyZWRTZXQoc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvciwgbWFwcGVyKSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUud2FzQWx0ZXJlZCA9IGZ1bmN0aW9uIHdhc0FsdGVyZWQgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hcC53YXNBbHRlcmVkKCk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLl9tYXAuX19pdGVyYXRlKGZ1bmN0aW9uIChrKSB7IHJldHVybiBmbihrLCBrLCB0aGlzJDEpOyB9LCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hcC5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbiBfX2Vuc3VyZU93bmVyIChvd25lcklEKSB7XG4gICAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgbmV3TWFwID0gdGhpcy5fbWFwLl9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gICAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9fZW1wdHkoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ld01hcDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fX21ha2UobmV3TWFwLCBvd25lcklEKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfShTZXRDb2xsZWN0aW9uKSk7XG5cbiAgU2V0LmlzU2V0ID0gaXNTZXQ7XG5cbiAgdmFyIFNldFByb3RvdHlwZSA9IFNldC5wcm90b3R5cGU7XG4gIFNldFByb3RvdHlwZVtJU19TRVRfU1lNQk9MXSA9IHRydWU7XG4gIFNldFByb3RvdHlwZVtERUxFVEVdID0gU2V0UHJvdG90eXBlLnJlbW92ZTtcbiAgU2V0UHJvdG90eXBlLm1lcmdlID0gU2V0UHJvdG90eXBlLmNvbmNhdCA9IFNldFByb3RvdHlwZS51bmlvbjtcbiAgU2V0UHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSB3aXRoTXV0YXRpb25zO1xuICBTZXRQcm90b3R5cGUuYXNJbW11dGFibGUgPSBhc0ltbXV0YWJsZTtcbiAgU2V0UHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gU2V0UHJvdG90eXBlLmFzTXV0YWJsZSA9IGFzTXV0YWJsZTtcbiAgU2V0UHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgYXJyKSB7XG4gICAgcmV0dXJuIHJlc3VsdC5hZGQoYXJyKTtcbiAgfTtcbiAgU2V0UHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iai5hc0ltbXV0YWJsZSgpO1xuICB9O1xuXG4gIFNldFByb3RvdHlwZS5fX2VtcHR5ID0gZW1wdHlTZXQ7XG4gIFNldFByb3RvdHlwZS5fX21ha2UgPSBtYWtlU2V0O1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNldChzZXQsIG5ld01hcCkge1xuICAgIGlmIChzZXQuX19vd25lcklEKSB7XG4gICAgICBzZXQuc2l6ZSA9IG5ld01hcC5zaXplO1xuICAgICAgc2V0Ll9tYXAgPSBuZXdNYXA7XG4gICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICByZXR1cm4gbmV3TWFwID09PSBzZXQuX21hcFxuICAgICAgPyBzZXRcbiAgICAgIDogbmV3TWFwLnNpemUgPT09IDBcbiAgICAgID8gc2V0Ll9fZW1wdHkoKVxuICAgICAgOiBzZXQuX19tYWtlKG5ld01hcCk7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlU2V0KG1hcCwgb3duZXJJRCkge1xuICAgIHZhciBzZXQgPSBPYmplY3QuY3JlYXRlKFNldFByb3RvdHlwZSk7XG4gICAgc2V0LnNpemUgPSBtYXAgPyBtYXAuc2l6ZSA6IDA7XG4gICAgc2V0Ll9tYXAgPSBtYXA7XG4gICAgc2V0Ll9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgcmV0dXJuIHNldDtcbiAgfVxuXG4gIHZhciBFTVBUWV9TRVQ7XG4gIGZ1bmN0aW9uIGVtcHR5U2V0KCkge1xuICAgIHJldHVybiBFTVBUWV9TRVQgfHwgKEVNUFRZX1NFVCA9IG1ha2VTZXQoZW1wdHlNYXAoKSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsYXp5IHNlcSBvZiBudW1zIGZyb20gc3RhcnQgKGluY2x1c2l2ZSkgdG8gZW5kXG4gICAqIChleGNsdXNpdmUpLCBieSBzdGVwLCB3aGVyZSBzdGFydCBkZWZhdWx0cyB0byAwLCBzdGVwIHRvIDEsIGFuZCBlbmQgdG9cbiAgICogaW5maW5pdHkuIFdoZW4gc3RhcnQgaXMgZXF1YWwgdG8gZW5kLCByZXR1cm5zIGVtcHR5IGxpc3QuXG4gICAqL1xuICB2YXIgUmFuZ2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbmRleGVkU2VxKSB7XG4gICAgZnVuY3Rpb24gUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJhbmdlKSkge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXApO1xuICAgICAgfVxuICAgICAgaW52YXJpYW50KHN0ZXAgIT09IDAsICdDYW5ub3Qgc3RlcCBhIFJhbmdlIGJ5IDAnKTtcbiAgICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmQgPSBJbmZpbml0eTtcbiAgICAgIH1cbiAgICAgIHN0ZXAgPSBzdGVwID09PSB1bmRlZmluZWQgPyAxIDogTWF0aC5hYnMoc3RlcCk7XG4gICAgICBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICAgICAgc3RlcCA9IC1zdGVwO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3RhcnQgPSBzdGFydDtcbiAgICAgIHRoaXMuX2VuZCA9IGVuZDtcbiAgICAgIHRoaXMuX3N0ZXAgPSBzdGVwO1xuICAgICAgdGhpcy5zaXplID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChlbmQgLSBzdGFydCkgLyBzdGVwIC0gMSkgKyAxKTtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgaWYgKEVNUFRZX1JBTkdFKSB7XG4gICAgICAgICAgcmV0dXJuIEVNUFRZX1JBTkdFO1xuICAgICAgICB9XG4gICAgICAgIEVNUFRZX1JBTkdFID0gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIEluZGV4ZWRTZXEgKSBSYW5nZS5fX3Byb3RvX18gPSBJbmRleGVkU2VxO1xuICAgIFJhbmdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEluZGV4ZWRTZXEgJiYgSW5kZXhlZFNlcS5wcm90b3R5cGUgKTtcbiAgICBSYW5nZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSYW5nZTtcblxuICAgIFJhbmdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuICdSYW5nZSBbXSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gKFxuICAgICAgICAnUmFuZ2UgWyAnICtcbiAgICAgICAgdGhpcy5fc3RhcnQgK1xuICAgICAgICAnLi4uJyArXG4gICAgICAgIHRoaXMuX2VuZCArXG4gICAgICAgICh0aGlzLl9zdGVwICE9PSAxID8gJyBieSAnICsgdGhpcy5fc3RlcCA6ICcnKSArXG4gICAgICAgICcgXSdcbiAgICAgICk7XG4gICAgfTtcblxuICAgIFJhbmdlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzKGluZGV4KVxuICAgICAgICA/IHRoaXMuX3N0YXJ0ICsgd3JhcEluZGV4KHRoaXMsIGluZGV4KSAqIHRoaXMuX3N0ZXBcbiAgICAgICAgOiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHNlYXJjaFZhbHVlKSB7XG4gICAgICB2YXIgcG9zc2libGVJbmRleCA9IChzZWFyY2hWYWx1ZSAtIHRoaXMuX3N0YXJ0KSAvIHRoaXMuX3N0ZXA7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBwb3NzaWJsZUluZGV4ID49IDAgJiZcbiAgICAgICAgcG9zc2libGVJbmRleCA8IHRoaXMuc2l6ZSAmJlxuICAgICAgICBwb3NzaWJsZUluZGV4ID09PSBNYXRoLmZsb29yKHBvc3NpYmxlSW5kZXgpXG4gICAgICApO1xuICAgIH07XG5cbiAgICBSYW5nZS5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoYmVnaW4sIGVuZCkge1xuICAgICAgaWYgKHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgdGhpcy5zaXplKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGJlZ2luID0gcmVzb2x2ZUJlZ2luKGJlZ2luLCB0aGlzLnNpemUpO1xuICAgICAgZW5kID0gcmVzb2x2ZUVuZChlbmQsIHRoaXMuc2l6ZSk7XG4gICAgICBpZiAoZW5kIDw9IGJlZ2luKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UoMCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKFxuICAgICAgICB0aGlzLmdldChiZWdpbiwgdGhpcy5fZW5kKSxcbiAgICAgICAgdGhpcy5nZXQoZW5kLCB0aGlzLl9lbmQpLFxuICAgICAgICB0aGlzLl9zdGVwXG4gICAgICApO1xuICAgIH07XG5cbiAgICBSYW5nZS5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHNlYXJjaFZhbHVlKSB7XG4gICAgICB2YXIgb2Zmc2V0VmFsdWUgPSBzZWFyY2hWYWx1ZSAtIHRoaXMuX3N0YXJ0O1xuICAgICAgaWYgKG9mZnNldFZhbHVlICUgdGhpcy5fc3RlcCA9PT0gMCkge1xuICAgICAgICB2YXIgaW5kZXggPSBvZmZzZXRWYWx1ZSAvIHRoaXMuX3N0ZXA7XG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5zaXplKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuICAgIFJhbmdlLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mIChzZWFyY2hWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXhPZihzZWFyY2hWYWx1ZSk7XG4gICAgfTtcblxuICAgIFJhbmdlLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgIHZhciBzdGVwID0gdGhpcy5fc3RlcDtcbiAgICAgIHZhciB2YWx1ZSA9IHJldmVyc2UgPyB0aGlzLl9zdGFydCArIChzaXplIC0gMSkgKiBzdGVwIDogdGhpcy5fc3RhcnQ7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB3aGlsZSAoaSAhPT0gc2l6ZSkge1xuICAgICAgICBpZiAoZm4odmFsdWUsIHJldmVyc2UgPyBzaXplIC0gKytpIDogaSsrLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSArPSByZXZlcnNlID8gLXN0ZXAgOiBzdGVwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGk7XG4gICAgfTtcblxuICAgIFJhbmdlLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgICB2YXIgc3RlcCA9IHRoaXMuX3N0ZXA7XG4gICAgICB2YXIgdmFsdWUgPSByZXZlcnNlID8gdGhpcy5fc3RhcnQgKyAoc2l6ZSAtIDEpICogc3RlcCA6IHRoaXMuX3N0YXJ0O1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpID09PSBzaXplKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2ID0gdmFsdWU7XG4gICAgICAgIHZhbHVlICs9IHJldmVyc2UgPyAtc3RlcCA6IHN0ZXA7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIHJldmVyc2UgPyBzaXplIC0gKytpIDogaSsrLCB2KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBSYW5nZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChvdGhlcikge1xuICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgUmFuZ2VcbiAgICAgICAgPyB0aGlzLl9zdGFydCA9PT0gb3RoZXIuX3N0YXJ0ICYmXG4gICAgICAgICAgICB0aGlzLl9lbmQgPT09IG90aGVyLl9lbmQgJiZcbiAgICAgICAgICAgIHRoaXMuX3N0ZXAgPT09IG90aGVyLl9zdGVwXG4gICAgICAgIDogZGVlcEVxdWFsKHRoaXMsIG90aGVyKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJhbmdlO1xuICB9KEluZGV4ZWRTZXEpKTtcblxuICB2YXIgRU1QVFlfUkFOR0U7XG5cbiAgZnVuY3Rpb24gZ2V0SW4oY29sbGVjdGlvbiwgc2VhcmNoS2V5UGF0aCwgbm90U2V0VmFsdWUpIHtcbiAgICB2YXIga2V5UGF0aCA9IGNvZXJjZUtleVBhdGgoc2VhcmNoS2V5UGF0aCk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpICE9PSBrZXlQYXRoLmxlbmd0aCkge1xuICAgICAgY29sbGVjdGlvbiA9IGdldChjb2xsZWN0aW9uLCBrZXlQYXRoW2krK10sIE5PVF9TRVQpO1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT09IE5PVF9TRVQpIHtcbiAgICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEluJDEoc2VhcmNoS2V5UGF0aCwgbm90U2V0VmFsdWUpIHtcbiAgICByZXR1cm4gZ2V0SW4odGhpcywgc2VhcmNoS2V5UGF0aCwgbm90U2V0VmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzSW4oY29sbGVjdGlvbiwga2V5UGF0aCkge1xuICAgIHJldHVybiBnZXRJbihjb2xsZWN0aW9uLCBrZXlQYXRoLCBOT1RfU0VUKSAhPT0gTk9UX1NFVDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0luJDEoc2VhcmNoS2V5UGF0aCkge1xuICAgIHJldHVybiBoYXNJbih0aGlzLCBzZWFyY2hLZXlQYXRoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMuc2l6ZSk7XG4gICAgdmFyIG9iamVjdCA9IHt9O1xuICAgIHRoaXMuX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICBvYmplY3Rba10gPSB2O1xuICAgIH0pO1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICAvLyBOb3RlOiBhbGwgb2YgdGhlc2UgbWV0aG9kcyBhcmUgZGVwcmVjYXRlZC5cbiAgQ29sbGVjdGlvbi5pc0l0ZXJhYmxlID0gaXNDb2xsZWN0aW9uO1xuICBDb2xsZWN0aW9uLmlzS2V5ZWQgPSBpc0tleWVkO1xuICBDb2xsZWN0aW9uLmlzSW5kZXhlZCA9IGlzSW5kZXhlZDtcbiAgQ29sbGVjdGlvbi5pc0Fzc29jaWF0aXZlID0gaXNBc3NvY2lhdGl2ZTtcbiAgQ29sbGVjdGlvbi5pc09yZGVyZWQgPSBpc09yZGVyZWQ7XG5cbiAgQ29sbGVjdGlvbi5JdGVyYXRvciA9IEl0ZXJhdG9yO1xuXG4gIG1peGluKENvbGxlY3Rpb24sIHtcbiAgICAvLyAjIyMgQ29udmVyc2lvbiB0byBvdGhlciB0eXBlc1xuXG4gICAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMuc2l6ZSk7XG4gICAgICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkodGhpcy5zaXplIHx8IDApO1xuICAgICAgdmFyIHVzZVR1cGxlcyA9IGlzS2V5ZWQodGhpcyk7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB0aGlzLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykge1xuICAgICAgICAvLyBLZXllZCBjb2xsZWN0aW9ucyBwcm9kdWNlIGFuIGFycmF5IG9mIHR1cGxlcy5cbiAgICAgICAgYXJyYXlbaSsrXSA9IHVzZVR1cGxlcyA/IFtrLCB2XSA6IHY7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9LFxuXG4gICAgdG9JbmRleGVkU2VxOiBmdW5jdGlvbiB0b0luZGV4ZWRTZXEoKSB7XG4gICAgICByZXR1cm4gbmV3IFRvSW5kZXhlZFNlcXVlbmNlKHRoaXMpO1xuICAgIH0sXG5cbiAgICB0b0pTOiBmdW5jdGlvbiB0b0pTJDEoKSB7XG4gICAgICByZXR1cm4gdG9KUyh0aGlzKTtcbiAgICB9LFxuXG4gICAgdG9LZXllZFNlcTogZnVuY3Rpb24gdG9LZXllZFNlcSgpIHtcbiAgICAgIHJldHVybiBuZXcgVG9LZXllZFNlcXVlbmNlKHRoaXMsIHRydWUpO1xuICAgIH0sXG5cbiAgICB0b01hcDogZnVuY3Rpb24gdG9NYXAoKSB7XG4gICAgICAvLyBVc2UgTGF0ZSBCaW5kaW5nIGhlcmUgdG8gc29sdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgICByZXR1cm4gTWFwKHRoaXMudG9LZXllZFNlcSgpKTtcbiAgICB9LFxuXG4gICAgdG9PYmplY3Q6IHRvT2JqZWN0LFxuXG4gICAgdG9PcmRlcmVkTWFwOiBmdW5jdGlvbiB0b09yZGVyZWRNYXAoKSB7XG4gICAgICAvLyBVc2UgTGF0ZSBCaW5kaW5nIGhlcmUgdG8gc29sdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgICByZXR1cm4gT3JkZXJlZE1hcCh0aGlzLnRvS2V5ZWRTZXEoKSk7XG4gICAgfSxcblxuICAgIHRvT3JkZXJlZFNldDogZnVuY3Rpb24gdG9PcmRlcmVkU2V0KCkge1xuICAgICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgICAgcmV0dXJuIE9yZGVyZWRTZXQoaXNLZXllZCh0aGlzKSA/IHRoaXMudmFsdWVTZXEoKSA6IHRoaXMpO1xuICAgIH0sXG5cbiAgICB0b1NldDogZnVuY3Rpb24gdG9TZXQoKSB7XG4gICAgICAvLyBVc2UgTGF0ZSBCaW5kaW5nIGhlcmUgdG8gc29sdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgICByZXR1cm4gU2V0KGlzS2V5ZWQodGhpcykgPyB0aGlzLnZhbHVlU2VxKCkgOiB0aGlzKTtcbiAgICB9LFxuXG4gICAgdG9TZXRTZXE6IGZ1bmN0aW9uIHRvU2V0U2VxKCkge1xuICAgICAgcmV0dXJuIG5ldyBUb1NldFNlcXVlbmNlKHRoaXMpO1xuICAgIH0sXG5cbiAgICB0b1NlcTogZnVuY3Rpb24gdG9TZXEoKSB7XG4gICAgICByZXR1cm4gaXNJbmRleGVkKHRoaXMpXG4gICAgICAgID8gdGhpcy50b0luZGV4ZWRTZXEoKVxuICAgICAgICA6IGlzS2V5ZWQodGhpcylcbiAgICAgICAgPyB0aGlzLnRvS2V5ZWRTZXEoKVxuICAgICAgICA6IHRoaXMudG9TZXRTZXEoKTtcbiAgICB9LFxuXG4gICAgdG9TdGFjazogZnVuY3Rpb24gdG9TdGFjaygpIHtcbiAgICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICAgIHJldHVybiBTdGFjayhpc0tleWVkKHRoaXMpID8gdGhpcy52YWx1ZVNlcSgpIDogdGhpcyk7XG4gICAgfSxcblxuICAgIHRvTGlzdDogZnVuY3Rpb24gdG9MaXN0KCkge1xuICAgICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgICAgcmV0dXJuIExpc3QoaXNLZXllZCh0aGlzKSA/IHRoaXMudmFsdWVTZXEoKSA6IHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyAjIyMgQ29tbW9uIEphdmFTY3JpcHQgbWV0aG9kcyBhbmQgcHJvcGVydGllc1xuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdbQ29sbGVjdGlvbl0nO1xuICAgIH0sXG5cbiAgICBfX3RvU3RyaW5nOiBmdW5jdGlvbiBfX3RvU3RyaW5nKGhlYWQsIHRhaWwpIHtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgaGVhZCArXG4gICAgICAgICcgJyArXG4gICAgICAgIHRoaXMudG9TZXEoKS5tYXAodGhpcy5fX3RvU3RyaW5nTWFwcGVyKS5qb2luKCcsICcpICtcbiAgICAgICAgJyAnICtcbiAgICAgICAgdGFpbFxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLy8gIyMjIEVTNiBDb2xsZWN0aW9uIG1ldGhvZHMgKEVTNiBBcnJheSBhbmQgTWFwKVxuXG4gICAgY29uY2F0OiBmdW5jdGlvbiBjb25jYXQoKSB7XG4gICAgICB2YXIgdmFsdWVzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgdmFsdWVzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBjb25jYXRGYWN0b3J5KHRoaXMsIHZhbHVlcykpO1xuICAgIH0sXG5cbiAgICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoVmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvbWUoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBpcyh2YWx1ZSwgc2VhcmNoVmFsdWUpOyB9KTtcbiAgICB9LFxuXG4gICAgZW50cmllczogZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTKTtcbiAgICB9LFxuXG4gICAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5zaXplKTtcbiAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHRydWU7XG4gICAgICB0aGlzLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaywgYykge1xuICAgICAgICBpZiAoIXByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIGMpKSB7XG4gICAgICAgICAgcmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH0sXG5cbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBmaWx0ZXJGYWN0b3J5KHRoaXMsIHByZWRpY2F0ZSwgY29udGV4dCwgdHJ1ZSkpO1xuICAgIH0sXG5cbiAgICBmaW5kOiBmdW5jdGlvbiBmaW5kKHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHZhciBlbnRyeSA9IHRoaXMuZmluZEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgICByZXR1cm4gZW50cnkgPyBlbnRyeVsxXSA6IG5vdFNldFZhbHVlO1xuICAgIH0sXG5cbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKHNpZGVFZmZlY3QsIGNvbnRleHQpIHtcbiAgICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMuc2l6ZSk7XG4gICAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdGUoY29udGV4dCA/IHNpZGVFZmZlY3QuYmluZChjb250ZXh0KSA6IHNpZGVFZmZlY3QpO1xuICAgIH0sXG5cbiAgICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcikge1xuICAgICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5zaXplKTtcbiAgICAgIHNlcGFyYXRvciA9IHNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gJycgKyBzZXBhcmF0b3IgOiAnLCc7XG4gICAgICB2YXIgam9pbmVkID0gJyc7XG4gICAgICB2YXIgaXNGaXJzdCA9IHRydWU7XG4gICAgICB0aGlzLl9faXRlcmF0ZShmdW5jdGlvbiAodikge1xuICAgICAgICBpc0ZpcnN0ID8gKGlzRmlyc3QgPSBmYWxzZSkgOiAoam9pbmVkICs9IHNlcGFyYXRvcik7XG4gICAgICAgIGpvaW5lZCArPSB2ICE9PSBudWxsICYmIHYgIT09IHVuZGVmaW5lZCA/IHYudG9TdHJpbmcoKSA6ICcnO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gam9pbmVkO1xuICAgIH0sXG5cbiAgICBrZXlzOiBmdW5jdGlvbiBrZXlzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX0tFWVMpO1xuICAgIH0sXG5cbiAgICBtYXA6IGZ1bmN0aW9uIG1hcChtYXBwZXIsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBtYXBGYWN0b3J5KHRoaXMsIG1hcHBlciwgY29udGV4dCkpO1xuICAgIH0sXG5cbiAgICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZSQxKHJlZHVjZXIsIGluaXRpYWxSZWR1Y3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWR1Y2UoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHJlZHVjZXIsXG4gICAgICAgIGluaXRpYWxSZWR1Y3Rpb24sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPCAyLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KHJlZHVjZXIsIGluaXRpYWxSZWR1Y3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWR1Y2UoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHJlZHVjZXIsXG4gICAgICAgIGluaXRpYWxSZWR1Y3Rpb24sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPCAyLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH0sXG5cbiAgICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHJldmVyc2VGYWN0b3J5KHRoaXMsIHRydWUpKTtcbiAgICB9LFxuXG4gICAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKGJlZ2luLCBlbmQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBzbGljZUZhY3RvcnkodGhpcywgYmVnaW4sIGVuZCwgdHJ1ZSkpO1xuICAgIH0sXG5cbiAgICBzb21lOiBmdW5jdGlvbiBzb21lKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuICF0aGlzLmV2ZXJ5KG5vdChwcmVkaWNhdGUpLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvcikpO1xuICAgIH0sXG5cbiAgICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMpO1xuICAgIH0sXG5cbiAgICAvLyAjIyMgTW9yZSBzZXF1ZW50aWFsIG1ldGhvZHNcblxuICAgIGJ1dExhc3Q6IGZ1bmN0aW9uIGJ1dExhc3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zbGljZSgwLCAtMSk7XG4gICAgfSxcblxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaXplICE9PSB1bmRlZmluZWQgPyB0aGlzLnNpemUgPT09IDAgOiAhdGhpcy5zb21lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0pO1xuICAgIH0sXG5cbiAgICBjb3VudDogZnVuY3Rpb24gY291bnQocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gZW5zdXJlU2l6ZShcbiAgICAgICAgcHJlZGljYXRlID8gdGhpcy50b1NlcSgpLmZpbHRlcihwcmVkaWNhdGUsIGNvbnRleHQpIDogdGhpc1xuICAgICAgKTtcbiAgICB9LFxuXG4gICAgY291bnRCeTogZnVuY3Rpb24gY291bnRCeShncm91cGVyLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gY291bnRCeUZhY3RvcnkodGhpcywgZ3JvdXBlciwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgICByZXR1cm4gZGVlcEVxdWFsKHRoaXMsIG90aGVyKTtcbiAgICB9LFxuXG4gICAgZW50cnlTZXE6IGZ1bmN0aW9uIGVudHJ5U2VxKCkge1xuICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzO1xuICAgICAgaWYgKGNvbGxlY3Rpb24uX2NhY2hlKSB7XG4gICAgICAgIC8vIFdlIGNhY2hlIGFzIGFuIGVudHJpZXMgYXJyYXksIHNvIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgY2FjaGUhXG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlTZXEoY29sbGVjdGlvbi5fY2FjaGUpO1xuICAgICAgfVxuICAgICAgdmFyIGVudHJpZXNTZXF1ZW5jZSA9IGNvbGxlY3Rpb24udG9TZXEoKS5tYXAoZW50cnlNYXBwZXIpLnRvSW5kZXhlZFNlcSgpO1xuICAgICAgZW50cmllc1NlcXVlbmNlLmZyb21FbnRyeVNlcSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbGxlY3Rpb24udG9TZXEoKTsgfTtcbiAgICAgIHJldHVybiBlbnRyaWVzU2VxdWVuY2U7XG4gICAgfSxcblxuICAgIGZpbHRlck5vdDogZnVuY3Rpb24gZmlsdGVyTm90KHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKG5vdChwcmVkaWNhdGUpLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgZmluZEVudHJ5OiBmdW5jdGlvbiBmaW5kRW50cnkocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSkge1xuICAgICAgdmFyIGZvdW5kID0gbm90U2V0VmFsdWU7XG4gICAgICB0aGlzLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaywgYykge1xuICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgYykpIHtcbiAgICAgICAgICBmb3VuZCA9IFtrLCB2XTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH0sXG5cbiAgICBmaW5kS2V5OiBmdW5jdGlvbiBmaW5kS2V5KHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgdmFyIGVudHJ5ID0gdGhpcy5maW5kRW50cnkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeVswXTtcbiAgICB9LFxuXG4gICAgZmluZExhc3Q6IGZ1bmN0aW9uIGZpbmRMYXN0KHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvS2V5ZWRTZXEoKS5yZXZlcnNlKCkuZmluZChwcmVkaWNhdGUsIGNvbnRleHQsIG5vdFNldFZhbHVlKTtcbiAgICB9LFxuXG4gICAgZmluZExhc3RFbnRyeTogZnVuY3Rpb24gZmluZExhc3RFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQsIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0tleWVkU2VxKClcbiAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAuZmluZEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpO1xuICAgIH0sXG5cbiAgICBmaW5kTGFzdEtleTogZnVuY3Rpb24gZmluZExhc3RLZXkocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy50b0tleWVkU2VxKCkucmV2ZXJzZSgpLmZpbmRLZXkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgZmlyc3Q6IGZ1bmN0aW9uIGZpcnN0KG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5kKHJldHVyblRydWUsIG51bGwsIG5vdFNldFZhbHVlKTtcbiAgICB9LFxuXG4gICAgZmxhdE1hcDogZnVuY3Rpb24gZmxhdE1hcChtYXBwZXIsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBmbGF0TWFwRmFjdG9yeSh0aGlzLCBtYXBwZXIsIGNvbnRleHQpKTtcbiAgICB9LFxuXG4gICAgZmxhdHRlbjogZnVuY3Rpb24gZmxhdHRlbihkZXB0aCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGZsYXR0ZW5GYWN0b3J5KHRoaXMsIGRlcHRoLCB0cnVlKSk7XG4gICAgfSxcblxuICAgIGZyb21FbnRyeVNlcTogZnVuY3Rpb24gZnJvbUVudHJ5U2VxKCkge1xuICAgICAgcmV0dXJuIG5ldyBGcm9tRW50cmllc1NlcXVlbmNlKHRoaXMpO1xuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldChzZWFyY2hLZXksIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5kKGZ1bmN0aW9uIChfLCBrZXkpIHsgcmV0dXJuIGlzKGtleSwgc2VhcmNoS2V5KTsgfSwgdW5kZWZpbmVkLCBub3RTZXRWYWx1ZSk7XG4gICAgfSxcblxuICAgIGdldEluOiBnZXRJbiQxLFxuXG4gICAgZ3JvdXBCeTogZnVuY3Rpb24gZ3JvdXBCeShncm91cGVyLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gZ3JvdXBCeUZhY3RvcnkodGhpcywgZ3JvdXBlciwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIGhhczogZnVuY3Rpb24gaGFzKHNlYXJjaEtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KHNlYXJjaEtleSwgTk9UX1NFVCkgIT09IE5PVF9TRVQ7XG4gICAgfSxcblxuICAgIGhhc0luOiBoYXNJbiQxLFxuXG4gICAgaXNTdWJzZXQ6IGZ1bmN0aW9uIGlzU3Vic2V0KGl0ZXIpIHtcbiAgICAgIGl0ZXIgPSB0eXBlb2YgaXRlci5pbmNsdWRlcyA9PT0gJ2Z1bmN0aW9uJyA/IGl0ZXIgOiBDb2xsZWN0aW9uKGl0ZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuZXZlcnkoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBpdGVyLmluY2x1ZGVzKHZhbHVlKTsgfSk7XG4gICAgfSxcblxuICAgIGlzU3VwZXJzZXQ6IGZ1bmN0aW9uIGlzU3VwZXJzZXQoaXRlcikge1xuICAgICAgaXRlciA9IHR5cGVvZiBpdGVyLmlzU3Vic2V0ID09PSAnZnVuY3Rpb24nID8gaXRlciA6IENvbGxlY3Rpb24oaXRlcik7XG4gICAgICByZXR1cm4gaXRlci5pc1N1YnNldCh0aGlzKTtcbiAgICB9LFxuXG4gICAga2V5T2Y6IGZ1bmN0aW9uIGtleU9mKHNlYXJjaFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5kS2V5KGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gaXModmFsdWUsIHNlYXJjaFZhbHVlKTsgfSk7XG4gICAgfSxcblxuICAgIGtleVNlcTogZnVuY3Rpb24ga2V5U2VxKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9TZXEoKS5tYXAoa2V5TWFwcGVyKS50b0luZGV4ZWRTZXEoKTtcbiAgICB9LFxuXG4gICAgbGFzdDogZnVuY3Rpb24gbGFzdChub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9TZXEoKS5yZXZlcnNlKCkuZmlyc3Qobm90U2V0VmFsdWUpO1xuICAgIH0sXG5cbiAgICBsYXN0S2V5T2Y6IGZ1bmN0aW9uIGxhc3RLZXlPZihzZWFyY2hWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9LZXllZFNlcSgpLnJldmVyc2UoKS5rZXlPZihzZWFyY2hWYWx1ZSk7XG4gICAgfSxcblxuICAgIG1heDogZnVuY3Rpb24gbWF4KGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiBtYXhGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IpO1xuICAgIH0sXG5cbiAgICBtYXhCeTogZnVuY3Rpb24gbWF4QnkobWFwcGVyLCBjb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gbWF4RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yLCBtYXBwZXIpO1xuICAgIH0sXG5cbiAgICBtaW46IGZ1bmN0aW9uIG1pbihjb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gbWF4RmFjdG9yeShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgY29tcGFyYXRvciA/IG5lZyhjb21wYXJhdG9yKSA6IGRlZmF1bHROZWdDb21wYXJhdG9yXG4gICAgICApO1xuICAgIH0sXG5cbiAgICBtaW5CeTogZnVuY3Rpb24gbWluQnkobWFwcGVyLCBjb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gbWF4RmFjdG9yeShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgY29tcGFyYXRvciA/IG5lZyhjb21wYXJhdG9yKSA6IGRlZmF1bHROZWdDb21wYXJhdG9yLFxuICAgICAgICBtYXBwZXJcbiAgICAgICk7XG4gICAgfSxcblxuICAgIHJlc3Q6IGZ1bmN0aW9uIHJlc3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zbGljZSgxKTtcbiAgICB9LFxuXG4gICAgc2tpcDogZnVuY3Rpb24gc2tpcChhbW91bnQpIHtcbiAgICAgIHJldHVybiBhbW91bnQgPT09IDAgPyB0aGlzIDogdGhpcy5zbGljZShNYXRoLm1heCgwLCBhbW91bnQpKTtcbiAgICB9LFxuXG4gICAgc2tpcExhc3Q6IGZ1bmN0aW9uIHNraXBMYXN0KGFtb3VudCkge1xuICAgICAgcmV0dXJuIGFtb3VudCA9PT0gMCA/IHRoaXMgOiB0aGlzLnNsaWNlKDAsIC1NYXRoLm1heCgwLCBhbW91bnQpKTtcbiAgICB9LFxuXG4gICAgc2tpcFdoaWxlOiBmdW5jdGlvbiBza2lwV2hpbGUocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgc2tpcFdoaWxlRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQsIHRydWUpKTtcbiAgICB9LFxuXG4gICAgc2tpcFVudGlsOiBmdW5jdGlvbiBza2lwVW50aWwocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5za2lwV2hpbGUobm90KHByZWRpY2F0ZSksIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBzb3J0Qnk6IGZ1bmN0aW9uIHNvcnRCeShtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yLCBtYXBwZXIpKTtcbiAgICB9LFxuXG4gICAgdGFrZTogZnVuY3Rpb24gdGFrZShhbW91bnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNsaWNlKDAsIE1hdGgubWF4KDAsIGFtb3VudCkpO1xuICAgIH0sXG5cbiAgICB0YWtlTGFzdDogZnVuY3Rpb24gdGFrZUxhc3QoYW1vdW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5zbGljZSgtTWF0aC5tYXgoMCwgYW1vdW50KSk7XG4gICAgfSxcblxuICAgIHRha2VXaGlsZTogZnVuY3Rpb24gdGFrZVdoaWxlKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHRha2VXaGlsZUZhY3RvcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0KSk7XG4gICAgfSxcblxuICAgIHRha2VVbnRpbDogZnVuY3Rpb24gdGFrZVVudGlsKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMudGFrZVdoaWxlKG5vdChwcmVkaWNhdGUpLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoZm4pIHtcbiAgICAgIHJldHVybiBmbih0aGlzKTtcbiAgICB9LFxuXG4gICAgdmFsdWVTZXE6IGZ1bmN0aW9uIHZhbHVlU2VxKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9JbmRleGVkU2VxKCk7XG4gICAgfSxcblxuICAgIC8vICMjIyBIYXNoYWJsZSBPYmplY3RcblxuICAgIGhhc2hDb2RlOiBmdW5jdGlvbiBoYXNoQ29kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9faGFzaCB8fCAodGhpcy5fX2hhc2ggPSBoYXNoQ29sbGVjdGlvbih0aGlzKSk7XG4gICAgfSxcblxuICAgIC8vICMjIyBJbnRlcm5hbFxuXG4gICAgLy8gYWJzdHJhY3QgX19pdGVyYXRlKGZuLCByZXZlcnNlKVxuXG4gICAgLy8gYWJzdHJhY3QgX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKVxuICB9KTtcblxuICB2YXIgQ29sbGVjdGlvblByb3RvdHlwZSA9IENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICBDb2xsZWN0aW9uUHJvdG90eXBlW0lTX0NPTExFQ1RJT05fU1lNQk9MXSA9IHRydWU7XG4gIENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JfU1lNQk9MXSA9IENvbGxlY3Rpb25Qcm90b3R5cGUudmFsdWVzO1xuICBDb2xsZWN0aW9uUHJvdG90eXBlLnRvSlNPTiA9IENvbGxlY3Rpb25Qcm90b3R5cGUudG9BcnJheTtcbiAgQ29sbGVjdGlvblByb3RvdHlwZS5fX3RvU3RyaW5nTWFwcGVyID0gcXVvdGVTdHJpbmc7XG4gIENvbGxlY3Rpb25Qcm90b3R5cGUuaW5zcGVjdCA9IENvbGxlY3Rpb25Qcm90b3R5cGUudG9Tb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfTtcbiAgQ29sbGVjdGlvblByb3RvdHlwZS5jaGFpbiA9IENvbGxlY3Rpb25Qcm90b3R5cGUuZmxhdE1hcDtcbiAgQ29sbGVjdGlvblByb3RvdHlwZS5jb250YWlucyA9IENvbGxlY3Rpb25Qcm90b3R5cGUuaW5jbHVkZXM7XG5cbiAgbWl4aW4oS2V5ZWRDb2xsZWN0aW9uLCB7XG4gICAgLy8gIyMjIE1vcmUgc2VxdWVudGlhbCBtZXRob2RzXG5cbiAgICBmbGlwOiBmdW5jdGlvbiBmbGlwKCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGZsaXBGYWN0b3J5KHRoaXMpKTtcbiAgICB9LFxuXG4gICAgbWFwRW50cmllczogZnVuY3Rpb24gbWFwRW50cmllcyhtYXBwZXIsIGNvbnRleHQpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICByZXR1cm4gcmVpZnkoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRoaXMudG9TZXEoKVxuICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIG1hcHBlci5jYWxsKGNvbnRleHQsIFtrLCB2XSwgaXRlcmF0aW9ucysrLCB0aGlzJDEpOyB9KVxuICAgICAgICAgIC5mcm9tRW50cnlTZXEoKVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgbWFwS2V5czogZnVuY3Rpb24gbWFwS2V5cyhtYXBwZXIsIGNvbnRleHQpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gcmVpZnkoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRoaXMudG9TZXEoKVxuICAgICAgICAgIC5mbGlwKClcbiAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrLCB2KSB7IHJldHVybiBtYXBwZXIuY2FsbChjb250ZXh0LCBrLCB2LCB0aGlzJDEpOyB9KVxuICAgICAgICAgIC5mbGlwKClcbiAgICAgICk7XG4gICAgfSxcbiAgfSk7XG5cbiAgdmFyIEtleWVkQ29sbGVjdGlvblByb3RvdHlwZSA9IEtleWVkQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIEtleWVkQ29sbGVjdGlvblByb3RvdHlwZVtJU19LRVlFRF9TWU1CT0xdID0gdHJ1ZTtcbiAgS2V5ZWRDb2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SX1NZTUJPTF0gPSBDb2xsZWN0aW9uUHJvdG90eXBlLmVudHJpZXM7XG4gIEtleWVkQ29sbGVjdGlvblByb3RvdHlwZS50b0pTT04gPSB0b09iamVjdDtcbiAgS2V5ZWRDb2xsZWN0aW9uUHJvdG90eXBlLl9fdG9TdHJpbmdNYXBwZXIgPSBmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gcXVvdGVTdHJpbmcoaykgKyAnOiAnICsgcXVvdGVTdHJpbmcodik7IH07XG5cbiAgbWl4aW4oSW5kZXhlZENvbGxlY3Rpb24sIHtcbiAgICAvLyAjIyMgQ29udmVyc2lvbiB0byBvdGhlciB0eXBlc1xuXG4gICAgdG9LZXllZFNlcTogZnVuY3Rpb24gdG9LZXllZFNlcSgpIHtcbiAgICAgIHJldHVybiBuZXcgVG9LZXllZFNlcXVlbmNlKHRoaXMsIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgLy8gIyMjIEVTNiBDb2xsZWN0aW9uIG1ldGhvZHMgKEVTNiBBcnJheSBhbmQgTWFwKVxuXG4gICAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgZmlsdGVyRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQsIGZhbHNlKSk7XG4gICAgfSxcblxuICAgIGZpbmRJbmRleDogZnVuY3Rpb24gZmluZEluZGV4KHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgdmFyIGVudHJ5ID0gdGhpcy5maW5kRW50cnkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBlbnRyeSA/IGVudHJ5WzBdIDogLTE7XG4gICAgfSxcblxuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoVmFsdWUpIHtcbiAgICAgIHZhciBrZXkgPSB0aGlzLmtleU9mKHNlYXJjaFZhbHVlKTtcbiAgICAgIHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/IC0xIDoga2V5O1xuICAgIH0sXG5cbiAgICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoVmFsdWUpIHtcbiAgICAgIHZhciBrZXkgPSB0aGlzLmxhc3RLZXlPZihzZWFyY2hWYWx1ZSk7XG4gICAgICByZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgPyAtMSA6IGtleTtcbiAgICB9LFxuXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCByZXZlcnNlRmFjdG9yeSh0aGlzLCBmYWxzZSkpO1xuICAgIH0sXG5cbiAgICBzbGljZTogZnVuY3Rpb24gc2xpY2UoYmVnaW4sIGVuZCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHNsaWNlRmFjdG9yeSh0aGlzLCBiZWdpbiwgZW5kLCBmYWxzZSkpO1xuICAgIH0sXG5cbiAgICBzcGxpY2U6IGZ1bmN0aW9uIHNwbGljZShpbmRleCwgcmVtb3ZlTnVtIC8qLCAuLi52YWx1ZXMqLykge1xuICAgICAgdmFyIG51bUFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgcmVtb3ZlTnVtID0gTWF0aC5tYXgocmVtb3ZlTnVtIHx8IDAsIDApO1xuICAgICAgaWYgKG51bUFyZ3MgPT09IDAgfHwgKG51bUFyZ3MgPT09IDIgJiYgIXJlbW92ZU51bSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICAvLyBJZiBpbmRleCBpcyBuZWdhdGl2ZSwgaXQgc2hvdWxkIHJlc29sdmUgcmVsYXRpdmUgdG8gdGhlIHNpemUgb2YgdGhlXG4gICAgICAvLyBjb2xsZWN0aW9uLiBIb3dldmVyIHNpemUgbWF5IGJlIGV4cGVuc2l2ZSB0byBjb21wdXRlIGlmIG5vdCBjYWNoZWQsIHNvXG4gICAgICAvLyBvbmx5IGNhbGwgY291bnQoKSBpZiB0aGUgbnVtYmVyIGlzIGluIGZhY3QgbmVnYXRpdmUuXG4gICAgICBpbmRleCA9IHJlc29sdmVCZWdpbihpbmRleCwgaW5kZXggPCAwID8gdGhpcy5jb3VudCgpIDogdGhpcy5zaXplKTtcbiAgICAgIHZhciBzcGxpY2VkID0gdGhpcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICByZXR1cm4gcmVpZnkoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIG51bUFyZ3MgPT09IDFcbiAgICAgICAgICA/IHNwbGljZWRcbiAgICAgICAgICA6IHNwbGljZWQuY29uY2F0KGFyckNvcHkoYXJndW1lbnRzLCAyKSwgdGhpcy5zbGljZShpbmRleCArIHJlbW92ZU51bSkpXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvLyAjIyMgTW9yZSBjb2xsZWN0aW9uIG1ldGhvZHNcblxuICAgIGZpbmRMYXN0SW5kZXg6IGZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgZW50cnkgPSB0aGlzLmZpbmRMYXN0RW50cnkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBlbnRyeSA/IGVudHJ5WzBdIDogLTE7XG4gICAgfSxcblxuICAgIGZpcnN0OiBmdW5jdGlvbiBmaXJzdChub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KDAsIG5vdFNldFZhbHVlKTtcbiAgICB9LFxuXG4gICAgZmxhdHRlbjogZnVuY3Rpb24gZmxhdHRlbihkZXB0aCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGZsYXR0ZW5GYWN0b3J5KHRoaXMsIGRlcHRoLCBmYWxzZSkpO1xuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldChpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICAgIHJldHVybiBpbmRleCA8IDAgfHxcbiAgICAgICAgdGhpcy5zaXplID09PSBJbmZpbml0eSB8fFxuICAgICAgICAodGhpcy5zaXplICE9PSB1bmRlZmluZWQgJiYgaW5kZXggPiB0aGlzLnNpemUpXG4gICAgICAgID8gbm90U2V0VmFsdWVcbiAgICAgICAgOiB0aGlzLmZpbmQoZnVuY3Rpb24gKF8sIGtleSkgeyByZXR1cm4ga2V5ID09PSBpbmRleDsgfSwgdW5kZWZpbmVkLCBub3RTZXRWYWx1ZSk7XG4gICAgfSxcblxuICAgIGhhczogZnVuY3Rpb24gaGFzKGluZGV4KSB7XG4gICAgICBpbmRleCA9IHdyYXBJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBpbmRleCA+PSAwICYmXG4gICAgICAgICh0aGlzLnNpemUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gdGhpcy5zaXplID09PSBJbmZpbml0eSB8fCBpbmRleCA8IHRoaXMuc2l6ZVxuICAgICAgICAgIDogdGhpcy5pbmRleE9mKGluZGV4KSAhPT0gLTEpXG4gICAgICApO1xuICAgIH0sXG5cbiAgICBpbnRlcnBvc2U6IGZ1bmN0aW9uIGludGVycG9zZShzZXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBpbnRlcnBvc2VGYWN0b3J5KHRoaXMsIHNlcGFyYXRvcikpO1xuICAgIH0sXG5cbiAgICBpbnRlcmxlYXZlOiBmdW5jdGlvbiBpbnRlcmxlYXZlKC8qLi4uY29sbGVjdGlvbnMqLykge1xuICAgICAgdmFyIGNvbGxlY3Rpb25zID0gW3RoaXNdLmNvbmNhdChhcnJDb3B5KGFyZ3VtZW50cykpO1xuICAgICAgdmFyIHppcHBlZCA9IHppcFdpdGhGYWN0b3J5KHRoaXMudG9TZXEoKSwgSW5kZXhlZFNlcS5vZiwgY29sbGVjdGlvbnMpO1xuICAgICAgdmFyIGludGVybGVhdmVkID0gemlwcGVkLmZsYXR0ZW4odHJ1ZSk7XG4gICAgICBpZiAoemlwcGVkLnNpemUpIHtcbiAgICAgICAgaW50ZXJsZWF2ZWQuc2l6ZSA9IHppcHBlZC5zaXplICogY29sbGVjdGlvbnMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGludGVybGVhdmVkKTtcbiAgICB9LFxuXG4gICAga2V5U2VxOiBmdW5jdGlvbiBrZXlTZXEoKSB7XG4gICAgICByZXR1cm4gUmFuZ2UoMCwgdGhpcy5zaXplKTtcbiAgICB9LFxuXG4gICAgbGFzdDogZnVuY3Rpb24gbGFzdChub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KC0xLCBub3RTZXRWYWx1ZSk7XG4gICAgfSxcblxuICAgIHNraXBXaGlsZTogZnVuY3Rpb24gc2tpcFdoaWxlKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHNraXBXaGlsZUZhY3RvcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0LCBmYWxzZSkpO1xuICAgIH0sXG5cbiAgICB6aXA6IGZ1bmN0aW9uIHppcCgvKiwgLi4uY29sbGVjdGlvbnMgKi8pIHtcbiAgICAgIHZhciBjb2xsZWN0aW9ucyA9IFt0aGlzXS5jb25jYXQoYXJyQ29weShhcmd1bWVudHMpKTtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCB6aXBXaXRoRmFjdG9yeSh0aGlzLCBkZWZhdWx0WmlwcGVyLCBjb2xsZWN0aW9ucykpO1xuICAgIH0sXG5cbiAgICB6aXBBbGw6IGZ1bmN0aW9uIHppcEFsbCgvKiwgLi4uY29sbGVjdGlvbnMgKi8pIHtcbiAgICAgIHZhciBjb2xsZWN0aW9ucyA9IFt0aGlzXS5jb25jYXQoYXJyQ29weShhcmd1bWVudHMpKTtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCB6aXBXaXRoRmFjdG9yeSh0aGlzLCBkZWZhdWx0WmlwcGVyLCBjb2xsZWN0aW9ucywgdHJ1ZSkpO1xuICAgIH0sXG5cbiAgICB6aXBXaXRoOiBmdW5jdGlvbiB6aXBXaXRoKHppcHBlciAvKiwgLi4uY29sbGVjdGlvbnMgKi8pIHtcbiAgICAgIHZhciBjb2xsZWN0aW9ucyA9IGFyckNvcHkoYXJndW1lbnRzKTtcbiAgICAgIGNvbGxlY3Rpb25zWzBdID0gdGhpcztcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCB6aXBXaXRoRmFjdG9yeSh0aGlzLCB6aXBwZXIsIGNvbGxlY3Rpb25zKSk7XG4gICAgfSxcbiAgfSk7XG5cbiAgdmFyIEluZGV4ZWRDb2xsZWN0aW9uUHJvdG90eXBlID0gSW5kZXhlZENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICBJbmRleGVkQ29sbGVjdGlvblByb3RvdHlwZVtJU19JTkRFWEVEX1NZTUJPTF0gPSB0cnVlO1xuICBJbmRleGVkQ29sbGVjdGlvblByb3RvdHlwZVtJU19PUkRFUkVEX1NZTUJPTF0gPSB0cnVlO1xuXG4gIG1peGluKFNldENvbGxlY3Rpb24sIHtcbiAgICAvLyAjIyMgRVM2IENvbGxlY3Rpb24gbWV0aG9kcyAoRVM2IEFycmF5IGFuZCBNYXApXG5cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCh2YWx1ZSwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyh2YWx1ZSkgPyB2YWx1ZSA6IG5vdFNldFZhbHVlO1xuICAgIH0sXG5cbiAgICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyh2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8vICMjIyBNb3JlIHNlcXVlbnRpYWwgbWV0aG9kc1xuXG4gICAga2V5U2VxOiBmdW5jdGlvbiBrZXlTZXEoKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZVNlcSgpO1xuICAgIH0sXG4gIH0pO1xuXG4gIFNldENvbGxlY3Rpb24ucHJvdG90eXBlLmhhcyA9IENvbGxlY3Rpb25Qcm90b3R5cGUuaW5jbHVkZXM7XG4gIFNldENvbGxlY3Rpb24ucHJvdG90eXBlLmNvbnRhaW5zID0gU2V0Q29sbGVjdGlvbi5wcm90b3R5cGUuaW5jbHVkZXM7XG5cbiAgLy8gTWl4aW4gc3ViY2xhc3Nlc1xuXG4gIG1peGluKEtleWVkU2VxLCBLZXllZENvbGxlY3Rpb24ucHJvdG90eXBlKTtcbiAgbWl4aW4oSW5kZXhlZFNlcSwgSW5kZXhlZENvbGxlY3Rpb24ucHJvdG90eXBlKTtcbiAgbWl4aW4oU2V0U2VxLCBTZXRDb2xsZWN0aW9uLnByb3RvdHlwZSk7XG5cbiAgLy8gI3ByYWdtYSBIZWxwZXIgZnVuY3Rpb25zXG5cbiAgZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIHJlZHVjZXIsIHJlZHVjdGlvbiwgY29udGV4dCwgdXNlRmlyc3QsIHJldmVyc2UpIHtcbiAgICBhc3NlcnROb3RJbmZpbml0ZShjb2xsZWN0aW9uLnNpemUpO1xuICAgIGNvbGxlY3Rpb24uX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrLCBjKSB7XG4gICAgICBpZiAodXNlRmlyc3QpIHtcbiAgICAgICAgdXNlRmlyc3QgPSBmYWxzZTtcbiAgICAgICAgcmVkdWN0aW9uID0gdjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZHVjdGlvbiA9IHJlZHVjZXIuY2FsbChjb250ZXh0LCByZWR1Y3Rpb24sIHYsIGssIGMpO1xuICAgICAgfVxuICAgIH0sIHJldmVyc2UpO1xuICAgIHJldHVybiByZWR1Y3Rpb247XG4gIH1cblxuICBmdW5jdGlvbiBrZXlNYXBwZXIodiwgaykge1xuICAgIHJldHVybiBrO1xuICB9XG5cbiAgZnVuY3Rpb24gZW50cnlNYXBwZXIodiwgaykge1xuICAgIHJldHVybiBbaywgdl07XG4gIH1cblxuICBmdW5jdGlvbiBub3QocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5lZyhwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIC1wcmVkaWNhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdFppcHBlcigpIHtcbiAgICByZXR1cm4gYXJyQ29weShhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdE5lZ0NvbXBhcmF0b3IoYSwgYikge1xuICAgIHJldHVybiBhIDwgYiA/IDEgOiBhID4gYiA/IC0xIDogMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc2hDb2xsZWN0aW9uKGNvbGxlY3Rpb24pIHtcbiAgICBpZiAoY29sbGVjdGlvbi5zaXplID09PSBJbmZpbml0eSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHZhciBvcmRlcmVkID0gaXNPcmRlcmVkKGNvbGxlY3Rpb24pO1xuICAgIHZhciBrZXllZCA9IGlzS2V5ZWQoY29sbGVjdGlvbik7XG4gICAgdmFyIGggPSBvcmRlcmVkID8gMSA6IDA7XG4gICAgdmFyIHNpemUgPSBjb2xsZWN0aW9uLl9faXRlcmF0ZShcbiAgICAgIGtleWVkXG4gICAgICAgID8gb3JkZXJlZFxuICAgICAgICAgID8gZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgICAgICAgaCA9ICgzMSAqIGggKyBoYXNoTWVyZ2UoaGFzaCh2KSwgaGFzaChrKSkpIHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgICAgICAgIGggPSAoaCArIGhhc2hNZXJnZShoYXNoKHYpLCBoYXNoKGspKSkgfCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICA6IG9yZGVyZWRcbiAgICAgICAgPyBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgaCA9ICgzMSAqIGggKyBoYXNoKHYpKSB8IDA7XG4gICAgICAgICAgfVxuICAgICAgICA6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBoID0gKGggKyBoYXNoKHYpKSB8IDA7XG4gICAgICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIG11cm11ckhhc2hPZlNpemUoc2l6ZSwgaCk7XG4gIH1cblxuICBmdW5jdGlvbiBtdXJtdXJIYXNoT2ZTaXplKHNpemUsIGgpIHtcbiAgICBoID0gaW11bChoLCAweGNjOWUyZDUxKTtcbiAgICBoID0gaW11bCgoaCA8PCAxNSkgfCAoaCA+Pj4gLTE1KSwgMHgxYjg3MzU5Myk7XG4gICAgaCA9IGltdWwoKGggPDwgMTMpIHwgKGggPj4+IC0xMyksIDUpO1xuICAgIGggPSAoKGggKyAweGU2NTQ2YjY0KSB8IDApIF4gc2l6ZTtcbiAgICBoID0gaW11bChoIF4gKGggPj4+IDE2KSwgMHg4NWViY2E2Yik7XG4gICAgaCA9IGltdWwoaCBeIChoID4+PiAxMyksIDB4YzJiMmFlMzUpO1xuICAgIGggPSBzbWkoaCBeIChoID4+PiAxNikpO1xuICAgIHJldHVybiBoO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzaE1lcmdlKGEsIGIpIHtcbiAgICByZXR1cm4gKGEgXiAoYiArIDB4OWUzNzc5YjkgKyAoYSA8PCA2KSArIChhID4+IDIpKSkgfCAwOyAvLyBpbnRcbiAgfVxuXG4gIHZhciBPcmRlcmVkU2V0ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoU2V0KSB7XG4gICAgZnVuY3Rpb24gT3JkZXJlZFNldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBlbXB0eU9yZGVyZWRTZXQoKVxuICAgICAgICA6IGlzT3JkZXJlZFNldCh2YWx1ZSlcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IGVtcHR5T3JkZXJlZFNldCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKHNldCkge1xuICAgICAgICAgICAgdmFyIGl0ZXIgPSBTZXRDb2xsZWN0aW9uKHZhbHVlKTtcbiAgICAgICAgICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG4gICAgICAgICAgICBpdGVyLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHNldC5hZGQodik7IH0pO1xuICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICggU2V0ICkgT3JkZXJlZFNldC5fX3Byb3RvX18gPSBTZXQ7XG4gICAgT3JkZXJlZFNldC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTZXQgJiYgU2V0LnByb3RvdHlwZSApO1xuICAgIE9yZGVyZWRTZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT3JkZXJlZFNldDtcblxuICAgIE9yZGVyZWRTZXQub2YgPSBmdW5jdGlvbiBvZiAoLyouLi52YWx1ZXMqLykge1xuICAgICAgcmV0dXJuIHRoaXMoYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgT3JkZXJlZFNldC5mcm9tS2V5cyA9IGZ1bmN0aW9uIGZyb21LZXlzICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMoS2V5ZWRDb2xsZWN0aW9uKHZhbHVlKS5rZXlTZXEoKSk7XG4gICAgfTtcblxuICAgIE9yZGVyZWRTZXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnT3JkZXJlZFNldCB7JywgJ30nKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE9yZGVyZWRTZXQ7XG4gIH0oU2V0KSk7XG5cbiAgT3JkZXJlZFNldC5pc09yZGVyZWRTZXQgPSBpc09yZGVyZWRTZXQ7XG5cbiAgdmFyIE9yZGVyZWRTZXRQcm90b3R5cGUgPSBPcmRlcmVkU2V0LnByb3RvdHlwZTtcbiAgT3JkZXJlZFNldFByb3RvdHlwZVtJU19PUkRFUkVEX1NZTUJPTF0gPSB0cnVlO1xuICBPcmRlcmVkU2V0UHJvdG90eXBlLnppcCA9IEluZGV4ZWRDb2xsZWN0aW9uUHJvdG90eXBlLnppcDtcbiAgT3JkZXJlZFNldFByb3RvdHlwZS56aXBXaXRoID0gSW5kZXhlZENvbGxlY3Rpb25Qcm90b3R5cGUuemlwV2l0aDtcblxuICBPcmRlcmVkU2V0UHJvdG90eXBlLl9fZW1wdHkgPSBlbXB0eU9yZGVyZWRTZXQ7XG4gIE9yZGVyZWRTZXRQcm90b3R5cGUuX19tYWtlID0gbWFrZU9yZGVyZWRTZXQ7XG5cbiAgZnVuY3Rpb24gbWFrZU9yZGVyZWRTZXQobWFwLCBvd25lcklEKSB7XG4gICAgdmFyIHNldCA9IE9iamVjdC5jcmVhdGUoT3JkZXJlZFNldFByb3RvdHlwZSk7XG4gICAgc2V0LnNpemUgPSBtYXAgPyBtYXAuc2l6ZSA6IDA7XG4gICAgc2V0Ll9tYXAgPSBtYXA7XG4gICAgc2V0Ll9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgcmV0dXJuIHNldDtcbiAgfVxuXG4gIHZhciBFTVBUWV9PUkRFUkVEX1NFVDtcbiAgZnVuY3Rpb24gZW1wdHlPcmRlcmVkU2V0KCkge1xuICAgIHJldHVybiAoXG4gICAgICBFTVBUWV9PUkRFUkVEX1NFVCB8fCAoRU1QVFlfT1JERVJFRF9TRVQgPSBtYWtlT3JkZXJlZFNldChlbXB0eU9yZGVyZWRNYXAoKSkpXG4gICAgKTtcbiAgfVxuXG4gIHZhciBSZWNvcmQgPSBmdW5jdGlvbiBSZWNvcmQoZGVmYXVsdFZhbHVlcywgbmFtZSkge1xuICAgIHZhciBoYXNJbml0aWFsaXplZDtcblxuICAgIHZhciBSZWNvcmRUeXBlID0gZnVuY3Rpb24gUmVjb3JkKHZhbHVlcykge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBSZWNvcmRUeXBlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICB9XG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVjb3JkVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWNvcmRUeXBlKHZhbHVlcyk7XG4gICAgICB9XG4gICAgICBpZiAoIWhhc0luaXRpYWxpemVkKSB7XG4gICAgICAgIGhhc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0VmFsdWVzKTtcbiAgICAgICAgdmFyIGluZGljZXMgPSAoUmVjb3JkVHlwZVByb3RvdHlwZS5faW5kaWNlcyA9IHt9KTtcbiAgICAgICAgLy8gRGVwcmVjYXRlZDogbGVmdCB0byBhdHRlbXB0IG5vdCB0byBicmVhayBhbnkgZXh0ZXJuYWwgY29kZSB3aGljaFxuICAgICAgICAvLyByZWxpZXMgb24gYSAuX25hbWUgcHJvcGVydHkgZXhpc3Rpbmcgb24gcmVjb3JkIGluc3RhbmNlcy5cbiAgICAgICAgLy8gVXNlIFJlY29yZC5nZXREZXNjcmlwdGl2ZU5hbWUoKSBpbnN0ZWFkXG4gICAgICAgIFJlY29yZFR5cGVQcm90b3R5cGUuX25hbWUgPSBuYW1lO1xuICAgICAgICBSZWNvcmRUeXBlUHJvdG90eXBlLl9rZXlzID0ga2V5cztcbiAgICAgICAgUmVjb3JkVHlwZVByb3RvdHlwZS5fZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRWYWx1ZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwcm9wTmFtZSA9IGtleXNbaV07XG4gICAgICAgICAgaW5kaWNlc1twcm9wTmFtZV0gPSBpO1xuICAgICAgICAgIGlmIChSZWNvcmRUeXBlUHJvdG90eXBlW3Byb3BOYW1lXSkge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybiAmJlxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgJ0Nhbm5vdCBkZWZpbmUgJyArXG4gICAgICAgICAgICAgICAgICByZWNvcmROYW1lKHRoaXMpICtcbiAgICAgICAgICAgICAgICAgICcgd2l0aCBwcm9wZXJ0eSBcIicgK1xuICAgICAgICAgICAgICAgICAgcHJvcE5hbWUgK1xuICAgICAgICAgICAgICAgICAgJ1wiIHNpbmNlIHRoYXQgcHJvcGVydHkgbmFtZSBpcyBwYXJ0IG9mIHRoZSBSZWNvcmQgQVBJLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRQcm9wKFJlY29yZFR5cGVQcm90b3R5cGUsIHByb3BOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX19vd25lcklEID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fdmFsdWVzID0gTGlzdCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgbC5zZXRTaXplKHRoaXMkMS5fa2V5cy5sZW5ndGgpO1xuICAgICAgICBLZXllZENvbGxlY3Rpb24odmFsdWVzKS5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgICAgbC5zZXQodGhpcyQxLl9pbmRpY2VzW2tdLCB2ID09PSB0aGlzJDEuX2RlZmF1bHRWYWx1ZXNba10gPyB1bmRlZmluZWQgOiB2KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIFJlY29yZFR5cGVQcm90b3R5cGUgPSAoUmVjb3JkVHlwZS5wcm90b3R5cGUgPVxuICAgICAgT2JqZWN0LmNyZWF0ZShSZWNvcmRQcm90b3R5cGUpKTtcbiAgICBSZWNvcmRUeXBlUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVjb3JkVHlwZTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICBSZWNvcmRUeXBlLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVjb3JkVHlwZTtcbiAgfTtcblxuICBSZWNvcmQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHZhciBzdHIgPSByZWNvcmROYW1lKHRoaXMpICsgJyB7ICc7XG4gICAgdmFyIGtleXMgPSB0aGlzLl9rZXlzO1xuICAgIHZhciBrO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgIT09IGw7IGkrKykge1xuICAgICAgayA9IGtleXNbaV07XG4gICAgICBzdHIgKz0gKGkgPyAnLCAnIDogJycpICsgayArICc6ICcgKyBxdW90ZVN0cmluZyh0aGlzLmdldChrKSk7XG4gICAgfVxuICAgIHJldHVybiBzdHIgKyAnIH0nO1xuICB9O1xuXG4gIFJlY29yZC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChvdGhlcikge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzID09PSBvdGhlciB8fFxuICAgICAgKG90aGVyICYmXG4gICAgICAgIHRoaXMuX2tleXMgPT09IG90aGVyLl9rZXlzICYmXG4gICAgICAgIHJlY29yZFNlcSh0aGlzKS5lcXVhbHMocmVjb3JkU2VxKG90aGVyKSkpXG4gICAgKTtcbiAgfTtcblxuICBSZWNvcmQucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24gaGFzaENvZGUgKCkge1xuICAgIHJldHVybiByZWNvcmRTZXEodGhpcykuaGFzaENvZGUoKTtcbiAgfTtcblxuICAvLyBAcHJhZ21hIEFjY2Vzc1xuXG4gIFJlY29yZC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGljZXMuaGFzT3duUHJvcGVydHkoayk7XG4gIH07XG5cbiAgUmVjb3JkLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGssIG5vdFNldFZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLmhhcyhrKSkge1xuICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9pbmRpY2VzW2tdO1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuX3ZhbHVlcy5nZXQoaW5kZXgpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fZGVmYXVsdFZhbHVlc1trXSA6IHZhbHVlO1xuICB9O1xuXG4gIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgUmVjb3JkLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKGssIHYpIHtcbiAgICBpZiAodGhpcy5oYXMoaykpIHtcbiAgICAgIHZhciBuZXdWYWx1ZXMgPSB0aGlzLl92YWx1ZXMuc2V0KFxuICAgICAgICB0aGlzLl9pbmRpY2VzW2tdLFxuICAgICAgICB2ID09PSB0aGlzLl9kZWZhdWx0VmFsdWVzW2tdID8gdW5kZWZpbmVkIDogdlxuICAgICAgKTtcbiAgICAgIGlmIChuZXdWYWx1ZXMgIT09IHRoaXMuX3ZhbHVlcyAmJiAhdGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VSZWNvcmQodGhpcywgbmV3VmFsdWVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgUmVjb3JkLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKGspIHtcbiAgICByZXR1cm4gdGhpcy5zZXQoayk7XG4gIH07XG5cbiAgUmVjb3JkLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICB2YXIgbmV3VmFsdWVzID0gdGhpcy5fdmFsdWVzLmNsZWFyKCkuc2V0U2l6ZSh0aGlzLl9rZXlzLmxlbmd0aCk7XG4gICAgcmV0dXJuIHRoaXMuX19vd25lcklEID8gdGhpcyA6IG1ha2VSZWNvcmQodGhpcywgbmV3VmFsdWVzKTtcbiAgfTtcblxuICBSZWNvcmQucHJvdG90eXBlLndhc0FsdGVyZWQgPSBmdW5jdGlvbiB3YXNBbHRlcmVkICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWVzLndhc0FsdGVyZWQoKTtcbiAgfTtcblxuICBSZWNvcmQucHJvdG90eXBlLnRvU2VxID0gZnVuY3Rpb24gdG9TZXEgKCkge1xuICAgIHJldHVybiByZWNvcmRTZXEodGhpcyk7XG4gIH07XG5cbiAgUmVjb3JkLnByb3RvdHlwZS50b0pTID0gZnVuY3Rpb24gdG9KUyQxICgpIHtcbiAgICByZXR1cm4gdG9KUyh0aGlzKTtcbiAgfTtcblxuICBSZWNvcmQucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiBlbnRyaWVzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUyk7XG4gIH07XG5cbiAgUmVjb3JkLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHJldHVybiByZWNvcmRTZXEodGhpcykuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgfTtcblxuICBSZWNvcmQucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICByZXR1cm4gcmVjb3JkU2VxKHRoaXMpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gIH07XG5cbiAgUmVjb3JkLnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24gX19lbnN1cmVPd25lciAob3duZXJJRCkge1xuICAgIGlmIChvd25lcklEID09PSB0aGlzLl9fb3duZXJJRCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBuZXdWYWx1ZXMgPSB0aGlzLl92YWx1ZXMuX19lbnN1cmVPd25lcihvd25lcklEKTtcbiAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgIHRoaXMuX3ZhbHVlcyA9IG5ld1ZhbHVlcztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gbWFrZVJlY29yZCh0aGlzLCBuZXdWYWx1ZXMsIG93bmVySUQpO1xuICB9O1xuXG4gIFJlY29yZC5pc1JlY29yZCA9IGlzUmVjb3JkO1xuICBSZWNvcmQuZ2V0RGVzY3JpcHRpdmVOYW1lID0gcmVjb3JkTmFtZTtcbiAgdmFyIFJlY29yZFByb3RvdHlwZSA9IFJlY29yZC5wcm90b3R5cGU7XG4gIFJlY29yZFByb3RvdHlwZVtJU19SRUNPUkRfU1lNQk9MXSA9IHRydWU7XG4gIFJlY29yZFByb3RvdHlwZVtERUxFVEVdID0gUmVjb3JkUHJvdG90eXBlLnJlbW92ZTtcbiAgUmVjb3JkUHJvdG90eXBlLmRlbGV0ZUluID0gUmVjb3JkUHJvdG90eXBlLnJlbW92ZUluID0gZGVsZXRlSW47XG4gIFJlY29yZFByb3RvdHlwZS5nZXRJbiA9IGdldEluJDE7XG4gIFJlY29yZFByb3RvdHlwZS5oYXNJbiA9IENvbGxlY3Rpb25Qcm90b3R5cGUuaGFzSW47XG4gIFJlY29yZFByb3RvdHlwZS5tZXJnZSA9IG1lcmdlO1xuICBSZWNvcmRQcm90b3R5cGUubWVyZ2VXaXRoID0gbWVyZ2VXaXRoO1xuICBSZWNvcmRQcm90b3R5cGUubWVyZ2VJbiA9IG1lcmdlSW47XG4gIFJlY29yZFByb3RvdHlwZS5tZXJnZURlZXAgPSBtZXJnZURlZXAkMTtcbiAgUmVjb3JkUHJvdG90eXBlLm1lcmdlRGVlcFdpdGggPSBtZXJnZURlZXBXaXRoJDE7XG4gIFJlY29yZFByb3RvdHlwZS5tZXJnZURlZXBJbiA9IG1lcmdlRGVlcEluO1xuICBSZWNvcmRQcm90b3R5cGUuc2V0SW4gPSBzZXRJbiQxO1xuICBSZWNvcmRQcm90b3R5cGUudXBkYXRlID0gdXBkYXRlJDE7XG4gIFJlY29yZFByb3RvdHlwZS51cGRhdGVJbiA9IHVwZGF0ZUluJDE7XG4gIFJlY29yZFByb3RvdHlwZS53aXRoTXV0YXRpb25zID0gd2l0aE11dGF0aW9ucztcbiAgUmVjb3JkUHJvdG90eXBlLmFzTXV0YWJsZSA9IGFzTXV0YWJsZTtcbiAgUmVjb3JkUHJvdG90eXBlLmFzSW1tdXRhYmxlID0gYXNJbW11dGFibGU7XG4gIFJlY29yZFByb3RvdHlwZVtJVEVSQVRPUl9TWU1CT0xdID0gUmVjb3JkUHJvdG90eXBlLmVudHJpZXM7XG4gIFJlY29yZFByb3RvdHlwZS50b0pTT04gPSBSZWNvcmRQcm90b3R5cGUudG9PYmplY3QgPVxuICAgIENvbGxlY3Rpb25Qcm90b3R5cGUudG9PYmplY3Q7XG4gIFJlY29yZFByb3RvdHlwZS5pbnNwZWN0ID0gUmVjb3JkUHJvdG90eXBlLnRvU291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZVJlY29yZChsaWtlUmVjb3JkLCB2YWx1ZXMsIG93bmVySUQpIHtcbiAgICB2YXIgcmVjb3JkID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YobGlrZVJlY29yZCkpO1xuICAgIHJlY29yZC5fdmFsdWVzID0gdmFsdWVzO1xuICAgIHJlY29yZC5fX293bmVySUQgPSBvd25lcklEO1xuICAgIHJldHVybiByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvcmROYW1lKHJlY29yZCkge1xuICAgIHJldHVybiByZWNvcmQuY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgcmVjb3JkLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ1JlY29yZCc7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvcmRTZXEocmVjb3JkKSB7XG4gICAgcmV0dXJuIGtleWVkU2VxRnJvbVZhbHVlKHJlY29yZC5fa2V5cy5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIFtrLCByZWNvcmQuZ2V0KGspXTsgfSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0UHJvcChwcm90b3R5cGUsIG5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgbmFtZSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXQobmFtZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaW52YXJpYW50KHRoaXMuX19vd25lcklELCAnQ2Fubm90IHNldCBvbiBhbiBpbW11dGFibGUgcmVjb3JkLicpO1xuICAgICAgICAgIHRoaXMuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBPYmplY3QuZGVmaW5lUHJvcGVydHkgZmFpbGVkLiBQcm9iYWJseSBJRTguXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsYXp5IFNlcSBvZiBgdmFsdWVgIHJlcGVhdGVkIGB0aW1lc2AgdGltZXMuIFdoZW4gYHRpbWVzYCBpc1xuICAgKiB1bmRlZmluZWQsIHJldHVybnMgYW4gaW5maW5pdGUgc2VxdWVuY2Ugb2YgYHZhbHVlYC5cbiAgICovXG4gIHZhciBSZXBlYXQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbmRleGVkU2VxKSB7XG4gICAgZnVuY3Rpb24gUmVwZWF0KHZhbHVlLCB0aW1lcykge1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlcGVhdCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBlYXQodmFsdWUsIHRpbWVzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLnNpemUgPSB0aW1lcyA9PT0gdW5kZWZpbmVkID8gSW5maW5pdHkgOiBNYXRoLm1heCgwLCB0aW1lcyk7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIGlmIChFTVBUWV9SRVBFQVQpIHtcbiAgICAgICAgICByZXR1cm4gRU1QVFlfUkVQRUFUO1xuICAgICAgICB9XG4gICAgICAgIEVNUFRZX1JFUEVBVCA9IHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCBJbmRleGVkU2VxICkgUmVwZWF0Ll9fcHJvdG9fXyA9IEluZGV4ZWRTZXE7XG4gICAgUmVwZWF0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEluZGV4ZWRTZXEgJiYgSW5kZXhlZFNlcS5wcm90b3R5cGUgKTtcbiAgICBSZXBlYXQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVwZWF0O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuICdSZXBlYXQgW10nO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdSZXBlYXQgWyAnICsgdGhpcy5fdmFsdWUgKyAnICcgKyB0aGlzLnNpemUgKyAnIHRpbWVzIF0nO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXMoaW5kZXgpID8gdGhpcy5fdmFsdWUgOiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzIChzZWFyY2hWYWx1ZSkge1xuICAgICAgcmV0dXJuIGlzKHRoaXMuX3ZhbHVlLCBzZWFyY2hWYWx1ZSk7XG4gICAgfTtcblxuICAgIFJlcGVhdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoYmVnaW4sIGVuZCkge1xuICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgICByZXR1cm4gd2hvbGVTbGljZShiZWdpbiwgZW5kLCBzaXplKVxuICAgICAgICA/IHRoaXNcbiAgICAgICAgOiBuZXcgUmVwZWF0KFxuICAgICAgICAgICAgdGhpcy5fdmFsdWUsXG4gICAgICAgICAgICByZXNvbHZlRW5kKGVuZCwgc2l6ZSkgLSByZXNvbHZlQmVnaW4oYmVnaW4sIHNpemUpXG4gICAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZSAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAoc2VhcmNoVmFsdWUpIHtcbiAgICAgIGlmIChpcyh0aGlzLl92YWx1ZSwgc2VhcmNoVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHNlYXJjaFZhbHVlKSB7XG4gICAgICBpZiAoaXModGhpcy5fdmFsdWUsIHNlYXJjaFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciBzaXplID0gdGhpcy5zaXplO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgd2hpbGUgKGkgIT09IHNpemUpIHtcbiAgICAgICAgaWYgKGZuKHRoaXMuX3ZhbHVlLCByZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGkgPT09IHNpemVcbiAgICAgICAgICA/IGl0ZXJhdG9yRG9uZSgpXG4gICAgICAgICAgOiBpdGVyYXRvclZhbHVlKHR5cGUsIHJldmVyc2UgPyBzaXplIC0gKytpIDogaSsrLCB0aGlzJDEuX3ZhbHVlKTsgfVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKG90aGVyKSB7XG4gICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBSZXBlYXRcbiAgICAgICAgPyBpcyh0aGlzLl92YWx1ZSwgb3RoZXIuX3ZhbHVlKVxuICAgICAgICA6IGRlZXBFcXVhbChvdGhlcik7XG4gICAgfTtcblxuICAgIHJldHVybiBSZXBlYXQ7XG4gIH0oSW5kZXhlZFNlcSkpO1xuXG4gIHZhciBFTVBUWV9SRVBFQVQ7XG5cbiAgZnVuY3Rpb24gZnJvbUpTKHZhbHVlLCBjb252ZXJ0ZXIpIHtcbiAgICByZXR1cm4gZnJvbUpTV2l0aChcbiAgICAgIFtdLFxuICAgICAgY29udmVydGVyIHx8IGRlZmF1bHRDb252ZXJ0ZXIsXG4gICAgICB2YWx1ZSxcbiAgICAgICcnLFxuICAgICAgY29udmVydGVyICYmIGNvbnZlcnRlci5sZW5ndGggPiAyID8gW10gOiB1bmRlZmluZWQsXG4gICAgICB7ICcnOiB2YWx1ZSB9XG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyb21KU1dpdGgoc3RhY2ssIGNvbnZlcnRlciwgdmFsdWUsIGtleSwga2V5UGF0aCwgcGFyZW50VmFsdWUpIHtcbiAgICB2YXIgdG9TZXEgPSBBcnJheS5pc0FycmF5KHZhbHVlKVxuICAgICAgPyBJbmRleGVkU2VxXG4gICAgICA6IGlzUGxhaW5PYmoodmFsdWUpXG4gICAgICA/IEtleWVkU2VxXG4gICAgICA6IG51bGw7XG4gICAgaWYgKHRvU2VxKSB7XG4gICAgICBpZiAofnN0YWNrLmluZGV4T2YodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGNpcmN1bGFyIHN0cnVjdHVyZSB0byBJbW11dGFibGUnKTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAga2V5UGF0aCAmJiBrZXkgIT09ICcnICYmIGtleVBhdGgucHVzaChrZXkpO1xuICAgICAgdmFyIGNvbnZlcnRlZCA9IGNvbnZlcnRlci5jYWxsKFxuICAgICAgICBwYXJlbnRWYWx1ZSxcbiAgICAgICAga2V5LFxuICAgICAgICB0b1NlcSh2YWx1ZSkubWFwKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBmcm9tSlNXaXRoKHN0YWNrLCBjb252ZXJ0ZXIsIHYsIGssIGtleVBhdGgsIHZhbHVlKTsgfVxuICAgICAgICApLFxuICAgICAgICBrZXlQYXRoICYmIGtleVBhdGguc2xpY2UoKVxuICAgICAgKTtcbiAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAga2V5UGF0aCAmJiBrZXlQYXRoLnBvcCgpO1xuICAgICAgcmV0dXJuIGNvbnZlcnRlZDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdENvbnZlcnRlcihrLCB2KSB7XG4gICAgcmV0dXJuIGlzS2V5ZWQodikgPyB2LnRvTWFwKCkgOiB2LnRvTGlzdCgpO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSBcIjQuMC4wLXJjLjEyXCI7XG5cbiAgdmFyIEltbXV0YWJsZSA9IHtcbiAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuXG4gICAgQ29sbGVjdGlvbjogQ29sbGVjdGlvbixcbiAgICAvLyBOb3RlOiBJdGVyYWJsZSBpcyBkZXByZWNhdGVkXG4gICAgSXRlcmFibGU6IENvbGxlY3Rpb24sXG5cbiAgICBTZXE6IFNlcSxcbiAgICBNYXA6IE1hcCxcbiAgICBPcmRlcmVkTWFwOiBPcmRlcmVkTWFwLFxuICAgIExpc3Q6IExpc3QsXG4gICAgU3RhY2s6IFN0YWNrLFxuICAgIFNldDogU2V0LFxuICAgIE9yZGVyZWRTZXQ6IE9yZGVyZWRTZXQsXG5cbiAgICBSZWNvcmQ6IFJlY29yZCxcbiAgICBSYW5nZTogUmFuZ2UsXG4gICAgUmVwZWF0OiBSZXBlYXQsXG5cbiAgICBpczogaXMsXG4gICAgZnJvbUpTOiBmcm9tSlMsXG4gICAgaGFzaDogaGFzaCxcblxuICAgIGlzSW1tdXRhYmxlOiBpc0ltbXV0YWJsZSxcbiAgICBpc0NvbGxlY3Rpb246IGlzQ29sbGVjdGlvbixcbiAgICBpc0tleWVkOiBpc0tleWVkLFxuICAgIGlzSW5kZXhlZDogaXNJbmRleGVkLFxuICAgIGlzQXNzb2NpYXRpdmU6IGlzQXNzb2NpYXRpdmUsXG4gICAgaXNPcmRlcmVkOiBpc09yZGVyZWQsXG4gICAgaXNWYWx1ZU9iamVjdDogaXNWYWx1ZU9iamVjdCxcbiAgICBpc1NlcTogaXNTZXEsXG4gICAgaXNMaXN0OiBpc0xpc3QsXG4gICAgaXNNYXA6IGlzTWFwLFxuICAgIGlzT3JkZXJlZE1hcDogaXNPcmRlcmVkTWFwLFxuICAgIGlzU3RhY2s6IGlzU3RhY2ssXG4gICAgaXNTZXQ6IGlzU2V0LFxuICAgIGlzT3JkZXJlZFNldDogaXNPcmRlcmVkU2V0LFxuICAgIGlzUmVjb3JkOiBpc1JlY29yZCxcblxuICAgIGdldDogZ2V0LFxuICAgIGdldEluOiBnZXRJbixcbiAgICBoYXM6IGhhcyxcbiAgICBoYXNJbjogaGFzSW4sXG4gICAgbWVyZ2U6IG1lcmdlJDEsXG4gICAgbWVyZ2VEZWVwOiBtZXJnZURlZXAsXG4gICAgbWVyZ2VXaXRoOiBtZXJnZVdpdGgkMSxcbiAgICBtZXJnZURlZXBXaXRoOiBtZXJnZURlZXBXaXRoLFxuICAgIHJlbW92ZTogcmVtb3ZlLFxuICAgIHJlbW92ZUluOiByZW1vdmVJbixcbiAgICBzZXQ6IHNldCxcbiAgICBzZXRJbjogc2V0SW4sXG4gICAgdXBkYXRlOiB1cGRhdGUsXG4gICAgdXBkYXRlSW46IHVwZGF0ZUluLFxuICB9O1xuXG4gIC8vIE5vdGU6IEl0ZXJhYmxlIGlzIGRlcHJlY2F0ZWRcbiAgdmFyIEl0ZXJhYmxlID0gQ29sbGVjdGlvbjtcblxuICBleHBvcnRzLkNvbGxlY3Rpb24gPSBDb2xsZWN0aW9uO1xuICBleHBvcnRzLkl0ZXJhYmxlID0gSXRlcmFibGU7XG4gIGV4cG9ydHMuTGlzdCA9IExpc3Q7XG4gIGV4cG9ydHMuTWFwID0gTWFwO1xuICBleHBvcnRzLk9yZGVyZWRNYXAgPSBPcmRlcmVkTWFwO1xuICBleHBvcnRzLk9yZGVyZWRTZXQgPSBPcmRlcmVkU2V0O1xuICBleHBvcnRzLlJhbmdlID0gUmFuZ2U7XG4gIGV4cG9ydHMuUmVjb3JkID0gUmVjb3JkO1xuICBleHBvcnRzLlJlcGVhdCA9IFJlcGVhdDtcbiAgZXhwb3J0cy5TZXEgPSBTZXE7XG4gIGV4cG9ydHMuU2V0ID0gU2V0O1xuICBleHBvcnRzLlN0YWNrID0gU3RhY2s7XG4gIGV4cG9ydHMuZGVmYXVsdCA9IEltbXV0YWJsZTtcbiAgZXhwb3J0cy5mcm9tSlMgPSBmcm9tSlM7XG4gIGV4cG9ydHMuZ2V0ID0gZ2V0O1xuICBleHBvcnRzLmdldEluID0gZ2V0SW47XG4gIGV4cG9ydHMuaGFzID0gaGFzO1xuICBleHBvcnRzLmhhc0luID0gaGFzSW47XG4gIGV4cG9ydHMuaGFzaCA9IGhhc2g7XG4gIGV4cG9ydHMuaXMgPSBpcztcbiAgZXhwb3J0cy5pc0Fzc29jaWF0aXZlID0gaXNBc3NvY2lhdGl2ZTtcbiAgZXhwb3J0cy5pc0NvbGxlY3Rpb24gPSBpc0NvbGxlY3Rpb247XG4gIGV4cG9ydHMuaXNJbW11dGFibGUgPSBpc0ltbXV0YWJsZTtcbiAgZXhwb3J0cy5pc0luZGV4ZWQgPSBpc0luZGV4ZWQ7XG4gIGV4cG9ydHMuaXNLZXllZCA9IGlzS2V5ZWQ7XG4gIGV4cG9ydHMuaXNPcmRlcmVkID0gaXNPcmRlcmVkO1xuICBleHBvcnRzLmlzVmFsdWVPYmplY3QgPSBpc1ZhbHVlT2JqZWN0O1xuICBleHBvcnRzLm1lcmdlID0gbWVyZ2UkMTtcbiAgZXhwb3J0cy5tZXJnZURlZXAgPSBtZXJnZURlZXA7XG4gIGV4cG9ydHMubWVyZ2VEZWVwV2l0aCA9IG1lcmdlRGVlcFdpdGg7XG4gIGV4cG9ydHMubWVyZ2VXaXRoID0gbWVyZ2VXaXRoJDE7XG4gIGV4cG9ydHMucmVtb3ZlID0gcmVtb3ZlO1xuICBleHBvcnRzLnJlbW92ZUluID0gcmVtb3ZlSW47XG4gIGV4cG9ydHMuc2V0ID0gc2V0O1xuICBleHBvcnRzLnNldEluID0gc2V0SW47XG4gIGV4cG9ydHMudXBkYXRlID0gdXBkYXRlO1xuICBleHBvcnRzLnVwZGF0ZUluID0gdXBkYXRlSW47XG4gIGV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7IF9fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgIT0gbnVsbCAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2UodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHZhciBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShcbiAgICAgIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGhcbiAgICApXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiLyoqXG4gKiBtYXJrZWQgLSBhIG1hcmtkb3duIHBhcnNlclxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMjAsIENocmlzdG9waGVyIEplZmZyZXkuIChNSVQgTGljZW5zZWQpXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWFya2VkanMvbWFya2VkXG4gKi9cblxuLyoqXG4gKiBETyBOT1QgRURJVCBUSElTIEZJTEVcbiAqIFRoZSBjb2RlIGluIHRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBmaWxlcyBpbiAuL3NyYy9cbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLm1hcmtlZCA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gICAgaWYgKCFvKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIH1cblxuICBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICAgIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgcmV0dXJuIGFycjI7XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG8sIGFsbG93QXJyYXlMaWtlKSB7XG4gICAgdmFyIGl0O1xuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBvW2krK11cbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gICAgfVxuXG4gICAgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICByZXR1cm4gaXQubmV4dC5iaW5kKGl0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcbiAgXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG4gIH1cblxuICB2YXIgZGVmYXVsdHMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgZnVuY3Rpb24gZ2V0RGVmYXVsdHMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYXNlVXJsOiBudWxsLFxuICAgICAgICBicmVha3M6IGZhbHNlLFxuICAgICAgICBnZm06IHRydWUsXG4gICAgICAgIGhlYWRlcklkczogdHJ1ZSxcbiAgICAgICAgaGVhZGVyUHJlZml4OiAnJyxcbiAgICAgICAgaGlnaGxpZ2h0OiBudWxsLFxuICAgICAgICBsYW5nUHJlZml4OiAnbGFuZ3VhZ2UtJyxcbiAgICAgICAgbWFuZ2xlOiB0cnVlLFxuICAgICAgICBwZWRhbnRpYzogZmFsc2UsXG4gICAgICAgIHJlbmRlcmVyOiBudWxsLFxuICAgICAgICBzYW5pdGl6ZTogZmFsc2UsXG4gICAgICAgIHNhbml0aXplcjogbnVsbCxcbiAgICAgICAgc2lsZW50OiBmYWxzZSxcbiAgICAgICAgc21hcnRMaXN0czogZmFsc2UsXG4gICAgICAgIHNtYXJ0eXBhbnRzOiBmYWxzZSxcbiAgICAgICAgdG9rZW5pemVyOiBudWxsLFxuICAgICAgICB3YWxrVG9rZW5zOiBudWxsLFxuICAgICAgICB4aHRtbDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hhbmdlRGVmYXVsdHMobmV3RGVmYXVsdHMpIHtcbiAgICAgIG1vZHVsZS5leHBvcnRzLmRlZmF1bHRzID0gbmV3RGVmYXVsdHM7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICBkZWZhdWx0czogZ2V0RGVmYXVsdHMoKSxcbiAgICAgIGdldERlZmF1bHRzOiBnZXREZWZhdWx0cyxcbiAgICAgIGNoYW5nZURlZmF1bHRzOiBjaGFuZ2VEZWZhdWx0c1xuICAgIH07XG4gIH0pO1xuICB2YXIgZGVmYXVsdHNfMSA9IGRlZmF1bHRzLmRlZmF1bHRzO1xuICB2YXIgZGVmYXVsdHNfMiA9IGRlZmF1bHRzLmdldERlZmF1bHRzO1xuICB2YXIgZGVmYXVsdHNfMyA9IGRlZmF1bHRzLmNoYW5nZURlZmF1bHRzO1xuXG4gIC8qKlxuICAgKiBIZWxwZXJzXG4gICAqL1xuICB2YXIgZXNjYXBlVGVzdCA9IC9bJjw+XCInXS87XG4gIHZhciBlc2NhcGVSZXBsYWNlID0gL1smPD5cIiddL2c7XG4gIHZhciBlc2NhcGVUZXN0Tm9FbmNvZGUgPSAvWzw+XCInXXwmKD8hIz9cXHcrOykvO1xuICB2YXIgZXNjYXBlUmVwbGFjZU5vRW5jb2RlID0gL1s8PlwiJ118Jig/ISM/XFx3KzspL2c7XG4gIHZhciBlc2NhcGVSZXBsYWNlbWVudHMgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnXG4gIH07XG5cbiAgdmFyIGdldEVzY2FwZVJlcGxhY2VtZW50ID0gZnVuY3Rpb24gZ2V0RXNjYXBlUmVwbGFjZW1lbnQoY2gpIHtcbiAgICByZXR1cm4gZXNjYXBlUmVwbGFjZW1lbnRzW2NoXTtcbiAgfTtcblxuICBmdW5jdGlvbiBlc2NhcGUoaHRtbCwgZW5jb2RlKSB7XG4gICAgaWYgKGVuY29kZSkge1xuICAgICAgaWYgKGVzY2FwZVRlc3QudGVzdChodG1sKSkge1xuICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKGVzY2FwZVJlcGxhY2UsIGdldEVzY2FwZVJlcGxhY2VtZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVzY2FwZVRlc3ROb0VuY29kZS50ZXN0KGh0bWwpKSB7XG4gICAgICAgIHJldHVybiBodG1sLnJlcGxhY2UoZXNjYXBlUmVwbGFjZU5vRW5jb2RlLCBnZXRFc2NhcGVSZXBsYWNlbWVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGh0bWw7XG4gIH1cblxuICB2YXIgdW5lc2NhcGVUZXN0ID0gLyYoIyg/OlxcZCspfCg/OiN4WzAtOUEtRmEtZl0rKXwoPzpcXHcrKSk7Py9pZztcblxuICBmdW5jdGlvbiB1bmVzY2FwZShodG1sKSB7XG4gICAgLy8gZXhwbGljaXRseSBtYXRjaCBkZWNpbWFsLCBoZXgsIGFuZCBuYW1lZCBIVE1MIGVudGl0aWVzXG4gICAgcmV0dXJuIGh0bWwucmVwbGFjZSh1bmVzY2FwZVRlc3QsIGZ1bmN0aW9uIChfLCBuKSB7XG4gICAgICBuID0gbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKG4gPT09ICdjb2xvbicpIHJldHVybiAnOic7XG5cbiAgICAgIGlmIChuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgIHJldHVybiBuLmNoYXJBdCgxKSA9PT0gJ3gnID8gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChuLnN1YnN0cmluZygyKSwgMTYpKSA6IFN0cmluZy5mcm9tQ2hhckNvZGUoK24uc3Vic3RyaW5nKDEpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcnO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGNhcmV0ID0gLyhefFteXFxbXSlcXF4vZztcblxuICBmdW5jdGlvbiBlZGl0KHJlZ2V4LCBvcHQpIHtcbiAgICByZWdleCA9IHJlZ2V4LnNvdXJjZSB8fCByZWdleDtcbiAgICBvcHQgPSBvcHQgfHwgJyc7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIHJlcGxhY2U6IGZ1bmN0aW9uIHJlcGxhY2UobmFtZSwgdmFsKSB7XG4gICAgICAgIHZhbCA9IHZhbC5zb3VyY2UgfHwgdmFsO1xuICAgICAgICB2YWwgPSB2YWwucmVwbGFjZShjYXJldCwgJyQxJyk7XG4gICAgICAgIHJlZ2V4ID0gcmVnZXgucmVwbGFjZShuYW1lLCB2YWwpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfSxcbiAgICAgIGdldFJlZ2V4OiBmdW5jdGlvbiBnZXRSZWdleCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXgsIG9wdCk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIG5vbldvcmRBbmRDb2xvblRlc3QgPSAvW15cXHc6XS9nO1xuICB2YXIgb3JpZ2luSW5kZXBlbmRlbnRVcmwgPSAvXiR8XlthLXpdW2EtejAtOSsuLV0qOnxeWz8jXS9pO1xuXG4gIGZ1bmN0aW9uIGNsZWFuVXJsKHNhbml0aXplLCBiYXNlLCBocmVmKSB7XG4gICAgaWYgKHNhbml0aXplKSB7XG4gICAgICB2YXIgcHJvdDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcHJvdCA9IGRlY29kZVVSSUNvbXBvbmVudCh1bmVzY2FwZShocmVmKSkucmVwbGFjZShub25Xb3JkQW5kQ29sb25UZXN0LCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm90LmluZGV4T2YoJ2phdmFzY3JpcHQ6JykgPT09IDAgfHwgcHJvdC5pbmRleE9mKCd2YnNjcmlwdDonKSA9PT0gMCB8fCBwcm90LmluZGV4T2YoJ2RhdGE6JykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgJiYgIW9yaWdpbkluZGVwZW5kZW50VXJsLnRlc3QoaHJlZikpIHtcbiAgICAgIGhyZWYgPSByZXNvbHZlVXJsKGJhc2UsIGhyZWYpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBocmVmID0gZW5jb2RlVVJJKGhyZWYpLnJlcGxhY2UoLyUyNS9nLCAnJScpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBocmVmO1xuICB9XG5cbiAgdmFyIGJhc2VVcmxzID0ge307XG4gIHZhciBqdXN0RG9tYWluID0gL15bXjpdKzpcXC8qW14vXSokLztcbiAgdmFyIHByb3RvY29sID0gL14oW146XSs6KVtcXHNcXFNdKiQvO1xuICB2YXIgZG9tYWluID0gL14oW146XSs6XFwvKlteL10qKVtcXHNcXFNdKiQvO1xuXG4gIGZ1bmN0aW9uIHJlc29sdmVVcmwoYmFzZSwgaHJlZikge1xuICAgIGlmICghYmFzZVVybHNbJyAnICsgYmFzZV0pIHtcbiAgICAgIC8vIHdlIGNhbiBpZ25vcmUgZXZlcnl0aGluZyBpbiBiYXNlIGFmdGVyIHRoZSBsYXN0IHNsYXNoIG9mIGl0cyBwYXRoIGNvbXBvbmVudCxcbiAgICAgIC8vIGJ1dCB3ZSBtaWdodCBuZWVkIHRvIGFkZCBfdGhhdF9cbiAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tM1xuICAgICAgaWYgKGp1c3REb21haW4udGVzdChiYXNlKSkge1xuICAgICAgICBiYXNlVXJsc1snICcgKyBiYXNlXSA9IGJhc2UgKyAnLyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlVXJsc1snICcgKyBiYXNlXSA9IHJ0cmltKGJhc2UsICcvJywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYmFzZSA9IGJhc2VVcmxzWycgJyArIGJhc2VdO1xuICAgIHZhciByZWxhdGl2ZUJhc2UgPSBiYXNlLmluZGV4T2YoJzonKSA9PT0gLTE7XG5cbiAgICBpZiAoaHJlZi5zdWJzdHJpbmcoMCwgMikgPT09ICcvLycpIHtcbiAgICAgIGlmIChyZWxhdGl2ZUJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGhyZWY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiYXNlLnJlcGxhY2UocHJvdG9jb2wsICckMScpICsgaHJlZjtcbiAgICB9IGVsc2UgaWYgKGhyZWYuY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgIGlmIChyZWxhdGl2ZUJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGhyZWY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiYXNlLnJlcGxhY2UoZG9tYWluLCAnJDEnKSArIGhyZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiYXNlICsgaHJlZjtcbiAgICB9XG4gIH1cblxuICB2YXIgbm9vcFRlc3QgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24gbm9vcFRlc3QoKSB7fVxuICB9O1xuXG4gIGZ1bmN0aW9uIG1lcmdlKG9iaikge1xuICAgIHZhciBpID0gMSxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBrZXk7XG5cbiAgICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHtcbiAgICAgICAgICBvYmpba2V5XSA9IHRhcmdldFtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNwbGl0Q2VsbHModGFibGVSb3csIGNvdW50KSB7XG4gICAgLy8gZW5zdXJlIHRoYXQgZXZlcnkgY2VsbC1kZWxpbWl0aW5nIHBpcGUgaGFzIGEgc3BhY2VcbiAgICAvLyBiZWZvcmUgaXQgdG8gZGlzdGluZ3Vpc2ggaXQgZnJvbSBhbiBlc2NhcGVkIHBpcGVcbiAgICB2YXIgcm93ID0gdGFibGVSb3cucmVwbGFjZSgvXFx8L2csIGZ1bmN0aW9uIChtYXRjaCwgb2Zmc2V0LCBzdHIpIHtcbiAgICAgIHZhciBlc2NhcGVkID0gZmFsc2UsXG4gICAgICAgICAgY3VyciA9IG9mZnNldDtcblxuICAgICAgd2hpbGUgKC0tY3VyciA+PSAwICYmIHN0cltjdXJyXSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgICAgLy8gb2RkIG51bWJlciBvZiBzbGFzaGVzIG1lYW5zIHwgaXMgZXNjYXBlZFxuICAgICAgICAvLyBzbyB3ZSBsZWF2ZSBpdCBhbG9uZVxuICAgICAgICByZXR1cm4gJ3wnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWRkIHNwYWNlIGJlZm9yZSB1bmVzY2FwZWQgfFxuICAgICAgICByZXR1cm4gJyB8JztcbiAgICAgIH1cbiAgICB9KSxcbiAgICAgICAgY2VsbHMgPSByb3cuc3BsaXQoLyBcXHwvKTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBpZiAoY2VsbHMubGVuZ3RoID4gY291bnQpIHtcbiAgICAgIGNlbGxzLnNwbGljZShjb3VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChjZWxscy5sZW5ndGggPCBjb3VudCkge1xuICAgICAgICBjZWxscy5wdXNoKCcnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBsZWFkaW5nIG9yIHRyYWlsaW5nIHdoaXRlc3BhY2UgaXMgaWdub3JlZCBwZXIgdGhlIGdmbSBzcGVjXG4gICAgICBjZWxsc1tpXSA9IGNlbGxzW2ldLnRyaW0oKS5yZXBsYWNlKC9cXFxcXFx8L2csICd8Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNlbGxzO1xuICB9IC8vIFJlbW92ZSB0cmFpbGluZyAnYydzLiBFcXVpdmFsZW50IHRvIHN0ci5yZXBsYWNlKC9jKiQvLCAnJykuXG4gIC8vIC9jKiQvIGlzIHZ1bG5lcmFibGUgdG8gUkVET1MuXG4gIC8vIGludmVydDogUmVtb3ZlIHN1ZmZpeCBvZiBub24tYyBjaGFycyBpbnN0ZWFkLiBEZWZhdWx0IGZhbHNleS5cblxuXG4gIGZ1bmN0aW9uIHJ0cmltKHN0ciwgYywgaW52ZXJ0KSB7XG4gICAgdmFyIGwgPSBzdHIubGVuZ3RoO1xuXG4gICAgaWYgKGwgPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9IC8vIExlbmd0aCBvZiBzdWZmaXggbWF0Y2hpbmcgdGhlIGludmVydCBjb25kaXRpb24uXG5cblxuICAgIHZhciBzdWZmTGVuID0gMDsgLy8gU3RlcCBsZWZ0IHVudGlsIHdlIGZhaWwgdG8gbWF0Y2ggdGhlIGludmVydCBjb25kaXRpb24uXG5cbiAgICB3aGlsZSAoc3VmZkxlbiA8IGwpIHtcbiAgICAgIHZhciBjdXJyQ2hhciA9IHN0ci5jaGFyQXQobCAtIHN1ZmZMZW4gLSAxKTtcblxuICAgICAgaWYgKGN1cnJDaGFyID09PSBjICYmICFpbnZlcnQpIHtcbiAgICAgICAgc3VmZkxlbisrO1xuICAgICAgfSBlbHNlIGlmIChjdXJyQ2hhciAhPT0gYyAmJiBpbnZlcnQpIHtcbiAgICAgICAgc3VmZkxlbisrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgbCAtIHN1ZmZMZW4pO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZENsb3NpbmdCcmFja2V0KHN0ciwgYikge1xuICAgIGlmIChzdHIuaW5kZXhPZihiWzFdKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICB2YXIgbCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIGxldmVsID0gMCxcbiAgICAgICAgaSA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHN0cltpXSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIGkrKztcbiAgICAgIH0gZWxzZSBpZiAoc3RyW2ldID09PSBiWzBdKSB7XG4gICAgICAgIGxldmVsKys7XG4gICAgICB9IGVsc2UgaWYgKHN0cltpXSA9PT0gYlsxXSkge1xuICAgICAgICBsZXZlbC0tO1xuXG4gICAgICAgIGlmIChsZXZlbCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrU2FuaXRpemVEZXByZWNhdGlvbihvcHQpIHtcbiAgICBpZiAob3B0ICYmIG9wdC5zYW5pdGl6ZSAmJiAhb3B0LnNpbGVudCkge1xuICAgICAgY29uc29sZS53YXJuKCdtYXJrZWQoKTogc2FuaXRpemUgYW5kIHNhbml0aXplciBwYXJhbWV0ZXJzIGFyZSBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMC43LjAsIHNob3VsZCBub3QgYmUgdXNlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuIFJlYWQgbW9yZSBoZXJlOiBodHRwczovL21hcmtlZC5qcy5vcmcvIy9VU0lOR19BRFZBTkNFRC5tZCNvcHRpb25zJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhlbHBlcnMgPSB7XG4gICAgZXNjYXBlOiBlc2NhcGUsXG4gICAgdW5lc2NhcGU6IHVuZXNjYXBlLFxuICAgIGVkaXQ6IGVkaXQsXG4gICAgY2xlYW5Vcmw6IGNsZWFuVXJsLFxuICAgIHJlc29sdmVVcmw6IHJlc29sdmVVcmwsXG4gICAgbm9vcFRlc3Q6IG5vb3BUZXN0LFxuICAgIG1lcmdlOiBtZXJnZSxcbiAgICBzcGxpdENlbGxzOiBzcGxpdENlbGxzLFxuICAgIHJ0cmltOiBydHJpbSxcbiAgICBmaW5kQ2xvc2luZ0JyYWNrZXQ6IGZpbmRDbG9zaW5nQnJhY2tldCxcbiAgICBjaGVja1Nhbml0aXplRGVwcmVjYXRpb246IGNoZWNrU2FuaXRpemVEZXByZWNhdGlvblxuICB9O1xuXG4gIHZhciBkZWZhdWx0cyQxID0gZGVmYXVsdHMuZGVmYXVsdHM7XG4gIHZhciBydHJpbSQxID0gaGVscGVycy5ydHJpbSxcbiAgICAgIHNwbGl0Q2VsbHMkMSA9IGhlbHBlcnMuc3BsaXRDZWxscyxcbiAgICAgIF9lc2NhcGUgPSBoZWxwZXJzLmVzY2FwZSxcbiAgICAgIGZpbmRDbG9zaW5nQnJhY2tldCQxID0gaGVscGVycy5maW5kQ2xvc2luZ0JyYWNrZXQ7XG5cbiAgZnVuY3Rpb24gb3V0cHV0TGluayhjYXAsIGxpbmssIHJhdykge1xuICAgIHZhciBocmVmID0gbGluay5ocmVmO1xuICAgIHZhciB0aXRsZSA9IGxpbmsudGl0bGUgPyBfZXNjYXBlKGxpbmsudGl0bGUpIDogbnVsbDtcbiAgICB2YXIgdGV4dCA9IGNhcFsxXS5yZXBsYWNlKC9cXFxcKFtcXFtcXF1dKS9nLCAnJDEnKTtcblxuICAgIGlmIChjYXBbMF0uY2hhckF0KDApICE9PSAnIScpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgICAgcmF3OiByYXcsXG4gICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgdGV4dDogdGV4dFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgcmF3OiByYXcsXG4gICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgdGV4dDogX2VzY2FwZSh0ZXh0KVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbmRlbnRDb2RlQ29tcGVuc2F0aW9uKHJhdywgdGV4dCkge1xuICAgIHZhciBtYXRjaEluZGVudFRvQ29kZSA9IHJhdy5tYXRjaCgvXihcXHMrKSg/OmBgYCkvKTtcblxuICAgIGlmIChtYXRjaEluZGVudFRvQ29kZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGluZGVudFRvQ29kZSA9IG1hdGNoSW5kZW50VG9Db2RlWzFdO1xuICAgIHJldHVybiB0ZXh0LnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBtYXRjaEluZGVudEluTm9kZSA9IG5vZGUubWF0Y2goL15cXHMrLyk7XG5cbiAgICAgIGlmIChtYXRjaEluZGVudEluTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGVudEluTm9kZSA9IG1hdGNoSW5kZW50SW5Ob2RlWzBdO1xuXG4gICAgICBpZiAoaW5kZW50SW5Ob2RlLmxlbmd0aCA+PSBpbmRlbnRUb0NvZGUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBub2RlLnNsaWNlKGluZGVudFRvQ29kZS5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KS5qb2luKCdcXG4nKTtcbiAgfVxuICAvKipcbiAgICogVG9rZW5pemVyXG4gICAqL1xuXG5cbiAgdmFyIFRva2VuaXplcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb2tlbml6ZXIob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQxO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBUb2tlbml6ZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLnNwYWNlID0gZnVuY3Rpb24gc3BhY2Uoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5uZXdsaW5lLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICBpZiAoY2FwWzBdLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ3NwYWNlJyxcbiAgICAgICAgICAgIHJhdzogY2FwWzBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmF3OiAnXFxuJ1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uY29kZSA9IGZ1bmN0aW9uIGNvZGUoc3JjLCB0b2tlbnMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmNvZGUuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdOyAvLyBBbiBpbmRlbnRlZCBjb2RlIGJsb2NrIGNhbm5vdCBpbnRlcnJ1cHQgYSBwYXJhZ3JhcGguXG5cbiAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICB0ZXh0OiBjYXBbMF0udHJpbVJpZ2h0KClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHQgPSBjYXBbMF0ucmVwbGFjZSgvXiB7NH0vZ20sICcnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgY29kZUJsb2NrU3R5bGU6ICdpbmRlbnRlZCcsXG4gICAgICAgICAgdGV4dDogIXRoaXMub3B0aW9ucy5wZWRhbnRpYyA/IHJ0cmltJDEodGV4dCwgJ1xcbicpIDogdGV4dFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uZmVuY2VzID0gZnVuY3Rpb24gZmVuY2VzKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2suZmVuY2VzLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgcmF3ID0gY2FwWzBdO1xuICAgICAgICB2YXIgdGV4dCA9IGluZGVudENvZGVDb21wZW5zYXRpb24ocmF3LCBjYXBbM10gfHwgJycpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgICByYXc6IHJhdyxcbiAgICAgICAgICBsYW5nOiBjYXBbMl0gPyBjYXBbMl0udHJpbSgpIDogY2FwWzJdLFxuICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmhlYWRpbmcgPSBmdW5jdGlvbiBoZWFkaW5nKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2suaGVhZGluZy5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgZGVwdGg6IGNhcFsxXS5sZW5ndGgsXG4gICAgICAgICAgdGV4dDogY2FwWzJdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5ucHRhYmxlID0gZnVuY3Rpb24gbnB0YWJsZShzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLm5wdGFibGUuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciBpdGVtID0ge1xuICAgICAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICAgICAgaGVhZGVyOiBzcGxpdENlbGxzJDEoY2FwWzFdLnJlcGxhY2UoL14gKnwgKlxcfCAqJC9nLCAnJykpLFxuICAgICAgICAgIGFsaWduOiBjYXBbMl0ucmVwbGFjZSgvXiAqfFxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgICBjZWxsczogY2FwWzNdID8gY2FwWzNdLnJlcGxhY2UoL1xcbiQvLCAnJykuc3BsaXQoJ1xcbicpIDogW10sXG4gICAgICAgICAgcmF3OiBjYXBbMF1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaXRlbS5oZWFkZXIubGVuZ3RoID09PSBpdGVtLmFsaWduLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBsID0gaXRlbS5hbGlnbi5sZW5ndGg7XG4gICAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoL14gKi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ3JpZ2h0JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL14gKjotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdjZW50ZXInO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnbGVmdCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsID0gaXRlbS5jZWxscy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtLmNlbGxzW2ldID0gc3BsaXRDZWxscyQxKGl0ZW0uY2VsbHNbaV0sIGl0ZW0uaGVhZGVyLmxlbmd0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmhyID0gZnVuY3Rpb24gaHIoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oci5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnaHInLFxuICAgICAgICAgIHJhdzogY2FwWzBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5ibG9ja3F1b3RlID0gZnVuY3Rpb24gYmxvY2txdW90ZShzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmJsb2NrcXVvdGUuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gY2FwWzBdLnJlcGxhY2UoL14gKj4gPy9nbSwgJycpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdibG9ja3F1b3RlJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5saXN0ID0gZnVuY3Rpb24gbGlzdChzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmxpc3QuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciByYXcgPSBjYXBbMF07XG4gICAgICAgIHZhciBidWxsID0gY2FwWzJdO1xuICAgICAgICB2YXIgaXNvcmRlcmVkID0gYnVsbC5sZW5ndGggPiAxO1xuICAgICAgICB2YXIgaXNwYXJlbiA9IGJ1bGxbYnVsbC5sZW5ndGggLSAxXSA9PT0gJyknO1xuICAgICAgICB2YXIgbGlzdCA9IHtcbiAgICAgICAgICB0eXBlOiAnbGlzdCcsXG4gICAgICAgICAgcmF3OiByYXcsXG4gICAgICAgICAgb3JkZXJlZDogaXNvcmRlcmVkLFxuICAgICAgICAgIHN0YXJ0OiBpc29yZGVyZWQgPyArYnVsbC5zbGljZSgwLCAtMSkgOiAnJyxcbiAgICAgICAgICBsb29zZTogZmFsc2UsXG4gICAgICAgICAgaXRlbXM6IFtdXG4gICAgICAgIH07IC8vIEdldCBlYWNoIHRvcC1sZXZlbCBpdGVtLlxuXG4gICAgICAgIHZhciBpdGVtTWF0Y2ggPSBjYXBbMF0ubWF0Y2godGhpcy5ydWxlcy5ibG9jay5pdGVtKTtcbiAgICAgICAgdmFyIG5leHQgPSBmYWxzZSxcbiAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICBzcGFjZSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBhZGRCYWNrLFxuICAgICAgICAgICAgbG9vc2UsXG4gICAgICAgICAgICBpc3Rhc2ssXG4gICAgICAgICAgICBpc2NoZWNrZWQ7XG4gICAgICAgIHZhciBsID0gaXRlbU1hdGNoLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGl0ZW0gPSBpdGVtTWF0Y2hbaV07XG4gICAgICAgICAgcmF3ID0gaXRlbTsgLy8gUmVtb3ZlIHRoZSBsaXN0IGl0ZW0ncyBidWxsZXRcbiAgICAgICAgICAvLyBzbyBpdCBpcyBzZWVuIGFzIHRoZSBuZXh0IHRva2VuLlxuXG4gICAgICAgICAgc3BhY2UgPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICBpdGVtID0gaXRlbS5yZXBsYWNlKC9eICooWyorLV18XFxkK1suKV0pICovLCAnJyk7IC8vIE91dGRlbnQgd2hhdGV2ZXIgdGhlXG4gICAgICAgICAgLy8gbGlzdCBpdGVtIGNvbnRhaW5zLiBIYWNreS5cblxuICAgICAgICAgIGlmICh+aXRlbS5pbmRleE9mKCdcXG4gJykpIHtcbiAgICAgICAgICAgIHNwYWNlIC09IGl0ZW0ubGVuZ3RoO1xuICAgICAgICAgICAgaXRlbSA9ICF0aGlzLm9wdGlvbnMucGVkYW50aWMgPyBpdGVtLnJlcGxhY2UobmV3IFJlZ0V4cCgnXiB7MSwnICsgc3BhY2UgKyAnfScsICdnbScpLCAnJykgOiBpdGVtLnJlcGxhY2UoL14gezEsNH0vZ20sICcnKTtcbiAgICAgICAgICB9IC8vIERldGVybWluZSB3aGV0aGVyIHRoZSBuZXh0IGxpc3QgaXRlbSBiZWxvbmdzIGhlcmUuXG4gICAgICAgICAgLy8gQmFja3BlZGFsIGlmIGl0IGRvZXMgbm90IGJlbG9uZyBpbiB0aGlzIGxpc3QuXG5cblxuICAgICAgICAgIGlmIChpICE9PSBsIC0gMSkge1xuICAgICAgICAgICAgYiA9IHRoaXMucnVsZXMuYmxvY2suYnVsbGV0LmV4ZWMoaXRlbU1hdGNoW2kgKyAxXSlbMF07XG5cbiAgICAgICAgICAgIGlmIChpc29yZGVyZWQgPyBiLmxlbmd0aCA9PT0gMSB8fCAhaXNwYXJlbiAmJiBiW2IubGVuZ3RoIC0gMV0gPT09ICcpJyA6IGIubGVuZ3RoID4gMSB8fCB0aGlzLm9wdGlvbnMuc21hcnRMaXN0cyAmJiBiICE9PSBidWxsKSB7XG4gICAgICAgICAgICAgIGFkZEJhY2sgPSBpdGVtTWF0Y2guc2xpY2UoaSArIDEpLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICBsaXN0LnJhdyA9IGxpc3QucmF3LnN1YnN0cmluZygwLCBsaXN0LnJhdy5sZW5ndGggLSBhZGRCYWNrLmxlbmd0aCk7XG4gICAgICAgICAgICAgIGkgPSBsIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIERldGVybWluZSB3aGV0aGVyIGl0ZW0gaXMgbG9vc2Ugb3Igbm90LlxuICAgICAgICAgIC8vIFVzZTogLyhefFxcbikoPyEgKVteXFxuXStcXG5cXG4oPyFcXHMqJCkvXG4gICAgICAgICAgLy8gZm9yIGRpc2NvdW50IGJlaGF2aW9yLlxuXG5cbiAgICAgICAgICBsb29zZSA9IG5leHQgfHwgL1xcblxcbig/IVxccyokKS8udGVzdChpdGVtKTtcblxuICAgICAgICAgIGlmIChpICE9PSBsIC0gMSkge1xuICAgICAgICAgICAgbmV4dCA9IGl0ZW0uY2hhckF0KGl0ZW0ubGVuZ3RoIC0gMSkgPT09ICdcXG4nO1xuICAgICAgICAgICAgaWYgKCFsb29zZSkgbG9vc2UgPSBuZXh0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsb29zZSkge1xuICAgICAgICAgICAgbGlzdC5sb29zZSA9IHRydWU7XG4gICAgICAgICAgfSAvLyBDaGVjayBmb3IgdGFzayBsaXN0IGl0ZW1zXG5cblxuICAgICAgICAgIGlzdGFzayA9IC9eXFxbWyB4WF1cXF0gLy50ZXN0KGl0ZW0pO1xuICAgICAgICAgIGlzY2hlY2tlZCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChpc3Rhc2spIHtcbiAgICAgICAgICAgIGlzY2hlY2tlZCA9IGl0ZW1bMV0gIT09ICcgJztcbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtLnJlcGxhY2UoL15cXFtbIHhYXVxcXSArLywgJycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3QuaXRlbXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnbGlzdF9pdGVtJyxcbiAgICAgICAgICAgIHJhdzogcmF3LFxuICAgICAgICAgICAgdGFzazogaXN0YXNrLFxuICAgICAgICAgICAgY2hlY2tlZDogaXNjaGVja2VkLFxuICAgICAgICAgICAgbG9vc2U6IGxvb3NlLFxuICAgICAgICAgICAgdGV4dDogaXRlbVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5odG1sID0gZnVuY3Rpb24gaHRtbChzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmh0bWwuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogdGhpcy5vcHRpb25zLnNhbml0aXplID8gJ3BhcmFncmFwaCcgOiAnaHRtbCcsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgcHJlOiAhdGhpcy5vcHRpb25zLnNhbml0aXplciAmJiAoY2FwWzFdID09PSAncHJlJyB8fCBjYXBbMV0gPT09ICdzY3JpcHQnIHx8IGNhcFsxXSA9PT0gJ3N0eWxlJyksXG4gICAgICAgICAgdGV4dDogdGhpcy5vcHRpb25zLnNhbml0aXplID8gdGhpcy5vcHRpb25zLnNhbml0aXplciA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIoY2FwWzBdKSA6IF9lc2NhcGUoY2FwWzBdKSA6IGNhcFswXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uZGVmID0gZnVuY3Rpb24gZGVmKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2suZGVmLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICBpZiAoY2FwWzNdKSBjYXBbM10gPSBjYXBbM10uc3Vic3RyaW5nKDEsIGNhcFszXS5sZW5ndGggLSAxKTtcbiAgICAgICAgdmFyIHRhZyA9IGNhcFsxXS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICBocmVmOiBjYXBbMl0sXG4gICAgICAgICAgdGl0bGU6IGNhcFszXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8udGFibGUgPSBmdW5jdGlvbiB0YWJsZShzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLnRhYmxlLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgaXRlbSA9IHtcbiAgICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICAgIGhlYWRlcjogc3BsaXRDZWxscyQxKGNhcFsxXS5yZXBsYWNlKC9eICp8ICpcXHwgKiQvZywgJycpKSxcbiAgICAgICAgICBhbGlnbjogY2FwWzJdLnJlcGxhY2UoL14gKnxcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgICAgY2VsbHM6IGNhcFszXSA/IGNhcFszXS5yZXBsYWNlKC9cXG4kLywgJycpLnNwbGl0KCdcXG4nKSA6IFtdXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGl0ZW0uaGVhZGVyLmxlbmd0aCA9PT0gaXRlbS5hbGlnbi5sZW5ndGgpIHtcbiAgICAgICAgICBpdGVtLnJhdyA9IGNhcFswXTtcbiAgICAgICAgICB2YXIgbCA9IGl0ZW0uYWxpZ24ubGVuZ3RoO1xuICAgICAgICAgIHZhciBpO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKC9eICotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdyaWdodCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnY2VudGVyJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL14gKjotKyAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2xlZnQnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbCA9IGl0ZW0uY2VsbHMubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaXRlbS5jZWxsc1tpXSA9IHNwbGl0Q2VsbHMkMShpdGVtLmNlbGxzW2ldLnJlcGxhY2UoL14gKlxcfCAqfCAqXFx8ICokL2csICcnKSwgaXRlbS5oZWFkZXIubGVuZ3RoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8ubGhlYWRpbmcgPSBmdW5jdGlvbiBsaGVhZGluZyhzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmxoZWFkaW5nLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICBkZXB0aDogY2FwWzJdLmNoYXJBdCgwKSA9PT0gJz0nID8gMSA6IDIsXG4gICAgICAgICAgdGV4dDogY2FwWzFdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5wYXJhZ3JhcGggPSBmdW5jdGlvbiBwYXJhZ3JhcGgoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5wYXJhZ3JhcGguZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogY2FwWzFdLmNoYXJBdChjYXBbMV0ubGVuZ3RoIC0gMSkgPT09ICdcXG4nID8gY2FwWzFdLnNsaWNlKDAsIC0xKSA6IGNhcFsxXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8udGV4dCA9IGZ1bmN0aW9uIHRleHQoc3JjLCB0b2tlbnMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLnRleHQuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChsYXN0VG9rZW4gJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgIHRleHQ6IGNhcFswXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICB0ZXh0OiBjYXBbMF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmVzY2FwZSA9IGZ1bmN0aW9uIGVzY2FwZShzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5lc2NhcGUuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2VzY2FwZScsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogX2VzY2FwZShjYXBbMV0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by50YWcgPSBmdW5jdGlvbiB0YWcoc3JjLCBpbkxpbmssIGluUmF3QmxvY2spIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS50YWcuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIGlmICghaW5MaW5rICYmIC9ePGEgL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgaW5MaW5rID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpbkxpbmsgJiYgL148XFwvYT4vaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgICBpbkxpbmsgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaW5SYXdCbG9jayAmJiAvXjwocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgaW5SYXdCbG9jayA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5SYXdCbG9jayAmJiAvXjxcXC8ocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgaW5SYXdCbG9jayA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiB0aGlzLm9wdGlvbnMuc2FuaXRpemUgPyAndGV4dCcgOiAnaHRtbCcsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgaW5MaW5rOiBpbkxpbmssXG4gICAgICAgICAgaW5SYXdCbG9jazogaW5SYXdCbG9jayxcbiAgICAgICAgICB0ZXh0OiB0aGlzLm9wdGlvbnMuc2FuaXRpemUgPyB0aGlzLm9wdGlvbnMuc2FuaXRpemVyID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pIDogX2VzY2FwZShjYXBbMF0pIDogY2FwWzBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5saW5rID0gZnVuY3Rpb24gbGluayhzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5saW5rLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgbGFzdFBhcmVuSW5kZXggPSBmaW5kQ2xvc2luZ0JyYWNrZXQkMShjYXBbMl0sICcoKScpO1xuXG4gICAgICAgIGlmIChsYXN0UGFyZW5JbmRleCA+IC0xKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gY2FwWzBdLmluZGV4T2YoJyEnKSA9PT0gMCA/IDUgOiA0O1xuICAgICAgICAgIHZhciBsaW5rTGVuID0gc3RhcnQgKyBjYXBbMV0ubGVuZ3RoICsgbGFzdFBhcmVuSW5kZXg7XG4gICAgICAgICAgY2FwWzJdID0gY2FwWzJdLnN1YnN0cmluZygwLCBsYXN0UGFyZW5JbmRleCk7XG4gICAgICAgICAgY2FwWzBdID0gY2FwWzBdLnN1YnN0cmluZygwLCBsaW5rTGVuKS50cmltKCk7XG4gICAgICAgICAgY2FwWzNdID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaHJlZiA9IGNhcFsyXTtcbiAgICAgICAgdmFyIHRpdGxlID0gJyc7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgIHZhciBsaW5rID0gL14oW14nXCJdKlteXFxzXSlcXHMrKFsnXCJdKSguKilcXDIvLmV4ZWMoaHJlZik7XG5cbiAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgaHJlZiA9IGxpbmtbMV07XG4gICAgICAgICAgICB0aXRsZSA9IGxpbmtbM107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpdGxlID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpdGxlID0gY2FwWzNdID8gY2FwWzNdLnNsaWNlKDEsIC0xKSA6ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaHJlZiA9IGhyZWYudHJpbSgpLnJlcGxhY2UoL148KFtcXHNcXFNdKik+JC8sICckMScpO1xuICAgICAgICB2YXIgdG9rZW4gPSBvdXRwdXRMaW5rKGNhcCwge1xuICAgICAgICAgIGhyZWY6IGhyZWYgPyBocmVmLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuX2VzY2FwZXMsICckMScpIDogaHJlZixcbiAgICAgICAgICB0aXRsZTogdGl0bGUgPyB0aXRsZS5yZXBsYWNlKHRoaXMucnVsZXMuaW5saW5lLl9lc2NhcGVzLCAnJDEnKSA6IHRpdGxlXG4gICAgICAgIH0sIGNhcFswXSk7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLnJlZmxpbmsgPSBmdW5jdGlvbiByZWZsaW5rKHNyYywgbGlua3MpIHtcbiAgICAgIHZhciBjYXA7XG5cbiAgICAgIGlmICgoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUucmVmbGluay5leGVjKHNyYykpIHx8IChjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5ub2xpbmsuZXhlYyhzcmMpKSkge1xuICAgICAgICB2YXIgbGluayA9IChjYXBbMl0gfHwgY2FwWzFdKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgICAgIGxpbmsgPSBsaW5rc1tsaW5rLnRvTG93ZXJDYXNlKCldO1xuXG4gICAgICAgIGlmICghbGluayB8fCAhbGluay5ocmVmKSB7XG4gICAgICAgICAgdmFyIHRleHQgPSBjYXBbMF0uY2hhckF0KDApO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICByYXc6IHRleHQsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b2tlbiA9IG91dHB1dExpbmsoY2FwLCBsaW5rLCBjYXBbMF0pO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5zdHJvbmcgPSBmdW5jdGlvbiBzdHJvbmcoc3JjLCBtYXNrZWRTcmMsIHByZXZDaGFyKSB7XG4gICAgICBpZiAocHJldkNoYXIgPT09IHZvaWQgMCkge1xuICAgICAgICBwcmV2Q2hhciA9ICcnO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF0Y2ggPSB0aGlzLnJ1bGVzLmlubGluZS5zdHJvbmcuc3RhcnQuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAobWF0Y2ggJiYgKCFtYXRjaFsxXSB8fCBtYXRjaFsxXSAmJiAocHJldkNoYXIgPT09ICcnIHx8IHRoaXMucnVsZXMuaW5saW5lLnB1bmN0dWF0aW9uLmV4ZWMocHJldkNoYXIpKSkpIHtcbiAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKC0xICogc3JjLmxlbmd0aCk7XG4gICAgICAgIHZhciBlbmRSZWcgPSBtYXRjaFswXSA9PT0gJyoqJyA/IHRoaXMucnVsZXMuaW5saW5lLnN0cm9uZy5lbmRBc3QgOiB0aGlzLnJ1bGVzLmlubGluZS5zdHJvbmcuZW5kVW5kO1xuICAgICAgICBlbmRSZWcubGFzdEluZGV4ID0gMDtcbiAgICAgICAgdmFyIGNhcDtcblxuICAgICAgICB3aGlsZSAoKG1hdGNoID0gZW5kUmVnLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnN0cm9uZy5taWRkbGUuZXhlYyhtYXNrZWRTcmMuc2xpY2UoMCwgbWF0Y2guaW5kZXggKyAzKSk7XG5cbiAgICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiAnc3Ryb25nJyxcbiAgICAgICAgICAgICAgcmF3OiBzcmMuc2xpY2UoMCwgY2FwWzBdLmxlbmd0aCksXG4gICAgICAgICAgICAgIHRleHQ6IHNyYy5zbGljZSgyLCBjYXBbMF0ubGVuZ3RoIC0gMilcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5lbSA9IGZ1bmN0aW9uIGVtKHNyYywgbWFza2VkU3JjLCBwcmV2Q2hhcikge1xuICAgICAgaWYgKHByZXZDaGFyID09PSB2b2lkIDApIHtcbiAgICAgICAgcHJldkNoYXIgPSAnJztcbiAgICAgIH1cblxuICAgICAgdmFyIG1hdGNoID0gdGhpcy5ydWxlcy5pbmxpbmUuZW0uc3RhcnQuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAobWF0Y2ggJiYgKCFtYXRjaFsxXSB8fCBtYXRjaFsxXSAmJiAocHJldkNoYXIgPT09ICcnIHx8IHRoaXMucnVsZXMuaW5saW5lLnB1bmN0dWF0aW9uLmV4ZWMocHJldkNoYXIpKSkpIHtcbiAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKC0xICogc3JjLmxlbmd0aCk7XG4gICAgICAgIHZhciBlbmRSZWcgPSBtYXRjaFswXSA9PT0gJyonID8gdGhpcy5ydWxlcy5pbmxpbmUuZW0uZW5kQXN0IDogdGhpcy5ydWxlcy5pbmxpbmUuZW0uZW5kVW5kO1xuICAgICAgICBlbmRSZWcubGFzdEluZGV4ID0gMDtcbiAgICAgICAgdmFyIGNhcDtcblxuICAgICAgICB3aGlsZSAoKG1hdGNoID0gZW5kUmVnLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmVtLm1pZGRsZS5leGVjKG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCArIDIpKTtcblxuICAgICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdlbScsXG4gICAgICAgICAgICAgIHJhdzogc3JjLnNsaWNlKDAsIGNhcFswXS5sZW5ndGgpLFxuICAgICAgICAgICAgICB0ZXh0OiBzcmMuc2xpY2UoMSwgY2FwWzBdLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uY29kZXNwYW4gPSBmdW5jdGlvbiBjb2Rlc3BhbihzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5jb2RlLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgdGV4dCA9IGNhcFsyXS5yZXBsYWNlKC9cXG4vZywgJyAnKTtcbiAgICAgICAgdmFyIGhhc05vblNwYWNlQ2hhcnMgPSAvW14gXS8udGVzdCh0ZXh0KTtcbiAgICAgICAgdmFyIGhhc1NwYWNlQ2hhcnNPbkJvdGhFbmRzID0gdGV4dC5zdGFydHNXaXRoKCcgJykgJiYgdGV4dC5lbmRzV2l0aCgnICcpO1xuXG4gICAgICAgIGlmIChoYXNOb25TcGFjZUNoYXJzICYmIGhhc1NwYWNlQ2hhcnNPbkJvdGhFbmRzKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDEsIHRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0ID0gX2VzY2FwZSh0ZXh0LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnY29kZXNwYW4nLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmJyID0gZnVuY3Rpb24gYnIoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuYnIuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2JyJyxcbiAgICAgICAgICByYXc6IGNhcFswXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uZGVsID0gZnVuY3Rpb24gZGVsKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmRlbC5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnZGVsJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICB0ZXh0OiBjYXBbMV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmF1dG9saW5rID0gZnVuY3Rpb24gYXV0b2xpbmsoc3JjLCBtYW5nbGUpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5hdXRvbGluay5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgdmFyIHRleHQsIGhyZWY7XG5cbiAgICAgICAgaWYgKGNhcFsyXSA9PT0gJ0AnKSB7XG4gICAgICAgICAgdGV4dCA9IF9lc2NhcGUodGhpcy5vcHRpb25zLm1hbmdsZSA/IG1hbmdsZShjYXBbMV0pIDogY2FwWzFdKTtcbiAgICAgICAgICBocmVmID0gJ21haWx0bzonICsgdGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0ID0gX2VzY2FwZShjYXBbMV0pO1xuICAgICAgICAgIGhyZWYgPSB0ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgIHRva2VuczogW3tcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8udXJsID0gZnVuY3Rpb24gdXJsKHNyYywgbWFuZ2xlKSB7XG4gICAgICB2YXIgY2FwO1xuXG4gICAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudXJsLmV4ZWMoc3JjKSkge1xuICAgICAgICB2YXIgdGV4dCwgaHJlZjtcblxuICAgICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgICB0ZXh0ID0gX2VzY2FwZSh0aGlzLm9wdGlvbnMubWFuZ2xlID8gbWFuZ2xlKGNhcFswXSkgOiBjYXBbMF0pO1xuICAgICAgICAgIGhyZWYgPSAnbWFpbHRvOicgKyB0ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRvIGV4dGVuZGVkIGF1dG9saW5rIHBhdGggdmFsaWRhdGlvblxuICAgICAgICAgIHZhciBwcmV2Q2FwWmVybztcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIHByZXZDYXBaZXJvID0gY2FwWzBdO1xuICAgICAgICAgICAgY2FwWzBdID0gdGhpcy5ydWxlcy5pbmxpbmUuX2JhY2twZWRhbC5leGVjKGNhcFswXSlbMF07XG4gICAgICAgICAgfSB3aGlsZSAocHJldkNhcFplcm8gIT09IGNhcFswXSk7XG5cbiAgICAgICAgICB0ZXh0ID0gX2VzY2FwZShjYXBbMF0pO1xuXG4gICAgICAgICAgaWYgKGNhcFsxXSA9PT0gJ3d3dy4nKSB7XG4gICAgICAgICAgICBocmVmID0gJ2h0dHA6Ly8nICsgdGV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgIHRva2VuczogW3tcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uaW5saW5lVGV4dCA9IGZ1bmN0aW9uIGlubGluZVRleHQoc3JjLCBpblJhd0Jsb2NrLCBzbWFydHlwYW50cykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnRleHQuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciB0ZXh0O1xuXG4gICAgICAgIGlmIChpblJhd0Jsb2NrKSB7XG4gICAgICAgICAgdGV4dCA9IHRoaXMub3B0aW9ucy5zYW5pdGl6ZSA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIgPyB0aGlzLm9wdGlvbnMuc2FuaXRpemVyKGNhcFswXSkgOiBfZXNjYXBlKGNhcFswXSkgOiBjYXBbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dCA9IF9lc2NhcGUodGhpcy5vcHRpb25zLnNtYXJ0eXBhbnRzID8gc21hcnR5cGFudHMoY2FwWzBdKSA6IGNhcFswXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBUb2tlbml6ZXI7XG4gIH0oKTtcblxuICB2YXIgbm9vcFRlc3QkMSA9IGhlbHBlcnMubm9vcFRlc3QsXG4gICAgICBlZGl0JDEgPSBoZWxwZXJzLmVkaXQsXG4gICAgICBtZXJnZSQxID0gaGVscGVycy5tZXJnZTtcbiAgLyoqXG4gICAqIEJsb2NrLUxldmVsIEdyYW1tYXJcbiAgICovXG5cbiAgdmFyIGJsb2NrID0ge1xuICAgIG5ld2xpbmU6IC9eXFxuKy8sXG4gICAgY29kZTogL14oIHs0fVteXFxuXStcXG4qKSsvLFxuICAgIGZlbmNlczogL14gezAsM30oYHszLH0oPz1bXmBcXG5dKlxcbil8fnszLH0pKFteXFxuXSopXFxuKD86fChbXFxzXFxTXSo/KVxcbikoPzogezAsM31cXDFbfmBdKiAqKD86XFxuK3wkKXwkKS8sXG4gICAgaHI6IC9eIHswLDN9KCg/Oi0gKil7Myx9fCg/Ol8gKil7Myx9fCg/OlxcKiAqKXszLH0pKD86XFxuK3wkKS8sXG4gICAgaGVhZGluZzogL14gezAsM30oI3sxLDZ9KSArKFteXFxuXSo/KSg/OiArIyspPyAqKD86XFxuK3wkKS8sXG4gICAgYmxvY2txdW90ZTogL14oIHswLDN9PiA/KHBhcmFncmFwaHxbXlxcbl0qKSg/OlxcbnwkKSkrLyxcbiAgICBsaXN0OiAvXiggezAsM30pKGJ1bGwpIFtcXHNcXFNdKz8oPzpocnxkZWZ8XFxuezIsfSg/ISApKD8hXFwxYnVsbCApXFxuKnxcXHMqJCkvLFxuICAgIGh0bWw6ICdeIHswLDN9KD86JyAvLyBvcHRpb25hbCBpbmRlbnRhdGlvblxuICAgICsgJzwoc2NyaXB0fHByZXxzdHlsZSlbXFxcXHM+XVtcXFxcc1xcXFxTXSo/KD86PC9cXFxcMT5bXlxcXFxuXSpcXFxcbit8JCknIC8vICgxKVxuICAgICsgJ3xjb21tZW50W15cXFxcbl0qKFxcXFxuK3wkKScgLy8gKDIpXG4gICAgKyAnfDxcXFxcP1tcXFxcc1xcXFxTXSo/KD86XFxcXD8+XFxcXG4qfCQpJyAvLyAoMylcbiAgICArICd8PCFbQS1aXVtcXFxcc1xcXFxTXSo/KD86PlxcXFxuKnwkKScgLy8gKDQpXG4gICAgKyAnfDwhXFxcXFtDREFUQVxcXFxbW1xcXFxzXFxcXFNdKj8oPzpcXFxcXVxcXFxdPlxcXFxuKnwkKScgLy8gKDUpXG4gICAgKyAnfDwvPyh0YWcpKD86ICt8XFxcXG58Lz8+KVtcXFxcc1xcXFxTXSo/KD86XFxcXG57Mix9fCQpJyAvLyAoNilcbiAgICArICd8PCg/IXNjcmlwdHxwcmV8c3R5bGUpKFthLXpdW1xcXFx3LV0qKSg/OmF0dHJpYnV0ZSkqPyAqLz8+KD89WyBcXFxcdF0qKD86XFxcXG58JCkpW1xcXFxzXFxcXFNdKj8oPzpcXFxcbnsyLH18JCknIC8vICg3KSBvcGVuIHRhZ1xuICAgICsgJ3w8Lyg/IXNjcmlwdHxwcmV8c3R5bGUpW2Etel1bXFxcXHctXSpcXFxccyo+KD89WyBcXFxcdF0qKD86XFxcXG58JCkpW1xcXFxzXFxcXFNdKj8oPzpcXFxcbnsyLH18JCknIC8vICg3KSBjbG9zaW5nIHRhZ1xuICAgICsgJyknLFxuICAgIGRlZjogL14gezAsM31cXFsobGFiZWwpXFxdOiAqXFxuPyAqPD8oW15cXHM+XSspPj8oPzooPzogK1xcbj8gKnwgKlxcbiAqKSh0aXRsZSkpPyAqKD86XFxuK3wkKS8sXG4gICAgbnB0YWJsZTogbm9vcFRlc3QkMSxcbiAgICB0YWJsZTogbm9vcFRlc3QkMSxcbiAgICBsaGVhZGluZzogL14oW15cXG5dKylcXG4gezAsM30oPSt8LSspICooPzpcXG4rfCQpLyxcbiAgICAvLyByZWdleCB0ZW1wbGF0ZSwgcGxhY2Vob2xkZXJzIHdpbGwgYmUgcmVwbGFjZWQgYWNjb3JkaW5nIHRvIGRpZmZlcmVudCBwYXJhZ3JhcGhcbiAgICAvLyBpbnRlcnJ1cHRpb24gcnVsZXMgb2YgY29tbW9ubWFyayBhbmQgdGhlIG9yaWdpbmFsIG1hcmtkb3duIHNwZWM6XG4gICAgX3BhcmFncmFwaDogL14oW15cXG5dKyg/Olxcbig/IWhyfGhlYWRpbmd8bGhlYWRpbmd8YmxvY2txdW90ZXxmZW5jZXN8bGlzdHxodG1sKVteXFxuXSspKikvLFxuICAgIHRleHQ6IC9eW15cXG5dKy9cbiAgfTtcbiAgYmxvY2suX2xhYmVsID0gLyg/IVxccypcXF0pKD86XFxcXFtcXFtcXF1dfFteXFxbXFxdXSkrLztcbiAgYmxvY2suX3RpdGxlID0gLyg/OlwiKD86XFxcXFwiP3xbXlwiXFxcXF0pKlwifCdbXidcXG5dKig/OlxcblteJ1xcbl0rKSpcXG4/J3xcXChbXigpXSpcXCkpLztcbiAgYmxvY2suZGVmID0gZWRpdCQxKGJsb2NrLmRlZikucmVwbGFjZSgnbGFiZWwnLCBibG9jay5fbGFiZWwpLnJlcGxhY2UoJ3RpdGxlJywgYmxvY2suX3RpdGxlKS5nZXRSZWdleCgpO1xuICBibG9jay5idWxsZXQgPSAvKD86WyorLV18XFxkezEsOX1bLildKS87XG4gIGJsb2NrLml0ZW0gPSAvXiggKikoYnVsbCkgP1teXFxuXSooPzpcXG4oPyFcXDFidWxsID8pW15cXG5dKikqLztcbiAgYmxvY2suaXRlbSA9IGVkaXQkMShibG9jay5pdGVtLCAnZ20nKS5yZXBsYWNlKC9idWxsL2csIGJsb2NrLmJ1bGxldCkuZ2V0UmVnZXgoKTtcbiAgYmxvY2subGlzdCA9IGVkaXQkMShibG9jay5saXN0KS5yZXBsYWNlKC9idWxsL2csIGJsb2NrLmJ1bGxldCkucmVwbGFjZSgnaHInLCAnXFxcXG4rKD89XFxcXDE/KD86KD86LSAqKXszLH18KD86XyAqKXszLH18KD86XFxcXCogKil7Myx9KSg/OlxcXFxuK3wkKSknKS5yZXBsYWNlKCdkZWYnLCAnXFxcXG4rKD89JyArIGJsb2NrLmRlZi5zb3VyY2UgKyAnKScpLmdldFJlZ2V4KCk7XG4gIGJsb2NrLl90YWcgPSAnYWRkcmVzc3xhcnRpY2xlfGFzaWRlfGJhc2V8YmFzZWZvbnR8YmxvY2txdW90ZXxib2R5fGNhcHRpb24nICsgJ3xjZW50ZXJ8Y29sfGNvbGdyb3VwfGRkfGRldGFpbHN8ZGlhbG9nfGRpcnxkaXZ8ZGx8ZHR8ZmllbGRzZXR8ZmlnY2FwdGlvbicgKyAnfGZpZ3VyZXxmb290ZXJ8Zm9ybXxmcmFtZXxmcmFtZXNldHxoWzEtNl18aGVhZHxoZWFkZXJ8aHJ8aHRtbHxpZnJhbWUnICsgJ3xsZWdlbmR8bGl8bGlua3xtYWlufG1lbnV8bWVudWl0ZW18bWV0YXxuYXZ8bm9mcmFtZXN8b2x8b3B0Z3JvdXB8b3B0aW9uJyArICd8cHxwYXJhbXxzZWN0aW9ufHNvdXJjZXxzdW1tYXJ5fHRhYmxlfHRib2R5fHRkfHRmb290fHRofHRoZWFkfHRpdGxlfHRyJyArICd8dHJhY2t8dWwnO1xuICBibG9jay5fY29tbWVudCA9IC88IS0tKD8hLT8+KVtcXHNcXFNdKj8oPzotLT58JCkvO1xuICBibG9jay5odG1sID0gZWRpdCQxKGJsb2NrLmh0bWwsICdpJykucmVwbGFjZSgnY29tbWVudCcsIGJsb2NrLl9jb21tZW50KS5yZXBsYWNlKCd0YWcnLCBibG9jay5fdGFnKS5yZXBsYWNlKCdhdHRyaWJ1dGUnLCAvICtbYS16QS1aOl9dW1xcdy46LV0qKD86ICo9ICpcIlteXCJcXG5dKlwifCAqPSAqJ1teJ1xcbl0qJ3wgKj0gKlteXFxzXCInPTw+YF0rKT8vKS5nZXRSZWdleCgpO1xuICBibG9jay5wYXJhZ3JhcGggPSBlZGl0JDEoYmxvY2suX3BhcmFncmFwaCkucmVwbGFjZSgnaHInLCBibG9jay5ocikucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0gJykucmVwbGFjZSgnfGxoZWFkaW5nJywgJycpIC8vIHNldGV4IGhlYWRpbmdzIGRvbid0IGludGVycnVwdCBjb21tb25tYXJrIHBhcmFncmFwaHNcbiAgLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpLnJlcGxhY2UoJ2ZlbmNlcycsICcgezAsM30oPzpgezMsfSg/PVteYFxcXFxuXSpcXFxcbil8fnszLH0pW15cXFxcbl0qXFxcXG4nKS5yZXBsYWNlKCdsaXN0JywgJyB7MCwzfSg/OlsqKy1dfDFbLildKSAnKSAvLyBvbmx5IGxpc3RzIHN0YXJ0aW5nIGZyb20gMSBjYW4gaW50ZXJydXB0XG4gIC5yZXBsYWNlKCdodG1sJywgJzwvPyg/OnRhZykoPzogK3xcXFxcbnwvPz4pfDwoPzpzY3JpcHR8cHJlfHN0eWxlfCEtLSknKS5yZXBsYWNlKCd0YWcnLCBibG9jay5fdGFnKSAvLyBwYXJzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAuZ2V0UmVnZXgoKTtcbiAgYmxvY2suYmxvY2txdW90ZSA9IGVkaXQkMShibG9jay5ibG9ja3F1b3RlKS5yZXBsYWNlKCdwYXJhZ3JhcGgnLCBibG9jay5wYXJhZ3JhcGgpLmdldFJlZ2V4KCk7XG4gIC8qKlxuICAgKiBOb3JtYWwgQmxvY2sgR3JhbW1hclxuICAgKi9cblxuICBibG9jay5ub3JtYWwgPSBtZXJnZSQxKHt9LCBibG9jayk7XG4gIC8qKlxuICAgKiBHRk0gQmxvY2sgR3JhbW1hclxuICAgKi9cblxuICBibG9jay5nZm0gPSBtZXJnZSQxKHt9LCBibG9jay5ub3JtYWwsIHtcbiAgICBucHRhYmxlOiAnXiAqKFtefFxcXFxuIF0uKlxcXFx8LiopXFxcXG4nIC8vIEhlYWRlclxuICAgICsgJyB7MCwzfShbLTpdKyAqXFxcXHxbLXwgOl0qKScgLy8gQWxpZ25cbiAgICArICcoPzpcXFxcbigoPzooPyFcXFxcbnxocnxoZWFkaW5nfGJsb2NrcXVvdGV8Y29kZXxmZW5jZXN8bGlzdHxodG1sKS4qKD86XFxcXG58JCkpKilcXFxcbip8JCknLFxuICAgIC8vIENlbGxzXG4gICAgdGFibGU6ICdeICpcXFxcfCguKylcXFxcbicgLy8gSGVhZGVyXG4gICAgKyAnIHswLDN9XFxcXHw/KCAqWy06XStbLXwgOl0qKScgLy8gQWxpZ25cbiAgICArICcoPzpcXFxcbiAqKCg/Oig/IVxcXFxufGhyfGhlYWRpbmd8YmxvY2txdW90ZXxjb2RlfGZlbmNlc3xsaXN0fGh0bWwpLiooPzpcXFxcbnwkKSkqKVxcXFxuKnwkKScgLy8gQ2VsbHNcblxuICB9KTtcbiAgYmxvY2suZ2ZtLm5wdGFibGUgPSBlZGl0JDEoYmxvY2suZ2ZtLm5wdGFibGUpLnJlcGxhY2UoJ2hyJywgYmxvY2suaHIpLnJlcGxhY2UoJ2hlYWRpbmcnLCAnIHswLDN9I3sxLDZ9ICcpLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpLnJlcGxhY2UoJ2NvZGUnLCAnIHs0fVteXFxcXG5dJykucmVwbGFjZSgnZmVuY2VzJywgJyB7MCwzfSg/OmB7Myx9KD89W15gXFxcXG5dKlxcXFxuKXx+ezMsfSlbXlxcXFxuXSpcXFxcbicpLnJlcGxhY2UoJ2xpc3QnLCAnIHswLDN9KD86WyorLV18MVsuKV0pICcpIC8vIG9ubHkgbGlzdHMgc3RhcnRpbmcgZnJvbSAxIGNhbiBpbnRlcnJ1cHRcbiAgLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8IS0tKScpLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpIC8vIHRhYmxlcyBjYW4gYmUgaW50ZXJydXB0ZWQgYnkgdHlwZSAoNikgaHRtbCBibG9ja3NcbiAgLmdldFJlZ2V4KCk7XG4gIGJsb2NrLmdmbS50YWJsZSA9IGVkaXQkMShibG9jay5nZm0udGFibGUpLnJlcGxhY2UoJ2hyJywgYmxvY2suaHIpLnJlcGxhY2UoJ2hlYWRpbmcnLCAnIHswLDN9I3sxLDZ9ICcpLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpLnJlcGxhY2UoJ2NvZGUnLCAnIHs0fVteXFxcXG5dJykucmVwbGFjZSgnZmVuY2VzJywgJyB7MCwzfSg/OmB7Myx9KD89W15gXFxcXG5dKlxcXFxuKXx+ezMsfSlbXlxcXFxuXSpcXFxcbicpLnJlcGxhY2UoJ2xpc3QnLCAnIHswLDN9KD86WyorLV18MVsuKV0pICcpIC8vIG9ubHkgbGlzdHMgc3RhcnRpbmcgZnJvbSAxIGNhbiBpbnRlcnJ1cHRcbiAgLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8IS0tKScpLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpIC8vIHRhYmxlcyBjYW4gYmUgaW50ZXJydXB0ZWQgYnkgdHlwZSAoNikgaHRtbCBibG9ja3NcbiAgLmdldFJlZ2V4KCk7XG4gIC8qKlxuICAgKiBQZWRhbnRpYyBncmFtbWFyIChvcmlnaW5hbCBKb2huIEdydWJlcidzIGxvb3NlIG1hcmtkb3duIHNwZWNpZmljYXRpb24pXG4gICAqL1xuXG4gIGJsb2NrLnBlZGFudGljID0gbWVyZ2UkMSh7fSwgYmxvY2subm9ybWFsLCB7XG4gICAgaHRtbDogZWRpdCQxKCdeICooPzpjb21tZW50ICooPzpcXFxcbnxcXFxccyokKScgKyAnfDwodGFnKVtcXFxcc1xcXFxTXSs/PC9cXFxcMT4gKig/OlxcXFxuezIsfXxcXFxccyokKScgLy8gY2xvc2VkIHRhZ1xuICAgICsgJ3w8dGFnKD86XCJbXlwiXSpcInxcXCdbXlxcJ10qXFwnfFxcXFxzW15cXCdcIi8+XFxcXHNdKikqPy8/PiAqKD86XFxcXG57Mix9fFxcXFxzKiQpKScpLnJlcGxhY2UoJ2NvbW1lbnQnLCBibG9jay5fY29tbWVudCkucmVwbGFjZSgvdGFnL2csICcoPyEoPzonICsgJ2F8ZW18c3Ryb25nfHNtYWxsfHN8Y2l0ZXxxfGRmbnxhYmJyfGRhdGF8dGltZXxjb2RlfHZhcnxzYW1wfGtiZHxzdWInICsgJ3xzdXB8aXxifHV8bWFya3xydWJ5fHJ0fHJwfGJkaXxiZG98c3Bhbnxicnx3YnJ8aW5zfGRlbHxpbWcpJyArICdcXFxcYilcXFxcdysoPyE6fFteXFxcXHdcXFxcc0BdKkApXFxcXGInKS5nZXRSZWdleCgpLFxuICAgIGRlZjogL14gKlxcWyhbXlxcXV0rKVxcXTogKjw/KFteXFxzPl0rKT4/KD86ICsoW1wiKF1bXlxcbl0rW1wiKV0pKT8gKig/Olxcbit8JCkvLFxuICAgIGhlYWRpbmc6IC9eICooI3sxLDZ9KSAqKFteXFxuXSs/KSAqKD86IysgKik/KD86XFxuK3wkKS8sXG4gICAgZmVuY2VzOiBub29wVGVzdCQxLFxuICAgIC8vIGZlbmNlcyBub3Qgc3VwcG9ydGVkXG4gICAgcGFyYWdyYXBoOiBlZGl0JDEoYmxvY2subm9ybWFsLl9wYXJhZ3JhcGgpLnJlcGxhY2UoJ2hyJywgYmxvY2suaHIpLnJlcGxhY2UoJ2hlYWRpbmcnLCAnICojezEsNn0gKlteXFxuXScpLnJlcGxhY2UoJ2xoZWFkaW5nJywgYmxvY2subGhlYWRpbmcpLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpLnJlcGxhY2UoJ3xmZW5jZXMnLCAnJykucmVwbGFjZSgnfGxpc3QnLCAnJykucmVwbGFjZSgnfGh0bWwnLCAnJykuZ2V0UmVnZXgoKVxuICB9KTtcbiAgLyoqXG4gICAqIElubGluZS1MZXZlbCBHcmFtbWFyXG4gICAqL1xuXG4gIHZhciBpbmxpbmUgPSB7XG4gICAgZXNjYXBlOiAvXlxcXFwoWyFcIiMkJSYnKCkqKyxcXC0uLzo7PD0+P0BcXFtcXF1cXFxcXl9ge3x9fl0pLyxcbiAgICBhdXRvbGluazogL148KHNjaGVtZTpbXlxcc1xceDAwLVxceDFmPD5dKnxlbWFpbCk+LyxcbiAgICB1cmw6IG5vb3BUZXN0JDEsXG4gICAgdGFnOiAnXmNvbW1lbnQnICsgJ3xePC9bYS16QS1aXVtcXFxcdzotXSpcXFxccyo+JyAvLyBzZWxmLWNsb3NpbmcgdGFnXG4gICAgKyAnfF48W2EtekEtWl1bXFxcXHctXSooPzphdHRyaWJ1dGUpKj9cXFxccyovPz4nIC8vIG9wZW4gdGFnXG4gICAgKyAnfF48XFxcXD9bXFxcXHNcXFxcU10qP1xcXFw/PicgLy8gcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiwgZS5nLiA8P3BocCA/PlxuICAgICsgJ3xePCFbYS16QS1aXStcXFxcc1tcXFxcc1xcXFxTXSo/PicgLy8gZGVjbGFyYXRpb24sIGUuZy4gPCFET0NUWVBFIGh0bWw+XG4gICAgKyAnfF48IVxcXFxbQ0RBVEFcXFxcW1tcXFxcc1xcXFxTXSo/XFxcXF1cXFxcXT4nLFxuICAgIC8vIENEQVRBIHNlY3Rpb25cbiAgICBsaW5rOiAvXiE/XFxbKGxhYmVsKVxcXVxcKFxccyooaHJlZikoPzpcXHMrKHRpdGxlKSk/XFxzKlxcKS8sXG4gICAgcmVmbGluazogL14hP1xcWyhsYWJlbClcXF1cXFsoPyFcXHMqXFxdKSgoPzpcXFxcW1xcW1xcXV0/fFteXFxbXFxdXFxcXF0pKylcXF0vLFxuICAgIG5vbGluazogL14hP1xcWyg/IVxccypcXF0pKCg/OlxcW1teXFxbXFxdXSpcXF18XFxcXFtcXFtcXF1dfFteXFxbXFxdXSkqKVxcXSg/OlxcW1xcXSk/LyxcbiAgICByZWZsaW5rU2VhcmNoOiAncmVmbGlua3xub2xpbmsoPyFcXFxcKCknLFxuICAgIHN0cm9uZzoge1xuICAgICAgc3RhcnQ6IC9eKD86KFxcKlxcKig/PVsqcHVuY3R1YXRpb25dKSl8XFwqXFwqKSg/IVtcXHNdKXxfXy8sXG4gICAgICAvLyAoMSkgcmV0dXJucyBpZiBzdGFydHMgdy8gcHVuY3R1YXRpb25cbiAgICAgIG1pZGRsZTogL15cXCpcXCooPzooPzooPyFvdmVybGFwU2tpcCkoPzpbXipdfFxcXFxcXCopfG92ZXJsYXBTa2lwKXxcXCooPzooPyFvdmVybGFwU2tpcCkoPzpbXipdfFxcXFxcXCopfG92ZXJsYXBTa2lwKSo/XFwqKSs/XFwqXFwqJHxeX18oPyFbXFxzXSkoKD86KD86KD8hb3ZlcmxhcFNraXApKD86W15fXXxcXFxcXyl8b3ZlcmxhcFNraXApfF8oPzooPyFvdmVybGFwU2tpcCkoPzpbXl9dfFxcXFxfKXxvdmVybGFwU2tpcCkqP18pKz8pX18kLyxcbiAgICAgIGVuZEFzdDogL1tecHVuY3R1YXRpb25cXHNdXFwqXFwqKD8hXFwqKXxbcHVuY3R1YXRpb25dXFwqXFwqKD8hXFwqKSg/Oig/PVtwdW5jdHVhdGlvbl9cXHNdfCQpKS8sXG4gICAgICAvLyBsYXN0IGNoYXIgY2FuJ3QgYmUgcHVuY3QsIG9yIGZpbmFsICogbXVzdCBhbHNvIGJlIGZvbGxvd2VkIGJ5IHB1bmN0IChvciBlbmRsaW5lKVxuICAgICAgZW5kVW5kOiAvW15cXHNdX18oPyFfKSg/Oig/PVtwdW5jdHVhdGlvbipcXHNdKXwkKS8gLy8gbGFzdCBjaGFyIGNhbid0IGJlIGEgc3BhY2UsIGFuZCBmaW5hbCBfIG11c3QgcHJlY2VlZCBwdW5jdCBvciBcXHMgKG9yIGVuZGxpbmUpXG5cbiAgICB9LFxuICAgIGVtOiB7XG4gICAgICBzdGFydDogL14oPzooXFwqKD89W3B1bmN0dWF0aW9uXSkpfFxcKikoPyFbKlxcc10pfF8vLFxuICAgICAgLy8gKDEpIHJldHVybnMgaWYgc3RhcnRzIHcvIHB1bmN0dWF0aW9uXG4gICAgICBtaWRkbGU6IC9eXFwqKD86KD86KD8hb3ZlcmxhcFNraXApKD86W14qXXxcXFxcXFwqKXxvdmVybGFwU2tpcCl8XFwqKD86KD8hb3ZlcmxhcFNraXApKD86W14qXXxcXFxcXFwqKXxvdmVybGFwU2tpcCkqP1xcKikrP1xcKiR8Xl8oPyFbX1xcc10pKD86KD86KD8hb3ZlcmxhcFNraXApKD86W15fXXxcXFxcXyl8b3ZlcmxhcFNraXApfF8oPzooPyFvdmVybGFwU2tpcCkoPzpbXl9dfFxcXFxfKXxvdmVybGFwU2tpcCkqP18pKz9fJC8sXG4gICAgICBlbmRBc3Q6IC9bXnB1bmN0dWF0aW9uXFxzXVxcKig/IVxcKil8W3B1bmN0dWF0aW9uXVxcKig/IVxcKikoPzooPz1bcHVuY3R1YXRpb25fXFxzXXwkKSkvLFxuICAgICAgLy8gbGFzdCBjaGFyIGNhbid0IGJlIHB1bmN0LCBvciBmaW5hbCAqIG11c3QgYWxzbyBiZSBmb2xsb3dlZCBieSBwdW5jdCAob3IgZW5kbGluZSlcbiAgICAgIGVuZFVuZDogL1teXFxzXV8oPyFfKSg/Oig/PVtwdW5jdHVhdGlvbipcXHNdKXwkKS8gLy8gbGFzdCBjaGFyIGNhbid0IGJlIGEgc3BhY2UsIGFuZCBmaW5hbCBfIG11c3QgcHJlY2VlZCBwdW5jdCBvciBcXHMgKG9yIGVuZGxpbmUpXG5cbiAgICB9LFxuICAgIGNvZGU6IC9eKGArKShbXmBdfFteYF1bXFxzXFxTXSo/W15gXSlcXDEoPyFgKS8sXG4gICAgYnI6IC9eKCB7Mix9fFxcXFwpXFxuKD8hXFxzKiQpLyxcbiAgICBkZWw6IG5vb3BUZXN0JDEsXG4gICAgdGV4dDogL14oYCt8W15gXSkoPzooPz0gezIsfVxcbil8W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKl18XFxiX3wkKXxbXiBdKD89IHsyLH1cXG4pKSkvLFxuICAgIHB1bmN0dWF0aW9uOiAvXihbXFxzKnB1bmN0dWF0aW9uXSkvXG4gIH07IC8vIGxpc3Qgb2YgcHVuY3R1YXRpb24gbWFya3MgZnJvbSBjb21tb24gbWFyayBzcGVjXG4gIC8vIHdpdGhvdXQgKiBhbmQgXyB0byB3b3JrYXJvdW5kIGNhc2VzIHdpdGggZG91YmxlIGVtcGhhc2lzXG5cbiAgaW5saW5lLl9wdW5jdHVhdGlvbiA9ICchXCIjJCUmXFwnKCkrXFxcXC0uLC86Ozw9Pj9AXFxcXFtcXFxcXWBee3x9fic7XG4gIGlubGluZS5wdW5jdHVhdGlvbiA9IGVkaXQkMShpbmxpbmUucHVuY3R1YXRpb24pLnJlcGxhY2UoL3B1bmN0dWF0aW9uL2csIGlubGluZS5fcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7IC8vIHNlcXVlbmNlcyBlbSBzaG91bGQgc2tpcCBvdmVyIFt0aXRsZV0obGluayksIGBjb2RlYCwgPGh0bWw+XG5cbiAgaW5saW5lLl9ibG9ja1NraXAgPSAnXFxcXFtbXlxcXFxdXSo/XFxcXF1cXFxcKFteXFxcXCldKj9cXFxcKXxgW15gXSo/YHw8W14+XSo/Pic7XG4gIGlubGluZS5fb3ZlcmxhcFNraXAgPSAnX19bXl9dKj9fX3xcXFxcKlxcXFwqXFxcXFteXFxcXCpcXFxcXSo/XFxcXCpcXFxcKic7XG4gIGlubGluZS5fY29tbWVudCA9IGVkaXQkMShibG9jay5fY29tbWVudCkucmVwbGFjZSgnKD86LS0+fCQpJywgJy0tPicpLmdldFJlZ2V4KCk7XG4gIGlubGluZS5lbS5zdGFydCA9IGVkaXQkMShpbmxpbmUuZW0uc3RhcnQpLnJlcGxhY2UoL3B1bmN0dWF0aW9uL2csIGlubGluZS5fcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG4gIGlubGluZS5lbS5taWRkbGUgPSBlZGl0JDEoaW5saW5lLmVtLm1pZGRsZSkucmVwbGFjZSgvcHVuY3R1YXRpb24vZywgaW5saW5lLl9wdW5jdHVhdGlvbikucmVwbGFjZSgvb3ZlcmxhcFNraXAvZywgaW5saW5lLl9vdmVybGFwU2tpcCkuZ2V0UmVnZXgoKTtcbiAgaW5saW5lLmVtLmVuZEFzdCA9IGVkaXQkMShpbmxpbmUuZW0uZW5kQXN0LCAnZycpLnJlcGxhY2UoL3B1bmN0dWF0aW9uL2csIGlubGluZS5fcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG4gIGlubGluZS5lbS5lbmRVbmQgPSBlZGl0JDEoaW5saW5lLmVtLmVuZFVuZCwgJ2cnKS5yZXBsYWNlKC9wdW5jdHVhdGlvbi9nLCBpbmxpbmUuX3B1bmN0dWF0aW9uKS5nZXRSZWdleCgpO1xuICBpbmxpbmUuc3Ryb25nLnN0YXJ0ID0gZWRpdCQxKGlubGluZS5zdHJvbmcuc3RhcnQpLnJlcGxhY2UoL3B1bmN0dWF0aW9uL2csIGlubGluZS5fcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG4gIGlubGluZS5zdHJvbmcubWlkZGxlID0gZWRpdCQxKGlubGluZS5zdHJvbmcubWlkZGxlKS5yZXBsYWNlKC9wdW5jdHVhdGlvbi9nLCBpbmxpbmUuX3B1bmN0dWF0aW9uKS5yZXBsYWNlKC9vdmVybGFwU2tpcC9nLCBpbmxpbmUuX292ZXJsYXBTa2lwKS5nZXRSZWdleCgpO1xuICBpbmxpbmUuc3Ryb25nLmVuZEFzdCA9IGVkaXQkMShpbmxpbmUuc3Ryb25nLmVuZEFzdCwgJ2cnKS5yZXBsYWNlKC9wdW5jdHVhdGlvbi9nLCBpbmxpbmUuX3B1bmN0dWF0aW9uKS5nZXRSZWdleCgpO1xuICBpbmxpbmUuc3Ryb25nLmVuZFVuZCA9IGVkaXQkMShpbmxpbmUuc3Ryb25nLmVuZFVuZCwgJ2cnKS5yZXBsYWNlKC9wdW5jdHVhdGlvbi9nLCBpbmxpbmUuX3B1bmN0dWF0aW9uKS5nZXRSZWdleCgpO1xuICBpbmxpbmUuYmxvY2tTa2lwID0gZWRpdCQxKGlubGluZS5fYmxvY2tTa2lwLCAnZycpLmdldFJlZ2V4KCk7XG4gIGlubGluZS5vdmVybGFwU2tpcCA9IGVkaXQkMShpbmxpbmUuX292ZXJsYXBTa2lwLCAnZycpLmdldFJlZ2V4KCk7XG4gIGlubGluZS5fZXNjYXBlcyA9IC9cXFxcKFshXCIjJCUmJygpKissXFwtLi86Ozw9Pj9AXFxbXFxdXFxcXF5fYHt8fX5dKS9nO1xuICBpbmxpbmUuX3NjaGVtZSA9IC9bYS16QS1aXVthLXpBLVowLTkrLi1dezEsMzF9LztcbiAgaW5saW5lLl9lbWFpbCA9IC9bYS16QS1aMC05LiEjJCUmJyorLz0/Xl9ge3x9fi1dKyhAKVthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykrKD8hWy1fXSkvO1xuICBpbmxpbmUuYXV0b2xpbmsgPSBlZGl0JDEoaW5saW5lLmF1dG9saW5rKS5yZXBsYWNlKCdzY2hlbWUnLCBpbmxpbmUuX3NjaGVtZSkucmVwbGFjZSgnZW1haWwnLCBpbmxpbmUuX2VtYWlsKS5nZXRSZWdleCgpO1xuICBpbmxpbmUuX2F0dHJpYnV0ZSA9IC9cXHMrW2EtekEtWjpfXVtcXHcuOi1dKig/Olxccyo9XFxzKlwiW15cIl0qXCJ8XFxzKj1cXHMqJ1teJ10qJ3xcXHMqPVxccypbXlxcc1wiJz08PmBdKyk/LztcbiAgaW5saW5lLnRhZyA9IGVkaXQkMShpbmxpbmUudGFnKS5yZXBsYWNlKCdjb21tZW50JywgaW5saW5lLl9jb21tZW50KS5yZXBsYWNlKCdhdHRyaWJ1dGUnLCBpbmxpbmUuX2F0dHJpYnV0ZSkuZ2V0UmVnZXgoKTtcbiAgaW5saW5lLl9sYWJlbCA9IC8oPzpcXFsoPzpcXFxcLnxbXlxcW1xcXVxcXFxdKSpcXF18XFxcXC58YFteYF0qYHxbXlxcW1xcXVxcXFxgXSkqPy87XG4gIGlubGluZS5faHJlZiA9IC88KD86XFxcXFs8Pl0/fFteXFxzPD5cXFxcXSkqPnxbXlxcc1xceDAwLVxceDFmXSovO1xuICBpbmxpbmUuX3RpdGxlID0gL1wiKD86XFxcXFwiP3xbXlwiXFxcXF0pKlwifCcoPzpcXFxcJz98W14nXFxcXF0pKid8XFwoKD86XFxcXFxcKT98W14pXFxcXF0pKlxcKS87XG4gIGlubGluZS5saW5rID0gZWRpdCQxKGlubGluZS5saW5rKS5yZXBsYWNlKCdsYWJlbCcsIGlubGluZS5fbGFiZWwpLnJlcGxhY2UoJ2hyZWYnLCBpbmxpbmUuX2hyZWYpLnJlcGxhY2UoJ3RpdGxlJywgaW5saW5lLl90aXRsZSkuZ2V0UmVnZXgoKTtcbiAgaW5saW5lLnJlZmxpbmsgPSBlZGl0JDEoaW5saW5lLnJlZmxpbmspLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lLl9sYWJlbCkuZ2V0UmVnZXgoKTtcbiAgaW5saW5lLnJlZmxpbmtTZWFyY2ggPSBlZGl0JDEoaW5saW5lLnJlZmxpbmtTZWFyY2gsICdnJykucmVwbGFjZSgncmVmbGluaycsIGlubGluZS5yZWZsaW5rKS5yZXBsYWNlKCdub2xpbmsnLCBpbmxpbmUubm9saW5rKS5nZXRSZWdleCgpO1xuICAvKipcbiAgICogTm9ybWFsIElubGluZSBHcmFtbWFyXG4gICAqL1xuXG4gIGlubGluZS5ub3JtYWwgPSBtZXJnZSQxKHt9LCBpbmxpbmUpO1xuICAvKipcbiAgICogUGVkYW50aWMgSW5saW5lIEdyYW1tYXJcbiAgICovXG5cbiAgaW5saW5lLnBlZGFudGljID0gbWVyZ2UkMSh7fSwgaW5saW5lLm5vcm1hbCwge1xuICAgIHN0cm9uZzoge1xuICAgICAgc3RhcnQ6IC9eX198XFwqXFwqLyxcbiAgICAgIG1pZGRsZTogL15fXyg/PVxcUykoW1xcc1xcU10qP1xcUylfXyg/IV8pfF5cXCpcXCooPz1cXFMpKFtcXHNcXFNdKj9cXFMpXFwqXFwqKD8hXFwqKS8sXG4gICAgICBlbmRBc3Q6IC9cXCpcXCooPyFcXCopL2csXG4gICAgICBlbmRVbmQ6IC9fXyg/IV8pL2dcbiAgICB9LFxuICAgIGVtOiB7XG4gICAgICBzdGFydDogL15ffFxcKi8sXG4gICAgICBtaWRkbGU6IC9eKClcXCooPz1cXFMpKFtcXHNcXFNdKj9cXFMpXFwqKD8hXFwqKXxeXyg/PVxcUykoW1xcc1xcU10qP1xcUylfKD8hXykvLFxuICAgICAgZW5kQXN0OiAvXFwqKD8hXFwqKS9nLFxuICAgICAgZW5kVW5kOiAvXyg/IV8pL2dcbiAgICB9LFxuICAgIGxpbms6IGVkaXQkMSgvXiE/XFxbKGxhYmVsKVxcXVxcKCguKj8pXFwpLykucmVwbGFjZSgnbGFiZWwnLCBpbmxpbmUuX2xhYmVsKS5nZXRSZWdleCgpLFxuICAgIHJlZmxpbms6IGVkaXQkMSgvXiE/XFxbKGxhYmVsKVxcXVxccypcXFsoW15cXF1dKilcXF0vKS5yZXBsYWNlKCdsYWJlbCcsIGlubGluZS5fbGFiZWwpLmdldFJlZ2V4KClcbiAgfSk7XG4gIC8qKlxuICAgKiBHRk0gSW5saW5lIEdyYW1tYXJcbiAgICovXG5cbiAgaW5saW5lLmdmbSA9IG1lcmdlJDEoe30sIGlubGluZS5ub3JtYWwsIHtcbiAgICBlc2NhcGU6IGVkaXQkMShpbmxpbmUuZXNjYXBlKS5yZXBsYWNlKCddKScsICd+fF0pJykuZ2V0UmVnZXgoKSxcbiAgICBfZXh0ZW5kZWRfZW1haWw6IC9bQS1aYS16MC05Ll8rLV0rKEApW2EtekEtWjAtOS1fXSsoPzpcXC5bYS16QS1aMC05LV9dKlthLXpBLVowLTldKSsoPyFbLV9dKS8sXG4gICAgdXJsOiAvXigoPzpmdHB8aHR0cHM/KTpcXC9cXC98d3d3XFwuKSg/OlthLXpBLVowLTlcXC1dK1xcLj8pK1teXFxzPF0qfF5lbWFpbC8sXG4gICAgX2JhY2twZWRhbDogLyg/OltePyEuLDo7Kl9+KCkmXSt8XFwoW14pXSpcXCl8Jig/IVthLXpBLVowLTldKzskKXxbPyEuLDo7Kl9+KV0rKD8hJCkpKy8sXG4gICAgZGVsOiAvXn4rKD89XFxTKShbXFxzXFxTXSo/XFxTKX4rLyxcbiAgICB0ZXh0OiAvXihgK3xbXmBdKSg/Oig/PSB7Mix9XFxuKXxbXFxzXFxTXSo/KD86KD89W1xcXFw8IVxcW2Aqfl18XFxiX3xodHRwcz86XFwvXFwvfGZ0cDpcXC9cXC98d3d3XFwufCQpfFteIF0oPz0gezIsfVxcbil8W15hLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0oPz1bYS16QS1aMC05LiEjJCUmJyorXFwvPT9fYHtcXHx9fi1dK0ApKXwoPz1bYS16QS1aMC05LiEjJCUmJyorXFwvPT9fYHtcXHx9fi1dK0ApKS9cbiAgfSk7XG4gIGlubGluZS5nZm0udXJsID0gZWRpdCQxKGlubGluZS5nZm0udXJsLCAnaScpLnJlcGxhY2UoJ2VtYWlsJywgaW5saW5lLmdmbS5fZXh0ZW5kZWRfZW1haWwpLmdldFJlZ2V4KCk7XG4gIC8qKlxuICAgKiBHRk0gKyBMaW5lIEJyZWFrcyBJbmxpbmUgR3JhbW1hclxuICAgKi9cblxuICBpbmxpbmUuYnJlYWtzID0gbWVyZ2UkMSh7fSwgaW5saW5lLmdmbSwge1xuICAgIGJyOiBlZGl0JDEoaW5saW5lLmJyKS5yZXBsYWNlKCd7Mix9JywgJyonKS5nZXRSZWdleCgpLFxuICAgIHRleHQ6IGVkaXQkMShpbmxpbmUuZ2ZtLnRleHQpLnJlcGxhY2UoJ1xcXFxiXycsICdcXFxcYl98IHsyLH1cXFxcbicpLnJlcGxhY2UoL1xcezIsXFx9L2csICcqJykuZ2V0UmVnZXgoKVxuICB9KTtcbiAgdmFyIHJ1bGVzID0ge1xuICAgIGJsb2NrOiBibG9jayxcbiAgICBpbmxpbmU6IGlubGluZVxuICB9O1xuXG4gIHZhciBkZWZhdWx0cyQyID0gZGVmYXVsdHMuZGVmYXVsdHM7XG4gIHZhciBibG9jayQxID0gcnVsZXMuYmxvY2ssXG4gICAgICBpbmxpbmUkMSA9IHJ1bGVzLmlubGluZTtcbiAgLyoqXG4gICAqIHNtYXJ0eXBhbnRzIHRleHQgcmVwbGFjZW1lbnRcbiAgICovXG5cbiAgZnVuY3Rpb24gc21hcnR5cGFudHModGV4dCkge1xuICAgIHJldHVybiB0ZXh0IC8vIGVtLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS0vZywgXCJcXHUyMDE0XCIpIC8vIGVuLWRhc2hlc1xuICAgIC5yZXBsYWNlKC8tLS9nLCBcIlxcdTIwMTNcIikgLy8gb3BlbmluZyBzaW5nbGVzXG4gICAgLnJlcGxhY2UoLyhefFstXFx1MjAxNC8oXFxbe1wiXFxzXSknL2csIFwiJDFcXHUyMDE4XCIpIC8vIGNsb3Npbmcgc2luZ2xlcyAmIGFwb3N0cm9waGVzXG4gICAgLnJlcGxhY2UoLycvZywgXCJcXHUyMDE5XCIpIC8vIG9wZW5pbmcgZG91Ymxlc1xuICAgIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcXHUyMDE4XFxzXSlcIi9nLCBcIiQxXFx1MjAxQ1wiKSAvLyBjbG9zaW5nIGRvdWJsZXNcbiAgICAucmVwbGFjZSgvXCIvZywgXCJcXHUyMDFEXCIpIC8vIGVsbGlwc2VzXG4gICAgLnJlcGxhY2UoL1xcLnszfS9nLCBcIlxcdTIwMjZcIik7XG4gIH1cbiAgLyoqXG4gICAqIG1hbmdsZSBlbWFpbCBhZGRyZXNzZXNcbiAgICovXG5cblxuICBmdW5jdGlvbiBtYW5nbGUodGV4dCkge1xuICAgIHZhciBvdXQgPSAnJyxcbiAgICAgICAgaSxcbiAgICAgICAgY2g7XG4gICAgdmFyIGwgPSB0ZXh0Lmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNoID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAgICBjaCA9ICd4JyArIGNoLnRvU3RyaW5nKDE2KTtcbiAgICAgIH1cblxuICAgICAgb3V0ICs9ICcmIycgKyBjaCArICc7JztcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIC8qKlxuICAgKiBCbG9jayBMZXhlclxuICAgKi9cblxuXG4gIHZhciBMZXhlcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMZXhlcihvcHRpb25zKSB7XG4gICAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgICAgdGhpcy50b2tlbnMubGlua3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQyO1xuICAgICAgdGhpcy5vcHRpb25zLnRva2VuaXplciA9IHRoaXMub3B0aW9ucy50b2tlbml6ZXIgfHwgbmV3IFRva2VuaXplcl8xKCk7XG4gICAgICB0aGlzLnRva2VuaXplciA9IHRoaXMub3B0aW9ucy50b2tlbml6ZXI7XG4gICAgICB0aGlzLnRva2VuaXplci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIHJ1bGVzID0ge1xuICAgICAgICBibG9jazogYmxvY2skMS5ub3JtYWwsXG4gICAgICAgIGlubGluZTogaW5saW5lJDEubm9ybWFsXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgIHJ1bGVzLmJsb2NrID0gYmxvY2skMS5wZWRhbnRpYztcbiAgICAgICAgcnVsZXMuaW5saW5lID0gaW5saW5lJDEucGVkYW50aWM7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICAgICAgcnVsZXMuYmxvY2sgPSBibG9jayQxLmdmbTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJyZWFrcykge1xuICAgICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZSQxLmJyZWFrcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUkMS5nZm07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy50b2tlbml6ZXIucnVsZXMgPSBydWxlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwb3NlIFJ1bGVzXG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBMZXggTWV0aG9kXG4gICAgICovXG4gICAgTGV4ZXIubGV4ID0gZnVuY3Rpb24gbGV4KHNyYywgb3B0aW9ucykge1xuICAgICAgdmFyIGxleGVyID0gbmV3IExleGVyKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGxleGVyLmxleChzcmMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgTGV4IElubGluZSBNZXRob2RcbiAgICAgKi9cbiAgICA7XG5cbiAgICBMZXhlci5sZXhJbmxpbmUgPSBmdW5jdGlvbiBsZXhJbmxpbmUoc3JjLCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGV4ZXIgPSBuZXcgTGV4ZXIob3B0aW9ucyk7XG4gICAgICByZXR1cm4gbGV4ZXIuaW5saW5lVG9rZW5zKHNyYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXByb2Nlc3NpbmdcbiAgICAgKi9cbiAgICA7XG5cbiAgICB2YXIgX3Byb3RvID0gTGV4ZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmxleCA9IGZ1bmN0aW9uIGxleChzcmMpIHtcbiAgICAgIHNyYyA9IHNyYy5yZXBsYWNlKC9cXHJcXG58XFxyL2csICdcXG4nKS5yZXBsYWNlKC9cXHQvZywgJyAgICAnKTtcbiAgICAgIHRoaXMuYmxvY2tUb2tlbnMoc3JjLCB0aGlzLnRva2VucywgdHJ1ZSk7XG4gICAgICB0aGlzLmlubGluZSh0aGlzLnRva2Vucyk7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExleGluZ1xuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5ibG9ja1Rva2VucyA9IGZ1bmN0aW9uIGJsb2NrVG9rZW5zKHNyYywgdG9rZW5zLCB0b3ApIHtcbiAgICAgIGlmICh0b2tlbnMgPT09IHZvaWQgMCkge1xuICAgICAgICB0b2tlbnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRvcCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRvcCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHNyYyA9IHNyYy5yZXBsYWNlKC9eICskL2dtLCAnJyk7XG4gICAgICB2YXIgdG9rZW4sIGksIGwsIGxhc3RUb2tlbjtcblxuICAgICAgd2hpbGUgKHNyYykge1xuICAgICAgICAvLyBuZXdsaW5lXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnNwYWNlKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuXG4gICAgICAgICAgaWYgKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBjb2RlXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5jb2RlKHNyYywgdG9rZW5zKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG5cbiAgICAgICAgICBpZiAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9ICdcXG4nICsgdG9rZW4udGV4dDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBmZW5jZXNcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmZlbmNlcyhzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gaGVhZGluZ1xuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaGVhZGluZyhzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gdGFibGUgbm8gbGVhZGluZyBwaXBlIChnZm0pXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5ucHRhYmxlKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBoclxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaHIoc3JjKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGJsb2NrcXVvdGVcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmJsb2NrcXVvdGUoc3JjKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW4udG9rZW5zID0gdGhpcy5ibG9ja1Rva2Vucyh0b2tlbi50ZXh0LCBbXSwgdG9wKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gbGlzdFxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGlzdChzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICBsID0gdG9rZW4uaXRlbXMubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdG9rZW4uaXRlbXNbaV0udG9rZW5zID0gdGhpcy5ibG9ja1Rva2Vucyh0b2tlbi5pdGVtc1tpXS50ZXh0LCBbXSwgZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBodG1sXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5odG1sKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBkZWZcblxuXG4gICAgICAgIGlmICh0b3AgJiYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZGVmKHNyYykpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcblxuICAgICAgICAgIGlmICghdGhpcy50b2tlbnMubGlua3NbdG9rZW4udGFnXSkge1xuICAgICAgICAgICAgdGhpcy50b2tlbnMubGlua3NbdG9rZW4udGFnXSA9IHtcbiAgICAgICAgICAgICAgaHJlZjogdG9rZW4uaHJlZixcbiAgICAgICAgICAgICAgdGl0bGU6IHRva2VuLnRpdGxlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIHRhYmxlIChnZm0pXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci50YWJsZShzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gbGhlYWRpbmdcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmxoZWFkaW5nKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyB0b3AtbGV2ZWwgcGFyYWdyYXBoXG5cblxuICAgICAgICBpZiAodG9wICYmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnBhcmFncmFwaChzcmMpKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIHRleHRcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRleHQoc3JjLCB0b2tlbnMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcblxuICAgICAgICAgIGlmICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgIHZhciBlcnJNc2cgPSAnSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH07XG5cbiAgICBfcHJvdG8uaW5saW5lID0gZnVuY3Rpb24gaW5saW5lKHRva2Vucykge1xuICAgICAgdmFyIGksIGosIGssIGwyLCByb3csIHRva2VuO1xuICAgICAgdmFyIGwgPSB0b2tlbnMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3BhcmFncmFwaCc6XG4gICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgY2FzZSAnaGVhZGluZyc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRva2VuLnRva2VucyA9IFtdO1xuICAgICAgICAgICAgICB0aGlzLmlubGluZVRva2Vucyh0b2tlbi50ZXh0LCB0b2tlbi50b2tlbnMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdG9rZW4udG9rZW5zID0ge1xuICAgICAgICAgICAgICAgIGhlYWRlcjogW10sXG4gICAgICAgICAgICAgICAgY2VsbHM6IFtdXG4gICAgICAgICAgICAgIH07IC8vIGhlYWRlclxuXG4gICAgICAgICAgICAgIGwyID0gdG9rZW4uaGVhZGVyLmxlbmd0aDtcblxuICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDI7IGorKykge1xuICAgICAgICAgICAgICAgIHRva2VuLnRva2Vucy5oZWFkZXJbal0gPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmlubGluZVRva2Vucyh0b2tlbi5oZWFkZXJbal0sIHRva2VuLnRva2Vucy5oZWFkZXJbal0pO1xuICAgICAgICAgICAgICB9IC8vIGNlbGxzXG5cblxuICAgICAgICAgICAgICBsMiA9IHRva2VuLmNlbGxzLmxlbmd0aDtcblxuICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDI7IGorKykge1xuICAgICAgICAgICAgICAgIHJvdyA9IHRva2VuLmNlbGxzW2pdO1xuICAgICAgICAgICAgICAgIHRva2VuLnRva2Vucy5jZWxsc1tqXSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IHJvdy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgdG9rZW4udG9rZW5zLmNlbGxzW2pdW2tdID0gW107XG4gICAgICAgICAgICAgICAgICB0aGlzLmlubGluZVRva2Vucyhyb3dba10sIHRva2VuLnRva2Vucy5jZWxsc1tqXVtrXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdibG9ja3F1b3RlJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhpcy5pbmxpbmUodG9rZW4udG9rZW5zKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdsaXN0JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbDIgPSB0b2tlbi5pdGVtcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGwyOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlubGluZSh0b2tlbi5pdGVtc1tqXS50b2tlbnMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGV4aW5nL0NvbXBpbGluZ1xuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5pbmxpbmVUb2tlbnMgPSBmdW5jdGlvbiBpbmxpbmVUb2tlbnMoc3JjLCB0b2tlbnMsIGluTGluaywgaW5SYXdCbG9jaywgcHJldkNoYXIpIHtcbiAgICAgIGlmICh0b2tlbnMgPT09IHZvaWQgMCkge1xuICAgICAgICB0b2tlbnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluTGluayA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGluTGluayA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5SYXdCbG9jayA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGluUmF3QmxvY2sgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByZXZDaGFyID09PSB2b2lkIDApIHtcbiAgICAgICAgcHJldkNoYXIgPSAnJztcbiAgICAgIH1cblxuICAgICAgdmFyIHRva2VuOyAvLyBTdHJpbmcgd2l0aCBsaW5rcyBtYXNrZWQgdG8gYXZvaWQgaW50ZXJmZXJlbmNlIHdpdGggZW0gYW5kIHN0cm9uZ1xuXG4gICAgICB2YXIgbWFza2VkU3JjID0gc3JjO1xuICAgICAgdmFyIG1hdGNoOyAvLyBNYXNrIG91dCByZWZsaW5rc1xuXG4gICAgICBpZiAodGhpcy50b2tlbnMubGlua3MpIHtcbiAgICAgICAgdmFyIGxpbmtzID0gT2JqZWN0LmtleXModGhpcy50b2tlbnMubGlua3MpO1xuXG4gICAgICAgIGlmIChsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5yZWZsaW5rU2VhcmNoLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGxpbmtzLmluY2x1ZGVzKG1hdGNoWzBdLnNsaWNlKG1hdGNoWzBdLmxhc3RJbmRleE9mKCdbJykgKyAxLCAtMSkpKSB7XG4gICAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnWycgKyAnYScucmVwZWF0KG1hdGNoWzBdLmxlbmd0aCAtIDIpICsgJ10nICsgbWFza2VkU3JjLnNsaWNlKHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5yZWZsaW5rU2VhcmNoLmxhc3RJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIE1hc2sgb3V0IG90aGVyIGJsb2Nrc1xuXG5cbiAgICAgIHdoaWxlICgobWF0Y2ggPSB0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYmxvY2tTa2lwLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgJ1snICsgJ2EnLnJlcGVhdChtYXRjaFswXS5sZW5ndGggLSAyKSArICddJyArIG1hc2tlZFNyYy5zbGljZSh0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYmxvY2tTa2lwLmxhc3RJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgLy8gZXNjYXBlXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmVzY2FwZShzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gdGFnXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci50YWcoc3JjLCBpbkxpbmssIGluUmF3QmxvY2spKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICBpbkxpbmsgPSB0b2tlbi5pbkxpbms7XG4gICAgICAgICAgaW5SYXdCbG9jayA9IHRva2VuLmluUmF3QmxvY2s7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGxpbmtcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmxpbmsoc3JjKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG5cbiAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2xpbmsnKSB7XG4gICAgICAgICAgICB0b2tlbi50b2tlbnMgPSB0aGlzLmlubGluZVRva2Vucyh0b2tlbi50ZXh0LCBbXSwgdHJ1ZSwgaW5SYXdCbG9jayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIHJlZmxpbmssIG5vbGlua1xuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIucmVmbGluayhzcmMsIHRoaXMudG9rZW5zLmxpbmtzKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG5cbiAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2xpbmsnKSB7XG4gICAgICAgICAgICB0b2tlbi50b2tlbnMgPSB0aGlzLmlubGluZVRva2Vucyh0b2tlbi50ZXh0LCBbXSwgdHJ1ZSwgaW5SYXdCbG9jayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIHN0cm9uZ1xuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuc3Ryb25nKHNyYywgbWFza2VkU3JjLCBwcmV2Q2hhcikpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2VuLnRva2VucyA9IHRoaXMuaW5saW5lVG9rZW5zKHRva2VuLnRleHQsIFtdLCBpbkxpbmssIGluUmF3QmxvY2spO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBlbVxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZW0oc3JjLCBtYXNrZWRTcmMsIHByZXZDaGFyKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW4udG9rZW5zID0gdGhpcy5pbmxpbmVUb2tlbnModG9rZW4udGV4dCwgW10sIGluTGluaywgaW5SYXdCbG9jayk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGNvZGVcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmNvZGVzcGFuKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBiclxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuYnIoc3JjKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGRlbCAoZ2ZtKVxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZGVsKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2VuLnRva2VucyA9IHRoaXMuaW5saW5lVG9rZW5zKHRva2VuLnRleHQsIFtdLCBpbkxpbmssIGluUmF3QmxvY2spO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBhdXRvbGlua1xuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuYXV0b2xpbmsoc3JjLCBtYW5nbGUpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gdXJsIChnZm0pXG5cblxuICAgICAgICBpZiAoIWluTGluayAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci51cmwoc3JjLCBtYW5nbGUpKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIHRleHRcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmlubGluZVRleHQoc3JjLCBpblJhd0Jsb2NrLCBzbWFydHlwYW50cykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHByZXZDaGFyID0gdG9rZW4ucmF3LnNsaWNlKC0xKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgdmFyIGVyck1zZyA9ICdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKTtcblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfTtcblxuICAgIF9jcmVhdGVDbGFzcyhMZXhlciwgbnVsbCwgW3tcbiAgICAgIGtleTogXCJydWxlc1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYmxvY2s6IGJsb2NrJDEsXG4gICAgICAgICAgaW5saW5lOiBpbmxpbmUkMVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBMZXhlcjtcbiAgfSgpO1xuXG4gIHZhciBkZWZhdWx0cyQzID0gZGVmYXVsdHMuZGVmYXVsdHM7XG4gIHZhciBjbGVhblVybCQxID0gaGVscGVycy5jbGVhblVybCxcbiAgICAgIGVzY2FwZSQxID0gaGVscGVycy5lc2NhcGU7XG4gIC8qKlxuICAgKiBSZW5kZXJlclxuICAgKi9cblxuICB2YXIgUmVuZGVyZXJfMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVuZGVyZXIob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQzO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBSZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uY29kZSA9IGZ1bmN0aW9uIGNvZGUoX2NvZGUsIGluZm9zdHJpbmcsIGVzY2FwZWQpIHtcbiAgICAgIHZhciBsYW5nID0gKGluZm9zdHJpbmcgfHwgJycpLm1hdGNoKC9cXFMqLylbMF07XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgICAgIHZhciBvdXQgPSB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KF9jb2RlLCBsYW5nKTtcblxuICAgICAgICBpZiAob3V0ICE9IG51bGwgJiYgb3V0ICE9PSBfY29kZSkge1xuICAgICAgICAgIGVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgIF9jb2RlID0gb3V0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghbGFuZykge1xuICAgICAgICByZXR1cm4gJzxwcmU+PGNvZGU+JyArIChlc2NhcGVkID8gX2NvZGUgOiBlc2NhcGUkMShfY29kZSwgdHJ1ZSkpICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJzxwcmU+PGNvZGUgY2xhc3M9XCInICsgdGhpcy5vcHRpb25zLmxhbmdQcmVmaXggKyBlc2NhcGUkMShsYW5nLCB0cnVlKSArICdcIj4nICsgKGVzY2FwZWQgPyBfY29kZSA6IGVzY2FwZSQxKF9jb2RlLCB0cnVlKSkgKyAnPC9jb2RlPjwvcHJlPlxcbic7XG4gICAgfTtcblxuICAgIF9wcm90by5ibG9ja3F1b3RlID0gZnVuY3Rpb24gYmxvY2txdW90ZShxdW90ZSkge1xuICAgICAgcmV0dXJuICc8YmxvY2txdW90ZT5cXG4nICsgcXVvdGUgKyAnPC9ibG9ja3F1b3RlPlxcbic7XG4gICAgfTtcblxuICAgIF9wcm90by5odG1sID0gZnVuY3Rpb24gaHRtbChfaHRtbCkge1xuICAgICAgcmV0dXJuIF9odG1sO1xuICAgIH07XG5cbiAgICBfcHJvdG8uaGVhZGluZyA9IGZ1bmN0aW9uIGhlYWRpbmcodGV4dCwgbGV2ZWwsIHJhdywgc2x1Z2dlcikge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oZWFkZXJJZHMpIHtcbiAgICAgICAgcmV0dXJuICc8aCcgKyBsZXZlbCArICcgaWQ9XCInICsgdGhpcy5vcHRpb25zLmhlYWRlclByZWZpeCArIHNsdWdnZXIuc2x1ZyhyYXcpICsgJ1wiPicgKyB0ZXh0ICsgJzwvaCcgKyBsZXZlbCArICc+XFxuJztcbiAgICAgIH0gLy8gaWdub3JlIElEc1xuXG5cbiAgICAgIHJldHVybiAnPGgnICsgbGV2ZWwgKyAnPicgKyB0ZXh0ICsgJzwvaCcgKyBsZXZlbCArICc+XFxuJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmhyID0gZnVuY3Rpb24gaHIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnhodG1sID8gJzxoci8+XFxuJyA6ICc8aHI+XFxuJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmxpc3QgPSBmdW5jdGlvbiBsaXN0KGJvZHksIG9yZGVyZWQsIHN0YXJ0KSB7XG4gICAgICB2YXIgdHlwZSA9IG9yZGVyZWQgPyAnb2wnIDogJ3VsJyxcbiAgICAgICAgICBzdGFydGF0dCA9IG9yZGVyZWQgJiYgc3RhcnQgIT09IDEgPyAnIHN0YXJ0PVwiJyArIHN0YXJ0ICsgJ1wiJyA6ICcnO1xuICAgICAgcmV0dXJuICc8JyArIHR5cGUgKyBzdGFydGF0dCArICc+XFxuJyArIGJvZHkgKyAnPC8nICsgdHlwZSArICc+XFxuJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmxpc3RpdGVtID0gZnVuY3Rpb24gbGlzdGl0ZW0odGV4dCkge1xuICAgICAgcmV0dXJuICc8bGk+JyArIHRleHQgKyAnPC9saT5cXG4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8uY2hlY2tib3ggPSBmdW5jdGlvbiBjaGVja2JveChjaGVja2VkKSB7XG4gICAgICByZXR1cm4gJzxpbnB1dCAnICsgKGNoZWNrZWQgPyAnY2hlY2tlZD1cIlwiICcgOiAnJykgKyAnZGlzYWJsZWQ9XCJcIiB0eXBlPVwiY2hlY2tib3hcIicgKyAodGhpcy5vcHRpb25zLnhodG1sID8gJyAvJyA6ICcnKSArICc+ICc7XG4gICAgfTtcblxuICAgIF9wcm90by5wYXJhZ3JhcGggPSBmdW5jdGlvbiBwYXJhZ3JhcGgodGV4dCkge1xuICAgICAgcmV0dXJuICc8cD4nICsgdGV4dCArICc8L3A+XFxuJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLnRhYmxlID0gZnVuY3Rpb24gdGFibGUoaGVhZGVyLCBib2R5KSB7XG4gICAgICBpZiAoYm9keSkgYm9keSA9ICc8dGJvZHk+JyArIGJvZHkgKyAnPC90Ym9keT4nO1xuICAgICAgcmV0dXJuICc8dGFibGU+XFxuJyArICc8dGhlYWQ+XFxuJyArIGhlYWRlciArICc8L3RoZWFkPlxcbicgKyBib2R5ICsgJzwvdGFibGU+XFxuJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLnRhYmxlcm93ID0gZnVuY3Rpb24gdGFibGVyb3coY29udGVudCkge1xuICAgICAgcmV0dXJuICc8dHI+XFxuJyArIGNvbnRlbnQgKyAnPC90cj5cXG4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8udGFibGVjZWxsID0gZnVuY3Rpb24gdGFibGVjZWxsKGNvbnRlbnQsIGZsYWdzKSB7XG4gICAgICB2YXIgdHlwZSA9IGZsYWdzLmhlYWRlciA/ICd0aCcgOiAndGQnO1xuICAgICAgdmFyIHRhZyA9IGZsYWdzLmFsaWduID8gJzwnICsgdHlwZSArICcgYWxpZ249XCInICsgZmxhZ3MuYWxpZ24gKyAnXCI+JyA6ICc8JyArIHR5cGUgKyAnPic7XG4gICAgICByZXR1cm4gdGFnICsgY29udGVudCArICc8LycgKyB0eXBlICsgJz5cXG4nO1xuICAgIH0gLy8gc3BhbiBsZXZlbCByZW5kZXJlclxuICAgIDtcblxuICAgIF9wcm90by5zdHJvbmcgPSBmdW5jdGlvbiBzdHJvbmcodGV4dCkge1xuICAgICAgcmV0dXJuICc8c3Ryb25nPicgKyB0ZXh0ICsgJzwvc3Ryb25nPic7XG4gICAgfTtcblxuICAgIF9wcm90by5lbSA9IGZ1bmN0aW9uIGVtKHRleHQpIHtcbiAgICAgIHJldHVybiAnPGVtPicgKyB0ZXh0ICsgJzwvZW0+JztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmNvZGVzcGFuID0gZnVuY3Rpb24gY29kZXNwYW4odGV4dCkge1xuICAgICAgcmV0dXJuICc8Y29kZT4nICsgdGV4dCArICc8L2NvZGU+JztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmJyID0gZnVuY3Rpb24gYnIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnhodG1sID8gJzxici8+JyA6ICc8YnI+JztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmRlbCA9IGZ1bmN0aW9uIGRlbCh0ZXh0KSB7XG4gICAgICByZXR1cm4gJzxkZWw+JyArIHRleHQgKyAnPC9kZWw+JztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmxpbmsgPSBmdW5jdGlvbiBsaW5rKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gICAgICBocmVmID0gY2xlYW5VcmwkMSh0aGlzLm9wdGlvbnMuc2FuaXRpemUsIHRoaXMub3B0aW9ucy5iYXNlVXJsLCBocmVmKTtcblxuICAgICAgaWYgKGhyZWYgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXQgPSAnPGEgaHJlZj1cIicgKyBlc2NhcGUkMShocmVmKSArICdcIic7XG5cbiAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICBvdXQgKz0gJyB0aXRsZT1cIicgKyB0aXRsZSArICdcIic7XG4gICAgICB9XG5cbiAgICAgIG91dCArPSAnPicgKyB0ZXh0ICsgJzwvYT4nO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmltYWdlID0gZnVuY3Rpb24gaW1hZ2UoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgIGhyZWYgPSBjbGVhblVybCQxKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSwgdGhpcy5vcHRpb25zLmJhc2VVcmwsIGhyZWYpO1xuXG4gICAgICBpZiAoaHJlZiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dCA9ICc8aW1nIHNyYz1cIicgKyBocmVmICsgJ1wiIGFsdD1cIicgKyB0ZXh0ICsgJ1wiJztcblxuICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgIG91dCArPSAnIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiJztcbiAgICAgIH1cblxuICAgICAgb3V0ICs9IHRoaXMub3B0aW9ucy54aHRtbCA/ICcvPicgOiAnPic7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH07XG5cbiAgICBfcHJvdG8udGV4dCA9IGZ1bmN0aW9uIHRleHQoX3RleHQpIHtcbiAgICAgIHJldHVybiBfdGV4dDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJlbmRlcmVyO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIFRleHRSZW5kZXJlclxuICAgKiByZXR1cm5zIG9ubHkgdGhlIHRleHR1YWwgcGFydCBvZiB0aGUgdG9rZW5cbiAgICovXG4gIHZhciBUZXh0UmVuZGVyZXJfMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGV4dFJlbmRlcmVyKCkge31cblxuICAgIHZhciBfcHJvdG8gPSBUZXh0UmVuZGVyZXIucHJvdG90eXBlO1xuXG4gICAgLy8gbm8gbmVlZCBmb3IgYmxvY2sgbGV2ZWwgcmVuZGVyZXJzXG4gICAgX3Byb3RvLnN0cm9uZyA9IGZ1bmN0aW9uIHN0cm9uZyh0ZXh0KSB7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmVtID0gZnVuY3Rpb24gZW0odGV4dCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by5jb2Rlc3BhbiA9IGZ1bmN0aW9uIGNvZGVzcGFuKHRleHQpIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG5cbiAgICBfcHJvdG8uZGVsID0gZnVuY3Rpb24gZGVsKHRleHQpIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG5cbiAgICBfcHJvdG8uaHRtbCA9IGZ1bmN0aW9uIGh0bWwodGV4dCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by50ZXh0ID0gZnVuY3Rpb24gdGV4dChfdGV4dCkge1xuICAgICAgcmV0dXJuIF90ZXh0O1xuICAgIH07XG5cbiAgICBfcHJvdG8ubGluayA9IGZ1bmN0aW9uIGxpbmsoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgIHJldHVybiAnJyArIHRleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by5pbWFnZSA9IGZ1bmN0aW9uIGltYWdlKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gICAgICByZXR1cm4gJycgKyB0ZXh0O1xuICAgIH07XG5cbiAgICBfcHJvdG8uYnIgPSBmdW5jdGlvbiBicigpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRleHRSZW5kZXJlcjtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBTbHVnZ2VyIGdlbmVyYXRlcyBoZWFkZXIgaWRcbiAgICovXG4gIHZhciBTbHVnZ2VyXzEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNsdWdnZXIoKSB7XG4gICAgICB0aGlzLnNlZW4gPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvID0gU2x1Z2dlci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCkgLy8gcmVtb3ZlIGh0bWwgdGFnc1xuICAgICAgLnJlcGxhY2UoLzxbIVxcL2Etel0uKj8+L2lnLCAnJykgLy8gcmVtb3ZlIHVud2FudGVkIGNoYXJzXG4gICAgICAucmVwbGFjZSgvW1xcdTIwMDAtXFx1MjA2RlxcdTJFMDAtXFx1MkU3RlxcXFwnIVwiIyQlJigpKissLi86Ozw9Pj9AW1xcXV5ge3x9fl0vZywgJycpLnJlcGxhY2UoL1xccy9nLCAnLScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbmV4dCBzYWZlICh1bmlxdWUpIHNsdWcgdG8gdXNlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmdldE5leHRTYWZlU2x1ZyA9IGZ1bmN0aW9uIGdldE5leHRTYWZlU2x1ZyhvcmlnaW5hbFNsdWcsIGlzRHJ5UnVuKSB7XG4gICAgICB2YXIgc2x1ZyA9IG9yaWdpbmFsU2x1ZztcbiAgICAgIHZhciBvY2N1cmVuY2VBY2N1bXVsYXRvciA9IDA7XG5cbiAgICAgIGlmICh0aGlzLnNlZW4uaGFzT3duUHJvcGVydHkoc2x1ZykpIHtcbiAgICAgICAgb2NjdXJlbmNlQWNjdW11bGF0b3IgPSB0aGlzLnNlZW5bb3JpZ2luYWxTbHVnXTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgb2NjdXJlbmNlQWNjdW11bGF0b3IrKztcbiAgICAgICAgICBzbHVnID0gb3JpZ2luYWxTbHVnICsgJy0nICsgb2NjdXJlbmNlQWNjdW11bGF0b3I7XG4gICAgICAgIH0gd2hpbGUgKHRoaXMuc2Vlbi5oYXNPd25Qcm9wZXJ0eShzbHVnKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNEcnlSdW4pIHtcbiAgICAgICAgdGhpcy5zZWVuW29yaWdpbmFsU2x1Z10gPSBvY2N1cmVuY2VBY2N1bXVsYXRvcjtcbiAgICAgICAgdGhpcy5zZWVuW3NsdWddID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNsdWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgc3RyaW5nIHRvIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmRyeXJ1biBHZW5lcmF0ZXMgdGhlIG5leHQgdW5pcXVlIHNsdWcgd2l0aG91dCB1cGRhdGluZyB0aGUgaW50ZXJuYWwgYWNjdW11bGF0b3IuXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnNsdWcgPSBmdW5jdGlvbiBzbHVnKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNsdWcgPSB0aGlzLnNlcmlhbGl6ZSh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcy5nZXROZXh0U2FmZVNsdWcoc2x1Zywgb3B0aW9ucy5kcnlydW4pO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2x1Z2dlcjtcbiAgfSgpO1xuXG4gIHZhciBkZWZhdWx0cyQ0ID0gZGVmYXVsdHMuZGVmYXVsdHM7XG4gIHZhciB1bmVzY2FwZSQxID0gaGVscGVycy51bmVzY2FwZTtcbiAgLyoqXG4gICAqIFBhcnNpbmcgJiBDb21waWxpbmdcbiAgICovXG5cbiAgdmFyIFBhcnNlcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJzZXIob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQ0O1xuICAgICAgdGhpcy5vcHRpb25zLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IG5ldyBSZW5kZXJlcl8xKCk7XG4gICAgICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyO1xuICAgICAgdGhpcy5yZW5kZXJlci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdGhpcy50ZXh0UmVuZGVyZXIgPSBuZXcgVGV4dFJlbmRlcmVyXzEoKTtcbiAgICAgIHRoaXMuc2x1Z2dlciA9IG5ldyBTbHVnZ2VyXzEoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIFBhcnNlIE1ldGhvZFxuICAgICAqL1xuXG5cbiAgICBQYXJzZXIucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSh0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZSh0b2tlbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgUGFyc2UgSW5saW5lIE1ldGhvZFxuICAgICAqL1xuICAgIDtcblxuICAgIFBhcnNlci5wYXJzZUlubGluZSA9IGZ1bmN0aW9uIHBhcnNlSW5saW5lKHRva2Vucywgb3B0aW9ucykge1xuICAgICAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gICAgICByZXR1cm4gcGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIExvb3BcbiAgICAgKi9cbiAgICA7XG5cbiAgICB2YXIgX3Byb3RvID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRva2VucywgdG9wKSB7XG4gICAgICBpZiAodG9wID09PSB2b2lkIDApIHtcbiAgICAgICAgdG9wID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dCA9ICcnLFxuICAgICAgICAgIGksXG4gICAgICAgICAgaixcbiAgICAgICAgICBrLFxuICAgICAgICAgIGwyLFxuICAgICAgICAgIGwzLFxuICAgICAgICAgIHJvdyxcbiAgICAgICAgICBjZWxsLFxuICAgICAgICAgIGhlYWRlcixcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIHRva2VuLFxuICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgbG9vc2UsXG4gICAgICAgICAgaXRlbUJvZHksXG4gICAgICAgICAgaXRlbSxcbiAgICAgICAgICBjaGVja2VkLFxuICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgY2hlY2tib3g7XG4gICAgICB2YXIgbCA9IHRva2Vucy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2hyJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaHIoKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdoZWFkaW5nJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaGVhZGluZyh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucyksIHRva2VuLmRlcHRoLCB1bmVzY2FwZSQxKHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zLCB0aGlzLnRleHRSZW5kZXJlcikpLCB0aGlzLnNsdWdnZXIpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2NvZGUnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5jb2RlKHRva2VuLnRleHQsIHRva2VuLmxhbmcsIHRva2VuLmVzY2FwZWQpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaGVhZGVyID0gJyc7IC8vIGhlYWRlclxuXG4gICAgICAgICAgICAgIGNlbGwgPSAnJztcbiAgICAgICAgICAgICAgbDIgPSB0b2tlbi5oZWFkZXIubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgY2VsbCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlY2VsbCh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2Vucy5oZWFkZXJbal0pLCB7XG4gICAgICAgICAgICAgICAgICBoZWFkZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgICBhbGlnbjogdG9rZW4uYWxpZ25bal1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGhlYWRlciArPSB0aGlzLnJlbmRlcmVyLnRhYmxlcm93KGNlbGwpO1xuICAgICAgICAgICAgICBib2R5ID0gJyc7XG4gICAgICAgICAgICAgIGwyID0gdG9rZW4uY2VsbHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgcm93ID0gdG9rZW4udG9rZW5zLmNlbGxzW2pdO1xuICAgICAgICAgICAgICAgIGNlbGwgPSAnJztcbiAgICAgICAgICAgICAgICBsMyA9IHJvdy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbDM7IGsrKykge1xuICAgICAgICAgICAgICAgICAgY2VsbCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlY2VsbCh0aGlzLnBhcnNlSW5saW5lKHJvd1trXSksIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYWxpZ246IHRva2VuLmFsaWduW2tdXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBib2R5ICs9IHRoaXMucmVuZGVyZXIudGFibGVyb3coY2VsbCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci50YWJsZShoZWFkZXIsIGJvZHkpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBib2R5ID0gdGhpcy5wYXJzZSh0b2tlbi50b2tlbnMpO1xuICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5ibG9ja3F1b3RlKGJvZHkpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvcmRlcmVkID0gdG9rZW4ub3JkZXJlZDtcbiAgICAgICAgICAgICAgc3RhcnQgPSB0b2tlbi5zdGFydDtcbiAgICAgICAgICAgICAgbG9vc2UgPSB0b2tlbi5sb29zZTtcbiAgICAgICAgICAgICAgbDIgPSB0b2tlbi5pdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICAgIGJvZHkgPSAnJztcblxuICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDI7IGorKykge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSB0b2tlbi5pdGVtc1tqXTtcbiAgICAgICAgICAgICAgICBjaGVja2VkID0gaXRlbS5jaGVja2VkO1xuICAgICAgICAgICAgICAgIHRhc2sgPSBpdGVtLnRhc2s7XG4gICAgICAgICAgICAgICAgaXRlbUJvZHkgPSAnJztcblxuICAgICAgICAgICAgICAgIGlmIChpdGVtLnRhc2spIHtcbiAgICAgICAgICAgICAgICAgIGNoZWNrYm94ID0gdGhpcy5yZW5kZXJlci5jaGVja2JveChjaGVja2VkKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGxvb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRva2Vucy5sZW5ndGggPiAwICYmIGl0ZW0udG9rZW5zWzBdLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zWzBdLnRleHQgPSBjaGVja2JveCArICcgJyArIGl0ZW0udG9rZW5zWzBdLnRleHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50b2tlbnNbMF0udG9rZW5zICYmIGl0ZW0udG9rZW5zWzBdLnRva2Vucy5sZW5ndGggPiAwICYmIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50ZXh0ID0gY2hlY2tib3ggKyAnICcgKyBpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgaXRlbS50b2tlbnMudW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjaGVja2JveFxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVtQm9keSArPSBjaGVja2JveDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpdGVtQm9keSArPSB0aGlzLnBhcnNlKGl0ZW0udG9rZW5zLCBsb29zZSk7XG4gICAgICAgICAgICAgICAgYm9keSArPSB0aGlzLnJlbmRlcmVyLmxpc3RpdGVtKGl0ZW1Cb2R5LCB0YXNrLCBjaGVja2VkKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmxpc3QoYm9keSwgb3JkZXJlZCwgc3RhcnQpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyBUT0RPIHBhcnNlIGlubGluZSBjb250ZW50IGlmIHBhcmFtZXRlciBtYXJrZG93bj0xXG4gICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmh0bWwodG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAncGFyYWdyYXBoJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zKSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGJvZHkgPSB0b2tlbi50b2tlbnMgPyB0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucykgOiB0b2tlbi50ZXh0O1xuXG4gICAgICAgICAgICAgIHdoaWxlIChpICsgMSA8IGwgJiYgdG9rZW5zW2kgKyAxXS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1srK2ldO1xuICAgICAgICAgICAgICAgIGJvZHkgKz0gJ1xcbicgKyAodG9rZW4udG9rZW5zID8gdGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMpIDogdG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvdXQgKz0gdG9wID8gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgoYm9keSkgOiBib2R5O1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBlcnJNc2cgPSAnVG9rZW4gd2l0aCBcIicgKyB0b2tlbi50eXBlICsgJ1wiIHR5cGUgd2FzIG5vdCBmb3VuZC4nO1xuXG4gICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIElubGluZSBUb2tlbnNcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8ucGFyc2VJbmxpbmUgPSBmdW5jdGlvbiBwYXJzZUlubGluZSh0b2tlbnMsIHJlbmRlcmVyKSB7XG4gICAgICByZW5kZXJlciA9IHJlbmRlcmVyIHx8IHRoaXMucmVuZGVyZXI7XG4gICAgICB2YXIgb3V0ID0gJycsXG4gICAgICAgICAgaSxcbiAgICAgICAgICB0b2tlbjtcbiAgICAgIHZhciBsID0gdG9rZW5zLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdlc2NhcGUnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIudGV4dCh0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmh0bWwodG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnbGluayc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5saW5rKHRva2VuLmhyZWYsIHRva2VuLnRpdGxlLCB0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5pbWFnZSh0b2tlbi5ocmVmLCB0b2tlbi50aXRsZSwgdG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnc3Ryb25nJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLnN0cm9uZyh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdlbSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5lbSh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdjb2Rlc3Bhbic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5jb2Rlc3Bhbih0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdicic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5icigpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2RlbCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5kZWwodGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMsIHJlbmRlcmVyKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci50ZXh0KHRva2VuLnRleHQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBlcnJNc2cgPSAnVG9rZW4gd2l0aCBcIicgKyB0b2tlbi50eXBlICsgJ1wiIHR5cGUgd2FzIG5vdCBmb3VuZC4nO1xuXG4gICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcblxuICAgIHJldHVybiBQYXJzZXI7XG4gIH0oKTtcblxuICB2YXIgbWVyZ2UkMiA9IGhlbHBlcnMubWVyZ2UsXG4gICAgICBjaGVja1Nhbml0aXplRGVwcmVjYXRpb24kMSA9IGhlbHBlcnMuY2hlY2tTYW5pdGl6ZURlcHJlY2F0aW9uLFxuICAgICAgZXNjYXBlJDIgPSBoZWxwZXJzLmVzY2FwZTtcbiAgdmFyIGdldERlZmF1bHRzID0gZGVmYXVsdHMuZ2V0RGVmYXVsdHMsXG4gICAgICBjaGFuZ2VEZWZhdWx0cyA9IGRlZmF1bHRzLmNoYW5nZURlZmF1bHRzLFxuICAgICAgZGVmYXVsdHMkNSA9IGRlZmF1bHRzLmRlZmF1bHRzO1xuICAvKipcbiAgICogTWFya2VkXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG1hcmtlZChzcmMsIG9wdCwgY2FsbGJhY2spIHtcbiAgICAvLyB0aHJvdyBlcnJvciBpbiBjYXNlIG9mIG5vbiBzdHJpbmcgaW5wdXRcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3VuZGVmaW5lZCcgfHwgc3JjID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcmtlZCgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkIG9yIG51bGwnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFya2VkKCk6IGlucHV0IHBhcmFtZXRlciBpcyBvZiB0eXBlICcgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3JjKSArICcsIHN0cmluZyBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdDtcbiAgICAgIG9wdCA9IG51bGw7XG4gICAgfVxuXG4gICAgb3B0ID0gbWVyZ2UkMih7fSwgbWFya2VkLmRlZmF1bHRzLCBvcHQgfHwge30pO1xuICAgIGNoZWNrU2FuaXRpemVEZXByZWNhdGlvbiQxKG9wdCk7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBoaWdobGlnaHQgPSBvcHQuaGlnaGxpZ2h0O1xuICAgICAgdmFyIHRva2VucztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdG9rZW5zID0gTGV4ZXJfMS5sZXgoc3JjLCBvcHQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkb25lID0gZnVuY3Rpb24gZG9uZShlcnIpIHtcbiAgICAgICAgdmFyIG91dDtcblxuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvdXQgPSBQYXJzZXJfMS5wYXJzZSh0b2tlbnMsIG9wdCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyID0gZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvcHQuaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0O1xuICAgICAgICByZXR1cm4gZXJyID8gY2FsbGJhY2soZXJyKSA6IGNhbGxiYWNrKG51bGwsIG91dCk7XG4gICAgICB9O1xuXG4gICAgICBpZiAoIWhpZ2hsaWdodCB8fCBoaWdobGlnaHQubGVuZ3RoIDwgMykge1xuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgb3B0LmhpZ2hsaWdodDtcbiAgICAgIGlmICghdG9rZW5zLmxlbmd0aCkgcmV0dXJuIGRvbmUoKTtcbiAgICAgIHZhciBwZW5kaW5nID0gMDtcbiAgICAgIG1hcmtlZC53YWxrVG9rZW5zKHRva2VucywgZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnY29kZScpIHtcbiAgICAgICAgICBwZW5kaW5nKys7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBoaWdobGlnaHQodG9rZW4udGV4dCwgdG9rZW4ubGFuZywgZnVuY3Rpb24gKGVyciwgY29kZSkge1xuICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChjb2RlICE9IG51bGwgJiYgY29kZSAhPT0gdG9rZW4udGV4dCkge1xuICAgICAgICAgICAgICAgIHRva2VuLnRleHQgPSBjb2RlO1xuICAgICAgICAgICAgICAgIHRva2VuLmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcGVuZGluZy0tO1xuXG4gICAgICAgICAgICAgIGlmIChwZW5kaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChwZW5kaW5nID09PSAwKSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB2YXIgX3Rva2VucyA9IExleGVyXzEubGV4KHNyYywgb3B0KTtcblxuICAgICAgaWYgKG9wdC53YWxrVG9rZW5zKSB7XG4gICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKF90b2tlbnMsIG9wdC53YWxrVG9rZW5zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFBhcnNlcl8xLnBhcnNlKF90b2tlbnMsIG9wdCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5tZXNzYWdlICs9ICdcXG5QbGVhc2UgcmVwb3J0IHRoaXMgdG8gaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZC4nO1xuXG4gICAgICBpZiAob3B0LnNpbGVudCkge1xuICAgICAgICByZXR1cm4gJzxwPkFuIGVycm9yIG9jY3VycmVkOjwvcD48cHJlPicgKyBlc2NhcGUkMihlLm1lc3NhZ2UgKyAnJywgdHJ1ZSkgKyAnPC9wcmU+JztcbiAgICAgIH1cblxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE9wdGlvbnNcbiAgICovXG5cblxuICBtYXJrZWQub3B0aW9ucyA9IG1hcmtlZC5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdCkge1xuICAgIG1lcmdlJDIobWFya2VkLmRlZmF1bHRzLCBvcHQpO1xuICAgIGNoYW5nZURlZmF1bHRzKG1hcmtlZC5kZWZhdWx0cyk7XG4gICAgcmV0dXJuIG1hcmtlZDtcbiAgfTtcblxuICBtYXJrZWQuZ2V0RGVmYXVsdHMgPSBnZXREZWZhdWx0cztcbiAgbWFya2VkLmRlZmF1bHRzID0gZGVmYXVsdHMkNTtcbiAgLyoqXG4gICAqIFVzZSBFeHRlbnNpb25cbiAgICovXG5cbiAgbWFya2VkLnVzZSA9IGZ1bmN0aW9uIChleHRlbnNpb24pIHtcbiAgICB2YXIgb3B0cyA9IG1lcmdlJDIoe30sIGV4dGVuc2lvbik7XG5cbiAgICBpZiAoZXh0ZW5zaW9uLnJlbmRlcmVyKSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSBtYXJrZWQuZGVmYXVsdHMucmVuZGVyZXIgfHwgbmV3IFJlbmRlcmVyXzEoKTtcblxuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChwcm9wKSB7XG4gICAgICAgICAgdmFyIHByZXZSZW5kZXJlciA9IHJlbmRlcmVyW3Byb3BdO1xuXG4gICAgICAgICAgcmVuZGVyZXJbcHJvcF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJldCA9IGV4dGVuc2lvbi5yZW5kZXJlcltwcm9wXS5hcHBseShyZW5kZXJlciwgYXJncyk7XG5cbiAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHJldCA9IHByZXZSZW5kZXJlci5hcHBseShyZW5kZXJlciwgYXJncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGV4dGVuc2lvbi5yZW5kZXJlcikge1xuICAgICAgICAgIF9sb29wKHByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0cy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgfSkoKTtcbiAgICB9XG5cbiAgICBpZiAoZXh0ZW5zaW9uLnRva2VuaXplcikge1xuICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRva2VuaXplciA9IG1hcmtlZC5kZWZhdWx0cy50b2tlbml6ZXIgfHwgbmV3IFRva2VuaXplcl8xKCk7XG5cbiAgICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihwcm9wKSB7XG4gICAgICAgICAgdmFyIHByZXZUb2tlbml6ZXIgPSB0b2tlbml6ZXJbcHJvcF07XG5cbiAgICAgICAgICB0b2tlbml6ZXJbcHJvcF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmV0ID0gZXh0ZW5zaW9uLnRva2VuaXplcltwcm9wXS5hcHBseSh0b2tlbml6ZXIsIGFyZ3MpO1xuXG4gICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXQgPSBwcmV2VG9rZW5pemVyLmFwcGx5KHRva2VuaXplciwgYXJncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGV4dGVuc2lvbi50b2tlbml6ZXIpIHtcbiAgICAgICAgICBfbG9vcDIocHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRzLnRva2VuaXplciA9IHRva2VuaXplcjtcbiAgICAgIH0pKCk7XG4gICAgfVxuXG4gICAgaWYgKGV4dGVuc2lvbi53YWxrVG9rZW5zKSB7XG4gICAgICB2YXIgd2Fsa1Rva2VucyA9IG1hcmtlZC5kZWZhdWx0cy53YWxrVG9rZW5zO1xuXG4gICAgICBvcHRzLndhbGtUb2tlbnMgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgZXh0ZW5zaW9uLndhbGtUb2tlbnModG9rZW4pO1xuXG4gICAgICAgIGlmICh3YWxrVG9rZW5zKSB7XG4gICAgICAgICAgd2Fsa1Rva2Vucyh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgbWFya2VkLnNldE9wdGlvbnMob3B0cyk7XG4gIH07XG4gIC8qKlxuICAgKiBSdW4gY2FsbGJhY2sgZm9yIGV2ZXJ5IHRva2VuXG4gICAqL1xuXG5cbiAgbWFya2VkLndhbGtUb2tlbnMgPSBmdW5jdGlvbiAodG9rZW5zLCBjYWxsYmFjaykge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodG9rZW5zKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICAgIHZhciB0b2tlbiA9IF9zdGVwLnZhbHVlO1xuICAgICAgY2FsbGJhY2sodG9rZW4pO1xuXG4gICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHRva2VuLnRva2Vucy5oZWFkZXIpLCBfc3RlcDI7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgY2VsbCA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICAgICAgbWFya2VkLndhbGtUb2tlbnMoY2VsbCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSh0b2tlbi50b2tlbnMuY2VsbHMpLCBfc3RlcDM7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMygpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgcm93ID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHJvdyksIF9zdGVwNDsgIShfc3RlcDQgPSBfaXRlcmF0b3I0KCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jZWxsID0gX3N0ZXA0LnZhbHVlO1xuICAgICAgICAgICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKF9jZWxsLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKHRva2VuLml0ZW1zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAodG9rZW4udG9rZW5zKSB7XG4gICAgICAgICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKHRva2VuLnRva2VucywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBQYXJzZSBJbmxpbmVcbiAgICovXG5cblxuICBtYXJrZWQucGFyc2VJbmxpbmUgPSBmdW5jdGlvbiAoc3JjLCBvcHQpIHtcbiAgICAvLyB0aHJvdyBlcnJvciBpbiBjYXNlIG9mIG5vbiBzdHJpbmcgaW5wdXRcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3VuZGVmaW5lZCcgfHwgc3JjID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcmtlZC5wYXJzZUlubGluZSgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkIG9yIG51bGwnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFya2VkLnBhcnNlSW5saW5lKCk6IGlucHV0IHBhcmFtZXRlciBpcyBvZiB0eXBlICcgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3JjKSArICcsIHN0cmluZyBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIG9wdCA9IG1lcmdlJDIoe30sIG1hcmtlZC5kZWZhdWx0cywgb3B0IHx8IHt9KTtcbiAgICBjaGVja1Nhbml0aXplRGVwcmVjYXRpb24kMShvcHQpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciB0b2tlbnMgPSBMZXhlcl8xLmxleElubGluZShzcmMsIG9wdCk7XG5cbiAgICAgIGlmIChvcHQud2Fsa1Rva2Vucykge1xuICAgICAgICBtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbnMsIG9wdC53YWxrVG9rZW5zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFBhcnNlcl8xLnBhcnNlSW5saW5lKHRva2Vucywgb3B0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlLm1lc3NhZ2UgKz0gJ1xcblBsZWFzZSByZXBvcnQgdGhpcyB0byBodHRwczovL2dpdGh1Yi5jb20vbWFya2VkanMvbWFya2VkLic7XG5cbiAgICAgIGlmIChvcHQuc2lsZW50KSB7XG4gICAgICAgIHJldHVybiAnPHA+QW4gZXJyb3Igb2NjdXJyZWQ6PC9wPjxwcmU+JyArIGVzY2FwZSQyKGUubWVzc2FnZSArICcnLCB0cnVlKSArICc8L3ByZT4nO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEV4cG9zZVxuICAgKi9cblxuXG4gIG1hcmtlZC5QYXJzZXIgPSBQYXJzZXJfMTtcbiAgbWFya2VkLnBhcnNlciA9IFBhcnNlcl8xLnBhcnNlO1xuICBtYXJrZWQuUmVuZGVyZXIgPSBSZW5kZXJlcl8xO1xuICBtYXJrZWQuVGV4dFJlbmRlcmVyID0gVGV4dFJlbmRlcmVyXzE7XG4gIG1hcmtlZC5MZXhlciA9IExleGVyXzE7XG4gIG1hcmtlZC5sZXhlciA9IExleGVyXzEubGV4O1xuICBtYXJrZWQuVG9rZW5pemVyID0gVG9rZW5pemVyXzE7XG4gIG1hcmtlZC5TbHVnZ2VyID0gU2x1Z2dlcl8xO1xuICBtYXJrZWQucGFyc2UgPSBtYXJrZWQ7XG4gIHZhciBtYXJrZWRfMSA9IG1hcmtlZDtcblxuICByZXR1cm4gbWFya2VkXzE7XG5cbn0pKSk7XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyoqXG4gKiBBY3Rpb25zIHRoYXQgbW9kaWZ5IHRoZSBVUkwuXG4gKi9cbnZhciBMb2NhdGlvbkFjdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBhIG5ldyBsb2NhdGlvbiBpcyBiZWluZyBwdXNoZWQgdG8gdGhlIGhpc3Rvcnkgc3RhY2suXG4gICAqL1xuICBQVVNIOiAncHVzaCcsXG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGUgY3VycmVudCBsb2NhdGlvbiBzaG91bGQgYmUgcmVwbGFjZWQuXG4gICAqL1xuICBSRVBMQUNFOiAncmVwbGFjZScsXG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGUgbW9zdCByZWNlbnQgZW50cnkgc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSB0aGUgaGlzdG9yeSBzdGFjay5cbiAgICovXG4gIFBPUDogJ3BvcCdcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMb2NhdGlvbkFjdGlvbnM7XG4iLCJ2YXIgTG9jYXRpb25BY3Rpb25zID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9Mb2NhdGlvbkFjdGlvbnMnKTtcblxuLyoqXG4gKiBBIHNjcm9sbCBiZWhhdmlvciB0aGF0IGF0dGVtcHRzIHRvIGltaXRhdGUgdGhlIGRlZmF1bHQgYmVoYXZpb3JcbiAqIG9mIG1vZGVybiBicm93c2Vycy5cbiAqL1xudmFyIEltaXRhdGVCcm93c2VyQmVoYXZpb3IgPSB7XG5cbiAgdXBkYXRlU2Nyb2xsUG9zaXRpb246IGZ1bmN0aW9uIChwb3NpdGlvbiwgYWN0aW9uVHlwZSkge1xuICAgIHN3aXRjaCAoYWN0aW9uVHlwZSkge1xuICAgICAgY2FzZSBMb2NhdGlvbkFjdGlvbnMuUFVTSDpcbiAgICAgIGNhc2UgTG9jYXRpb25BY3Rpb25zLlJFUExBQ0U6XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExvY2F0aW9uQWN0aW9ucy5QT1A6XG4gICAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW1pdGF0ZUJyb3dzZXJCZWhhdmlvcjtcbiIsIi8qKlxuICogQSBzY3JvbGwgYmVoYXZpb3IgdGhhdCBhbHdheXMgc2Nyb2xscyB0byB0aGUgdG9wIG9mIHRoZSBwYWdlXG4gKiBhZnRlciBhIHRyYW5zaXRpb24uXG4gKi9cbnZhciBTY3JvbGxUb1RvcEJlaGF2aW9yID0ge1xuXG4gIHVwZGF0ZVNjcm9sbFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2Nyb2xsVG9Ub3BCZWhhdmlvcjtcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgRmFrZU5vZGUgPSByZXF1aXJlKCcuLi9taXhpbnMvRmFrZU5vZGUnKTtcbnZhciBQcm9wVHlwZXMgPSByZXF1aXJlKCcuLi91dGlscy9Qcm9wVHlwZXMnKTtcblxuLyoqXG4gKiBBIDxEZWZhdWx0Um91dGU+IGNvbXBvbmVudCBpcyBhIHNwZWNpYWwga2luZCBvZiA8Um91dGU+IHRoYXRcbiAqIHJlbmRlcnMgd2hlbiBpdHMgcGFyZW50IG1hdGNoZXMgYnV0IG5vbmUgb2YgaXRzIHNpYmxpbmdzIGRvLlxuICogT25seSBvbmUgc3VjaCByb3V0ZSBtYXkgYmUgdXNlZCBhdCBhbnkgZ2l2ZW4gbGV2ZWwgaW4gdGhlXG4gKiByb3V0ZSBoaWVyYXJjaHkuXG4gKi9cbnZhciBEZWZhdWx0Um91dGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgZGlzcGxheU5hbWU6ICdEZWZhdWx0Um91dGUnLFxuXG4gIG1peGluczogWyBGYWtlTm9kZSBdLFxuXG4gIHByb3BUeXBlczoge1xuICAgIG5hbWU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgcGF0aDogUHJvcFR5cGVzLmZhbHN5LFxuICAgIGhhbmRsZXI6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWZhdWx0Um91dGU7XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGNsYXNzU2V0ID0gcmVxdWlyZSgncmVhY3QvbGliL2N4Jyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgncmVhY3QvbGliL09iamVjdC5hc3NpZ24nKTtcbnZhciBOYXZpZ2F0aW9uID0gcmVxdWlyZSgnLi4vbWl4aW5zL05hdmlnYXRpb24nKTtcbnZhciBTdGF0ZSA9IHJlcXVpcmUoJy4uL21peGlucy9TdGF0ZScpO1xuXG5mdW5jdGlvbiBpc0xlZnRDbGlja0V2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5idXR0b24gPT09IDA7XG59XG5cbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudCkge1xuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG59XG5cbi8qKlxuICogPExpbms+IGNvbXBvbmVudHMgYXJlIHVzZWQgdG8gY3JlYXRlIGFuIDxhPiBlbGVtZW50IHRoYXQgbGlua3MgdG8gYSByb3V0ZS5cbiAqIFdoZW4gdGhhdCByb3V0ZSBpcyBhY3RpdmUsIHRoZSBsaW5rIGdldHMgYW4gXCJhY3RpdmVcIiBjbGFzcyBuYW1lIChvciB0aGVcbiAqIHZhbHVlIG9mIGl0cyBgYWN0aXZlQ2xhc3NOYW1lYCBwcm9wKS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgYXNzdW1pbmcgeW91IGhhdmUgdGhlIGZvbGxvd2luZyByb3V0ZTpcbiAqXG4gKiAgIDxSb3V0ZSBuYW1lPVwic2hvd1Bvc3RcIiBwYXRoPVwiL3Bvc3RzLzpwb3N0SURcIiBoYW5kbGVyPXtQb3N0fS8+XG4gKlxuICogWW91IGNvdWxkIHVzZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudCB0byBsaW5rIHRvIHRoYXQgcm91dGU6XG4gKlxuICogICA8TGluayB0bz1cInNob3dQb3N0XCIgcGFyYW1zPXt7IHBvc3RJRDogXCIxMjNcIiB9fSAvPlxuICpcbiAqIEluIGFkZGl0aW9uIHRvIHBhcmFtcywgbGlua3MgbWF5IHBhc3MgYWxvbmcgcXVlcnkgc3RyaW5nIHBhcmFtZXRlcnNcbiAqIHVzaW5nIHRoZSBgcXVlcnlgIHByb3AuXG4gKlxuICogICA8TGluayB0bz1cInNob3dQb3N0XCIgcGFyYW1zPXt7IHBvc3RJRDogXCIxMjNcIiB9fSBxdWVyeT17eyBzaG93OnRydWUgfX0vPlxuICovXG52YXIgTGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICBkaXNwbGF5TmFtZTogJ0xpbmsnLFxuXG4gIG1peGluczogWyBOYXZpZ2F0aW9uLCBTdGF0ZSBdLFxuXG4gIHByb3BUeXBlczoge1xuICAgIGFjdGl2ZUNsYXNzTmFtZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIHRvOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgcGFyYW1zOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHF1ZXJ5OiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIG9uQ2xpY2s6IFJlYWN0LlByb3BUeXBlcy5mdW5jXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGl2ZUNsYXNzTmFtZTogJ2FjdGl2ZSdcbiAgICB9O1xuICB9LFxuXG4gIGhhbmRsZUNsaWNrOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgYWxsb3dUcmFuc2l0aW9uID0gdHJ1ZTtcbiAgICB2YXIgY2xpY2tSZXN1bHQ7XG5cbiAgICBpZiAodGhpcy5wcm9wcy5vbkNsaWNrKVxuICAgICAgY2xpY2tSZXN1bHQgPSB0aGlzLnByb3BzLm9uQ2xpY2soZXZlbnQpO1xuXG4gICAgaWYgKGlzTW9kaWZpZWRFdmVudChldmVudCkgfHwgIWlzTGVmdENsaWNrRXZlbnQoZXZlbnQpKVxuICAgICAgcmV0dXJuO1xuXG4gICAgaWYgKGNsaWNrUmVzdWx0ID09PSBmYWxzZSB8fCBldmVudC5kZWZhdWx0UHJldmVudGVkID09PSB0cnVlKVxuICAgICAgYWxsb3dUcmFuc2l0aW9uID0gZmFsc2U7XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgaWYgKGFsbG93VHJhbnNpdGlvbilcbiAgICAgIHRoaXMudHJhbnNpdGlvblRvKHRoaXMucHJvcHMudG8sIHRoaXMucHJvcHMucGFyYW1zLCB0aGlzLnByb3BzLnF1ZXJ5KTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIFwiaHJlZlwiIGF0dHJpYnV0ZSB0byB1c2Ugb24gdGhlIERPTSBlbGVtZW50LlxuICAgKi9cbiAgZ2V0SHJlZjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1ha2VIcmVmKHRoaXMucHJvcHMudG8sIHRoaXMucHJvcHMucGFyYW1zLCB0aGlzLnByb3BzLnF1ZXJ5KTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIFwiY2xhc3NcIiBhdHRyaWJ1dGUgdG8gdXNlIG9uIHRoZSBET00gZWxlbWVudCwgd2hpY2ggY29udGFpbnNcbiAgICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmVDbGFzc05hbWUgcHJvcGVydHkgd2hlbiB0aGlzIDxMaW5rPiBpcyBhY3RpdmUuXG4gICAqL1xuICBnZXRDbGFzc05hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2xhc3NOYW1lcyA9IHt9O1xuXG4gICAgaWYgKHRoaXMucHJvcHMuY2xhc3NOYW1lKVxuICAgICAgY2xhc3NOYW1lc1t0aGlzLnByb3BzLmNsYXNzTmFtZV0gPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMuaXNBY3RpdmUodGhpcy5wcm9wcy50bywgdGhpcy5wcm9wcy5wYXJhbXMsIHRoaXMucHJvcHMucXVlcnkpKVxuICAgICAgY2xhc3NOYW1lc1t0aGlzLnByb3BzLmFjdGl2ZUNsYXNzTmFtZV0gPSB0cnVlO1xuXG4gICAgcmV0dXJuIGNsYXNzU2V0KGNsYXNzTmFtZXMpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9wcyA9IGFzc2lnbih7fSwgdGhpcy5wcm9wcywge1xuICAgICAgaHJlZjogdGhpcy5nZXRIcmVmKCksXG4gICAgICBjbGFzc05hbWU6IHRoaXMuZ2V0Q2xhc3NOYW1lKCksXG4gICAgICBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrXG4gICAgfSk7XG5cbiAgICByZXR1cm4gUmVhY3QuRE9NLmEocHJvcHMsIHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbms7XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIEZha2VOb2RlID0gcmVxdWlyZSgnLi4vbWl4aW5zL0Zha2VOb2RlJyk7XG52YXIgUHJvcFR5cGVzID0gcmVxdWlyZSgnLi4vdXRpbHMvUHJvcFR5cGVzJyk7XG5cbi8qKlxuICogQSA8Tm90Rm91bmRSb3V0ZT4gaXMgYSBzcGVjaWFsIGtpbmQgb2YgPFJvdXRlPiB0aGF0XG4gKiByZW5kZXJzIHdoZW4gdGhlIGJlZ2lubmluZyBvZiBpdHMgcGFyZW50J3MgcGF0aCBtYXRjaGVzXG4gKiBidXQgbm9uZSBvZiBpdHMgc2libGluZ3MgZG8sIGluY2x1ZGluZyBhbnkgPERlZmF1bHRSb3V0ZT4uXG4gKiBPbmx5IG9uZSBzdWNoIHJvdXRlIG1heSBiZSB1c2VkIGF0IGFueSBnaXZlbiBsZXZlbCBpbiB0aGVcbiAqIHJvdXRlIGhpZXJhcmNoeS5cbiAqL1xudmFyIE5vdEZvdW5kUm91dGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgZGlzcGxheU5hbWU6ICdOb3RGb3VuZFJvdXRlJyxcblxuICBtaXhpbnM6IFsgRmFrZU5vZGUgXSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBuYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHBhdGg6IFByb3BUeXBlcy5mYWxzeSxcbiAgICBoYW5kbGVyOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTm90Rm91bmRSb3V0ZTtcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgRmFrZU5vZGUgPSByZXF1aXJlKCcuLi9taXhpbnMvRmFrZU5vZGUnKTtcbnZhciBQcm9wVHlwZXMgPSByZXF1aXJlKCcuLi91dGlscy9Qcm9wVHlwZXMnKTtcblxuLyoqXG4gKiBBIDxSZWRpcmVjdD4gY29tcG9uZW50IGlzIGEgc3BlY2lhbCBraW5kIG9mIDxSb3V0ZT4gdGhhdCBhbHdheXNcbiAqIHJlZGlyZWN0cyB0byBhbm90aGVyIHJvdXRlIHdoZW4gaXQgbWF0Y2hlcy5cbiAqL1xudmFyIFJlZGlyZWN0ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gIGRpc3BsYXlOYW1lOiAnUmVkaXJlY3QnLFxuXG4gIG1peGluczogWyBGYWtlTm9kZSBdLFxuXG4gIHByb3BUeXBlczoge1xuICAgIHBhdGg6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgZnJvbTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZywgLy8gQWxpYXMgZm9yIHBhdGguXG4gICAgdG86IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgaGFuZGxlcjogUHJvcFR5cGVzLmZhbHN5XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVkaXJlY3Q7XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIEZha2VOb2RlID0gcmVxdWlyZSgnLi4vbWl4aW5zL0Zha2VOb2RlJyk7XG5cbi8qKlxuICogPFJvdXRlPiBjb21wb25lbnRzIHNwZWNpZnkgY29tcG9uZW50cyB0aGF0IGFyZSByZW5kZXJlZCB0byB0aGUgcGFnZSB3aGVuIHRoZVxuICogVVJMIG1hdGNoZXMgYSBnaXZlbiBwYXR0ZXJuLlxuICpcbiAqIFJvdXRlcyBhcmUgYXJyYW5nZWQgaW4gYSBuZXN0ZWQgdHJlZSBzdHJ1Y3R1cmUuIFdoZW4gYSBuZXcgVVJMIGlzIHJlcXVlc3RlZCxcbiAqIHRoZSB0cmVlIGlzIHNlYXJjaGVkIGRlcHRoLWZpcnN0IHRvIGZpbmQgYSByb3V0ZSB3aG9zZSBwYXRoIG1hdGNoZXMgdGhlIFVSTC5cbiAqIFdoZW4gb25lIGlzIGZvdW5kLCBhbGwgcm91dGVzIGluIHRoZSB0cmVlIHRoYXQgbGVhZCB0byBpdCBhcmUgY29uc2lkZXJlZFxuICogXCJhY3RpdmVcIiBhbmQgdGhlaXIgY29tcG9uZW50cyBhcmUgcmVuZGVyZWQgaW50byB0aGUgRE9NLCBuZXN0ZWQgaW4gdGhlIHNhbWVcbiAqIG9yZGVyIGFzIHRoZXkgYXJlIGluIHRoZSB0cmVlLlxuICpcbiAqIFRoZSBwcmVmZXJyZWQgd2F5IHRvIGNvbmZpZ3VyZSBhIHJvdXRlciBpcyB1c2luZyBKU1guIFRoZSBYTUwtbGlrZSBzeW50YXggaXNcbiAqIGEgZ3JlYXQgd2F5IHRvIHZpc3VhbGl6ZSBob3cgcm91dGVzIGFyZSBsYWlkIG91dCBpbiBhbiBhcHBsaWNhdGlvbi5cbiAqXG4gKiAgIHZhciByb3V0ZXMgPSBbXG4gKiAgICAgPFJvdXRlIGhhbmRsZXI9e0FwcH0+XG4gKiAgICAgICA8Um91dGUgbmFtZT1cImxvZ2luXCIgaGFuZGxlcj17TG9naW59Lz5cbiAqICAgICAgIDxSb3V0ZSBuYW1lPVwibG9nb3V0XCIgaGFuZGxlcj17TG9nb3V0fS8+XG4gKiAgICAgICA8Um91dGUgbmFtZT1cImFib3V0XCIgaGFuZGxlcj17QWJvdXR9Lz5cbiAqICAgICA8L1JvdXRlPlxuICogICBdO1xuICogICBcbiAqICAgUm91dGVyLnJ1bihyb3V0ZXMsIGZ1bmN0aW9uIChIYW5kbGVyKSB7XG4gKiAgICAgUmVhY3QucmVuZGVyKDxIYW5kbGVyLz4sIGRvY3VtZW50LmJvZHkpO1xuICogICB9KTtcbiAqXG4gKiBIYW5kbGVycyBmb3IgUm91dGUgY29tcG9uZW50cyB0aGF0IGNvbnRhaW4gY2hpbGRyZW4gY2FuIHJlbmRlciB0aGVpciBhY3RpdmVcbiAqIGNoaWxkIHJvdXRlIHVzaW5nIGEgPFJvdXRlSGFuZGxlcj4gZWxlbWVudC5cbiAqXG4gKiAgIHZhciBBcHAgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICByZXR1cm4gKFxuICogICAgICAgICA8ZGl2IGNsYXNzPVwiYXBwbGljYXRpb25cIj5cbiAqICAgICAgICAgICA8Um91dGVIYW5kbGVyLz5cbiAqICAgICAgICAgPC9kaXY+XG4gKiAgICAgICApO1xuICogICAgIH1cbiAqICAgfSk7XG4gKi9cbnZhciBSb3V0ZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICBkaXNwbGF5TmFtZTogJ1JvdXRlJyxcblxuICBtaXhpbnM6IFsgRmFrZU5vZGUgXSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBuYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLFxuICAgIHBhdGg6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgaGFuZGxlcjogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBpZ25vcmVTY3JvbGxCZWhhdmlvcjogUmVhY3QuUHJvcFR5cGVzLmJvb2xcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3V0ZTtcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUm91dGVIYW5kbGVyTWl4aW4gPSByZXF1aXJlKCcuLi9taXhpbnMvUm91dGVIYW5kbGVyJyk7XG5cbi8qKlxuICogQSA8Um91dGVIYW5kbGVyPiBjb21wb25lbnQgcmVuZGVycyB0aGUgYWN0aXZlIGNoaWxkIHJvdXRlIGhhbmRsZXJcbiAqIHdoZW4gcm91dGVzIGFyZSBuZXN0ZWQuXG4gKi9cbnZhciBSb3V0ZUhhbmRsZXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgZGlzcGxheU5hbWU6ICdSb3V0ZUhhbmRsZXInLFxuXG4gIG1peGluczogW1JvdXRlSGFuZGxlck1peGluXSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVmOiAnX19yb3V0ZUhhbmRsZXJfXydcbiAgICB9O1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldFJvdXRlSGFuZGxlcigpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdXRlSGFuZGxlcjtcbiIsImV4cG9ydHMuRGVmYXVsdFJvdXRlID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL0RlZmF1bHRSb3V0ZScpO1xuZXhwb3J0cy5MaW5rID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL0xpbmsnKTtcbmV4cG9ydHMuTm90Rm91bmRSb3V0ZSA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9Ob3RGb3VuZFJvdXRlJyk7XG5leHBvcnRzLlJlZGlyZWN0ID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL1JlZGlyZWN0Jyk7XG5leHBvcnRzLlJvdXRlID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL1JvdXRlJyk7XG5leHBvcnRzLlJvdXRlSGFuZGxlciA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9Sb3V0ZUhhbmRsZXInKTtcblxuZXhwb3J0cy5IYXNoTG9jYXRpb24gPSByZXF1aXJlKCcuL2xvY2F0aW9ucy9IYXNoTG9jYXRpb24nKTtcbmV4cG9ydHMuSGlzdG9yeUxvY2F0aW9uID0gcmVxdWlyZSgnLi9sb2NhdGlvbnMvSGlzdG9yeUxvY2F0aW9uJyk7XG5leHBvcnRzLlJlZnJlc2hMb2NhdGlvbiA9IHJlcXVpcmUoJy4vbG9jYXRpb25zL1JlZnJlc2hMb2NhdGlvbicpO1xuXG5leHBvcnRzLkltaXRhdGVCcm93c2VyQmVoYXZpb3IgPSByZXF1aXJlKCcuL2JlaGF2aW9ycy9JbWl0YXRlQnJvd3NlckJlaGF2aW9yJyk7XG5leHBvcnRzLlNjcm9sbFRvVG9wQmVoYXZpb3IgPSByZXF1aXJlKCcuL2JlaGF2aW9ycy9TY3JvbGxUb1RvcEJlaGF2aW9yJyk7XG5cbmV4cG9ydHMuTmF2aWdhdGlvbiA9IHJlcXVpcmUoJy4vbWl4aW5zL05hdmlnYXRpb24nKTtcbmV4cG9ydHMuU3RhdGUgPSByZXF1aXJlKCcuL21peGlucy9TdGF0ZScpO1xuXG5leHBvcnRzLmNyZWF0ZSA9IHJlcXVpcmUoJy4vdXRpbHMvY3JlYXRlUm91dGVyJyk7XG5leHBvcnRzLnJ1biA9IHJlcXVpcmUoJy4vdXRpbHMvcnVuUm91dGVyJyk7XG5cbmV4cG9ydHMuSGlzdG9yeSA9IHJlcXVpcmUoJy4vdXRpbHMvSGlzdG9yeScpO1xuIiwidmFyIExvY2F0aW9uQWN0aW9ucyA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvTG9jYXRpb25BY3Rpb25zJyk7XG52YXIgSGlzdG9yeSA9IHJlcXVpcmUoJy4uL3V0aWxzL0hpc3RvcnknKTtcbnZhciBQYXRoID0gcmVxdWlyZSgnLi4vdXRpbHMvUGF0aCcpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgVVJMIHBhdGggZnJvbSB0aGUgYGhhc2hgIHBvcnRpb24gb2YgdGhlIFVSTCwgaW5jbHVkaW5nXG4gKiBxdWVyeSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGdldEhhc2hQYXRoKCkge1xuICByZXR1cm4gUGF0aC5kZWNvZGUoXG4gICAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAgIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gICAgd2luZG93LmxvY2F0aW9uLmhyZWYuc3BsaXQoJyMnKVsxXSB8fCAnJ1xuICApO1xufVxuXG52YXIgX2FjdGlvblR5cGU7XG5cbmZ1bmN0aW9uIGVuc3VyZVNsYXNoKCkge1xuICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XG5cbiAgaWYgKHBhdGguY2hhckF0KDApID09PSAnLycpXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgSGFzaExvY2F0aW9uLnJlcGxhY2UoJy8nICsgcGF0aCk7XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgX2NoYW5nZUxpc3RlbmVycyA9IFtdO1xuXG5mdW5jdGlvbiBub3RpZnlDaGFuZ2UodHlwZSkge1xuICBpZiAodHlwZSA9PT0gTG9jYXRpb25BY3Rpb25zLlBVU0gpXG4gICAgSGlzdG9yeS5sZW5ndGggKz0gMTtcblxuICB2YXIgY2hhbmdlID0ge1xuICAgIHBhdGg6IGdldEhhc2hQYXRoKCksXG4gICAgdHlwZTogdHlwZVxuICB9O1xuXG4gIF9jaGFuZ2VMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICBsaXN0ZW5lcihjaGFuZ2UpO1xuICB9KTtcbn1cblxudmFyIF9pc0xpc3RlbmluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBvbkhhc2hDaGFuZ2UoKSB7XG4gIGlmIChlbnN1cmVTbGFzaCgpKSB7XG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbiBfYWN0aW9uVHlwZSB0aGVuIGFsbCB3ZSBrbm93IGlzIHRoZSBoYXNoXG4gICAgLy8gY2hhbmdlZC4gSXQgd2FzIHByb2JhYmx5IGNhdXNlZCBieSB0aGUgdXNlciBjbGlja2luZyB0aGUgQmFja1xuICAgIC8vIGJ1dHRvbiwgYnV0IG1heSBoYXZlIGFsc28gYmVlbiB0aGUgRm9yd2FyZCBidXR0b24gb3IgbWFudWFsXG4gICAgLy8gbWFuaXB1bGF0aW9uLiBTbyBqdXN0IGd1ZXNzICdwb3AnLlxuICAgIG5vdGlmeUNoYW5nZShfYWN0aW9uVHlwZSB8fCBMb2NhdGlvbkFjdGlvbnMuUE9QKTtcbiAgICBfYWN0aW9uVHlwZSA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBBIExvY2F0aW9uIHRoYXQgdXNlcyBgd2luZG93LmxvY2F0aW9uLmhhc2hgLlxuICovXG52YXIgSGFzaExvY2F0aW9uID0ge1xuXG4gIGFkZENoYW5nZUxpc3RlbmVyOiBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICBfY2hhbmdlTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgLy8gRG8gdGhpcyBCRUZPUkUgbGlzdGVuaW5nIGZvciBoYXNoY2hhbmdlLlxuICAgIGVuc3VyZVNsYXNoKCk7XG5cbiAgICBpZiAoX2lzTGlzdGVuaW5nKVxuICAgICAgcmV0dXJuO1xuXG4gICAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIG9uSGFzaENoYW5nZSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuYXR0YWNoRXZlbnQoJ29uaGFzaGNoYW5nZScsIG9uSGFzaENoYW5nZSk7XG4gICAgfVxuXG4gICAgX2lzTGlzdGVuaW5nID0gdHJ1ZTtcbiAgfSxcblxuICByZW1vdmVDaGFuZ2VMaXN0ZW5lcjogZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IF9jaGFuZ2VMaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbDsgaSArKykge1xuICAgICAgaWYgKF9jaGFuZ2VMaXN0ZW5lcnNbaV0gPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIF9jaGFuZ2VMaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgb25IYXNoQ2hhbmdlLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudCgnb25oYXNoY2hhbmdlJywgb25IYXNoQ2hhbmdlKTtcbiAgICB9XG5cbiAgICBpZiAoX2NoYW5nZUxpc3RlbmVycy5sZW5ndGggPT09IDApXG4gICAgICBfaXNMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgfSxcblxuXG5cbiAgcHVzaDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBfYWN0aW9uVHlwZSA9IExvY2F0aW9uQWN0aW9ucy5QVVNIO1xuICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gUGF0aC5lbmNvZGUocGF0aCk7XG4gIH0sXG5cbiAgcmVwbGFjZTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBfYWN0aW9uVHlwZSA9IExvY2F0aW9uQWN0aW9ucy5SRVBMQUNFO1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArICcjJyArIFBhdGguZW5jb2RlKHBhdGgpKTtcbiAgfSxcblxuICBwb3A6IGZ1bmN0aW9uICgpIHtcbiAgICBfYWN0aW9uVHlwZSA9IExvY2F0aW9uQWN0aW9ucy5QT1A7XG4gICAgSGlzdG9yeS5iYWNrKCk7XG4gIH0sXG5cbiAgZ2V0Q3VycmVudFBhdGg6IGdldEhhc2hQYXRoLFxuXG4gIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICc8SGFzaExvY2F0aW9uPic7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoTG9jYXRpb247XG4iLCJ2YXIgTG9jYXRpb25BY3Rpb25zID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9Mb2NhdGlvbkFjdGlvbnMnKTtcbnZhciBIaXN0b3J5ID0gcmVxdWlyZSgnLi4vdXRpbHMvSGlzdG9yeScpO1xudmFyIFBhdGggPSByZXF1aXJlKCcuLi91dGlscy9QYXRoJyk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBVUkwgcGF0aCBmcm9tIGB3aW5kb3cubG9jYXRpb25gLCBpbmNsdWRpbmcgcXVlcnkgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3dQYXRoKCkge1xuICByZXR1cm4gUGF0aC5kZWNvZGUoXG4gICAgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaFxuICApO1xufVxuXG52YXIgX2NoYW5nZUxpc3RlbmVycyA9IFtdO1xuXG5mdW5jdGlvbiBub3RpZnlDaGFuZ2UodHlwZSkge1xuICB2YXIgY2hhbmdlID0ge1xuICAgIHBhdGg6IGdldFdpbmRvd1BhdGgoKSxcbiAgICB0eXBlOiB0eXBlXG4gIH07XG5cbiAgX2NoYW5nZUxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgIGxpc3RlbmVyKGNoYW5nZSk7XG4gIH0pO1xufVxuXG52YXIgX2lzTGlzdGVuaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIG9uUG9wU3RhdGUoKSB7XG4gIG5vdGlmeUNoYW5nZShMb2NhdGlvbkFjdGlvbnMuUE9QKTtcbn1cblxuLyoqXG4gKiBBIExvY2F0aW9uIHRoYXQgdXNlcyBIVE1MNSBoaXN0b3J5LlxuICovXG52YXIgSGlzdG9yeUxvY2F0aW9uID0ge1xuXG4gIGFkZENoYW5nZUxpc3RlbmVyOiBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICBfY2hhbmdlTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgaWYgKF9pc0xpc3RlbmluZylcbiAgICAgIHJldHVybjtcblxuICAgIGlmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgb25Qb3BTdGF0ZSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuYXR0YWNoRXZlbnQoJ3BvcHN0YXRlJywgb25Qb3BTdGF0ZSk7XG4gICAgfVxuXG4gICAgX2lzTGlzdGVuaW5nID0gdHJ1ZTtcbiAgfSxcblxuICByZW1vdmVDaGFuZ2VMaXN0ZW5lcjogZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IF9jaGFuZ2VMaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbDsgaSArKykge1xuICAgICAgaWYgKF9jaGFuZ2VMaXN0ZW5lcnNbaV0gPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIF9jaGFuZ2VMaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIG9uUG9wU3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnQoJ3BvcHN0YXRlJywgb25Qb3BTdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKF9jaGFuZ2VMaXN0ZW5lcnMubGVuZ3RoID09PSAwKVxuICAgICAgX2lzTGlzdGVuaW5nID0gZmFsc2U7XG4gIH0sXG5cblxuXG4gIHB1c2g6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHsgcGF0aDogcGF0aCB9LCAnJywgUGF0aC5lbmNvZGUocGF0aCkpO1xuICAgIEhpc3RvcnkubGVuZ3RoICs9IDE7XG4gICAgbm90aWZ5Q2hhbmdlKExvY2F0aW9uQWN0aW9ucy5QVVNIKTtcbiAgfSxcblxuICByZXBsYWNlOiBmdW5jdGlvbiAocGF0aCkge1xuICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IHBhdGg6IHBhdGggfSwgJycsIFBhdGguZW5jb2RlKHBhdGgpKTtcbiAgICBub3RpZnlDaGFuZ2UoTG9jYXRpb25BY3Rpb25zLlJFUExBQ0UpO1xuICB9LFxuXG4gIHBvcDogSGlzdG9yeS5iYWNrLFxuXG4gIGdldEN1cnJlbnRQYXRoOiBnZXRXaW5kb3dQYXRoLFxuXG4gIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICc8SGlzdG9yeUxvY2F0aW9uPic7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIaXN0b3J5TG9jYXRpb247XG4iLCJ2YXIgSGlzdG9yeUxvY2F0aW9uID0gcmVxdWlyZSgnLi9IaXN0b3J5TG9jYXRpb24nKTtcbnZhciBIaXN0b3J5ID0gcmVxdWlyZSgnLi4vdXRpbHMvSGlzdG9yeScpO1xudmFyIFBhdGggPSByZXF1aXJlKCcuLi91dGlscy9QYXRoJyk7XG5cbi8qKlxuICogQSBMb2NhdGlvbiB0aGF0IHVzZXMgZnVsbCBwYWdlIHJlZnJlc2hlcy4gVGhpcyBpcyB1c2VkIGFzXG4gKiB0aGUgZmFsbGJhY2sgZm9yIEhpc3RvcnlMb2NhdGlvbiBpbiBicm93c2VycyB0aGF0IGRvIG5vdFxuICogc3VwcG9ydCB0aGUgSFRNTDUgaGlzdG9yeSBBUEkuXG4gKi9cbnZhciBSZWZyZXNoTG9jYXRpb24gPSB7XG5cbiAgcHVzaDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICB3aW5kb3cubG9jYXRpb24gPSBQYXRoLmVuY29kZShwYXRoKTtcbiAgfSxcblxuICByZXBsYWNlOiBmdW5jdGlvbiAocGF0aCkge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKFBhdGguZW5jb2RlKHBhdGgpKTtcbiAgfSxcblxuICBwb3A6IEhpc3RvcnkuYmFjayxcblxuICBnZXRDdXJyZW50UGF0aDogSGlzdG9yeUxvY2F0aW9uLmdldEN1cnJlbnRQYXRoLFxuXG4gIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICc8UmVmcmVzaExvY2F0aW9uPic7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWZyZXNoTG9jYXRpb247XG4iLCJ2YXIgaW52YXJpYW50ID0gcmVxdWlyZSgncmVhY3QvbGliL2ludmFyaWFudCcpO1xuXG52YXIgRmFrZU5vZGUgPSB7XG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgZmFsc2UsXG4gICAgICAnJXMgZWxlbWVudHMgc2hvdWxkIG5vdCBiZSByZW5kZXJlZCcsXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lXG4gICAgKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZha2VOb2RlO1xuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLyoqXG4gKiBBIG1peGluIGZvciBjb21wb25lbnRzIHRoYXQgbW9kaWZ5IHRoZSBVUkwuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgbWl4aW5zOiBbIFJvdXRlci5OYXZpZ2F0aW9uIF0sXG4gKiAgICAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uIChldmVudCkge1xuICogICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAqICAgICAgIHRoaXMudHJhbnNpdGlvblRvKCdhUm91dGUnLCB7IHRoZTogJ3BhcmFtcycgfSwgeyB0aGU6ICdxdWVyeScgfSk7XG4gKiAgICAgfSxcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAqICAgICAgIHJldHVybiAoXG4gKiAgICAgICAgIDxhIG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xpY2t9PkNsaWNrIG1lITwvYT5cbiAqICAgICAgICk7XG4gKiAgICAgfVxuICogICB9KTtcbiAqL1xudmFyIE5hdmlnYXRpb24gPSB7XG5cbiAgY29udGV4dFR5cGVzOiB7XG4gICAgbWFrZVBhdGg6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgbWFrZUhyZWY6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgdHJhbnNpdGlvblRvOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIHJlcGxhY2VXaXRoOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIGdvQmFjazogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFic29sdXRlIFVSTCBwYXRoIGNyZWF0ZWQgZnJvbSB0aGUgZ2l2ZW4gcm91dGVcbiAgICogbmFtZSwgVVJMIHBhcmFtZXRlcnMsIGFuZCBxdWVyeSB2YWx1ZXMuXG4gICAqL1xuICBtYWtlUGF0aDogZnVuY3Rpb24gKHRvLCBwYXJhbXMsIHF1ZXJ5KSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5tYWtlUGF0aCh0bywgcGFyYW1zLCBxdWVyeSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgdGhhdCBtYXkgc2FmZWx5IGJlIHVzZWQgYXMgdGhlIGhyZWYgb2YgYVxuICAgKiBsaW5rIHRvIHRoZSByb3V0ZSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICAgKi9cbiAgbWFrZUhyZWY6IGZ1bmN0aW9uICh0bywgcGFyYW1zLCBxdWVyeSkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQubWFrZUhyZWYodG8sIHBhcmFtcywgcXVlcnkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFuc2l0aW9ucyB0byB0aGUgVVJMIHNwZWNpZmllZCBpbiB0aGUgYXJndW1lbnRzIGJ5IHB1c2hpbmdcbiAgICogYSBuZXcgVVJMIG9udG8gdGhlIGhpc3Rvcnkgc3RhY2suXG4gICAqL1xuICB0cmFuc2l0aW9uVG86IGZ1bmN0aW9uICh0bywgcGFyYW1zLCBxdWVyeSkge1xuICAgIHRoaXMuY29udGV4dC50cmFuc2l0aW9uVG8odG8sIHBhcmFtcywgcXVlcnkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFuc2l0aW9ucyB0byB0aGUgVVJMIHNwZWNpZmllZCBpbiB0aGUgYXJndW1lbnRzIGJ5IHJlcGxhY2luZ1xuICAgKiB0aGUgY3VycmVudCBVUkwgaW4gdGhlIGhpc3Rvcnkgc3RhY2suXG4gICAqL1xuICByZXBsYWNlV2l0aDogZnVuY3Rpb24gKHRvLCBwYXJhbXMsIHF1ZXJ5KSB7XG4gICAgdGhpcy5jb250ZXh0LnJlcGxhY2VXaXRoKHRvLCBwYXJhbXMsIHF1ZXJ5KTtcbiAgfSxcblxuICAvKipcbiAgICogVHJhbnNpdGlvbnMgdG8gdGhlIHByZXZpb3VzIFVSTC5cbiAgICovXG4gIGdvQmFjazogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29udGV4dC5nb0JhY2soKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5hdmlnYXRpb247XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vKipcbiAqIFByb3ZpZGVzIHRoZSByb3V0ZXIgd2l0aCBjb250ZXh0IGZvciBSb3V0ZXIuTmF2aWdhdGlvbi5cbiAqL1xudmFyIE5hdmlnYXRpb25Db250ZXh0ID0ge1xuXG4gIGNoaWxkQ29udGV4dFR5cGVzOiB7XG4gICAgbWFrZVBhdGg6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgbWFrZUhyZWY6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgdHJhbnNpdGlvblRvOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIHJlcGxhY2VXaXRoOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIGdvQmFjazogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICB9LFxuXG4gIGdldENoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYWtlUGF0aDogdGhpcy5jb25zdHJ1Y3Rvci5tYWtlUGF0aCxcbiAgICAgIG1ha2VIcmVmOiB0aGlzLmNvbnN0cnVjdG9yLm1ha2VIcmVmLFxuICAgICAgdHJhbnNpdGlvblRvOiB0aGlzLmNvbnN0cnVjdG9yLnRyYW5zaXRpb25UbyxcbiAgICAgIHJlcGxhY2VXaXRoOiB0aGlzLmNvbnN0cnVjdG9yLnJlcGxhY2VXaXRoLFxuICAgICAgZ29CYWNrOiB0aGlzLmNvbnN0cnVjdG9yLmdvQmFja1xuICAgIH07XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOYXZpZ2F0aW9uQ29udGV4dDtcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb250ZXh0VHlwZXM6IHtcbiAgICBnZXRSb3V0ZUF0RGVwdGg6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgZ2V0Um91dGVDb21wb25lbnRzOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIHJvdXRlSGFuZGxlcnM6IFJlYWN0LlByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgY2hpbGRDb250ZXh0VHlwZXM6IHtcbiAgICByb3V0ZUhhbmRsZXJzOiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZFxuICB9LFxuXG4gIGdldENoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICByb3V0ZUhhbmRsZXJzOiB0aGlzLmNvbnRleHQucm91dGVIYW5kbGVycy5jb25jYXQoWyB0aGlzIF0pXG4gICAgfTtcbiAgfSxcblxuICBnZXRSb3V0ZURlcHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5yb3V0ZUhhbmRsZXJzLmxlbmd0aCAtIDE7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl91cGRhdGVSb3V0ZUNvbXBvbmVudCgpO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3VwZGF0ZVJvdXRlQ29tcG9uZW50KCk7XG4gIH0sXG5cbiAgX3VwZGF0ZVJvdXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlcHRoID0gdGhpcy5nZXRSb3V0ZURlcHRoKCk7XG4gICAgdmFyIGNvbXBvbmVudHMgPSB0aGlzLmNvbnRleHQuZ2V0Um91dGVDb21wb25lbnRzKCk7XG4gICAgY29tcG9uZW50c1tkZXB0aF0gPSB0aGlzLnJlZnNbdGhpcy5wcm9wcy5yZWYgfHwgJ19fcm91dGVIYW5kbGVyX18nXTtcbiAgfSxcblxuICBnZXRSb3V0ZUhhbmRsZXI6IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciByb3V0ZSA9IHRoaXMuY29udGV4dC5nZXRSb3V0ZUF0RGVwdGgodGhpcy5nZXRSb3V0ZURlcHRoKCkpO1xuICAgIHJldHVybiByb3V0ZSA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQocm91dGUuaGFuZGxlciwgcHJvcHMgfHwgdGhpcy5wcm9wcykgOiBudWxsO1xuICB9XG59OyIsInZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdyZWFjdC9saWIvaW52YXJpYW50Jyk7XG52YXIgY2FuVXNlRE9NID0gcmVxdWlyZSgncmVhY3QvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50JykuY2FuVXNlRE9NO1xudmFyIGdldFdpbmRvd1Njcm9sbFBvc2l0aW9uID0gcmVxdWlyZSgnLi4vdXRpbHMvZ2V0V2luZG93U2Nyb2xsUG9zaXRpb24nKTtcblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlU2Nyb2xsKHN0YXRlLCBwcmV2U3RhdGUpIHtcbiAgaWYgKCFwcmV2U3RhdGUpXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgLy8gRG9uJ3QgdXBkYXRlIHNjcm9sbCBwb3NpdGlvbiB3aGVuIG9ubHkgdGhlIHF1ZXJ5IGhhcyBjaGFuZ2VkLlxuICBpZiAoc3RhdGUucGF0aG5hbWUgPT09IHByZXZTdGF0ZS5wYXRobmFtZSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIHJvdXRlcyA9IHN0YXRlLnJvdXRlcztcbiAgdmFyIHByZXZSb3V0ZXMgPSBwcmV2U3RhdGUucm91dGVzO1xuXG4gIHZhciBzaGFyZWRBbmNlc3RvclJvdXRlcyA9IHJvdXRlcy5maWx0ZXIoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgcmV0dXJuIHByZXZSb3V0ZXMuaW5kZXhPZihyb3V0ZSkgIT09IC0xO1xuICB9KTtcblxuICByZXR1cm4gIXNoYXJlZEFuY2VzdG9yUm91dGVzLnNvbWUoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgcmV0dXJuIHJvdXRlLmlnbm9yZVNjcm9sbEJlaGF2aW9yO1xuICB9KTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyB0aGUgcm91dGVyIHdpdGggdGhlIGFiaWxpdHkgdG8gbWFuYWdlIHdpbmRvdyBzY3JvbGwgcG9zaXRpb25cbiAqIGFjY29yZGluZyB0byBpdHMgc2Nyb2xsIGJlaGF2aW9yLlxuICovXG52YXIgU2Nyb2xsaW5nID0ge1xuXG4gIHN0YXRpY3M6IHtcbiAgICAvKipcbiAgICAgKiBSZWNvcmRzIGN1cmVudCBzY3JvbGwgcG9zaXRpb24gYXMgdGhlIGxhc3Qga25vd24gcG9zaXRpb24gZm9yIHRoZSBnaXZlbiBVUkwgcGF0aC5cbiAgICAgKi9cbiAgICByZWNvcmRTY3JvbGxQb3NpdGlvbjogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIGlmICghdGhpcy5zY3JvbGxIaXN0b3J5KVxuICAgICAgICB0aGlzLnNjcm9sbEhpc3RvcnkgPSB7fTtcblxuICAgICAgdGhpcy5zY3JvbGxIaXN0b3J5W3BhdGhdID0gZ2V0V2luZG93U2Nyb2xsUG9zaXRpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGFzdCBrbm93biBzY3JvbGwgcG9zaXRpb24gZm9yIHRoZSBnaXZlbiBVUkwgcGF0aC5cbiAgICAgKi9cbiAgICBnZXRTY3JvbGxQb3NpdGlvbjogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIGlmICghdGhpcy5zY3JvbGxIaXN0b3J5KVxuICAgICAgICB0aGlzLnNjcm9sbEhpc3RvcnkgPSB7fTtcblxuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsSGlzdG9yeVtwYXRoXSB8fCBudWxsO1xuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICB0aGlzLmdldFNjcm9sbEJlaGF2aW9yKCkgPT0gbnVsbCB8fCBjYW5Vc2VET00sXG4gICAgICAnQ2Fubm90IHVzZSBzY3JvbGwgYmVoYXZpb3Igd2l0aG91dCBhIERPTSdcbiAgICApO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdXBkYXRlU2Nyb2xsKCk7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbiAocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICB0aGlzLl91cGRhdGVTY3JvbGwocHJldlN0YXRlKTtcbiAgfSxcblxuICBfdXBkYXRlU2Nyb2xsOiBmdW5jdGlvbiAocHJldlN0YXRlKSB7XG4gICAgaWYgKCFzaG91bGRVcGRhdGVTY3JvbGwodGhpcy5zdGF0ZSwgcHJldlN0YXRlKSlcbiAgICAgIHJldHVybjtcblxuICAgIHZhciBzY3JvbGxCZWhhdmlvciA9IHRoaXMuZ2V0U2Nyb2xsQmVoYXZpb3IoKTtcblxuICAgIGlmIChzY3JvbGxCZWhhdmlvcilcbiAgICAgIHNjcm9sbEJlaGF2aW9yLnVwZGF0ZVNjcm9sbFBvc2l0aW9uKFxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmdldFNjcm9sbFBvc2l0aW9uKHRoaXMuc3RhdGUucGF0aCksXG4gICAgICAgIHRoaXMuc3RhdGUuYWN0aW9uXG4gICAgICApO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2Nyb2xsaW5nO1xuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLyoqXG4gKiBBIG1peGluIGZvciBjb21wb25lbnRzIHRoYXQgbmVlZCB0byBrbm93IHRoZSBwYXRoLCByb3V0ZXMsIFVSTFxuICogcGFyYW1zIGFuZCBxdWVyeSB0aGF0IGFyZSBjdXJyZW50bHkgYWN0aXZlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICB2YXIgQWJvdXRMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIG1peGluczogWyBSb3V0ZXIuU3RhdGUgXSxcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAqICAgICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLnByb3BzLmNsYXNzTmFtZTtcbiAqICAgXG4gKiAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSgnYWJvdXQnKSlcbiAqICAgICAgICAgY2xhc3NOYW1lICs9ICcgaXMtYWN0aXZlJztcbiAqICAgXG4gKiAgICAgICByZXR1cm4gUmVhY3QuRE9NLmEoeyBjbGFzc05hbWU6IGNsYXNzTmFtZSB9LCB0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICovXG52YXIgU3RhdGUgPSB7XG5cbiAgY29udGV4dFR5cGVzOiB7XG4gICAgZ2V0Q3VycmVudFBhdGg6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgZ2V0Q3VycmVudFJvdXRlczogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBnZXRDdXJyZW50UGF0aG5hbWU6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgZ2V0Q3VycmVudFBhcmFtczogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBnZXRDdXJyZW50UXVlcnk6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgaXNBY3RpdmU6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBVUkwgcGF0aC5cbiAgICovXG4gIGdldFBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LmdldEN1cnJlbnRQYXRoKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJvdXRlcyB0aGF0IGFyZSBjdXJyZW50bHkgYWN0aXZlLlxuICAgKi9cbiAgZ2V0Um91dGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5nZXRDdXJyZW50Um91dGVzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgVVJMIHBhdGggd2l0aG91dCB0aGUgcXVlcnkgc3RyaW5nLlxuICAgKi9cbiAgZ2V0UGF0aG5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LmdldEN1cnJlbnRQYXRobmFtZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCBvZiB0aGUgVVJMIHBhcmFtcyB0aGF0IGFyZSBjdXJyZW50bHkgYWN0aXZlLlxuICAgKi9cbiAgZ2V0UGFyYW1zOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5nZXRDdXJyZW50UGFyYW1zKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IG9mIHRoZSBxdWVyeSBwYXJhbXMgdGhhdCBhcmUgY3VycmVudGx5IGFjdGl2ZS5cbiAgICovXG4gIGdldFF1ZXJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5nZXRDdXJyZW50UXVlcnkoKTtcbiAgfSxcblxuICAvKipcbiAgICogQSBoZWxwZXIgbWV0aG9kIHRvIGRldGVybWluZSBpZiBhIGdpdmVuIHJvdXRlLCBwYXJhbXMsIGFuZCBxdWVyeVxuICAgKiBhcmUgYWN0aXZlLlxuICAgKi9cbiAgaXNBY3RpdmU6IGZ1bmN0aW9uICh0bywgcGFyYW1zLCBxdWVyeSkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuaXNBY3RpdmUodG8sIHBhcmFtcywgcXVlcnkpO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGU7XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9PYmplY3QuYXNzaWduJyk7XG52YXIgUGF0aCA9IHJlcXVpcmUoJy4uL3V0aWxzL1BhdGgnKTtcblxuZnVuY3Rpb24gcm91dGVJc0FjdGl2ZShhY3RpdmVSb3V0ZXMsIHJvdXRlTmFtZSkge1xuICByZXR1cm4gYWN0aXZlUm91dGVzLnNvbWUoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgcmV0dXJuIHJvdXRlLm5hbWUgPT09IHJvdXRlTmFtZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBhcmFtc0FyZUFjdGl2ZShhY3RpdmVQYXJhbXMsIHBhcmFtcykge1xuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBwYXJhbXMpXG4gICAgaWYgKFN0cmluZyhhY3RpdmVQYXJhbXNbcHJvcGVydHldKSAhPT0gU3RyaW5nKHBhcmFtc1twcm9wZXJ0eV0pKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBxdWVyeUlzQWN0aXZlKGFjdGl2ZVF1ZXJ5LCBxdWVyeSkge1xuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBxdWVyeSlcbiAgICBpZiAoU3RyaW5nKGFjdGl2ZVF1ZXJ5W3Byb3BlcnR5XSkgIT09IFN0cmluZyhxdWVyeVtwcm9wZXJ0eV0pKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIHRoZSByb3V0ZXIgd2l0aCBjb250ZXh0IGZvciBSb3V0ZXIuU3RhdGUuXG4gKi9cbnZhciBTdGF0ZUNvbnRleHQgPSB7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgVVJMIHBhdGggKyBxdWVyeSBzdHJpbmcuXG4gICAqL1xuICBnZXRDdXJyZW50UGF0aDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnBhdGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSByZWFkLW9ubHkgYXJyYXkgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgcm91dGVzLlxuICAgKi9cbiAgZ2V0Q3VycmVudFJvdXRlczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnJvdXRlcy5zbGljZSgwKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBVUkwgcGF0aCB3aXRob3V0IHRoZSBxdWVyeSBzdHJpbmcuXG4gICAqL1xuICBnZXRDdXJyZW50UGF0aG5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5wYXRobmFtZTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHJlYWQtb25seSBvYmplY3Qgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgVVJMIHBhcmFtZXRlcnMuXG4gICAqL1xuICBnZXRDdXJyZW50UGFyYW1zOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFzc2lnbih7fSwgdGhpcy5zdGF0ZS5wYXJhbXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcmVhZC1vbmx5IG9iamVjdCBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBxdWVyeSBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgZ2V0Q3VycmVudFF1ZXJ5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFzc2lnbih7fSwgdGhpcy5zdGF0ZS5xdWVyeSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcm91dGUsIHBhcmFtcywgYW5kIHF1ZXJ5IGFyZSBhY3RpdmUuXG4gICAqL1xuICBpc0FjdGl2ZTogZnVuY3Rpb24gKHRvLCBwYXJhbXMsIHF1ZXJ5KSB7XG4gICAgaWYgKFBhdGguaXNBYnNvbHV0ZSh0bykpXG4gICAgICByZXR1cm4gdG8gPT09IHRoaXMuc3RhdGUucGF0aDtcblxuICAgIHJldHVybiByb3V0ZUlzQWN0aXZlKHRoaXMuc3RhdGUucm91dGVzLCB0bykgJiZcbiAgICAgIHBhcmFtc0FyZUFjdGl2ZSh0aGlzLnN0YXRlLnBhcmFtcywgcGFyYW1zKSAmJlxuICAgICAgKHF1ZXJ5ID09IG51bGwgfHwgcXVlcnlJc0FjdGl2ZSh0aGlzLnN0YXRlLnF1ZXJ5LCBxdWVyeSkpO1xuICB9LFxuXG4gIGNoaWxkQ29udGV4dFR5cGVzOiB7XG4gICAgZ2V0Q3VycmVudFBhdGg6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgZ2V0Q3VycmVudFJvdXRlczogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBnZXRDdXJyZW50UGF0aG5hbWU6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgZ2V0Q3VycmVudFBhcmFtczogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBnZXRDdXJyZW50UXVlcnk6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgaXNBY3RpdmU6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgfSxcblxuICBnZXRDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0Q3VycmVudFBhdGg6IHRoaXMuZ2V0Q3VycmVudFBhdGgsXG4gICAgICBnZXRDdXJyZW50Um91dGVzOiB0aGlzLmdldEN1cnJlbnRSb3V0ZXMsXG4gICAgICBnZXRDdXJyZW50UGF0aG5hbWU6IHRoaXMuZ2V0Q3VycmVudFBhdGhuYW1lLFxuICAgICAgZ2V0Q3VycmVudFBhcmFtczogdGhpcy5nZXRDdXJyZW50UGFyYW1zLFxuICAgICAgZ2V0Q3VycmVudFF1ZXJ5OiB0aGlzLmdldEN1cnJlbnRRdWVyeSxcbiAgICAgIGlzQWN0aXZlOiB0aGlzLmlzQWN0aXZlXG4gICAgfTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlQ29udGV4dDtcbiIsIi8qKlxuICogUmVwcmVzZW50cyBhIGNhbmNlbGxhdGlvbiBjYXVzZWQgYnkgbmF2aWdhdGluZyBhd2F5XG4gKiBiZWZvcmUgdGhlIHByZXZpb3VzIHRyYW5zaXRpb24gaGFzIGZ1bGx5IHJlc29sdmVkLlxuICovXG5mdW5jdGlvbiBDYW5jZWxsYXRpb24oKSB7IH1cblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxsYXRpb247XG4iLCJ2YXIgaW52YXJpYW50ID0gcmVxdWlyZSgncmVhY3QvbGliL2ludmFyaWFudCcpO1xudmFyIGNhblVzZURPTSA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpLmNhblVzZURPTTtcblxudmFyIEhpc3RvcnkgPSB7XG5cbiAgLyoqXG4gICAqIFNlbmRzIHRoZSBicm93c2VyIGJhY2sgb25lIGVudHJ5IGluIHRoZSBoaXN0b3J5LlxuICAgKi9cbiAgYmFjazogZnVuY3Rpb24gKCkge1xuICAgIGludmFyaWFudChcbiAgICAgIGNhblVzZURPTSxcbiAgICAgICdDYW5ub3QgdXNlIEhpc3RvcnkuYmFjayB3aXRob3V0IGEgRE9NJ1xuICAgICk7XG5cbiAgICAvLyBEbyB0aGlzIGZpcnN0IHNvIHRoYXQgSGlzdG9yeS5sZW5ndGggd2lsbFxuICAgIC8vIGJlIGFjY3VyYXRlIGluIGxvY2F0aW9uIGNoYW5nZSBsaXN0ZW5lcnMuXG4gICAgSGlzdG9yeS5sZW5ndGggLT0gMTtcblxuICAgIHdpbmRvdy5oaXN0b3J5LmJhY2soKTtcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIGhpc3RvcnkuXG4gICAqL1xuICBsZW5ndGg6IDFcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIaXN0b3J5O1xuIiwidmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9pbnZhcmlhbnQnKTtcbnZhciBtZXJnZSA9IHJlcXVpcmUoJ3FzL2xpYi91dGlscycpLm1lcmdlO1xudmFyIHFzID0gcmVxdWlyZSgncXMnKTtcblxudmFyIHBhcmFtQ29tcGlsZU1hdGNoZXIgPSAvOihbYS16QS1aXyRdW2EtekEtWjAtOV8kXSopfFsqLigpXFxbXFxdXFxcXCt8e31eJF0vZztcbnZhciBwYXJhbUluamVjdE1hdGNoZXIgPSAvOihbYS16QS1aXyRdW2EtekEtWjAtOV8kP10qWz9dPyl8WypdL2c7XG52YXIgcGFyYW1JbmplY3RUcmFpbGluZ1NsYXNoTWF0Y2hlciA9IC9cXC9cXC9cXD98XFwvXFw/L2c7XG52YXIgcXVlcnlNYXRjaGVyID0gL1xcPyguKykvO1xuXG52YXIgX2NvbXBpbGVkUGF0dGVybnMgPSB7fTtcblxuZnVuY3Rpb24gY29tcGlsZVBhdHRlcm4ocGF0dGVybikge1xuICBpZiAoIShwYXR0ZXJuIGluIF9jb21waWxlZFBhdHRlcm5zKSkge1xuICAgIHZhciBwYXJhbU5hbWVzID0gW107XG4gICAgdmFyIHNvdXJjZSA9IHBhdHRlcm4ucmVwbGFjZShwYXJhbUNvbXBpbGVNYXRjaGVyLCBmdW5jdGlvbiAobWF0Y2gsIHBhcmFtTmFtZSkge1xuICAgICAgaWYgKHBhcmFtTmFtZSkge1xuICAgICAgICBwYXJhbU5hbWVzLnB1c2gocGFyYW1OYW1lKTtcbiAgICAgICAgcmV0dXJuICcoW14vPyNdKyknO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaCA9PT0gJyonKSB7XG4gICAgICAgIHBhcmFtTmFtZXMucHVzaCgnc3BsYXQnKTtcbiAgICAgICAgcmV0dXJuICcoLio/KSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ1xcXFwnICsgbWF0Y2g7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBfY29tcGlsZWRQYXR0ZXJuc1twYXR0ZXJuXSA9IHtcbiAgICAgIG1hdGNoZXI6IG5ldyBSZWdFeHAoJ14nICsgc291cmNlICsgJyQnLCAnaScpLFxuICAgICAgcGFyYW1OYW1lczogcGFyYW1OYW1lc1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2NvbXBpbGVkUGF0dGVybnNbcGF0dGVybl07XG59XG5cbnZhciBQYXRoID0ge1xuXG4gIC8qKlxuICAgKiBTYWZlbHkgZGVjb2RlcyBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIFVSTCBwYXRoLlxuICAgKi9cbiAgZGVjb2RlOiBmdW5jdGlvbiAocGF0aCkge1xuICAgIHJldHVybiBkZWNvZGVVUkkocGF0aC5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhZmVseSBlbmNvZGVzIHNwZWNpYWwgY2hhcmFjdGVycyBpbiB0aGUgZ2l2ZW4gVVJMIHBhdGguXG4gICAqL1xuICBlbmNvZGU6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSShwYXRoKS5yZXBsYWNlKC8lMjAvZywgJysnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgbmFtZXMgb2YgYWxsIHBhcmFtZXRlcnMgaW4gdGhlIGdpdmVuIHBhdHRlcm4uXG4gICAqL1xuICBleHRyYWN0UGFyYW1OYW1lczogZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgICByZXR1cm4gY29tcGlsZVBhdHRlcm4ocGF0dGVybikucGFyYW1OYW1lcztcbiAgfSxcblxuICAvKipcbiAgICogRXh0cmFjdHMgdGhlIHBvcnRpb25zIG9mIHRoZSBnaXZlbiBVUkwgcGF0aCB0aGF0IG1hdGNoIHRoZSBnaXZlbiBwYXR0ZXJuXG4gICAqIGFuZCByZXR1cm5zIGFuIG9iamVjdCBvZiBwYXJhbSBuYW1lID0+IHZhbHVlIHBhaXJzLiBSZXR1cm5zIG51bGwgaWYgdGhlXG4gICAqIHBhdHRlcm4gZG9lcyBub3QgbWF0Y2ggdGhlIGdpdmVuIHBhdGguXG4gICAqL1xuICBleHRyYWN0UGFyYW1zOiBmdW5jdGlvbiAocGF0dGVybiwgcGF0aCkge1xuICAgIHZhciBvYmplY3QgPSBjb21waWxlUGF0dGVybihwYXR0ZXJuKTtcbiAgICB2YXIgbWF0Y2ggPSBwYXRoLm1hdGNoKG9iamVjdC5tYXRjaGVyKTtcblxuICAgIGlmICghbWF0Y2gpXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIHZhciBwYXJhbXMgPSB7fTtcblxuICAgIG9iamVjdC5wYXJhbU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtTmFtZSwgaW5kZXgpIHtcbiAgICAgIHBhcmFtc1twYXJhbU5hbWVdID0gbWF0Y2hbaW5kZXggKyAxXTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2ZXJzaW9uIG9mIHRoZSBnaXZlbiByb3V0ZSBwYXRoIHdpdGggcGFyYW1zIGludGVycG9sYXRlZC4gVGhyb3dzXG4gICAqIGlmIHRoZXJlIGlzIGEgZHluYW1pYyBzZWdtZW50IG9mIHRoZSByb3V0ZSBwYXRoIGZvciB3aGljaCB0aGVyZSBpcyBubyBwYXJhbS5cbiAgICovXG4gIGluamVjdFBhcmFtczogZnVuY3Rpb24gKHBhdHRlcm4sIHBhcmFtcykge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICAgIHZhciBzcGxhdEluZGV4ID0gMDtcblxuICAgIHJldHVybiBwYXR0ZXJuLnJlcGxhY2UocGFyYW1JbmplY3RNYXRjaGVyLCBmdW5jdGlvbiAobWF0Y2gsIHBhcmFtTmFtZSkge1xuICAgICAgcGFyYW1OYW1lID0gcGFyYW1OYW1lIHx8ICdzcGxhdCc7XG5cbiAgICAgIC8vIElmIHBhcmFtIGlzIG9wdGlvbmFsIGRvbid0IGNoZWNrIGZvciBleGlzdGVuY2VcbiAgICAgIGlmIChwYXJhbU5hbWUuc2xpY2UoLTEpICE9PSAnPycpIHtcbiAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgIHBhcmFtc1twYXJhbU5hbWVdICE9IG51bGwsXG4gICAgICAgICAgJ01pc3NpbmcgXCInICsgcGFyYW1OYW1lICsgJ1wiIHBhcmFtZXRlciBmb3IgcGF0aCBcIicgKyBwYXR0ZXJuICsgJ1wiJ1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1OYW1lID0gcGFyYW1OYW1lLnNsaWNlKDAsIC0xKTtcblxuICAgICAgICBpZiAocGFyYW1zW3BhcmFtTmFtZV0gPT0gbnVsbClcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWdtZW50O1xuICAgICAgaWYgKHBhcmFtTmFtZSA9PT0gJ3NwbGF0JyAmJiBBcnJheS5pc0FycmF5KHBhcmFtc1twYXJhbU5hbWVdKSkge1xuICAgICAgICBzZWdtZW50ID0gcGFyYW1zW3BhcmFtTmFtZV1bc3BsYXRJbmRleCsrXTtcblxuICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgc2VnbWVudCAhPSBudWxsLFxuICAgICAgICAgICdNaXNzaW5nIHNwbGF0ICMgJyArIHNwbGF0SW5kZXggKyAnIGZvciBwYXRoIFwiJyArIHBhdHRlcm4gKyAnXCInXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWdtZW50ID0gcGFyYW1zW3BhcmFtTmFtZV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWdtZW50O1xuICAgIH0pLnJlcGxhY2UocGFyYW1JbmplY3RUcmFpbGluZ1NsYXNoTWF0Y2hlciwgJy8nKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBpcyB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgYW55IHF1ZXJ5IHN0cmluZyBjb250YWluZWRcbiAgICogaW4gdGhlIGdpdmVuIHBhdGgsIG51bGwgaWYgdGhlIHBhdGggY29udGFpbnMgbm8gcXVlcnkgc3RyaW5nLlxuICAgKi9cbiAgZXh0cmFjdFF1ZXJ5OiBmdW5jdGlvbiAocGF0aCkge1xuICAgIHZhciBtYXRjaCA9IHBhdGgubWF0Y2gocXVlcnlNYXRjaGVyKTtcbiAgICByZXR1cm4gbWF0Y2ggJiYgcXMucGFyc2UobWF0Y2hbMV0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gcGF0aCB3aXRob3V0IHRoZSBxdWVyeSBzdHJpbmcuXG4gICAqL1xuICB3aXRob3V0UXVlcnk6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZShxdWVyeU1hdGNoZXIsICcnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZlcnNpb24gb2YgdGhlIGdpdmVuIHBhdGggd2l0aCB0aGUgcGFyYW1ldGVycyBpbiB0aGUgZ2l2ZW5cbiAgICogcXVlcnkgbWVyZ2VkIGludG8gdGhlIHF1ZXJ5IHN0cmluZy5cbiAgICovXG4gIHdpdGhRdWVyeTogZnVuY3Rpb24gKHBhdGgsIHF1ZXJ5KSB7XG4gICAgdmFyIGV4aXN0aW5nUXVlcnkgPSBQYXRoLmV4dHJhY3RRdWVyeShwYXRoKTtcblxuICAgIGlmIChleGlzdGluZ1F1ZXJ5KVxuICAgICAgcXVlcnkgPSBxdWVyeSA/IG1lcmdlKGV4aXN0aW5nUXVlcnksIHF1ZXJ5KSA6IGV4aXN0aW5nUXVlcnk7XG5cbiAgICB2YXIgcXVlcnlTdHJpbmcgPSBxdWVyeSAmJiBxcy5zdHJpbmdpZnkocXVlcnkpO1xuXG4gICAgaWYgKHF1ZXJ5U3RyaW5nKVxuICAgICAgcmV0dXJuIFBhdGgud2l0aG91dFF1ZXJ5KHBhdGgpICsgJz8nICsgcXVlcnlTdHJpbmc7XG5cbiAgICByZXR1cm4gcGF0aDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwYXRoIGlzIGFic29sdXRlLlxuICAgKi9cbiAgaXNBYnNvbHV0ZTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gcGF0aC5cbiAgICovXG4gIG5vcm1hbGl6ZTogZnVuY3Rpb24gKHBhdGgsIHBhcmVudFJvdXRlKSB7XG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXlxcLyovLCAnLycpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBKb2lucyB0d28gVVJMIHBhdGhzIHRvZ2V0aGVyLlxuICAgKi9cbiAgam9pbjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS5yZXBsYWNlKC9cXC8qJC8sICcvJykgKyBiO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGF0aDtcbiIsInZhciBQcm9taXNlID0gcmVxdWlyZSgnd2hlbi9saWIvUHJvbWlzZScpO1xuXG4vLyBUT0RPOiBVc2UgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgY2hlY2sgKyBlbnZpZnkgdG8gZW5hYmxlXG4vLyB3aGVuJ3MgcHJvbWlzZSBtb25pdG9yIGhlcmUgd2hlbiBpbiBkZXYuXG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcbiIsInZhciBQcm9wVHlwZXMgPSB7XG5cbiAgLyoqXG4gICAqIFJlcXVpcmVzIHRoYXQgdGhlIHZhbHVlIG9mIGEgcHJvcCBiZSBmYWxzeS5cbiAgICovXG4gIGZhbHN5OiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSlcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJzwnICsgY29tcG9uZW50TmFtZSArICc+IG1heSBub3QgaGF2ZSBhIFwiJyArIHByb3BOYW1lICsgJ1wiIHByb3AnKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb3BUeXBlcztcbiIsIi8qKlxuICogRW5jYXBzdWxhdGVzIGEgcmVkaXJlY3QgdG8gdGhlIGdpdmVuIHJvdXRlLlxuICovXG5mdW5jdGlvbiBSZWRpcmVjdCh0bywgcGFyYW1zLCBxdWVyeSkge1xuICB0aGlzLnRvID0gdG87XG4gIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVkaXJlY3Q7XG4iLCJ2YXIgYXNzaWduID0gcmVxdWlyZSgncmVhY3QvbGliL09iamVjdC5hc3NpZ24nKTtcbnZhciByZXZlcnNlZEFycmF5ID0gcmVxdWlyZSgnLi9yZXZlcnNlZEFycmF5Jyk7XG52YXIgUmVkaXJlY3QgPSByZXF1aXJlKCcuL1JlZGlyZWN0Jyk7XG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vUHJvbWlzZScpO1xuXG4vKipcbiAqIFJ1bnMgYWxsIGhvb2sgZnVuY3Rpb25zIHNlcmlhbGx5IGFuZCBjYWxscyBjYWxsYmFjayhlcnJvcikgd2hlbiBmaW5pc2hlZC5cbiAqIEEgaG9vayBtYXkgcmV0dXJuIGEgcHJvbWlzZSBpZiBpdCBuZWVkcyB0byBleGVjdXRlIGFzeW5jaHJvbm91c2x5LlxuICovXG5mdW5jdGlvbiBydW5Ib29rcyhob29rcywgY2FsbGJhY2spIHtcbiAgdmFyIHByb21pc2U7XG4gIHRyeSB7XG4gICAgcHJvbWlzZSA9IGhvb2tzLnJlZHVjZShmdW5jdGlvbiAocHJvbWlzZSwgaG9vaykge1xuICAgICAgLy8gVGhlIGZpcnN0IGhvb2sgdG8gdXNlIHRyYW5zaXRpb24ud2FpdCBtYWtlcyB0aGUgcmVzdFxuICAgICAgLy8gb2YgdGhlIHRyYW5zaXRpb24gYXN5bmMgZnJvbSB0aGF0IHBvaW50IGZvcndhcmQuXG4gICAgICByZXR1cm4gcHJvbWlzZSA/IHByb21pc2UudGhlbihob29rKSA6IGhvb2soKTtcbiAgICB9LCBudWxsKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IpOyAvLyBTeW5jIGVycm9yLlxuICB9XG5cbiAgaWYgKHByb21pc2UpIHtcbiAgICAvLyBVc2Ugc2V0VGltZW91dCB0byBicmVhayB0aGUgcHJvbWlzZSBjaGFpbi5cbiAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChjYWxsYmFjayk7XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuXG4vKipcbiAqIENhbGxzIHRoZSB3aWxsVHJhbnNpdGlvbkZyb20gaG9vayBvZiBhbGwgaGFuZGxlcnMgaW4gdGhlIGdpdmVuIG1hdGNoZXNcbiAqIHNlcmlhbGx5IGluIHJldmVyc2Ugd2l0aCB0aGUgdHJhbnNpdGlvbiBvYmplY3QgYW5kIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mXG4gKiB0aGUgcm91dGUncyBoYW5kbGVyLCBzbyB0aGF0IHRoZSBkZWVwZXN0IG5lc3RlZCBoYW5kbGVycyBhcmUgY2FsbGVkIGZpcnN0LlxuICogQ2FsbHMgY2FsbGJhY2soZXJyb3IpIHdoZW4gZmluaXNoZWQuXG4gKi9cbmZ1bmN0aW9uIHJ1blRyYW5zaXRpb25Gcm9tSG9va3ModHJhbnNpdGlvbiwgcm91dGVzLCBjb21wb25lbnRzLCBjYWxsYmFjaykge1xuICBjb21wb25lbnRzID0gcmV2ZXJzZWRBcnJheShjb21wb25lbnRzKTtcblxuICB2YXIgaG9va3MgPSByZXZlcnNlZEFycmF5KHJvdXRlcykubWFwKGZ1bmN0aW9uIChyb3V0ZSwgaW5kZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGhhbmRsZXIgPSByb3V0ZS5oYW5kbGVyO1xuXG4gICAgICBpZiAoIXRyYW5zaXRpb24uaXNBYm9ydGVkICYmIGhhbmRsZXIud2lsbFRyYW5zaXRpb25Gcm9tKVxuICAgICAgICByZXR1cm4gaGFuZGxlci53aWxsVHJhbnNpdGlvbkZyb20odHJhbnNpdGlvbiwgY29tcG9uZW50c1tpbmRleF0pO1xuXG4gICAgICB2YXIgcHJvbWlzZSA9IHRyYW5zaXRpb24uX3Byb21pc2U7XG4gICAgICB0cmFuc2l0aW9uLl9wcm9taXNlID0gbnVsbDtcblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcbiAgfSk7XG5cbiAgcnVuSG9va3MoaG9va3MsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBDYWxscyB0aGUgd2lsbFRyYW5zaXRpb25UbyBob29rIG9mIGFsbCBoYW5kbGVycyBpbiB0aGUgZ2l2ZW4gbWF0Y2hlc1xuICogc2VyaWFsbHkgd2l0aCB0aGUgdHJhbnNpdGlvbiBvYmplY3QgYW5kIGFueSBwYXJhbXMgdGhhdCBhcHBseSB0byB0aGF0XG4gKiBoYW5kbGVyLiBDYWxscyBjYWxsYmFjayhlcnJvcikgd2hlbiBmaW5pc2hlZC5cbiAqL1xuZnVuY3Rpb24gcnVuVHJhbnNpdGlvblRvSG9va3ModHJhbnNpdGlvbiwgcm91dGVzLCBwYXJhbXMsIHF1ZXJ5LCBjYWxsYmFjaykge1xuICB2YXIgaG9va3MgPSByb3V0ZXMubWFwKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IHJvdXRlLmhhbmRsZXI7XG5cbiAgICAgIGlmICghdHJhbnNpdGlvbi5pc0Fib3J0ZWQgJiYgaGFuZGxlci53aWxsVHJhbnNpdGlvblRvKVxuICAgICAgICBoYW5kbGVyLndpbGxUcmFuc2l0aW9uVG8odHJhbnNpdGlvbiwgcGFyYW1zLCBxdWVyeSk7XG5cbiAgICAgIHZhciBwcm9taXNlID0gdHJhbnNpdGlvbi5fcHJvbWlzZTtcbiAgICAgIHRyYW5zaXRpb24uX3Byb21pc2UgPSBudWxsO1xuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuICB9KTtcblxuICBydW5Ib29rcyhob29rcywgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIEVuY2Fwc3VsYXRlcyBhIHRyYW5zaXRpb24gdG8gYSBnaXZlbiBwYXRoLlxuICpcbiAqIFRoZSB3aWxsVHJhbnNpdGlvblRvIGFuZCB3aWxsVHJhbnNpdGlvbkZyb20gaGFuZGxlcnMgcmVjZWl2ZVxuICogYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBhcyB0aGVpciBmaXJzdCBhcmd1bWVudC5cbiAqL1xuZnVuY3Rpb24gVHJhbnNpdGlvbihwYXRoLCByZXRyeSkge1xuICB0aGlzLnBhdGggPSBwYXRoO1xuICB0aGlzLmFib3J0UmVhc29uID0gbnVsbDtcbiAgdGhpcy5pc0Fib3J0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZXRyeSA9IHJldHJ5LmJpbmQodGhpcyk7XG4gIHRoaXMuX3Byb21pc2UgPSBudWxsO1xufVxuXG5hc3NpZ24oVHJhbnNpdGlvbi5wcm90b3R5cGUsIHtcblxuICBhYm9ydDogZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIGlmICh0aGlzLmlzQWJvcnRlZCkge1xuICAgICAgLy8gRmlyc3QgYWJvcnQgd2lucy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmFib3J0UmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMuaXNBYm9ydGVkID0gdHJ1ZTtcbiAgfSxcblxuICByZWRpcmVjdDogZnVuY3Rpb24gKHRvLCBwYXJhbXMsIHF1ZXJ5KSB7XG4gICAgdGhpcy5hYm9ydChuZXcgUmVkaXJlY3QodG8sIHBhcmFtcywgcXVlcnkpKTtcbiAgfSxcblxuICB3YWl0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLl9wcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcbiAgfSxcblxuICBmcm9tOiBmdW5jdGlvbiAocm91dGVzLCBjb21wb25lbnRzLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBydW5UcmFuc2l0aW9uRnJvbUhvb2tzKHRoaXMsIHJvdXRlcywgY29tcG9uZW50cywgY2FsbGJhY2spO1xuICB9LFxuXG4gIHRvOiBmdW5jdGlvbiAocm91dGVzLCBwYXJhbXMsIHF1ZXJ5LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBydW5UcmFuc2l0aW9uVG9Ib29rcyh0aGlzLCByb3V0ZXMsIHBhcmFtcywgcXVlcnksIGNhbGxiYWNrKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2l0aW9uO1xuIiwiLyoganNoaW50IC1XMDU4ICovXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdyZWFjdC9saWIvd2FybmluZycpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9pbnZhcmlhbnQnKTtcbnZhciBjYW5Vc2VET00gPSByZXF1aXJlKCdyZWFjdC9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKS5jYW5Vc2VET007XG52YXIgSW1pdGF0ZUJyb3dzZXJCZWhhdmlvciA9IHJlcXVpcmUoJy4uL2JlaGF2aW9ycy9JbWl0YXRlQnJvd3NlckJlaGF2aW9yJyk7XG52YXIgUm91dGVIYW5kbGVyID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9Sb3V0ZUhhbmRsZXInKTtcbnZhciBMb2NhdGlvbkFjdGlvbnMgPSByZXF1aXJlKCcuLi9hY3Rpb25zL0xvY2F0aW9uQWN0aW9ucycpO1xudmFyIEhhc2hMb2NhdGlvbiA9IHJlcXVpcmUoJy4uL2xvY2F0aW9ucy9IYXNoTG9jYXRpb24nKTtcbnZhciBIaXN0b3J5TG9jYXRpb24gPSByZXF1aXJlKCcuLi9sb2NhdGlvbnMvSGlzdG9yeUxvY2F0aW9uJyk7XG52YXIgUmVmcmVzaExvY2F0aW9uID0gcmVxdWlyZSgnLi4vbG9jYXRpb25zL1JlZnJlc2hMb2NhdGlvbicpO1xudmFyIE5hdmlnYXRpb25Db250ZXh0ID0gcmVxdWlyZSgnLi4vbWl4aW5zL05hdmlnYXRpb25Db250ZXh0Jyk7XG52YXIgU3RhdGVDb250ZXh0ID0gcmVxdWlyZSgnLi4vbWl4aW5zL1N0YXRlQ29udGV4dCcpO1xudmFyIFNjcm9sbGluZyA9IHJlcXVpcmUoJy4uL21peGlucy9TY3JvbGxpbmcnKTtcbnZhciBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4gPSByZXF1aXJlKCcuL2NyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbicpO1xudmFyIHN1cHBvcnRzSGlzdG9yeSA9IHJlcXVpcmUoJy4vc3VwcG9ydHNIaXN0b3J5Jyk7XG52YXIgVHJhbnNpdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNpdGlvbicpO1xudmFyIFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vUHJvcFR5cGVzJyk7XG52YXIgUmVkaXJlY3QgPSByZXF1aXJlKCcuL1JlZGlyZWN0Jyk7XG52YXIgSGlzdG9yeSA9IHJlcXVpcmUoJy4vSGlzdG9yeScpO1xudmFyIENhbmNlbGxhdGlvbiA9IHJlcXVpcmUoJy4vQ2FuY2VsbGF0aW9uJyk7XG52YXIgUGF0aCA9IHJlcXVpcmUoJy4vUGF0aCcpO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGxvY2F0aW9uIGZvciBuZXcgcm91dGVycy5cbiAqL1xudmFyIERFRkFVTFRfTE9DQVRJT04gPSBjYW5Vc2VET00gPyBIYXNoTG9jYXRpb24gOiAnLyc7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgc2Nyb2xsIGJlaGF2aW9yIGZvciBuZXcgcm91dGVycy5cbiAqL1xudmFyIERFRkFVTFRfU0NST0xMX0JFSEFWSU9SID0gY2FuVXNlRE9NID8gSW1pdGF0ZUJyb3dzZXJCZWhhdmlvciA6IG51bGw7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgZXJyb3IgaGFuZGxlciBmb3IgbmV3IHJvdXRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRFcnJvckhhbmRsZXIoZXJyb3IpIHtcbiAgLy8gVGhyb3cgc28gd2UgZG9uJ3Qgc2lsZW50bHkgc3dhbGxvdyBhc3luYyBlcnJvcnMuXG4gIHRocm93IGVycm9yOyAvLyBUaGlzIGVycm9yIHByb2JhYmx5IG9yaWdpbmF0ZWQgaW4gYSB0cmFuc2l0aW9uIGhvb2suXG59XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgYWJvcnRlZCB0cmFuc2l0aW9uIGhhbmRsZXIgZm9yIG5ldyByb3V0ZXJzLlxuICovXG5mdW5jdGlvbiBkZWZhdWx0QWJvcnRIYW5kbGVyKGFib3J0UmVhc29uLCBsb2NhdGlvbikge1xuICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBhYm9ydGVkIHRyYW5zaXRpb24hIFJlYXNvbjogJyArIGFib3J0UmVhc29uKTtcblxuICBpZiAoYWJvcnRSZWFzb24gaW5zdGFuY2VvZiBDYW5jZWxsYXRpb24pIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoYWJvcnRSZWFzb24gaW5zdGFuY2VvZiBSZWRpcmVjdCkge1xuICAgIGxvY2F0aW9uLnJlcGxhY2UodGhpcy5tYWtlUGF0aChhYm9ydFJlYXNvbi50bywgYWJvcnRSZWFzb24ucGFyYW1zLCBhYm9ydFJlYXNvbi5xdWVyeSkpO1xuICB9IGVsc2Uge1xuICAgIGxvY2F0aW9uLnBvcCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRNYXRjaChwYXRobmFtZSwgcm91dGVzLCBkZWZhdWx0Um91dGUsIG5vdEZvdW5kUm91dGUpIHtcbiAgdmFyIG1hdGNoLCByb3V0ZSwgcGFyYW1zO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSByb3V0ZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICByb3V0ZSA9IHJvdXRlc1tpXTtcblxuICAgIC8vIENoZWNrIHRoZSBzdWJ0cmVlIGZpcnN0IHRvIGZpbmQgdGhlIG1vc3QgZGVlcGx5LW5lc3RlZCBtYXRjaC5cbiAgICBtYXRjaCA9IGZpbmRNYXRjaChwYXRobmFtZSwgcm91dGUuY2hpbGRSb3V0ZXMsIHJvdXRlLmRlZmF1bHRSb3V0ZSwgcm91dGUubm90Rm91bmRSb3V0ZSk7XG5cbiAgICBpZiAobWF0Y2ggIT0gbnVsbCkge1xuICAgICAgbWF0Y2gucm91dGVzLnVuc2hpZnQocm91dGUpO1xuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cblxuICAgIC8vIE5vIHJvdXRlcyBpbiB0aGUgc3VidHJlZSBtYXRjaGVkLCBzbyBjaGVjayB0aGlzIHJvdXRlLlxuICAgIHBhcmFtcyA9IFBhdGguZXh0cmFjdFBhcmFtcyhyb3V0ZS5wYXRoLCBwYXRobmFtZSk7XG5cbiAgICBpZiAocGFyYW1zKVxuICAgICAgcmV0dXJuIGNyZWF0ZU1hdGNoKHJvdXRlLCBwYXJhbXMpO1xuICB9XG5cbiAgLy8gTm8gcm91dGVzIG1hdGNoZWQsIHNvIHRyeSB0aGUgZGVmYXVsdCByb3V0ZSBpZiB0aGVyZSBpcyBvbmUuXG4gIGlmIChkZWZhdWx0Um91dGUgJiYgKHBhcmFtcyA9IFBhdGguZXh0cmFjdFBhcmFtcyhkZWZhdWx0Um91dGUucGF0aCwgcGF0aG5hbWUpKSlcbiAgICByZXR1cm4gY3JlYXRlTWF0Y2goZGVmYXVsdFJvdXRlLCBwYXJhbXMpO1xuXG4gIC8vIExhc3QgYXR0ZW1wdDogZG9lcyB0aGUgXCJub3QgZm91bmRcIiByb3V0ZSBtYXRjaD9cbiAgaWYgKG5vdEZvdW5kUm91dGUgJiYgKHBhcmFtcyA9IFBhdGguZXh0cmFjdFBhcmFtcyhub3RGb3VuZFJvdXRlLnBhdGgsIHBhdGhuYW1lKSkpXG4gICAgcmV0dXJuIGNyZWF0ZU1hdGNoKG5vdEZvdW5kUm91dGUsIHBhcmFtcyk7XG5cbiAgcmV0dXJuIG1hdGNoO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNYXRjaChyb3V0ZSwgcGFyYW1zKSB7XG4gIHJldHVybiB7IHJvdXRlczogWyByb3V0ZSBdLCBwYXJhbXM6IHBhcmFtcyB9O1xufVxuXG5mdW5jdGlvbiBoYXNQcm9wZXJ0aWVzKG9iamVjdCwgcHJvcGVydGllcykge1xuICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gcHJvcGVydGllcylcbiAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpICYmIG9iamVjdFtwcm9wZXJ0eU5hbWVdICE9PSBwcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGhhc01hdGNoKHJvdXRlcywgcm91dGUsIHByZXZQYXJhbXMsIG5leHRQYXJhbXMsIHByZXZRdWVyeSwgbmV4dFF1ZXJ5KSB7XG4gIHJldHVybiByb3V0ZXMuc29tZShmdW5jdGlvbiAocikge1xuICAgIGlmIChyICE9PSByb3V0ZSlcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBwYXJhbU5hbWVzID0gcm91dGUucGFyYW1OYW1lcztcbiAgICB2YXIgcGFyYW1OYW1lO1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgYWxsIHBhcmFtcyB0aGUgcm91dGUgY2FyZXMgYWJvdXQgZGlkIG5vdCBjaGFuZ2UuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcmFtTmFtZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHBhcmFtTmFtZSA9IHBhcmFtTmFtZXNbaV07XG5cbiAgICAgIGlmIChuZXh0UGFyYW1zW3BhcmFtTmFtZV0gIT09IHByZXZQYXJhbXNbcGFyYW1OYW1lXSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSB0aGUgcXVlcnkgaGFzbid0IGNoYW5nZWQuXG4gICAgcmV0dXJuIGhhc1Byb3BlcnRpZXMocHJldlF1ZXJ5LCBuZXh0UXVlcnkpICYmIGhhc1Byb3BlcnRpZXMobmV4dFF1ZXJ5LCBwcmV2UXVlcnkpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3IHJvdXRlciB1c2luZyB0aGUgZ2l2ZW4gb3B0aW9ucy4gQSByb3V0ZXJcbiAqIGlzIGEgUmVhY3RDb21wb25lbnQgY2xhc3MgdGhhdCBrbm93cyBob3cgdG8gcmVhY3QgdG8gY2hhbmdlcyBpbiB0aGVcbiAqIFVSTCBhbmQga2VlcCB0aGUgY29udGVudHMgb2YgdGhlIHBhZ2UgaW4gc3luYy5cbiAqXG4gKiBPcHRpb25zIG1heSBiZSBhbnkgb2YgdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAtIHJvdXRlcyAgICAgICAgICAgKHJlcXVpcmVkKSBUaGUgcm91dGUgY29uZmlnXG4gKiAtIGxvY2F0aW9uICAgICAgICAgVGhlIGxvY2F0aW9uIHRvIHVzZS4gRGVmYXVsdHMgdG8gSGFzaExvY2F0aW9uIHdoZW5cbiAqICAgICAgICAgICAgICAgICAgICB0aGUgRE9NIGlzIGF2YWlsYWJsZSwgXCIvXCIgb3RoZXJ3aXNlXG4gKiAtIHNjcm9sbEJlaGF2aW9yICAgVGhlIHNjcm9sbCBiZWhhdmlvciB0byB1c2UuIERlZmF1bHRzIHRvIEltaXRhdGVCcm93c2VyQmVoYXZpb3JcbiAqICAgICAgICAgICAgICAgICAgICB3aGVuIHRoZSBET00gaXMgYXZhaWxhYmxlLCBudWxsIG90aGVyd2lzZVxuICogLSBvbkVycm9yICAgICAgICAgIEEgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGhhbmRsZSBlcnJvcnNcbiAqIC0gb25BYm9ydCAgICAgICAgICBBIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBoYW5kbGUgYWJvcnRlZCB0cmFuc2l0aW9uc1xuICpcbiAqIFdoZW4gcmVuZGVyaW5nIGluIGEgc2VydmVyLXNpZGUgZW52aXJvbm1lbnQsIHRoZSBsb2NhdGlvbiBzaG91bGQgc2ltcGx5XG4gKiBiZSB0aGUgVVJMIHBhdGggdGhhdCB3YXMgdXNlZCBpbiB0aGUgcmVxdWVzdCwgaW5jbHVkaW5nIHRoZSBxdWVyeSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlcihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMgPSB7IHJvdXRlczogb3B0aW9ucyB9OyAvLyBSb3V0ZXIuY3JlYXRlKDxSb3V0ZT4pXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgIG9wdGlvbnMgPSB7IHJvdXRlczogb3B0aW9ucyB9OyAvLyBSb3V0ZXIuY3JlYXRlKFsgPFJvdXRlPiwgPFJvdXRlPiBdKVxuICB9XG5cbiAgdmFyIHJvdXRlcyA9IFtdO1xuICB2YXIgbmFtZWRSb3V0ZXMgPSB7fTtcbiAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgdmFyIGxvY2F0aW9uID0gb3B0aW9ucy5sb2NhdGlvbiB8fCBERUZBVUxUX0xPQ0FUSU9OO1xuICB2YXIgc2Nyb2xsQmVoYXZpb3IgPSBvcHRpb25zLnNjcm9sbEJlaGF2aW9yIHx8IERFRkFVTFRfU0NST0xMX0JFSEFWSU9SO1xuICB2YXIgb25FcnJvciA9IG9wdGlvbnMub25FcnJvciB8fCBkZWZhdWx0RXJyb3JIYW5kbGVyO1xuICB2YXIgb25BYm9ydCA9IG9wdGlvbnMub25BYm9ydCB8fCBkZWZhdWx0QWJvcnRIYW5kbGVyO1xuICB2YXIgc3RhdGUgPSB7fTtcbiAgdmFyIG5leHRTdGF0ZSA9IHt9O1xuICB2YXIgcGVuZGluZ1RyYW5zaXRpb24gPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKCkge1xuICAgIHN0YXRlID0gbmV4dFN0YXRlO1xuICAgIG5leHRTdGF0ZSA9IHt9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgIWNhblVzZURPTSB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnLFxuICAgICAgJ1lvdSBzaG91bGQgbm90IHVzZSBhIHN0YXRpYyBsb2NhdGlvbiBpbiBhIERPTSBlbnZpcm9ubWVudCBiZWNhdXNlICcgK1xuICAgICAgJ3RoZSByb3V0ZXIgd2lsbCBub3QgYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIGN1cnJlbnQgVVJMJ1xuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgY2FuVXNlRE9NLFxuICAgICAgJ1lvdSBjYW5ub3QgdXNlICVzIHdpdGhvdXQgYSBET00nLFxuICAgICAgbG9jYXRpb25cbiAgICApO1xuICB9XG5cbiAgLy8gQXV0b21hdGljYWxseSBmYWxsIGJhY2sgdG8gZnVsbCBwYWdlIHJlZnJlc2hlcyBpblxuICAvLyBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdGhlIEhUTUwgaGlzdG9yeSBBUEkuXG4gIGlmIChsb2NhdGlvbiA9PT0gSGlzdG9yeUxvY2F0aW9uICYmICFzdXBwb3J0c0hpc3RvcnkoKSlcbiAgICBsb2NhdGlvbiA9IFJlZnJlc2hMb2NhdGlvbjtcblxuICB2YXIgcm91dGVyID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gICAgZGlzcGxheU5hbWU6ICdSb3V0ZXInLFxuXG4gICAgbWl4aW5zOiBbIE5hdmlnYXRpb25Db250ZXh0LCBTdGF0ZUNvbnRleHQsIFNjcm9sbGluZyBdLFxuXG4gICAgc3RhdGljczoge1xuXG4gICAgICBkZWZhdWx0Um91dGU6IG51bGwsXG4gICAgICBub3RGb3VuZFJvdXRlOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgcm91dGVzIHRvIHRoaXMgcm91dGVyIGZyb20gdGhlIGdpdmVuIGNoaWxkcmVuIG9iamVjdCAoc2VlIFJlYWN0Q2hpbGRyZW4pLlxuICAgICAgICovXG4gICAgICBhZGRSb3V0ZXM6IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgICAgICByb3V0ZXMucHVzaC5hcHBseShyb3V0ZXMsIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihjaGlsZHJlbiwgdGhpcywgbmFtZWRSb3V0ZXMpKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhbiBhYnNvbHV0ZSBVUkwgcGF0aCBjcmVhdGVkIGZyb20gdGhlIGdpdmVuIHJvdXRlXG4gICAgICAgKiBuYW1lLCBVUkwgcGFyYW1ldGVycywgYW5kIHF1ZXJ5LlxuICAgICAgICovXG4gICAgICBtYWtlUGF0aDogZnVuY3Rpb24gKHRvLCBwYXJhbXMsIHF1ZXJ5KSB7XG4gICAgICAgIHZhciBwYXRoO1xuICAgICAgICBpZiAoUGF0aC5pc0Fic29sdXRlKHRvKSkge1xuICAgICAgICAgIHBhdGggPSBQYXRoLm5vcm1hbGl6ZSh0byk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJvdXRlID0gbmFtZWRSb3V0ZXNbdG9dO1xuXG4gICAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICAnVW5hYmxlIHRvIGZpbmQgPFJvdXRlIG5hbWU9XCIlc1wiPicsXG4gICAgICAgICAgICB0b1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBwYXRoID0gcm91dGUucGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQYXRoLndpdGhRdWVyeShQYXRoLmluamVjdFBhcmFtcyhwYXRoLCBwYXJhbXMpLCBxdWVyeSk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgdGhhdCBtYXkgc2FmZWx5IGJlIHVzZWQgYXMgdGhlIGhyZWYgb2YgYSBsaW5rXG4gICAgICAgKiB0byB0aGUgcm91dGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZSwgVVJMIHBhcmFtZXRlcnMsIGFuZCBxdWVyeS5cbiAgICAgICAqL1xuICAgICAgbWFrZUhyZWY6IGZ1bmN0aW9uICh0bywgcGFyYW1zLCBxdWVyeSkge1xuICAgICAgICB2YXIgcGF0aCA9IHRoaXMubWFrZVBhdGgodG8sIHBhcmFtcywgcXVlcnkpO1xuICAgICAgICByZXR1cm4gKGxvY2F0aW9uID09PSBIYXNoTG9jYXRpb24pID8gJyMnICsgcGF0aCA6IHBhdGg7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zaXRpb25zIHRvIHRoZSBVUkwgc3BlY2lmaWVkIGluIHRoZSBhcmd1bWVudHMgYnkgcHVzaGluZ1xuICAgICAgICogYSBuZXcgVVJMIG9udG8gdGhlIGhpc3Rvcnkgc3RhY2suXG4gICAgICAgKi9cbiAgICAgIHRyYW5zaXRpb25UbzogZnVuY3Rpb24gKHRvLCBwYXJhbXMsIHF1ZXJ5KSB7XG4gICAgICAgIGludmFyaWFudChcbiAgICAgICAgICB0eXBlb2YgbG9jYXRpb24gIT09ICdzdHJpbmcnLFxuICAgICAgICAgICdZb3UgY2Fubm90IHVzZSB0cmFuc2l0aW9uVG8gd2l0aCBhIHN0YXRpYyBsb2NhdGlvbidcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMubWFrZVBhdGgodG8sIHBhcmFtcywgcXVlcnkpO1xuXG4gICAgICAgIGlmIChwZW5kaW5nVHJhbnNpdGlvbikge1xuICAgICAgICAgIC8vIFJlcGxhY2Ugc28gcGVuZGluZyBsb2NhdGlvbiBkb2VzIG5vdCBzdGF5IGluIGhpc3RvcnkuXG4gICAgICAgICAgbG9jYXRpb24ucmVwbGFjZShwYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2NhdGlvbi5wdXNoKHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zaXRpb25zIHRvIHRoZSBVUkwgc3BlY2lmaWVkIGluIHRoZSBhcmd1bWVudHMgYnkgcmVwbGFjaW5nXG4gICAgICAgKiB0aGUgY3VycmVudCBVUkwgaW4gdGhlIGhpc3Rvcnkgc3RhY2suXG4gICAgICAgKi9cbiAgICAgIHJlcGxhY2VXaXRoOiBmdW5jdGlvbiAodG8sIHBhcmFtcywgcXVlcnkpIHtcbiAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgIHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3N0cmluZycsXG4gICAgICAgICAgJ1lvdSBjYW5ub3QgdXNlIHJlcGxhY2VXaXRoIHdpdGggYSBzdGF0aWMgbG9jYXRpb24nXG4gICAgICAgICk7XG5cbiAgICAgICAgbG9jYXRpb24ucmVwbGFjZSh0aGlzLm1ha2VQYXRoKHRvLCBwYXJhbXMsIHF1ZXJ5KSk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zaXRpb25zIHRvIHRoZSBwcmV2aW91cyBVUkwgaWYgb25lIGlzIGF2YWlsYWJsZS4gUmV0dXJucyB0cnVlIGlmIHRoZVxuICAgICAgICogcm91dGVyIHdhcyBhYmxlIHRvIGdvIGJhY2ssIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAqXG4gICAgICAgKiBOb3RlOiBUaGUgcm91dGVyIG9ubHkgdHJhY2tzIGhpc3RvcnkgZW50cmllcyBpbiB5b3VyIGFwcGxpY2F0aW9uLCBub3QgdGhlXG4gICAgICAgKiBjdXJyZW50IGJyb3dzZXIgc2Vzc2lvbiwgc28geW91IGNhbiBzYWZlbHkgY2FsbCB0aGlzIGZ1bmN0aW9uIHdpdGhvdXQgZ3VhcmRpbmdcbiAgICAgICAqIGFnYWluc3Qgc2VuZGluZyB0aGUgdXNlciBiYWNrIHRvIHNvbWUgb3RoZXIgc2l0ZS4gSG93ZXZlciwgd2hlbiB1c2luZ1xuICAgICAgICogUmVmcmVzaExvY2F0aW9uICh3aGljaCBpcyB0aGUgZmFsbGJhY2sgZm9yIEhpc3RvcnlMb2NhdGlvbiBpbiBicm93c2VycyB0aGF0XG4gICAgICAgKiBkb24ndCBzdXBwb3J0IEhUTUw1IGhpc3RvcnkpIHRoaXMgbWV0aG9kIHdpbGwgKmFsd2F5cyogc2VuZCB0aGUgY2xpZW50IGJhY2tcbiAgICAgICAqIGJlY2F1c2Ugd2UgY2Fubm90IHJlbGlhYmx5IHRyYWNrIGhpc3RvcnkgbGVuZ3RoLlxuICAgICAgICovXG4gICAgICBnb0JhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgIHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3N0cmluZycsXG4gICAgICAgICAgJ1lvdSBjYW5ub3QgdXNlIGdvQmFjayB3aXRoIGEgc3RhdGljIGxvY2F0aW9uJ1xuICAgICAgICApO1xuXG4gICAgICAgIGlmIChIaXN0b3J5Lmxlbmd0aCA+IDEgfHwgbG9jYXRpb24gPT09IFJlZnJlc2hMb2NhdGlvbikge1xuICAgICAgICAgIGxvY2F0aW9uLnBvcCgpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ2dvQmFjaygpIHdhcyBpZ25vcmVkIGJlY2F1c2UgdGhlcmUgaXMgbm8gcm91dGVyIGhpc3RvcnknKTtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFBlcmZvcm1zIGEgbWF0Y2ggb2YgdGhlIGdpdmVuIHBhdGhuYW1lIGFnYWluc3QgdGhpcyByb3V0ZXIgYW5kIHJldHVybnMgYW4gb2JqZWN0XG4gICAgICAgKiB3aXRoIHRoZSB7IHJvdXRlcywgcGFyYW1zIH0gdGhhdCBtYXRjaC4gUmV0dXJucyBudWxsIGlmIG5vIG1hdGNoIGNhbiBiZSBtYWRlLlxuICAgICAgICovXG4gICAgICBtYXRjaDogZnVuY3Rpb24gKHBhdGhuYW1lKSB7XG4gICAgICAgIHJldHVybiBmaW5kTWF0Y2gocGF0aG5hbWUsIHJvdXRlcywgdGhpcy5kZWZhdWx0Um91dGUsIHRoaXMubm90Rm91bmRSb3V0ZSkgfHwgbnVsbDtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUGVyZm9ybXMgYSB0cmFuc2l0aW9uIHRvIHRoZSBnaXZlbiBwYXRoIGFuZCBjYWxscyBjYWxsYmFjayhlcnJvciwgYWJvcnRSZWFzb24pXG4gICAgICAgKiB3aGVuIHRoZSB0cmFuc2l0aW9uIGlzIGZpbmlzaGVkLiBJZiBib3RoIGFyZ3VtZW50cyBhcmUgbnVsbCB0aGUgcm91dGVyJ3Mgc3RhdGVcbiAgICAgICAqIHdhcyB1cGRhdGVkLiBPdGhlcndpc2UgdGhlIHRyYW5zaXRpb24gZGlkIG5vdCBjb21wbGV0ZS5cbiAgICAgICAqXG4gICAgICAgKiBJbiBhIHRyYW5zaXRpb24sIGEgcm91dGVyIGZpcnN0IGRldGVybWluZXMgd2hpY2ggcm91dGVzIGFyZSBpbnZvbHZlZCBieSBiZWdpbm5pbmdcbiAgICAgICAqIHdpdGggdGhlIGN1cnJlbnQgcm91dGUsIHVwIHRoZSByb3V0ZSB0cmVlIHRvIHRoZSBmaXJzdCBwYXJlbnQgcm91dGUgdGhhdCBpcyBzaGFyZWRcbiAgICAgICAqIHdpdGggdGhlIGRlc3RpbmF0aW9uIHJvdXRlLCBhbmQgYmFjayBkb3duIHRoZSB0cmVlIHRvIHRoZSBkZXN0aW5hdGlvbiByb3V0ZS4gVGhlXG4gICAgICAgKiB3aWxsVHJhbnNpdGlvbkZyb20gaG9vayBpcyBpbnZva2VkIG9uIGFsbCByb3V0ZSBoYW5kbGVycyB3ZSdyZSB0cmFuc2l0aW9uaW5nIGF3YXlcbiAgICAgICAqIGZyb20sIGluIHJldmVyc2UgbmVzdGluZyBvcmRlci4gTGlrZXdpc2UsIHRoZSB3aWxsVHJhbnNpdGlvblRvIGhvb2sgaXMgaW52b2tlZCBvblxuICAgICAgICogYWxsIHJvdXRlIGhhbmRsZXJzIHdlJ3JlIHRyYW5zaXRpb25pbmcgdG8uXG4gICAgICAgKlxuICAgICAgICogQm90aCB3aWxsVHJhbnNpdGlvbkZyb20gYW5kIHdpbGxUcmFuc2l0aW9uVG8gaG9va3MgbWF5IGVpdGhlciBhYm9ydCBvciByZWRpcmVjdCB0aGVcbiAgICAgICAqIHRyYW5zaXRpb24uIFRvIHJlc29sdmUgYXN5bmNocm9ub3VzbHksIHRoZXkgbWF5IHVzZSB0cmFuc2l0aW9uLndhaXQocHJvbWlzZSkuIElmIG5vXG4gICAgICAgKiBob29rcyB3YWl0LCB0aGUgdHJhbnNpdGlvbiBpcyBmdWxseSBzeW5jaHJvbm91cy5cbiAgICAgICAqL1xuICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIChwYXRoLCBhY3Rpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChwZW5kaW5nVHJhbnNpdGlvbikge1xuICAgICAgICAgIHBlbmRpbmdUcmFuc2l0aW9uLmFib3J0KG5ldyBDYW5jZWxsYXRpb24pO1xuICAgICAgICAgIHBlbmRpbmdUcmFuc2l0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmV2UGF0aCA9IHN0YXRlLnBhdGg7XG4gICAgICAgIGlmIChwcmV2UGF0aCA9PT0gcGF0aClcbiAgICAgICAgICByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG8hXG5cbiAgICAgICAgLy8gUmVjb3JkIHRoZSBzY3JvbGwgcG9zaXRpb24gYXMgZWFybHkgYXMgcG9zc2libGUgdG9cbiAgICAgICAgLy8gZ2V0IGl0IGJlZm9yZSBicm93c2VycyB0cnkgdXBkYXRlIGl0IGF1dG9tYXRpY2FsbHkuXG4gICAgICAgIGlmIChwcmV2UGF0aCAmJiBhY3Rpb24gIT09IExvY2F0aW9uQWN0aW9ucy5SRVBMQUNFKVxuICAgICAgICAgIHRoaXMucmVjb3JkU2Nyb2xsUG9zaXRpb24ocHJldlBhdGgpO1xuXG4gICAgICAgIHZhciBwYXRobmFtZSA9IFBhdGgud2l0aG91dFF1ZXJ5KHBhdGgpO1xuICAgICAgICB2YXIgbWF0Y2ggPSB0aGlzLm1hdGNoKHBhdGhuYW1lKTtcblxuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIG1hdGNoICE9IG51bGwsXG4gICAgICAgICAgJ05vIHJvdXRlIG1hdGNoZXMgcGF0aCBcIiVzXCIuIE1ha2Ugc3VyZSB5b3UgaGF2ZSA8Um91dGUgcGF0aD1cIiVzXCI+IHNvbWV3aGVyZSBpbiB5b3VyIHJvdXRlcycsXG4gICAgICAgICAgcGF0aCwgcGF0aFxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChtYXRjaCA9PSBudWxsKVxuICAgICAgICAgIG1hdGNoID0ge307XG5cbiAgICAgICAgdmFyIHByZXZSb3V0ZXMgPSBzdGF0ZS5yb3V0ZXMgfHwgW107XG4gICAgICAgIHZhciBwcmV2UGFyYW1zID0gc3RhdGUucGFyYW1zIHx8IHt9O1xuICAgICAgICB2YXIgcHJldlF1ZXJ5ID0gc3RhdGUucXVlcnkgfHwge307XG5cbiAgICAgICAgdmFyIG5leHRSb3V0ZXMgPSBtYXRjaC5yb3V0ZXMgfHwgW107XG4gICAgICAgIHZhciBuZXh0UGFyYW1zID0gbWF0Y2gucGFyYW1zIHx8IHt9O1xuICAgICAgICB2YXIgbmV4dFF1ZXJ5ID0gUGF0aC5leHRyYWN0UXVlcnkocGF0aCkgfHwge307XG5cbiAgICAgICAgdmFyIGZyb21Sb3V0ZXMsIHRvUm91dGVzO1xuICAgICAgICBpZiAocHJldlJvdXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICBmcm9tUm91dGVzID0gcHJldlJvdXRlcy5maWx0ZXIoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gIWhhc01hdGNoKG5leHRSb3V0ZXMsIHJvdXRlLCBwcmV2UGFyYW1zLCBuZXh0UGFyYW1zLCBwcmV2UXVlcnksIG5leHRRdWVyeSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0b1JvdXRlcyA9IG5leHRSb3V0ZXMuZmlsdGVyKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICAgICAgcmV0dXJuICFoYXNNYXRjaChwcmV2Um91dGVzLCByb3V0ZSwgcHJldlBhcmFtcywgbmV4dFBhcmFtcywgcHJldlF1ZXJ5LCBuZXh0UXVlcnkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyb21Sb3V0ZXMgPSBbXTtcbiAgICAgICAgICB0b1JvdXRlcyA9IG5leHRSb3V0ZXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IG5ldyBUcmFuc2l0aW9uKHBhdGgsIHRoaXMucmVwbGFjZVdpdGguYmluZCh0aGlzLCBwYXRoKSk7XG4gICAgICAgIHBlbmRpbmdUcmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcblxuICAgICAgICB0cmFuc2l0aW9uLmZyb20oZnJvbVJvdXRlcywgY29tcG9uZW50cywgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgaWYgKGVycm9yIHx8IHRyYW5zaXRpb24uaXNBYm9ydGVkKVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwocm91dGVyLCBlcnJvciwgdHJhbnNpdGlvbik7XG5cbiAgICAgICAgICB0cmFuc2l0aW9uLnRvKHRvUm91dGVzLCBuZXh0UGFyYW1zLCBuZXh0UXVlcnksIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yIHx8IHRyYW5zaXRpb24uaXNBYm9ydGVkKVxuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChyb3V0ZXIsIGVycm9yLCB0cmFuc2l0aW9uKTtcblxuICAgICAgICAgICAgbmV4dFN0YXRlLnBhdGggPSBwYXRoO1xuICAgICAgICAgICAgbmV4dFN0YXRlLmFjdGlvbiA9IGFjdGlvbjtcbiAgICAgICAgICAgIG5leHRTdGF0ZS5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgbmV4dFN0YXRlLnJvdXRlcyA9IG5leHRSb3V0ZXM7XG4gICAgICAgICAgICBuZXh0U3RhdGUucGFyYW1zID0gbmV4dFBhcmFtcztcbiAgICAgICAgICAgIG5leHRTdGF0ZS5xdWVyeSA9IG5leHRRdWVyeTtcblxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbChyb3V0ZXIsIG51bGwsIHRyYW5zaXRpb24pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogU3RhcnRzIHRoaXMgcm91dGVyIGFuZCBjYWxscyBjYWxsYmFjayhyb3V0ZXIsIHN0YXRlKSB3aGVuIHRoZSByb3V0ZSBjaGFuZ2VzLlxuICAgICAgICpcbiAgICAgICAqIElmIHRoZSByb3V0ZXIncyBsb2NhdGlvbiBpcyBzdGF0aWMgKGkuZS4gYSBVUkwgcGF0aCBpbiBhIHNlcnZlciBlbnZpcm9ubWVudClcbiAgICAgICAqIHRoZSBjYWxsYmFjayBpcyBjYWxsZWQgb25seSBvbmNlLiBPdGhlcndpc2UsIHRoZSBsb2NhdGlvbiBzaG91bGQgYmUgb25lIG9mIHRoZVxuICAgICAgICogUm91dGVyLipMb2NhdGlvbiBvYmplY3RzIChlLmcuIFJvdXRlci5IYXNoTG9jYXRpb24gb3IgUm91dGVyLkhpc3RvcnlMb2NhdGlvbikuXG4gICAgICAgKi9cbiAgICAgIHJ1bjogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBkaXNwYXRjaEhhbmRsZXIgPSBmdW5jdGlvbiAoZXJyb3IsIHRyYW5zaXRpb24pIHtcbiAgICAgICAgICBwZW5kaW5nVHJhbnNpdGlvbiA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIG9uRXJyb3IuY2FsbChyb3V0ZXIsIGVycm9yKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRyYW5zaXRpb24uaXNBYm9ydGVkKSB7XG4gICAgICAgICAgICBvbkFib3J0LmNhbGwocm91dGVyLCB0cmFuc2l0aW9uLmFib3J0UmVhc29uLCBsb2NhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwocm91dGVyLCByb3V0ZXIsIG5leHRTdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcm91dGVyLmRpc3BhdGNoKGxvY2F0aW9uLCBudWxsLCBkaXNwYXRjaEhhbmRsZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIExpc3RlbiBmb3IgY2hhbmdlcyB0byB0aGUgbG9jYXRpb24uXG4gICAgICAgICAgdmFyIGNoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgcm91dGVyLmRpc3BhdGNoKGNoYW5nZS5wYXRoLCBjaGFuZ2UudHlwZSwgZGlzcGF0Y2hIYW5kbGVyKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKGxvY2F0aW9uLmFkZENoYW5nZUxpc3RlbmVyKVxuICAgICAgICAgICAgbG9jYXRpb24uYWRkQ2hhbmdlTGlzdGVuZXIoY2hhbmdlTGlzdGVuZXIpO1xuXG4gICAgICAgICAgLy8gQm9vdHN0cmFwIHVzaW5nIHRoZSBjdXJyZW50IHBhdGguXG4gICAgICAgICAgcm91dGVyLmRpc3BhdGNoKGxvY2F0aW9uLmdldEN1cnJlbnRQYXRoKCksIG51bGwsIGRpc3BhdGNoSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHRlYXJkb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbG9jYXRpb24ucmVtb3ZlQ2hhbmdlTGlzdGVuZXIodGhpcy5jaGFuZ2VMaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgcHJvcFR5cGVzOiB7XG4gICAgICBjaGlsZHJlbjogUHJvcFR5cGVzLmZhbHN5XG4gICAgfSxcblxuICAgIGdldExvY2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgfSxcblxuICAgIGdldFNjcm9sbEJlaGF2aW9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc2Nyb2xsQmVoYXZpb3I7XG4gICAgfSxcblxuICAgIGdldFJvdXRlQXREZXB0aDogZnVuY3Rpb24gKGRlcHRoKSB7XG4gICAgICB2YXIgcm91dGVzID0gdGhpcy5zdGF0ZS5yb3V0ZXM7XG4gICAgICByZXR1cm4gcm91dGVzICYmIHJvdXRlc1tkZXB0aF07XG4gICAgfSxcblxuICAgIGdldFJvdXRlQ29tcG9uZW50czogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgfSxcblxuICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdXBkYXRlU3RhdGUoKTtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gKCkge1xuICAgICAgdXBkYXRlU3RhdGUoKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoc3RhdGUpO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICByb3V0ZXIudGVhcmRvd24oKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSb3V0ZUF0RGVwdGgoMCkgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlSGFuZGxlciwgdGhpcy5wcm9wcykgOiBudWxsO1xuICAgIH0sXG5cbiAgICBjaGlsZENvbnRleHRUeXBlczoge1xuICAgICAgZ2V0Um91dGVBdERlcHRoOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgZ2V0Um91dGVDb21wb25lbnRzOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgcm91dGVIYW5kbGVyczogUmVhY3QuUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWRcbiAgICB9LFxuXG4gICAgZ2V0Q2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXRSb3V0ZUNvbXBvbmVudHM6IHRoaXMuZ2V0Um91dGVDb21wb25lbnRzLFxuICAgICAgICBnZXRSb3V0ZUF0RGVwdGg6IHRoaXMuZ2V0Um91dGVBdERlcHRoLFxuICAgICAgICByb3V0ZUhhbmRsZXJzOiBbIHRoaXMgXVxuICAgICAgfTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgaWYgKG9wdGlvbnMucm91dGVzKVxuICAgIHJvdXRlci5hZGRSb3V0ZXMob3B0aW9ucy5yb3V0ZXMpO1xuXG4gIHJldHVybiByb3V0ZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUm91dGVyO1xuIiwiLyoganNoaW50IC1XMDg0ICovXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdyZWFjdC9saWIvd2FybmluZycpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9pbnZhcmlhbnQnKTtcbnZhciBEZWZhdWx0Um91dGUgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL0RlZmF1bHRSb3V0ZScpO1xudmFyIE5vdEZvdW5kUm91dGUgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL05vdEZvdW5kUm91dGUnKTtcbnZhciBSZWRpcmVjdCA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvUmVkaXJlY3QnKTtcbnZhciBSb3V0ZSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvUm91dGUnKTtcbnZhciBQYXRoID0gcmVxdWlyZSgnLi9QYXRoJyk7XG5cbnZhciBDT05GSUdfRUxFTUVOVF9UWVBFUyA9IFtcbiAgRGVmYXVsdFJvdXRlLnR5cGUsXG4gIE5vdEZvdW5kUm91dGUudHlwZSxcbiAgUmVkaXJlY3QudHlwZSxcbiAgUm91dGUudHlwZVxuXTtcblxuZnVuY3Rpb24gY3JlYXRlUmVkaXJlY3RIYW5kbGVyKHRvLCBfcGFyYW1zLCBfcXVlcnkpIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICBzdGF0aWNzOiB7XG4gICAgICB3aWxsVHJhbnNpdGlvblRvOiBmdW5jdGlvbiAodHJhbnNpdGlvbiwgcGFyYW1zLCBxdWVyeSkge1xuICAgICAgICB0cmFuc2l0aW9uLnJlZGlyZWN0KHRvLCBfcGFyYW1zIHx8IHBhcmFtcywgX3F1ZXJ5IHx8IHF1ZXJ5KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyhjb21wb25lbnROYW1lLCBwcm9wVHlwZXMsIHByb3BzKSB7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xuICAgIGlmIChwcm9wVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICB2YXIgZXJyb3IgPSBwcm9wVHlwZXNbcHJvcE5hbWVdKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKVxuICAgICAgICB3YXJuaW5nKGZhbHNlLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUm91dGUoZWxlbWVudCwgcGFyZW50Um91dGUsIG5hbWVkUm91dGVzKSB7XG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICB2YXIgcHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICB2YXIgY29tcG9uZW50TmFtZSA9ICh0eXBlICYmIHR5cGUuZGlzcGxheU5hbWUpIHx8ICdVbmtub3duQ29tcG9uZW50JztcblxuICBpbnZhcmlhbnQoXG4gICAgQ09ORklHX0VMRU1FTlRfVFlQRVMuaW5kZXhPZih0eXBlKSAhPT0gLTEsXG4gICAgJ1VucmVjb2duaXplZCByb3V0ZSBjb25maWd1cmF0aW9uIGVsZW1lbnQgXCI8JXM+XCInLFxuICAgIGNvbXBvbmVudE5hbWVcbiAgKTtcblxuICBpZiAodHlwZS5wcm9wVHlwZXMpXG4gICAgY2hlY2tQcm9wVHlwZXMoY29tcG9uZW50TmFtZSwgdHlwZS5wcm9wVHlwZXMsIHByb3BzKTtcblxuICB2YXIgcm91dGUgPSB7IG5hbWU6IHByb3BzLm5hbWUgfTtcblxuICBpZiAocHJvcHMuaWdub3JlU2Nyb2xsQmVoYXZpb3IpIHtcbiAgICByb3V0ZS5pZ25vcmVTY3JvbGxCZWhhdmlvciA9IHRydWU7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gUmVkaXJlY3QudHlwZSkge1xuICAgIHJvdXRlLmhhbmRsZXIgPSBjcmVhdGVSZWRpcmVjdEhhbmRsZXIocHJvcHMudG8sIHByb3BzLnBhcmFtcywgcHJvcHMucXVlcnkpO1xuICAgIHByb3BzLnBhdGggPSBwcm9wcy5wYXRoIHx8IHByb3BzLmZyb20gfHwgJyonO1xuICB9IGVsc2Uge1xuICAgIHJvdXRlLmhhbmRsZXIgPSBwcm9wcy5oYW5kbGVyO1xuICB9XG5cbiAgdmFyIHBhcmVudFBhdGggPSAocGFyZW50Um91dGUgJiYgcGFyZW50Um91dGUucGF0aCkgfHwgJy8nO1xuXG4gIGlmICgocHJvcHMucGF0aCB8fCBwcm9wcy5uYW1lKSAmJiB0eXBlICE9PSBEZWZhdWx0Um91dGUudHlwZSAmJiB0eXBlICE9PSBOb3RGb3VuZFJvdXRlLnR5cGUpIHtcbiAgICB2YXIgcGF0aCA9IHByb3BzLnBhdGggfHwgcHJvcHMubmFtZTtcblxuICAgIC8vIFJlbGF0aXZlIHBhdGhzIGV4dGVuZCB0aGVpciBwYXJlbnQuXG4gICAgaWYgKCFQYXRoLmlzQWJzb2x1dGUocGF0aCkpXG4gICAgICBwYXRoID0gUGF0aC5qb2luKHBhcmVudFBhdGgsIHBhdGgpO1xuXG4gICAgcm91dGUucGF0aCA9IFBhdGgubm9ybWFsaXplKHBhdGgpO1xuICB9IGVsc2Uge1xuICAgIHJvdXRlLnBhdGggPSBwYXJlbnRQYXRoO1xuXG4gICAgaWYgKHR5cGUgPT09IE5vdEZvdW5kUm91dGUudHlwZSlcbiAgICAgIHJvdXRlLnBhdGggKz0gJyonO1xuICB9XG5cbiAgcm91dGUucGFyYW1OYW1lcyA9IFBhdGguZXh0cmFjdFBhcmFtTmFtZXMocm91dGUucGF0aCk7XG5cbiAgLy8gTWFrZSBzdXJlIHRoZSByb3V0ZSdzIHBhdGggaGFzIGFsbCBwYXJhbXMgaXRzIHBhcmVudCBuZWVkcy5cbiAgaWYgKHBhcmVudFJvdXRlICYmIEFycmF5LmlzQXJyYXkocGFyZW50Um91dGUucGFyYW1OYW1lcykpIHtcbiAgICBwYXJlbnRSb3V0ZS5wYXJhbU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtTmFtZSkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICByb3V0ZS5wYXJhbU5hbWVzLmluZGV4T2YocGFyYW1OYW1lKSAhPT0gLTEsXG4gICAgICAgICdUaGUgbmVzdGVkIHJvdXRlIHBhdGggXCIlc1wiIGlzIG1pc3NpbmcgdGhlIFwiJXNcIiBwYXJhbWV0ZXIgb2YgaXRzIHBhcmVudCBwYXRoIFwiJXNcIicsXG4gICAgICAgIHJvdXRlLnBhdGgsIHBhcmFtTmFtZSwgcGFyZW50Um91dGUucGF0aFxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSB0aGUgcm91dGUgY2FuIGJlIGxvb2tlZCB1cCBieSA8TGluaz5zLlxuICBpZiAocHJvcHMubmFtZSkge1xuICAgIGludmFyaWFudChcbiAgICAgIG5hbWVkUm91dGVzW3Byb3BzLm5hbWVdID09IG51bGwsXG4gICAgICAnWW91IGNhbm5vdCB1c2UgdGhlIG5hbWUgXCIlc1wiIGZvciBtb3JlIHRoYW4gb25lIHJvdXRlJyxcbiAgICAgIHByb3BzLm5hbWVcbiAgICApO1xuXG4gICAgbmFtZWRSb3V0ZXNbcHJvcHMubmFtZV0gPSByb3V0ZTtcbiAgfVxuXG4gIC8vIEhhbmRsZSA8Tm90Rm91bmRSb3V0ZT4uXG4gIGlmICh0eXBlID09PSBOb3RGb3VuZFJvdXRlLnR5cGUpIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBwYXJlbnRSb3V0ZSxcbiAgICAgICc8Tm90Rm91bmRSb3V0ZT4gbXVzdCBoYXZlIGEgcGFyZW50IDxSb3V0ZT4nXG4gICAgKTtcblxuICAgIGludmFyaWFudChcbiAgICAgIHBhcmVudFJvdXRlLm5vdEZvdW5kUm91dGUgPT0gbnVsbCxcbiAgICAgICdZb3UgbWF5IG5vdCBoYXZlIG1vcmUgdGhhbiBvbmUgPE5vdEZvdW5kUm91dGU+IHBlciA8Um91dGU+J1xuICAgICk7XG5cbiAgICBwYXJlbnRSb3V0ZS5ub3RGb3VuZFJvdXRlID0gcm91dGU7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEhhbmRsZSA8RGVmYXVsdFJvdXRlPi5cbiAgaWYgKHR5cGUgPT09IERlZmF1bHRSb3V0ZS50eXBlKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgcGFyZW50Um91dGUsXG4gICAgICAnPERlZmF1bHRSb3V0ZT4gbXVzdCBoYXZlIGEgcGFyZW50IDxSb3V0ZT4nXG4gICAgKTtcblxuICAgIGludmFyaWFudChcbiAgICAgIHBhcmVudFJvdXRlLmRlZmF1bHRSb3V0ZSA9PSBudWxsLFxuICAgICAgJ1lvdSBtYXkgbm90IGhhdmUgbW9yZSB0aGFuIG9uZSA8RGVmYXVsdFJvdXRlPiBwZXIgPFJvdXRlPidcbiAgICApO1xuXG4gICAgcGFyZW50Um91dGUuZGVmYXVsdFJvdXRlID0gcm91dGU7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJvdXRlLmNoaWxkUm91dGVzID0gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKHByb3BzLmNoaWxkcmVuLCByb3V0ZSwgbmFtZWRSb3V0ZXMpO1xuXG4gIHJldHVybiByb3V0ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHJvdXRlIG9iamVjdHMgZnJvbSB0aGUgZ2l2ZW4gUmVhY3RDaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGNoaWxkcmVuLCBwYXJlbnRSb3V0ZSwgbmFtZWRSb3V0ZXMpIHtcbiAgdmFyIHJvdXRlcyA9IFtdO1xuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIC8vIEV4Y2x1ZGUgPERlZmF1bHRSb3V0ZT5zIGFuZCA8Tm90Rm91bmRSb3V0ZT5zLlxuICAgIGlmIChjaGlsZCA9IGNyZWF0ZVJvdXRlKGNoaWxkLCBwYXJlbnRSb3V0ZSwgbmFtZWRSb3V0ZXMpKVxuICAgICAgcm91dGVzLnB1c2goY2hpbGQpO1xuICB9KTtcblxuICByZXR1cm4gcm91dGVzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbjtcbiIsInZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdyZWFjdC9saWIvaW52YXJpYW50Jyk7XG52YXIgY2FuVXNlRE9NID0gcmVxdWlyZSgncmVhY3QvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50JykuY2FuVXNlRE9NO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSB3aW5kb3cgYXMgeyB4LCB5IH0uXG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbFBvc2l0aW9uKCkge1xuICBpbnZhcmlhbnQoXG4gICAgY2FuVXNlRE9NLFxuICAgICdDYW5ub3QgZ2V0IGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIHdpdGhvdXQgYSBET00nXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG4gICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRXaW5kb3dTY3JvbGxQb3NpdGlvbjtcbiIsImZ1bmN0aW9uIHJldmVyc2VkQXJyYXkoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5LnNsaWNlKDApLnJldmVyc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXZlcnNlZEFycmF5O1xuIiwidmFyIGNyZWF0ZVJvdXRlciA9IHJlcXVpcmUoJy4vY3JlYXRlUm91dGVyJyk7XG5cbi8qKlxuICogQSBoaWdoLWxldmVsIGNvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGNyZWF0ZXMsIGNvbmZpZ3VyZXMsIGFuZFxuICogcnVucyBhIHJvdXRlciBpbiBvbmUgc2hvdC4gVGhlIG1ldGhvZCBzaWduYXR1cmUgaXM6XG4gKlxuICogICBSb3V0ZXIucnVuKHJvdXRlc1ssIGxvY2F0aW9uIF0sIGNhbGxiYWNrKTtcbiAqXG4gKiBVc2luZyBgd2luZG93LmxvY2F0aW9uLmhhc2hgIHRvIG1hbmFnZSB0aGUgVVJMLCB5b3UgY291bGQgZG86XG4gKlxuICogICBSb3V0ZXIucnVuKHJvdXRlcywgZnVuY3Rpb24gKEhhbmRsZXIpIHtcbiAqICAgICBSZWFjdC5yZW5kZXIoPEhhbmRsZXIvPiwgZG9jdW1lbnQuYm9keSk7XG4gKiAgIH0pO1xuICogXG4gKiBVc2luZyBIVE1MNSBoaXN0b3J5IGFuZCBhIGN1c3RvbSBcImN1cnNvclwiIHByb3A6XG4gKiBcbiAqICAgUm91dGVyLnJ1bihyb3V0ZXMsIFJvdXRlci5IaXN0b3J5TG9jYXRpb24sIGZ1bmN0aW9uIChIYW5kbGVyKSB7XG4gKiAgICAgUmVhY3QucmVuZGVyKDxIYW5kbGVyIGN1cnNvcj17Y3Vyc29yfS8+LCBkb2N1bWVudC5ib2R5KTtcbiAqICAgfSk7XG4gKlxuICogUmV0dXJucyB0aGUgbmV3bHkgY3JlYXRlZCByb3V0ZXIuXG4gKlxuICogTm90ZTogSWYgeW91IG5lZWQgdG8gc3BlY2lmeSBmdXJ0aGVyIG9wdGlvbnMgZm9yIHlvdXIgcm91dGVyIHN1Y2hcbiAqIGFzIGVycm9yL2Fib3J0IGhhbmRsaW5nIG9yIGN1c3RvbSBzY3JvbGwgYmVoYXZpb3IsIHVzZSBSb3V0ZXIuY3JlYXRlXG4gKiBpbnN0ZWFkLlxuICpcbiAqICAgdmFyIHJvdXRlciA9IFJvdXRlci5jcmVhdGUob3B0aW9ucyk7XG4gKiAgIHJvdXRlci5ydW4oZnVuY3Rpb24gKEhhbmRsZXIpIHtcbiAqICAgICAvLyAuLi5cbiAqICAgfSk7XG4gKi9cbmZ1bmN0aW9uIHJ1blJvdXRlcihyb3V0ZXMsIGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBsb2NhdGlvbjtcbiAgICBsb2NhdGlvbiA9IG51bGw7XG4gIH1cblxuICB2YXIgcm91dGVyID0gY3JlYXRlUm91dGVyKHtcbiAgICByb3V0ZXM6IHJvdXRlcyxcbiAgICBsb2NhdGlvbjogbG9jYXRpb25cbiAgfSk7XG5cbiAgcm91dGVyLnJ1bihjYWxsYmFjayk7XG5cbiAgcmV0dXJuIHJvdXRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBydW5Sb3V0ZXI7XG4iLCJmdW5jdGlvbiBzdXBwb3J0c0hpc3RvcnkoKSB7XG4gIC8qISB0YWtlbiBmcm9tIG1vZGVybml6clxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9MSUNFTlNFXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL2ZlYXR1cmUtZGV0ZWN0cy9oaXN0b3J5LmpzXG4gICAqIGNoYW5nZWQgdG8gYXZvaWQgZmFsc2UgbmVnYXRpdmVzIGZvciBXaW5kb3dzIFBob25lczogaHR0cHM6Ly9naXRodWIuY29tL3JhY2t0L3JlYWN0LXJvdXRlci9pc3N1ZXMvNTg2XG4gICAqL1xuICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICBpZiAoKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHxcbiAgICAgICh1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkpICYmXG4gICAgICB1YS5pbmRleE9mKCdNb2JpbGUgU2FmYXJpJykgIT09IC0xICYmXG4gICAgICB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiZcbiAgICAgIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuICh3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNIaXN0b3J5O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYicpO1xuIiwiLy8gTG9hZCBtb2R1bGVzXG5cbnZhciBTdHJpbmdpZnkgPSByZXF1aXJlKCcuL3N0cmluZ2lmeScpO1xudmFyIFBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpO1xuXG5cbi8vIERlY2xhcmUgaW50ZXJuYWxzXG5cbnZhciBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzdHJpbmdpZnk6IFN0cmluZ2lmeSxcbiAgICBwYXJzZTogUGFyc2Vcbn07XG4iLCIvLyBMb2FkIG1vZHVsZXNcblxudmFyIFV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5cbi8vIERlY2xhcmUgaW50ZXJuYWxzXG5cbnZhciBpbnRlcm5hbHMgPSB7XG4gICAgZGVsaW1pdGVyOiAnJicsXG4gICAgZGVwdGg6IDUsXG4gICAgYXJyYXlMaW1pdDogMjAsXG4gICAgcGFyYW1ldGVyTGltaXQ6IDEwMDBcbn07XG5cblxuaW50ZXJuYWxzLnBhcnNlVmFsdWVzID0gZnVuY3Rpb24gKHN0ciwgb3B0aW9ucykge1xuXG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdChvcHRpb25zLmRlbGltaXRlciwgb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdCA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBvcHRpb25zLnBhcmFtZXRlckxpbWl0KTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHBhcnRzLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgdmFyIHBvcyA9IHBhcnQuaW5kZXhPZignXT0nKSA9PT0gLTEgPyBwYXJ0LmluZGV4T2YoJz0nKSA6IHBhcnQuaW5kZXhPZignXT0nKSArIDE7XG5cbiAgICAgICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgICAgICAgIG9ialtVdGlscy5kZWNvZGUocGFydCldID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gVXRpbHMuZGVjb2RlKHBhcnQuc2xpY2UoMCwgcG9zKSk7XG4gICAgICAgICAgICB2YXIgdmFsID0gVXRpbHMuZGVjb2RlKHBhcnQuc2xpY2UocG9zICsgMSkpO1xuXG4gICAgICAgICAgICBpZiAoIW9ialtrZXldKSB7XG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IFtdLmNvbmNhdChvYmpba2V5XSkuY29uY2F0KHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxuXG5pbnRlcm5hbHMucGFyc2VPYmplY3QgPSBmdW5jdGlvbiAoY2hhaW4sIHZhbCwgb3B0aW9ucykge1xuXG4gICAgaWYgKCFjaGFpbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICB2YXIgcm9vdCA9IGNoYWluLnNoaWZ0KCk7XG5cbiAgICB2YXIgb2JqID0ge307XG4gICAgaWYgKHJvb3QgPT09ICdbXScpIHtcbiAgICAgICAgb2JqID0gW107XG4gICAgICAgIG9iaiA9IG9iai5jb25jYXQoaW50ZXJuYWxzLnBhcnNlT2JqZWN0KGNoYWluLCB2YWwsIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBjbGVhblJvb3QgPSByb290WzBdID09PSAnWycgJiYgcm9vdFtyb290Lmxlbmd0aCAtIDFdID09PSAnXScgPyByb290LnNsaWNlKDEsIHJvb3QubGVuZ3RoIC0gMSkgOiByb290O1xuICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludChjbGVhblJvb3QsIDEwKTtcbiAgICAgICAgaWYgKCFpc05hTihpbmRleCkgJiZcbiAgICAgICAgICAgIHJvb3QgIT09IGNsZWFuUm9vdCAmJlxuICAgICAgICAgICAgaW5kZXggPD0gb3B0aW9ucy5hcnJheUxpbWl0KSB7XG5cbiAgICAgICAgICAgIG9iaiA9IFtdO1xuICAgICAgICAgICAgb2JqW2luZGV4XSA9IGludGVybmFscy5wYXJzZU9iamVjdChjaGFpbiwgdmFsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9ialtjbGVhblJvb3RdID0gaW50ZXJuYWxzLnBhcnNlT2JqZWN0KGNoYWluLCB2YWwsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cblxuaW50ZXJuYWxzLnBhcnNlS2V5cyA9IGZ1bmN0aW9uIChrZXksIHZhbCwgb3B0aW9ucykge1xuXG4gICAgaWYgKCFrZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRoZSByZWdleCBjaHVua3NcblxuICAgIHZhciBwYXJlbnQgPSAvXihbXlxcW1xcXV0qKS87XG4gICAgdmFyIGNoaWxkID0gLyhcXFtbXlxcW1xcXV0qXFxdKS9nO1xuXG4gICAgLy8gR2V0IHRoZSBwYXJlbnRcblxuICAgIHZhciBzZWdtZW50ID0gcGFyZW50LmV4ZWMoa2V5KTtcblxuICAgIC8vIERvbid0IGFsbG93IHRoZW0gdG8gb3ZlcndyaXRlIG9iamVjdCBwcm90b3R5cGUgcHJvcGVydGllc1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoc2VnbWVudFsxXSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFN0YXNoIHRoZSBwYXJlbnQgaWYgaXQgZXhpc3RzXG5cbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGlmIChzZWdtZW50WzFdKSB7XG4gICAgICAgIGtleXMucHVzaChzZWdtZW50WzFdKTtcbiAgICB9XG5cbiAgICAvLyBMb29wIHRocm91Z2ggY2hpbGRyZW4gYXBwZW5kaW5nIHRvIHRoZSBhcnJheSB1bnRpbCB3ZSBoaXQgZGVwdGhcblxuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoKHNlZ21lbnQgPSBjaGlsZC5leGVjKGtleSkpICE9PSBudWxsICYmIGkgPCBvcHRpb25zLmRlcHRoKSB7XG5cbiAgICAgICAgKytpO1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoc2VnbWVudFsxXS5yZXBsYWNlKC9cXFt8XFxdL2csICcnKSkpIHtcbiAgICAgICAgICAgIGtleXMucHVzaChzZWdtZW50WzFdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZXJlJ3MgYSByZW1haW5kZXIsIGp1c3QgYWRkIHdoYXRldmVyIGlzIGxlZnRcblxuICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIGtleXMucHVzaCgnWycgKyBrZXkuc2xpY2Uoc2VnbWVudC5pbmRleCkgKyAnXScpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcm5hbHMucGFyc2VPYmplY3Qoa2V5cywgdmFsLCBvcHRpb25zKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyLCBvcHRpb25zKSB7XG5cbiAgICBpZiAoc3RyID09PSAnJyB8fFxuICAgICAgICBzdHIgPT09IG51bGwgfHxcbiAgICAgICAgdHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcblxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5kZWxpbWl0ZXIgPSB0eXBlb2Ygb3B0aW9ucy5kZWxpbWl0ZXIgPT09ICdzdHJpbmcnIHx8IFV0aWxzLmlzUmVnRXhwKG9wdGlvbnMuZGVsaW1pdGVyKSA/IG9wdGlvbnMuZGVsaW1pdGVyIDogaW50ZXJuYWxzLmRlbGltaXRlcjtcbiAgICBvcHRpb25zLmRlcHRoID0gdHlwZW9mIG9wdGlvbnMuZGVwdGggPT09ICdudW1iZXInID8gb3B0aW9ucy5kZXB0aCA6IGludGVybmFscy5kZXB0aDtcbiAgICBvcHRpb25zLmFycmF5TGltaXQgPSB0eXBlb2Ygb3B0aW9ucy5hcnJheUxpbWl0ID09PSAnbnVtYmVyJyA/IG9wdGlvbnMuYXJyYXlMaW1pdCA6IGludGVybmFscy5hcnJheUxpbWl0O1xuICAgIG9wdGlvbnMucGFyYW1ldGVyTGltaXQgPSB0eXBlb2Ygb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdCA9PT0gJ251bWJlcicgPyBvcHRpb25zLnBhcmFtZXRlckxpbWl0IDogaW50ZXJuYWxzLnBhcmFtZXRlckxpbWl0O1xuXG4gICAgdmFyIHRlbXBPYmogPSB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IGludGVybmFscy5wYXJzZVZhbHVlcyhzdHIsIG9wdGlvbnMpIDogc3RyO1xuICAgIHZhciBvYmogPSB7fTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUga2V5cyBhbmQgc2V0dXAgdGhlIG5ldyBvYmplY3RcblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGVtcE9iaik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0ga2V5cy5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgbmV3T2JqID0gaW50ZXJuYWxzLnBhcnNlS2V5cyhrZXksIHRlbXBPYmpba2V5XSwgb3B0aW9ucyk7XG4gICAgICAgIG9iaiA9IFV0aWxzLm1lcmdlKG9iaiwgbmV3T2JqKTtcbiAgICB9XG5cbiAgICByZXR1cm4gVXRpbHMuY29tcGFjdChvYmopO1xufTtcbiIsIi8vIExvYWQgbW9kdWxlc1xuXG52YXIgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cblxuLy8gRGVjbGFyZSBpbnRlcm5hbHNcblxudmFyIGludGVybmFscyA9IHtcbiAgICBkZWxpbWl0ZXI6ICcmJ1xufTtcblxuXG5pbnRlcm5hbHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKG9iaiwgcHJlZml4KSB7XG5cbiAgICBpZiAoVXRpbHMuaXNCdWZmZXIob2JqKSkge1xuICAgICAgICBvYmogPSBvYmoudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBvYmogPSBvYmoudG9JU09TdHJpbmcoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIG9iaiA9ICcnO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJyB8fFxuICAgICAgICB0eXBlb2Ygb2JqID09PSAnbnVtYmVyJyB8fFxuICAgICAgICB0eXBlb2Ygb2JqID09PSAnYm9vbGVhbicpIHtcblxuICAgICAgICByZXR1cm4gW2VuY29kZVVSSUNvbXBvbmVudChwcmVmaXgpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9iaildO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KGludGVybmFscy5zdHJpbmdpZnkob2JqW2tleV0sIHByZWZpeCArICdbJyArIGtleSArICddJykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlcztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBvcHRpb25zKSB7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgZGVsaW1pdGVyID0gdHlwZW9mIG9wdGlvbnMuZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/IGludGVybmFscy5kZWxpbWl0ZXIgOiBvcHRpb25zLmRlbGltaXRlcjtcblxuICAgIHZhciBrZXlzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAga2V5cyA9IGtleXMuY29uY2F0KGludGVybmFscy5zdHJpbmdpZnkob2JqW2tleV0sIGtleSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleXMuam9pbihkZWxpbWl0ZXIpO1xufTtcbiIsIi8vIExvYWQgbW9kdWxlc1xuXG5cbi8vIERlY2xhcmUgaW50ZXJuYWxzXG5cbnZhciBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLmFycmF5VG9PYmplY3QgPSBmdW5jdGlvbiAoc291cmNlKSB7XG5cbiAgICB2YXIgb2JqID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gc291cmNlLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VbaV0gIT09ICd1bmRlZmluZWQnKSB7XG5cbiAgICAgICAgICAgIG9ialtpXSA9IHNvdXJjZVtpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuXG5cbmV4cG9ydHMubWVyZ2UgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblxuICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBzb3VyY2UubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtpXSA9IGV4cG9ydHMubWVyZ2UodGFyZ2V0W2ldLCBzb3VyY2VbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2ldID0gc291cmNlW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKHNvdXJjZSk7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0ID0gZXhwb3J0cy5hcnJheVRvT2JqZWN0KHRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgZm9yICh2YXIgayA9IDAsIGtsID0ga2V5cy5sZW5ndGg7IGsgPCBrbDsgKytrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2tdO1xuICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgaWYgKCF0YXJnZXRba2V5XSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IGV4cG9ydHMubWVyZ2UodGFyZ2V0W2tleV0sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLmNvbXBhY3QgPSBmdW5jdGlvbiAob2JqLCByZWZzKSB7XG5cbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgb2JqID09PSBudWxsKSB7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICByZWZzID0gcmVmcyB8fCBbXTtcbiAgICB2YXIgbG9va3VwID0gcmVmcy5pbmRleE9mKG9iaik7XG4gICAgaWYgKGxvb2t1cCAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHJlZnNbbG9va3VwXTtcbiAgICB9XG5cbiAgICByZWZzLnB1c2gob2JqKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgdmFyIGNvbXBhY3RlZCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmpbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29tcGFjdGVkLnB1c2gob2JqW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wYWN0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGtleXMubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgb2JqW2tleV0gPSBleHBvcnRzLmNvbXBhY3Qob2JqW2tleV0sIHJlZnMpO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuXG5cbmV4cG9ydHMuaXNSZWdFeHAgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBSZWdFeHBdJztcbn07XG5cblxuZXhwb3J0cy5pc0J1ZmZlciA9IGZ1bmN0aW9uIChvYmopIHtcblxuICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbiIsIi8qKiBAbGljZW5zZSBNSVQgTGljZW5zZSAoYykgY29weXJpZ2h0IDIwMTAtMjAxNCBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9ycyAqL1xuLyoqIEBhdXRob3IgQnJpYW4gQ2F2YWxpZXIgKi9cbi8qKiBAYXV0aG9yIEpvaG4gSGFubiAqL1xuXG4oZnVuY3Rpb24oZGVmaW5lKSB7ICd1c2Ugc3RyaWN0JztcbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSkge1xuXG5cdHZhciBtYWtlUHJvbWlzZSA9IHJlcXVpcmUoJy4vbWFrZVByb21pc2UnKTtcblx0dmFyIFNjaGVkdWxlciA9IHJlcXVpcmUoJy4vU2NoZWR1bGVyJyk7XG5cdHZhciBhc3luYyA9IHJlcXVpcmUoJy4vYXN5bmMnKTtcblxuXHRyZXR1cm4gbWFrZVByb21pc2Uoe1xuXHRcdHNjaGVkdWxlcjogbmV3IFNjaGVkdWxlcihhc3luYylcblx0fSk7XG5cbn0pO1xufSkodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24gKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9KTtcbiIsIi8qKiBAbGljZW5zZSBNSVQgTGljZW5zZSAoYykgY29weXJpZ2h0IDIwMTAtMjAxNCBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9ycyAqL1xuLyoqIEBhdXRob3IgQnJpYW4gQ2F2YWxpZXIgKi9cbi8qKiBAYXV0aG9yIEpvaG4gSGFubiAqL1xuXG4oZnVuY3Rpb24oZGVmaW5lKSB7ICd1c2Ugc3RyaWN0JztcbmRlZmluZShmdW5jdGlvbigpIHtcblx0LyoqXG5cdCAqIENpcmN1bGFyIHF1ZXVlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjYXBhY2l0eVBvdzIgcG93ZXIgb2YgMiB0byB3aGljaCB0aGlzIHF1ZXVlJ3MgY2FwYWNpdHlcblx0ICogIHdpbGwgYmUgc2V0IGluaXRpYWxseS4gZWcgd2hlbiBjYXBhY2l0eVBvdzIgPT0gMywgcXVldWUgY2FwYWNpdHlcblx0ICogIHdpbGwgYmUgOC5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBRdWV1ZShjYXBhY2l0eVBvdzIpIHtcblx0XHR0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSB0aGlzLmxlbmd0aCA9IDA7XG5cdFx0dGhpcy5idWZmZXIgPSBuZXcgQXJyYXkoMSA8PCBjYXBhY2l0eVBvdzIpO1xuXHR9XG5cblx0UXVldWUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbih4KSB7XG5cdFx0aWYodGhpcy5sZW5ndGggPT09IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5fZW5zdXJlQ2FwYWNpdHkodGhpcy5sZW5ndGggKiAyKTtcblx0XHR9XG5cblx0XHR0aGlzLmJ1ZmZlclt0aGlzLnRhaWxdID0geDtcblx0XHR0aGlzLnRhaWwgPSAodGhpcy50YWlsICsgMSkgJiAodGhpcy5idWZmZXIubGVuZ3RoIC0gMSk7XG5cdFx0Kyt0aGlzLmxlbmd0aDtcblx0XHRyZXR1cm4gdGhpcy5sZW5ndGg7XG5cdH07XG5cblx0UXVldWUucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHggPSB0aGlzLmJ1ZmZlclt0aGlzLmhlYWRdO1xuXHRcdHRoaXMuYnVmZmVyW3RoaXMuaGVhZF0gPSB2b2lkIDA7XG5cdFx0dGhpcy5oZWFkID0gKHRoaXMuaGVhZCArIDEpICYgKHRoaXMuYnVmZmVyLmxlbmd0aCAtIDEpO1xuXHRcdC0tdGhpcy5sZW5ndGg7XG5cdFx0cmV0dXJuIHg7XG5cdH07XG5cblx0UXVldWUucHJvdG90eXBlLl9lbnN1cmVDYXBhY2l0eSA9IGZ1bmN0aW9uKGNhcGFjaXR5KSB7XG5cdFx0dmFyIGhlYWQgPSB0aGlzLmhlYWQ7XG5cdFx0dmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuXHRcdHZhciBuZXdCdWZmZXIgPSBuZXcgQXJyYXkoY2FwYWNpdHkpO1xuXHRcdHZhciBpID0gMDtcblx0XHR2YXIgbGVuO1xuXG5cdFx0aWYoaGVhZCA9PT0gMCkge1xuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGg7XG5cdFx0XHRmb3IoOyBpPGxlbjsgKytpKSB7XG5cdFx0XHRcdG5ld0J1ZmZlcltpXSA9IGJ1ZmZlcltpXTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FwYWNpdHkgPSBidWZmZXIubGVuZ3RoO1xuXHRcdFx0bGVuID0gdGhpcy50YWlsO1xuXHRcdFx0Zm9yKDsgaGVhZDxjYXBhY2l0eTsgKytpLCArK2hlYWQpIHtcblx0XHRcdFx0bmV3QnVmZmVyW2ldID0gYnVmZmVyW2hlYWRdO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoaGVhZD0wOyBoZWFkPGxlbjsgKytpLCArK2hlYWQpIHtcblx0XHRcdFx0bmV3QnVmZmVyW2ldID0gYnVmZmVyW2hlYWRdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuYnVmZmVyID0gbmV3QnVmZmVyO1xuXHRcdHRoaXMuaGVhZCA9IDA7XG5cdFx0dGhpcy50YWlsID0gdGhpcy5sZW5ndGg7XG5cdH07XG5cblx0cmV0dXJuIFF1ZXVlO1xuXG59KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24oZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTsgfSkpO1xuIiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG4vKiogQGF1dGhvciBCcmlhbiBDYXZhbGllciAqL1xuLyoqIEBhdXRob3IgSm9obiBIYW5uICovXG5cbihmdW5jdGlvbihkZWZpbmUpIHsgJ3VzZSBzdHJpY3QnO1xuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUpIHtcblxuXHR2YXIgUXVldWUgPSByZXF1aXJlKCcuL1F1ZXVlJyk7XG5cblx0Ly8gQ3JlZGl0IHRvIFR3aXNvbCAoaHR0cHM6Ly9naXRodWIuY29tL1R3aXNvbCkgZm9yIHN1Z2dlc3Rpbmdcblx0Ly8gdGhpcyB0eXBlIG9mIGV4dGVuc2libGUgcXVldWUgKyB0cmFtcG9saW5lIGFwcHJvYWNoIGZvciBuZXh0LXRpY2sgY29uZmxhdGlvbi5cblxuXHQvKipcblx0ICogQXN5bmMgdGFzayBzY2hlZHVsZXJcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gYXN5bmMgZnVuY3Rpb24gdG8gc2NoZWR1bGUgYSBzaW5nbGUgYXN5bmMgZnVuY3Rpb25cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBTY2hlZHVsZXIoYXN5bmMpIHtcblx0XHR0aGlzLl9hc3luYyA9IGFzeW5jO1xuXHRcdHRoaXMuX3F1ZXVlID0gbmV3IFF1ZXVlKDE1KTtcblx0XHR0aGlzLl9hZnRlclF1ZXVlID0gbmV3IFF1ZXVlKDUpO1xuXHRcdHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcblxuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR0aGlzLmRyYWluID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRzZWxmLl9kcmFpbigpO1xuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogRW5xdWV1ZSBhIHRhc2tcblx0ICogQHBhcmFtIHt7IHJ1bjpmdW5jdGlvbiB9fSB0YXNrXG5cdCAqL1xuXHRTY2hlZHVsZXIucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbih0YXNrKSB7XG5cdFx0dGhpcy5fYWRkKHRoaXMuX3F1ZXVlLCB0YXNrKTtcblx0fTtcblxuXHQvKipcblx0ICogRW5xdWV1ZSBhIHRhc2sgdG8gcnVuIGFmdGVyIHRoZSBtYWluIHRhc2sgcXVldWVcblx0ICogQHBhcmFtIHt7IHJ1bjpmdW5jdGlvbiB9fSB0YXNrXG5cdCAqL1xuXHRTY2hlZHVsZXIucHJvdG90eXBlLmFmdGVyUXVldWUgPSBmdW5jdGlvbih0YXNrKSB7XG5cdFx0dGhpcy5fYWRkKHRoaXMuX2FmdGVyUXVldWUsIHRhc2spO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmFpbiB0aGUgaGFuZGxlciBxdWV1ZSBlbnRpcmVseSwgYW5kIHRoZW4gdGhlIGFmdGVyIHF1ZXVlXG5cdCAqL1xuXHRTY2hlZHVsZXIucHJvdG90eXBlLl9kcmFpbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHJ1blF1ZXVlKHRoaXMuX3F1ZXVlKTtcblx0XHR0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG5cdFx0cnVuUXVldWUodGhpcy5fYWZ0ZXJRdWV1ZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZCBhIHRhc2sgdG8gdGhlIHEsIGFuZCBzY2hlZHVsZSBkcmFpbiBpZiBub3QgYWxyZWFkeSBzY2hlZHVsZWRcblx0ICogQHBhcmFtIHtRdWV1ZX0gcXVldWVcblx0ICogQHBhcmFtIHt7cnVuOmZ1bmN0aW9ufX0gdGFza1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0U2NoZWR1bGVyLnByb3RvdHlwZS5fYWRkID0gZnVuY3Rpb24ocXVldWUsIHRhc2spIHtcblx0XHRxdWV1ZS5wdXNoKHRhc2spO1xuXHRcdGlmKCF0aGlzLl9ydW5uaW5nKSB7XG5cdFx0XHR0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcblx0XHRcdHRoaXMuX2FzeW5jKHRoaXMuZHJhaW4pO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUnVuIGFsbCB0aGUgdGFza3MgaW4gdGhlIHFcblx0ICogQHBhcmFtIHF1ZXVlXG5cdCAqL1xuXHRmdW5jdGlvbiBydW5RdWV1ZShxdWV1ZSkge1xuXHRcdHdoaWxlKHF1ZXVlLmxlbmd0aCA+IDApIHtcblx0XHRcdHF1ZXVlLnNoaWZ0KCkucnVuKCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIFNjaGVkdWxlcjtcblxufSk7XG59KHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUpOyB9KSk7XG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cblxuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSkge1xuXG5cdC8vIFNuaWZmIFwiYmVzdFwiIGFzeW5jIHNjaGVkdWxpbmcgb3B0aW9uXG5cdC8vIFByZWZlciBwcm9jZXNzLm5leHRUaWNrIG9yIE11dGF0aW9uT2JzZXJ2ZXIsIHRoZW4gY2hlY2sgZm9yXG5cdC8vIHZlcnR4IGFuZCBmaW5hbGx5IGZhbGwgYmFjayB0byBzZXRUaW1lb3V0XG5cblx0Lypqc2hpbnQgbWF4Y29tcGxleGl0eTo2Ki9cblx0LypnbG9iYWwgcHJvY2Vzcyxkb2N1bWVudCxzZXRUaW1lb3V0LE11dGF0aW9uT2JzZXJ2ZXIsV2ViS2l0TXV0YXRpb25PYnNlcnZlciovXG5cdHZhciBuZXh0VGljaywgTXV0YXRpb25PYnM7XG5cblx0aWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzICE9PSBudWxsICYmXG5cdFx0dHlwZW9mIHByb2Nlc3MubmV4dFRpY2sgPT09ICdmdW5jdGlvbicpIHtcblx0XHRuZXh0VGljayA9IGZ1bmN0aW9uKGYpIHtcblx0XHRcdHByb2Nlc3MubmV4dFRpY2soZik7XG5cdFx0fTtcblxuXHR9IGVsc2UgaWYgKE11dGF0aW9uT2JzID1cblx0XHQodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicgJiYgTXV0YXRpb25PYnNlcnZlcikgfHxcblx0XHQodHlwZW9mIFdlYktpdE11dGF0aW9uT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicgJiYgV2ViS2l0TXV0YXRpb25PYnNlcnZlcikpIHtcblx0XHRuZXh0VGljayA9IChmdW5jdGlvbiAoZG9jdW1lbnQsIE11dGF0aW9uT2JzZXJ2ZXIpIHtcblx0XHRcdHZhciBzY2hlZHVsZWQ7XG5cdFx0XHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRcdHZhciBvID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIocnVuKTtcblx0XHRcdG8ub2JzZXJ2ZShlbCwgeyBhdHRyaWJ1dGVzOiB0cnVlIH0pO1xuXG5cdFx0XHRmdW5jdGlvbiBydW4oKSB7XG5cdFx0XHRcdHZhciBmID0gc2NoZWR1bGVkO1xuXHRcdFx0XHRzY2hlZHVsZWQgPSB2b2lkIDA7XG5cdFx0XHRcdGYoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChmKSB7XG5cdFx0XHRcdHNjaGVkdWxlZCA9IGY7XG5cdFx0XHRcdGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAneCcpO1xuXHRcdFx0fTtcblx0XHR9KGRvY3VtZW50LCBNdXRhdGlvbk9icykpO1xuXG5cdH0gZWxzZSB7XG5cdFx0bmV4dFRpY2sgPSAoZnVuY3Rpb24oY2pzUmVxdWlyZSkge1xuXHRcdFx0dmFyIHZlcnR4O1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gdmVydC54IDEueCB8fCAyLnhcblx0XHRcdFx0dmVydHggPSBjanNSZXF1aXJlKCd2ZXJ0eCcpO1xuXHRcdFx0fSBjYXRjaCAoaWdub3JlKSB7fVxuXG5cdFx0XHRpZiAodmVydHgpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiB2ZXJ0eC5ydW5Pbkxvb3AgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRyZXR1cm4gdmVydHgucnVuT25Mb29wO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0eXBlb2YgdmVydHgucnVuT25Db250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZlcnR4LnJ1bk9uQ29udGV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjYXB0dXJlIHNldFRpbWVvdXQgdG8gYXZvaWQgYmVpbmcgY2F1Z2h0IGJ5IGZha2UgdGltZXJzXG5cdFx0XHQvLyB1c2VkIGluIHRpbWUgYmFzZWQgdGVzdHNcblx0XHRcdHZhciBjYXB0dXJlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICh0KSB7XG5cdFx0XHRcdGNhcHR1cmVkU2V0VGltZW91dCh0LCAwKTtcblx0XHRcdH07XG5cdFx0fShyZXF1aXJlKSk7XG5cdH1cblxuXHRyZXR1cm4gbmV4dFRpY2s7XG59KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24oZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH0pKTtcbiIsIi8qKiBAbGljZW5zZSBNSVQgTGljZW5zZSAoYykgY29weXJpZ2h0IDIwMTAtMjAxNCBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9ycyAqL1xuLyoqIEBhdXRob3IgQnJpYW4gQ2F2YWxpZXIgKi9cbi8qKiBAYXV0aG9yIEpvaG4gSGFubiAqL1xuXG4oZnVuY3Rpb24oZGVmaW5lKSB7ICd1c2Ugc3RyaWN0JztcbmRlZmluZShmdW5jdGlvbigpIHtcblxuXHRyZXR1cm4gZnVuY3Rpb24gbWFrZVByb21pc2UoZW52aXJvbm1lbnQpIHtcblxuXHRcdHZhciB0YXNrcyA9IGVudmlyb25tZW50LnNjaGVkdWxlcjtcblxuXHRcdHZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8XG5cdFx0XHRmdW5jdGlvbihwcm90bykge1xuXHRcdFx0XHRmdW5jdGlvbiBDaGlsZCgpIHt9XG5cdFx0XHRcdENoaWxkLnByb3RvdHlwZSA9IHByb3RvO1xuXHRcdFx0XHRyZXR1cm4gbmV3IENoaWxkKCk7XG5cdFx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIGEgcHJvbWlzZSB3aG9zZSBmYXRlIGlzIGRldGVybWluZWQgYnkgcmVzb2x2ZXJcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZVxuXHRcdCAqIEBuYW1lIFByb21pc2Vcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyLCBoYW5kbGVyKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVyID0gcmVzb2x2ZXIgPT09IEhhbmRsZXIgPyBoYW5kbGVyIDogaW5pdChyZXNvbHZlcik7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUnVuIHRoZSBzdXBwbGllZCByZXNvbHZlclxuXHRcdCAqIEBwYXJhbSByZXNvbHZlclxuXHRcdCAqIEByZXR1cm5zIHtQZW5kaW5nfVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGluaXQocmVzb2x2ZXIpIHtcblx0XHRcdHZhciBoYW5kbGVyID0gbmV3IFBlbmRpbmcoKTtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmVzb2x2ZXIocHJvbWlzZVJlc29sdmUsIHByb21pc2VSZWplY3QsIHByb21pc2VOb3RpZnkpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRwcm9taXNlUmVqZWN0KGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaGFuZGxlcjtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUcmFuc2l0aW9uIGZyb20gcHJlLXJlc29sdXRpb24gc3RhdGUgdG8gcG9zdC1yZXNvbHV0aW9uIHN0YXRlLCBub3RpZnlpbmdcblx0XHRcdCAqIGFsbCBsaXN0ZW5lcnMgb2YgdGhlIHVsdGltYXRlIGZ1bGZpbGxtZW50IG9yIHJlamVjdGlvblxuXHRcdFx0ICogQHBhcmFtIHsqfSB4IHJlc29sdXRpb24gdmFsdWVcblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gcHJvbWlzZVJlc29sdmUgKHgpIHtcblx0XHRcdFx0aGFuZGxlci5yZXNvbHZlKHgpO1xuXHRcdFx0fVxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZWplY3QgdGhpcyBwcm9taXNlIHdpdGggcmVhc29uLCB3aGljaCB3aWxsIGJlIHVzZWQgdmVyYmF0aW1cblx0XHRcdCAqIEBwYXJhbSB7RXJyb3J8Kn0gcmVhc29uIHJlamVjdGlvbiByZWFzb24sIHN0cm9uZ2x5IHN1Z2dlc3RlZFxuXHRcdFx0ICogICB0byBiZSBhbiBFcnJvciB0eXBlXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIHByb21pc2VSZWplY3QgKHJlYXNvbikge1xuXHRcdFx0XHRoYW5kbGVyLnJlamVjdChyZWFzb24pO1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIElzc3VlIGEgcHJvZ3Jlc3MgZXZlbnQsIG5vdGlmeWluZyBhbGwgcHJvZ3Jlc3MgbGlzdGVuZXJzXG5cdFx0XHQgKiBAcGFyYW0geyp9IHggcHJvZ3Jlc3MgZXZlbnQgcGF5bG9hZCB0byBwYXNzIHRvIGFsbCBsaXN0ZW5lcnNcblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gcHJvbWlzZU5vdGlmeSAoeCkge1xuXHRcdFx0XHRoYW5kbGVyLm5vdGlmeSh4KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDcmVhdGlvblxuXG5cdFx0UHJvbWlzZS5yZXNvbHZlID0gcmVzb2x2ZTtcblx0XHRQcm9taXNlLnJlamVjdCA9IHJlamVjdDtcblx0XHRQcm9taXNlLm5ldmVyID0gbmV2ZXI7XG5cblx0XHRQcm9taXNlLl9kZWZlciA9IGRlZmVyO1xuXHRcdFByb21pc2UuX2hhbmRsZXIgPSBnZXRIYW5kbGVyO1xuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhIHRydXN0ZWQgcHJvbWlzZS4gSWYgeCBpcyBhbHJlYWR5IGEgdHJ1c3RlZCBwcm9taXNlLCBpdCBpc1xuXHRcdCAqIHJldHVybmVkLCBvdGhlcndpc2UgcmV0dXJucyBhIG5ldyB0cnVzdGVkIFByb21pc2Ugd2hpY2ggZm9sbG93cyB4LlxuXHRcdCAqIEBwYXJhbSAgeyp9IHhcblx0XHQgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG5cdFx0XHRyZXR1cm4gaXNQcm9taXNlKHgpID8geFxuXHRcdFx0XHQ6IG5ldyBQcm9taXNlKEhhbmRsZXIsIG5ldyBBc3luYyhnZXRIYW5kbGVyKHgpKSk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIGEgcmVqZWN0IHByb21pc2Ugd2l0aCB4IGFzIGl0cyByZWFzb24gKHggaXMgdXNlZCB2ZXJiYXRpbSlcblx0XHQgKiBAcGFyYW0geyp9IHhcblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gcmVqZWN0ZWQgcHJvbWlzZVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHJlamVjdCh4KSB7XG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoSGFuZGxlciwgbmV3IEFzeW5jKG5ldyBSZWplY3RlZCh4KSkpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiBhIHByb21pc2UgdGhhdCByZW1haW5zIHBlbmRpbmcgZm9yZXZlclxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBmb3JldmVyLXBlbmRpbmcgcHJvbWlzZS5cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBuZXZlcigpIHtcblx0XHRcdHJldHVybiBmb3JldmVyUGVuZGluZ1Byb21pc2U7IC8vIFNob3VsZCBiZSBmcm96ZW5cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGVzIGFuIGludGVybmFsIHtwcm9taXNlLCByZXNvbHZlcn0gcGFpclxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gZGVmZXIoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoSGFuZGxlciwgbmV3IFBlbmRpbmcoKSk7XG5cdFx0fVxuXG5cdFx0Ly8gVHJhbnNmb3JtYXRpb24gYW5kIGZsb3cgY29udHJvbFxuXG5cdFx0LyoqXG5cdFx0ICogVHJhbnNmb3JtIHRoaXMgcHJvbWlzZSdzIGZ1bGZpbGxtZW50IHZhbHVlLCByZXR1cm5pbmcgYSBuZXcgUHJvbWlzZVxuXHRcdCAqIGZvciB0aGUgdHJhbnNmb3JtZWQgcmVzdWx0LiAgSWYgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZCwgb25SZWplY3RlZFxuXHRcdCAqIGlzIGNhbGxlZCB3aXRoIHRoZSByZWFzb24uICBvblByb2dyZXNzICptYXkqIGJlIGNhbGxlZCB3aXRoIHVwZGF0ZXMgdG93YXJkXG5cdFx0ICogdGhpcyBwcm9taXNlJ3MgZnVsZmlsbG1lbnQuXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbj19IG9uRnVsZmlsbGVkIGZ1bGZpbGxtZW50IGhhbmRsZXJcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gb25SZWplY3RlZCByZWplY3Rpb24gaGFuZGxlclxuXHRcdCAqIEBkZXByZWNhdGVkIEBwYXJhbSB7ZnVuY3Rpb249fSBvblByb2dyZXNzIHByb2dyZXNzIGhhbmRsZXJcblx0XHQgKiBAcmV0dXJuIHtQcm9taXNlfSBuZXcgcHJvbWlzZVxuXHRcdCAqL1xuXHRcdFByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMuX2hhbmRsZXI7XG5cdFx0XHR2YXIgc3RhdGUgPSBwYXJlbnQuam9pbigpLnN0YXRlKCk7XG5cblx0XHRcdGlmICgodHlwZW9mIG9uRnVsZmlsbGVkICE9PSAnZnVuY3Rpb24nICYmIHN0YXRlID4gMCkgfHxcblx0XHRcdFx0KHR5cGVvZiBvblJlamVjdGVkICE9PSAnZnVuY3Rpb24nICYmIHN0YXRlIDwgMCkpIHtcblx0XHRcdFx0Ly8gU2hvcnQgY2lyY3VpdDogdmFsdWUgd2lsbCBub3QgY2hhbmdlLCBzaW1wbHkgc2hhcmUgaGFuZGxlclxuXHRcdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoSGFuZGxlciwgcGFyZW50KTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHAgPSB0aGlzLl9iZWdldCgpO1xuXHRcdFx0dmFyIGNoaWxkID0gcC5faGFuZGxlcjtcblxuXHRcdFx0cGFyZW50LmNoYWluKGNoaWxkLCBwYXJlbnQucmVjZWl2ZXIsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLFxuXHRcdFx0XHRcdGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdm9pZCAwKTtcblxuXHRcdFx0cmV0dXJuIHA7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIElmIHRoaXMgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkIGR1ZSB0byBhbiBlcnJvciwgY2FsbCBvblJlamVjdGVkIHRvXG5cdFx0ICogaGFuZGxlIHRoZSBlcnJvci4gU2hvcnRjdXQgZm9yIC50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZClcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uP30gb25SZWplY3RlZFxuXHRcdCAqIEByZXR1cm4ge1Byb21pc2V9XG5cdFx0ICovXG5cdFx0UHJvbWlzZS5wcm90b3R5cGVbJ2NhdGNoJ10gPSBmdW5jdGlvbihvblJlamVjdGVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50aGVuKHZvaWQgMCwgb25SZWplY3RlZCk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgYSBuZXcsIHBlbmRpbmcgcHJvbWlzZSBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoaXMgcHJvbWlzZVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdFx0ICovXG5cdFx0UHJvbWlzZS5wcm90b3R5cGUuX2JlZ2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5faGFuZGxlcjtcblx0XHRcdHZhciBjaGlsZCA9IG5ldyBQZW5kaW5nKHBhcmVudC5yZWNlaXZlciwgcGFyZW50LmpvaW4oKS5jb250ZXh0KTtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihIYW5kbGVyLCBjaGlsZCk7XG5cdFx0fTtcblxuXHRcdC8vIEFycmF5IGNvbWJpbmF0b3JzXG5cblx0XHRQcm9taXNlLmFsbCA9IGFsbDtcblx0XHRQcm9taXNlLnJhY2UgPSByYWNlO1xuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIGEgcHJvbWlzZSB0aGF0IHdpbGwgZnVsZmlsbCB3aGVuIGFsbCBwcm9taXNlcyBpbiB0aGVcblx0XHQgKiBpbnB1dCBhcnJheSBoYXZlIGZ1bGZpbGxlZCwgb3Igd2lsbCByZWplY3Qgd2hlbiBvbmUgb2YgdGhlXG5cdFx0ICogcHJvbWlzZXMgcmVqZWN0cy5cblx0XHQgKiBAcGFyYW0ge2FycmF5fSBwcm9taXNlcyBhcnJheSBvZiBwcm9taXNlc1xuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIGZvciBhcnJheSBvZiBmdWxmaWxsbWVudCB2YWx1ZXNcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcblx0XHRcdC8qanNoaW50IG1heGNvbXBsZXhpdHk6OCovXG5cdFx0XHR2YXIgcmVzb2x2ZXIgPSBuZXcgUGVuZGluZygpO1xuXHRcdFx0dmFyIHBlbmRpbmcgPSBwcm9taXNlcy5sZW5ndGggPj4+IDA7XG5cdFx0XHR2YXIgcmVzdWx0cyA9IG5ldyBBcnJheShwZW5kaW5nKTtcblxuXHRcdFx0dmFyIGksIGgsIHgsIHM7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcHJvbWlzZXMubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0eCA9IHByb21pc2VzW2ldO1xuXG5cdFx0XHRcdGlmICh4ID09PSB2b2lkIDAgJiYgIShpIGluIHByb21pc2VzKSkge1xuXHRcdFx0XHRcdC0tcGVuZGluZztcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChtYXliZVRoZW5hYmxlKHgpKSB7XG5cdFx0XHRcdFx0aCA9IGdldEhhbmRsZXJNYXliZVRoZW5hYmxlKHgpO1xuXG5cdFx0XHRcdFx0cyA9IGguc3RhdGUoKTtcblx0XHRcdFx0XHRpZiAocyA9PT0gMCkge1xuXHRcdFx0XHRcdFx0aC5mb2xkKHNldHRsZUF0LCBpLCByZXN1bHRzLCByZXNvbHZlcik7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChzID4gMCkge1xuXHRcdFx0XHRcdFx0cmVzdWx0c1tpXSA9IGgudmFsdWU7XG5cdFx0XHRcdFx0XHQtLXBlbmRpbmc7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHVucmVwb3J0UmVtYWluaW5nKHByb21pc2VzLCBpKzEsIGgpO1xuXHRcdFx0XHRcdFx0cmVzb2x2ZXIuYmVjb21lKGgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzdWx0c1tpXSA9IHg7XG5cdFx0XHRcdFx0LS1wZW5kaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmKHBlbmRpbmcgPT09IDApIHtcblx0XHRcdFx0cmVzb2x2ZXIuYmVjb21lKG5ldyBGdWxmaWxsZWQocmVzdWx0cykpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoSGFuZGxlciwgcmVzb2x2ZXIpO1xuXG5cdFx0XHRmdW5jdGlvbiBzZXR0bGVBdChpLCB4LCByZXNvbHZlcikge1xuXHRcdFx0XHQvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSovXG5cdFx0XHRcdHRoaXNbaV0gPSB4O1xuXHRcdFx0XHRpZigtLXBlbmRpbmcgPT09IDApIHtcblx0XHRcdFx0XHRyZXNvbHZlci5iZWNvbWUobmV3IEZ1bGZpbGxlZCh0aGlzKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1bnJlcG9ydFJlbWFpbmluZyhwcm9taXNlcywgc3RhcnQsIHJlamVjdGVkSGFuZGxlcikge1xuXHRcdFx0dmFyIGksIGgsIHg7XG5cdFx0XHRmb3IoaT1zdGFydDsgaTxwcm9taXNlcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR4ID0gcHJvbWlzZXNbaV07XG5cdFx0XHRcdGlmKG1heWJlVGhlbmFibGUoeCkpIHtcblx0XHRcdFx0XHRoID0gZ2V0SGFuZGxlck1heWJlVGhlbmFibGUoeCk7XG5cblx0XHRcdFx0XHRpZihoICE9PSByZWplY3RlZEhhbmRsZXIpIHtcblx0XHRcdFx0XHRcdGgudmlzaXQoaCwgdm9pZCAwLCBoLl91bnJlcG9ydCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogRnVsZmlsbC1yZWplY3QgY29tcGV0aXRpdmUgcmFjZS4gUmV0dXJuIGEgcHJvbWlzZSB0aGF0IHdpbGwgc2V0dGxlXG5cdFx0ICogdG8gdGhlIHNhbWUgc3RhdGUgYXMgdGhlIGVhcmxpZXN0IGlucHV0IHByb21pc2UgdG8gc2V0dGxlLlxuXHRcdCAqXG5cdFx0ICogV0FSTklORzogVGhlIEVTNiBQcm9taXNlIHNwZWMgcmVxdWlyZXMgdGhhdCByYWNlKClpbmcgYW4gZW1wdHkgYXJyYXlcblx0XHQgKiBtdXN0IHJldHVybiBhIHByb21pc2UgdGhhdCBpcyBwZW5kaW5nIGZvcmV2ZXIuICBUaGlzIGltcGxlbWVudGF0aW9uXG5cdFx0ICogcmV0dXJucyBhIHNpbmdsZXRvbiBmb3JldmVyLXBlbmRpbmcgcHJvbWlzZSwgdGhlIHNhbWUgc2luZ2xldG9uIHRoYXQgaXNcblx0XHQgKiByZXR1cm5lZCBieSBQcm9taXNlLm5ldmVyKCksIHRodXMgY2FuIGJlIGNoZWNrZWQgd2l0aCA9PT1cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7YXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzIHRvIHJhY2Vcblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gaWYgaW5wdXQgaXMgbm9uLWVtcHR5LCBhIHByb21pc2UgdGhhdCB3aWxsIHNldHRsZVxuXHRcdCAqIHRvIHRoZSBzYW1lIG91dGNvbWUgYXMgdGhlIGVhcmxpZXN0IGlucHV0IHByb21pc2UgdG8gc2V0dGxlLiBpZiBlbXB0eVxuXHRcdCAqIGlzIGVtcHR5LCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgbmV2ZXIgc2V0dGxlLlxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHJhY2UocHJvbWlzZXMpIHtcblx0XHRcdC8vIFNpZ2gsIHJhY2UoW10pIGlzIHVudGVzdGFibGUgdW5sZXNzIHdlIHJldHVybiAqc29tZXRoaW5nKlxuXHRcdFx0Ly8gdGhhdCBpcyByZWNvZ25pemFibGUgd2l0aG91dCBjYWxsaW5nIC50aGVuKCkgb24gaXQuXG5cdFx0XHRpZihPYmplY3QocHJvbWlzZXMpID09PSBwcm9taXNlcyAmJiBwcm9taXNlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIG5ldmVyKCk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBoID0gbmV3IFBlbmRpbmcoKTtcblx0XHRcdHZhciBpLCB4O1xuXHRcdFx0Zm9yKGk9MDsgaTxwcm9taXNlcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR4ID0gcHJvbWlzZXNbaV07XG5cdFx0XHRcdGlmICh4ICE9PSB2b2lkIDAgJiYgaSBpbiBwcm9taXNlcykge1xuXHRcdFx0XHRcdGdldEhhbmRsZXIoeCkudmlzaXQoaCwgaC5yZXNvbHZlLCBoLnJlamVjdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShIYW5kbGVyLCBoKTtcblx0XHR9XG5cblx0XHQvLyBQcm9taXNlIGludGVybmFsc1xuXHRcdC8vIEJlbG93IHRoaXMsIGV2ZXJ5dGhpbmcgaXMgQHByaXZhdGVcblxuXHRcdC8qKlxuXHRcdCAqIEdldCBhbiBhcHByb3ByaWF0ZSBoYW5kbGVyIGZvciB4LCB3aXRob3V0IGNoZWNraW5nIGZvciBjeWNsZXNcblx0XHQgKiBAcGFyYW0geyp9IHhcblx0XHQgKiBAcmV0dXJucyB7b2JqZWN0fSBoYW5kbGVyXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gZ2V0SGFuZGxlcih4KSB7XG5cdFx0XHRpZihpc1Byb21pc2UoeCkpIHtcblx0XHRcdFx0cmV0dXJuIHguX2hhbmRsZXIuam9pbigpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1heWJlVGhlbmFibGUoeCkgPyBnZXRIYW5kbGVyVW50cnVzdGVkKHgpIDogbmV3IEZ1bGZpbGxlZCh4KTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBHZXQgYSBoYW5kbGVyIGZvciB0aGVuYWJsZSB4LlxuXHRcdCAqIE5PVEU6IFlvdSBtdXN0IG9ubHkgY2FsbCB0aGlzIGlmIG1heWJlVGhlbmFibGUoeCkgPT0gdHJ1ZVxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufFByb21pc2V9IHhcblx0XHQgKiBAcmV0dXJucyB7b2JqZWN0fSBoYW5kbGVyXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gZ2V0SGFuZGxlck1heWJlVGhlbmFibGUoeCkge1xuXHRcdFx0cmV0dXJuIGlzUHJvbWlzZSh4KSA/IHguX2hhbmRsZXIuam9pbigpIDogZ2V0SGFuZGxlclVudHJ1c3RlZCh4KTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBHZXQgYSBoYW5kbGVyIGZvciBwb3RlbnRpYWxseSB1bnRydXN0ZWQgdGhlbmFibGUgeFxuXHRcdCAqIEBwYXJhbSB7Kn0geFxuXHRcdCAqIEByZXR1cm5zIHtvYmplY3R9IGhhbmRsZXJcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBnZXRIYW5kbGVyVW50cnVzdGVkKHgpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciB1bnRydXN0ZWRUaGVuID0geC50aGVuO1xuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIHVudHJ1c3RlZFRoZW4gPT09ICdmdW5jdGlvbidcblx0XHRcdFx0XHQ/IG5ldyBUaGVuYWJsZSh1bnRydXN0ZWRUaGVuLCB4KVxuXHRcdFx0XHRcdDogbmV3IEZ1bGZpbGxlZCh4KTtcblx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IFJlamVjdGVkKGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXIgZm9yIGEgcHJvbWlzZSB0aGF0IGlzIHBlbmRpbmcgZm9yZXZlclxuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIEhhbmRsZXIoKSB7fVxuXG5cdFx0SGFuZGxlci5wcm90b3R5cGUud2hlblxuXHRcdFx0PSBIYW5kbGVyLnByb3RvdHlwZS5iZWNvbWVcblx0XHRcdD0gSGFuZGxlci5wcm90b3R5cGUubm90aWZ5XG5cdFx0XHQ9IEhhbmRsZXIucHJvdG90eXBlLmZhaWxcblx0XHRcdD0gSGFuZGxlci5wcm90b3R5cGUuX3VucmVwb3J0XG5cdFx0XHQ9IEhhbmRsZXIucHJvdG90eXBlLl9yZXBvcnRcblx0XHRcdD0gbm9vcDtcblxuXHRcdEhhbmRsZXIucHJvdG90eXBlLl9zdGF0ZSA9IDA7XG5cblx0XHRIYW5kbGVyLnByb3RvdHlwZS5zdGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3N0YXRlO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSZWN1cnNpdmVseSBjb2xsYXBzZSBoYW5kbGVyIGNoYWluIHRvIGZpbmQgdGhlIGhhbmRsZXJcblx0XHQgKiBuZWFyZXN0IHRvIHRoZSBmdWxseSByZXNvbHZlZCB2YWx1ZS5cblx0XHQgKiBAcmV0dXJucyB7b2JqZWN0fSBoYW5kbGVyIG5lYXJlc3QgdGhlIGZ1bGx5IHJlc29sdmVkIHZhbHVlXG5cdFx0ICovXG5cdFx0SGFuZGxlci5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGggPSB0aGlzO1xuXHRcdFx0d2hpbGUoaC5oYW5kbGVyICE9PSB2b2lkIDApIHtcblx0XHRcdFx0aCA9IGguaGFuZGxlcjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBoO1xuXHRcdH07XG5cblx0XHRIYW5kbGVyLnByb3RvdHlwZS5jaGFpbiA9IGZ1bmN0aW9uKHRvLCByZWNlaXZlciwgZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIHtcblx0XHRcdHRoaXMud2hlbih7XG5cdFx0XHRcdHJlc29sdmVyOiB0byxcblx0XHRcdFx0cmVjZWl2ZXI6IHJlY2VpdmVyLFxuXHRcdFx0XHRmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcblx0XHRcdFx0cmVqZWN0ZWQ6IHJlamVjdGVkLFxuXHRcdFx0XHRwcm9ncmVzczogcHJvZ3Jlc3Ncblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHRIYW5kbGVyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uKHJlY2VpdmVyLCBmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcykge1xuXHRcdFx0dGhpcy5jaGFpbihmYWlsSWZSZWplY3RlZCwgcmVjZWl2ZXIsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKTtcblx0XHR9O1xuXG5cdFx0SGFuZGxlci5wcm90b3R5cGUuZm9sZCA9IGZ1bmN0aW9uKGYsIHosIGMsIHRvKSB7XG5cdFx0XHR0aGlzLnZpc2l0KHRvLCBmdW5jdGlvbih4KSB7XG5cdFx0XHRcdGYuY2FsbChjLCB6LCB4LCB0aGlzKTtcblx0XHRcdH0sIHRvLnJlamVjdCwgdG8ubm90aWZ5KTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlciB0aGF0IGludm9rZXMgZmFpbCgpIG9uIGFueSBoYW5kbGVyIGl0IGJlY29tZXNcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBGYWlsSWZSZWplY3RlZCgpIHt9XG5cblx0XHRpbmhlcml0KEhhbmRsZXIsIEZhaWxJZlJlamVjdGVkKTtcblxuXHRcdEZhaWxJZlJlamVjdGVkLnByb3RvdHlwZS5iZWNvbWUgPSBmdW5jdGlvbihoKSB7XG5cdFx0XHRoLmZhaWwoKTtcblx0XHR9O1xuXG5cdFx0dmFyIGZhaWxJZlJlamVjdGVkID0gbmV3IEZhaWxJZlJlamVjdGVkKCk7XG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGVyIHRoYXQgbWFuYWdlcyBhIHF1ZXVlIG9mIGNvbnN1bWVycyB3YWl0aW5nIG9uIGEgcGVuZGluZyBwcm9taXNlXG5cdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gUGVuZGluZyhyZWNlaXZlciwgaW5oZXJpdGVkQ29udGV4dCkge1xuXHRcdFx0UHJvbWlzZS5jcmVhdGVDb250ZXh0KHRoaXMsIGluaGVyaXRlZENvbnRleHQpO1xuXG5cdFx0XHR0aGlzLmNvbnN1bWVycyA9IHZvaWQgMDtcblx0XHRcdHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcblx0XHRcdHRoaXMuaGFuZGxlciA9IHZvaWQgMDtcblx0XHRcdHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRpbmhlcml0KEhhbmRsZXIsIFBlbmRpbmcpO1xuXG5cdFx0UGVuZGluZy5wcm90b3R5cGUuX3N0YXRlID0gMDtcblxuXHRcdFBlbmRpbmcucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbih4KSB7XG5cdFx0XHR0aGlzLmJlY29tZShnZXRIYW5kbGVyKHgpKTtcblx0XHR9O1xuXG5cdFx0UGVuZGluZy5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0aWYodGhpcy5yZXNvbHZlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuYmVjb21lKG5ldyBSZWplY3RlZCh4KSk7XG5cdFx0fTtcblxuXHRcdFBlbmRpbmcucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICghdGhpcy5yZXNvbHZlZCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblxuXHRcdFx0dmFyIGggPSB0aGlzO1xuXG5cdFx0XHR3aGlsZSAoaC5oYW5kbGVyICE9PSB2b2lkIDApIHtcblx0XHRcdFx0aCA9IGguaGFuZGxlcjtcblx0XHRcdFx0aWYgKGggPT09IHRoaXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5oYW5kbGVyID0gY3ljbGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaDtcblx0XHR9O1xuXG5cdFx0UGVuZGluZy5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcSA9IHRoaXMuY29uc3VtZXJzO1xuXHRcdFx0dmFyIGhhbmRsZXIgPSB0aGlzLmpvaW4oKTtcblx0XHRcdHRoaXMuY29uc3VtZXJzID0gdm9pZCAwO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHEubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0aGFuZGxlci53aGVuKHFbaV0pO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRQZW5kaW5nLnByb3RvdHlwZS5iZWNvbWUgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG5cdFx0XHRpZih0aGlzLnJlc29sdmVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5yZXNvbHZlZCA9IHRydWU7XG5cdFx0XHR0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuXHRcdFx0aWYodGhpcy5jb25zdW1lcnMgIT09IHZvaWQgMCkge1xuXHRcdFx0XHR0YXNrcy5lbnF1ZXVlKHRoaXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZih0aGlzLmNvbnRleHQgIT09IHZvaWQgMCkge1xuXHRcdFx0XHRoYW5kbGVyLl9yZXBvcnQodGhpcy5jb250ZXh0KTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0UGVuZGluZy5wcm90b3R5cGUud2hlbiA9IGZ1bmN0aW9uKGNvbnRpbnVhdGlvbikge1xuXHRcdFx0aWYodGhpcy5yZXNvbHZlZCkge1xuXHRcdFx0XHR0YXNrcy5lbnF1ZXVlKG5ldyBDb250aW51YXRpb25UYXNrKGNvbnRpbnVhdGlvbiwgdGhpcy5oYW5kbGVyKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZih0aGlzLmNvbnN1bWVycyA9PT0gdm9pZCAwKSB7XG5cdFx0XHRcdFx0dGhpcy5jb25zdW1lcnMgPSBbY29udGludWF0aW9uXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLmNvbnN1bWVycy5wdXNoKGNvbnRpbnVhdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0UGVuZGluZy5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0aWYoIXRoaXMucmVzb2x2ZWQpIHtcblx0XHRcdFx0dGFza3MuZW5xdWV1ZShuZXcgUHJvZ3Jlc3NUYXNrKHgsIHRoaXMpKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0UGVuZGluZy5wcm90b3R5cGUuZmFpbCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0XHRcdHZhciBjID0gdHlwZW9mIGNvbnRleHQgPT09ICd1bmRlZmluZWQnID8gdGhpcy5jb250ZXh0IDogY29udGV4dDtcblx0XHRcdHRoaXMucmVzb2x2ZWQgJiYgdGhpcy5oYW5kbGVyLmpvaW4oKS5mYWlsKGMpO1xuXHRcdH07XG5cblx0XHRQZW5kaW5nLnByb3RvdHlwZS5fcmVwb3J0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdFx0dGhpcy5yZXNvbHZlZCAmJiB0aGlzLmhhbmRsZXIuam9pbigpLl9yZXBvcnQoY29udGV4dCk7XG5cdFx0fTtcblxuXHRcdFBlbmRpbmcucHJvdG90eXBlLl91bnJlcG9ydCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5yZXNvbHZlZCAmJiB0aGlzLmhhbmRsZXIuam9pbigpLl91bnJlcG9ydCgpO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBXcmFwIGFub3RoZXIgaGFuZGxlciBhbmQgZm9yY2UgaXQgaW50byBhIGZ1dHVyZSBzdGFja1xuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBoYW5kbGVyXG5cdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gQXN5bmMoaGFuZGxlcikge1xuXHRcdFx0dGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcblx0XHR9XG5cblx0XHRpbmhlcml0KEhhbmRsZXIsIEFzeW5jKTtcblxuXHRcdEFzeW5jLnByb3RvdHlwZS53aGVuID0gZnVuY3Rpb24oY29udGludWF0aW9uKSB7XG5cdFx0XHR0YXNrcy5lbnF1ZXVlKG5ldyBDb250aW51YXRpb25UYXNrKGNvbnRpbnVhdGlvbiwgdGhpcykpO1xuXHRcdH07XG5cblx0XHRBc3luYy5wcm90b3R5cGUuX3JlcG9ydCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0XHRcdHRoaXMuam9pbigpLl9yZXBvcnQoY29udGV4dCk7XG5cdFx0fTtcblxuXHRcdEFzeW5jLnByb3RvdHlwZS5fdW5yZXBvcnQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuam9pbigpLl91bnJlcG9ydCgpO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGVyIHRoYXQgd3JhcHMgYW4gdW50cnVzdGVkIHRoZW5hYmxlIGFuZCBhc3NpbWlsYXRlcyBpdCBpbiBhIGZ1dHVyZSBzdGFja1xuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IHRoZW5cblx0XHQgKiBAcGFyYW0ge3t0aGVuOiBmdW5jdGlvbn19IHRoZW5hYmxlXG5cdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gVGhlbmFibGUodGhlbiwgdGhlbmFibGUpIHtcblx0XHRcdFBlbmRpbmcuY2FsbCh0aGlzKTtcblx0XHRcdHRhc2tzLmVucXVldWUobmV3IEFzc2ltaWxhdGVUYXNrKHRoZW4sIHRoZW5hYmxlLCB0aGlzKSk7XG5cdFx0fVxuXG5cdFx0aW5oZXJpdChQZW5kaW5nLCBUaGVuYWJsZSk7XG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGVyIGZvciBhIGZ1bGZpbGxlZCBwcm9taXNlXG5cdFx0ICogQHBhcmFtIHsqfSB4IGZ1bGZpbGxtZW50IHZhbHVlXG5cdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gRnVsZmlsbGVkKHgpIHtcblx0XHRcdFByb21pc2UuY3JlYXRlQ29udGV4dCh0aGlzKTtcblx0XHRcdHRoaXMudmFsdWUgPSB4O1xuXHRcdH1cblxuXHRcdGluaGVyaXQoSGFuZGxlciwgRnVsZmlsbGVkKTtcblxuXHRcdEZ1bGZpbGxlZC5wcm90b3R5cGUuX3N0YXRlID0gMTtcblxuXHRcdEZ1bGZpbGxlZC5wcm90b3R5cGUuZm9sZCA9IGZ1bmN0aW9uKGYsIHosIGMsIHRvKSB7XG5cdFx0XHRydW5Db250aW51YXRpb24zKGYsIHosIHRoaXMsIGMsIHRvKTtcblx0XHR9O1xuXG5cdFx0RnVsZmlsbGVkLnByb3RvdHlwZS53aGVuID0gZnVuY3Rpb24oY29udCkge1xuXHRcdFx0cnVuQ29udGludWF0aW9uMShjb250LmZ1bGZpbGxlZCwgdGhpcywgY29udC5yZWNlaXZlciwgY29udC5yZXNvbHZlcik7XG5cdFx0fTtcblxuXHRcdHZhciBlcnJvcklkID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXIgZm9yIGEgcmVqZWN0ZWQgcHJvbWlzZVxuXHRcdCAqIEBwYXJhbSB7Kn0geCByZWplY3Rpb24gcmVhc29uXG5cdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gUmVqZWN0ZWQoeCkge1xuXHRcdFx0UHJvbWlzZS5jcmVhdGVDb250ZXh0KHRoaXMpO1xuXG5cdFx0XHR0aGlzLmlkID0gKytlcnJvcklkO1xuXHRcdFx0dGhpcy52YWx1ZSA9IHg7XG5cdFx0XHR0aGlzLmhhbmRsZWQgPSBmYWxzZTtcblx0XHRcdHRoaXMucmVwb3J0ZWQgPSBmYWxzZTtcblxuXHRcdFx0dGhpcy5fcmVwb3J0KCk7XG5cdFx0fVxuXG5cdFx0aW5oZXJpdChIYW5kbGVyLCBSZWplY3RlZCk7XG5cblx0XHRSZWplY3RlZC5wcm90b3R5cGUuX3N0YXRlID0gLTE7XG5cblx0XHRSZWplY3RlZC5wcm90b3R5cGUuZm9sZCA9IGZ1bmN0aW9uKGYsIHosIGMsIHRvKSB7XG5cdFx0XHR0by5iZWNvbWUodGhpcyk7XG5cdFx0fTtcblxuXHRcdFJlamVjdGVkLnByb3RvdHlwZS53aGVuID0gZnVuY3Rpb24oY29udCkge1xuXHRcdFx0aWYodHlwZW9mIGNvbnQucmVqZWN0ZWQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0dGhpcy5fdW5yZXBvcnQoKTtcblx0XHRcdH1cblx0XHRcdHJ1bkNvbnRpbnVhdGlvbjEoY29udC5yZWplY3RlZCwgdGhpcywgY29udC5yZWNlaXZlciwgY29udC5yZXNvbHZlcik7XG5cdFx0fTtcblxuXHRcdFJlamVjdGVkLnByb3RvdHlwZS5fcmVwb3J0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdFx0dGFza3MuYWZ0ZXJRdWV1ZShuZXcgUmVwb3J0VGFzayh0aGlzLCBjb250ZXh0KSk7XG5cdFx0fTtcblxuXHRcdFJlamVjdGVkLnByb3RvdHlwZS5fdW5yZXBvcnQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuaGFuZGxlZCA9IHRydWU7XG5cdFx0XHR0YXNrcy5hZnRlclF1ZXVlKG5ldyBVbnJlcG9ydFRhc2sodGhpcykpO1xuXHRcdH07XG5cblx0XHRSZWplY3RlZC5wcm90b3R5cGUuZmFpbCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0XHRcdFByb21pc2Uub25GYXRhbFJlamVjdGlvbih0aGlzLCBjb250ZXh0ID09PSB2b2lkIDAgPyB0aGlzLmNvbnRleHQgOiBjb250ZXh0KTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gUmVwb3J0VGFzayhyZWplY3Rpb24sIGNvbnRleHQpIHtcblx0XHRcdHRoaXMucmVqZWN0aW9uID0gcmVqZWN0aW9uO1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gY29udGV4dDtcblx0XHR9XG5cblx0XHRSZXBvcnRUYXNrLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmKCF0aGlzLnJlamVjdGlvbi5oYW5kbGVkKSB7XG5cdFx0XHRcdHRoaXMucmVqZWN0aW9uLnJlcG9ydGVkID0gdHJ1ZTtcblx0XHRcdFx0UHJvbWlzZS5vblBvdGVudGlhbGx5VW5oYW5kbGVkUmVqZWN0aW9uKHRoaXMucmVqZWN0aW9uLCB0aGlzLmNvbnRleHQpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBVbnJlcG9ydFRhc2socmVqZWN0aW9uKSB7XG5cdFx0XHR0aGlzLnJlamVjdGlvbiA9IHJlamVjdGlvbjtcblx0XHR9XG5cblx0XHRVbnJlcG9ydFRhc2sucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYodGhpcy5yZWplY3Rpb24ucmVwb3J0ZWQpIHtcblx0XHRcdFx0UHJvbWlzZS5vblBvdGVudGlhbGx5VW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlZCh0aGlzLnJlamVjdGlvbik7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIFVuaGFuZGxlZCByZWplY3Rpb24gaG9va3Ncblx0XHQvLyBCeSBkZWZhdWx0LCBldmVyeXRoaW5nIGlzIGEgbm9vcFxuXG5cdFx0Ly8gVE9ETzogQmV0dGVyIG5hbWVzOiBcImFubm90YXRlXCI/XG5cdFx0UHJvbWlzZS5jcmVhdGVDb250ZXh0XG5cdFx0XHQ9IFByb21pc2UuZW50ZXJDb250ZXh0XG5cdFx0XHQ9IFByb21pc2UuZXhpdENvbnRleHRcblx0XHRcdD0gUHJvbWlzZS5vblBvdGVudGlhbGx5VW5oYW5kbGVkUmVqZWN0aW9uXG5cdFx0XHQ9IFByb21pc2Uub25Qb3RlbnRpYWxseVVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWRcblx0XHRcdD0gUHJvbWlzZS5vbkZhdGFsUmVqZWN0aW9uXG5cdFx0XHQ9IG5vb3A7XG5cblx0XHQvLyBFcnJvcnMgYW5kIHNpbmdsZXRvbnNcblxuXHRcdHZhciBmb3JldmVyUGVuZGluZ0hhbmRsZXIgPSBuZXcgSGFuZGxlcigpO1xuXHRcdHZhciBmb3JldmVyUGVuZGluZ1Byb21pc2UgPSBuZXcgUHJvbWlzZShIYW5kbGVyLCBmb3JldmVyUGVuZGluZ0hhbmRsZXIpO1xuXG5cdFx0ZnVuY3Rpb24gY3ljbGUoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFJlamVjdGVkKG5ldyBUeXBlRXJyb3IoJ1Byb21pc2UgY3ljbGUnKSk7XG5cdFx0fVxuXG5cdFx0Ly8gVGFzayBydW5uZXJzXG5cblx0XHQvKipcblx0XHQgKiBSdW4gYSBzaW5nbGUgY29uc3VtZXJcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBDb250aW51YXRpb25UYXNrKGNvbnRpbnVhdGlvbiwgaGFuZGxlcikge1xuXHRcdFx0dGhpcy5jb250aW51YXRpb24gPSBjb250aW51YXRpb247XG5cdFx0XHR0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuXHRcdH1cblxuXHRcdENvbnRpbnVhdGlvblRhc2sucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5oYW5kbGVyLmpvaW4oKS53aGVuKHRoaXMuY29udGludWF0aW9uKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUnVuIGEgcXVldWUgb2YgcHJvZ3Jlc3MgaGFuZGxlcnNcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBQcm9ncmVzc1Rhc2sodmFsdWUsIGhhbmRsZXIpIHtcblx0XHRcdHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG5cdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0UHJvZ3Jlc3NUYXNrLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBxID0gdGhpcy5oYW5kbGVyLmNvbnN1bWVycztcblx0XHRcdGlmKHEgPT09IHZvaWQgMCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGZvciAodmFyIGMsIGkgPSAwOyBpIDwgcS5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRjID0gcVtpXTtcblx0XHRcdFx0cnVuTm90aWZ5KGMucHJvZ3Jlc3MsIHRoaXMudmFsdWUsIHRoaXMuaGFuZGxlciwgYy5yZWNlaXZlciwgYy5yZXNvbHZlcik7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEFzc2ltaWxhdGUgYSB0aGVuYWJsZSwgc2VuZGluZyBpdCdzIHZhbHVlIHRvIHJlc29sdmVyXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gdGhlblxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSB0aGVuYWJsZVxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSByZXNvbHZlclxuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIEFzc2ltaWxhdGVUYXNrKHRoZW4sIHRoZW5hYmxlLCByZXNvbHZlcikge1xuXHRcdFx0dGhpcy5fdGhlbiA9IHRoZW47XG5cdFx0XHR0aGlzLnRoZW5hYmxlID0gdGhlbmFibGU7XG5cdFx0XHR0aGlzLnJlc29sdmVyID0gcmVzb2x2ZXI7XG5cdFx0fVxuXG5cdFx0QXNzaW1pbGF0ZVRhc2sucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGggPSB0aGlzLnJlc29sdmVyO1xuXHRcdFx0dHJ5QXNzaW1pbGF0ZSh0aGlzLl90aGVuLCB0aGlzLnRoZW5hYmxlLCBfcmVzb2x2ZSwgX3JlamVjdCwgX25vdGlmeSk7XG5cblx0XHRcdGZ1bmN0aW9uIF9yZXNvbHZlKHgpIHsgaC5yZXNvbHZlKHgpOyB9XG5cdFx0XHRmdW5jdGlvbiBfcmVqZWN0KHgpICB7IGgucmVqZWN0KHgpOyB9XG5cdFx0XHRmdW5jdGlvbiBfbm90aWZ5KHgpICB7IGgubm90aWZ5KHgpOyB9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHRyeUFzc2ltaWxhdGUodGhlbiwgdGhlbmFibGUsIHJlc29sdmUsIHJlamVjdCwgbm90aWZ5KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR0aGVuLmNhbGwodGhlbmFibGUsIHJlc29sdmUsIHJlamVjdCwgbm90aWZ5KTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmVqZWN0KGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE90aGVyIGhlbHBlcnNcblxuXHRcdC8qKlxuXHRcdCAqIEBwYXJhbSB7Kn0geFxuXHRcdCAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmZiB4IGlzIGEgdHJ1c3RlZCBQcm9taXNlXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gaXNQcm9taXNlKHgpIHtcblx0XHRcdHJldHVybiB4IGluc3RhbmNlb2YgUHJvbWlzZTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBUZXN0IGp1c3QgZW5vdWdoIHRvIHJ1bGUgb3V0IHByaW1pdGl2ZXMsIGluIG9yZGVyIHRvIHRha2UgZmFzdGVyXG5cdFx0ICogcGF0aHMgaW4gc29tZSBjb2RlXG5cdFx0ICogQHBhcmFtIHsqfSB4XG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlIGlmZiB4IGlzIGd1YXJhbnRlZWQgKm5vdCogdG8gYmUgYSB0aGVuYWJsZVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIG1heWJlVGhlbmFibGUoeCkge1xuXHRcdFx0cmV0dXJuICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHggPT09ICdmdW5jdGlvbicpICYmIHggIT09IG51bGw7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcnVuQ29udGludWF0aW9uMShmLCBoLCByZWNlaXZlciwgbmV4dCkge1xuXHRcdFx0aWYodHlwZW9mIGYgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0cmV0dXJuIG5leHQuYmVjb21lKGgpO1xuXHRcdFx0fVxuXG5cdFx0XHRQcm9taXNlLmVudGVyQ29udGV4dChoKTtcblx0XHRcdHRyeUNhdGNoUmVqZWN0KGYsIGgudmFsdWUsIHJlY2VpdmVyLCBuZXh0KTtcblx0XHRcdFByb21pc2UuZXhpdENvbnRleHQoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBydW5Db250aW51YXRpb24zKGYsIHgsIGgsIHJlY2VpdmVyLCBuZXh0KSB7XG5cdFx0XHRpZih0eXBlb2YgZiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRyZXR1cm4gbmV4dC5iZWNvbWUoaCk7XG5cdFx0XHR9XG5cblx0XHRcdFByb21pc2UuZW50ZXJDb250ZXh0KGgpO1xuXHRcdFx0dHJ5Q2F0Y2hSZWplY3QzKGYsIHgsIGgudmFsdWUsIHJlY2VpdmVyLCBuZXh0KTtcblx0XHRcdFByb21pc2UuZXhpdENvbnRleHQoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBydW5Ob3RpZnkoZiwgeCwgaCwgcmVjZWl2ZXIsIG5leHQpIHtcblx0XHRcdGlmKHR5cGVvZiBmICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHJldHVybiBuZXh0Lm5vdGlmeSh4KTtcblx0XHRcdH1cblxuXHRcdFx0UHJvbWlzZS5lbnRlckNvbnRleHQoaCk7XG5cdFx0XHR0cnlDYXRjaFJldHVybihmLCB4LCByZWNlaXZlciwgbmV4dCk7XG5cdFx0XHRQcm9taXNlLmV4aXRDb250ZXh0KCk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIGYuY2FsbCh0aGlzQXJnLCB4KSwgb3IgaWYgaXQgdGhyb3dzIHJldHVybiBhIHJlamVjdGVkIHByb21pc2UgZm9yXG5cdFx0ICogdGhlIHRocm93biBleGNlcHRpb25cblx0XHQgKi9cblx0XHRmdW5jdGlvbiB0cnlDYXRjaFJlamVjdChmLCB4LCB0aGlzQXJnLCBuZXh0KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRuZXh0LmJlY29tZShnZXRIYW5kbGVyKGYuY2FsbCh0aGlzQXJnLCB4KSkpO1xuXHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdG5leHQuYmVjb21lKG5ldyBSZWplY3RlZChlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogU2FtZSBhcyBhYm92ZSwgYnV0IGluY2x1ZGVzIHRoZSBleHRyYSBhcmd1bWVudCBwYXJhbWV0ZXIuXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gdHJ5Q2F0Y2hSZWplY3QzKGYsIHgsIHksIHRoaXNBcmcsIG5leHQpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGYuY2FsbCh0aGlzQXJnLCB4LCB5LCBuZXh0KTtcblx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRuZXh0LmJlY29tZShuZXcgUmVqZWN0ZWQoZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiBmLmNhbGwodGhpc0FyZywgeCksIG9yIGlmIGl0IHRocm93cywgKnJldHVybiogdGhlIGV4Y2VwdGlvblxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHRyeUNhdGNoUmV0dXJuKGYsIHgsIHRoaXNBcmcsIG5leHQpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdG5leHQubm90aWZ5KGYuY2FsbCh0aGlzQXJnLCB4KSk7XG5cdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0bmV4dC5ub3RpZnkoZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW5oZXJpdChQYXJlbnQsIENoaWxkKSB7XG5cdFx0XHRDaGlsZC5wcm90b3R5cGUgPSBvYmplY3RDcmVhdGUoUGFyZW50LnByb3RvdHlwZSk7XG5cdFx0XHRDaGlsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDaGlsZDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBub29wKCkge31cblxuXHRcdHJldHVybiBQcm9taXNlO1xuXHR9O1xufSk7XG59KHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSA6IGZ1bmN0aW9uKGZhY3RvcnkpIHsgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7IH0pKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDU1NDb3JlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogVGhlIENTU0NvcmUgbW9kdWxlIHNwZWNpZmllcyB0aGUgQVBJIChhbmQgaW1wbGVtZW50cyBtb3N0IG9mIHRoZSBtZXRob2RzKVxuICogdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVuIGRlYWxpbmcgd2l0aCB0aGUgZGlzcGxheSBvZiBlbGVtZW50cyAodmlhIHRoZWlyXG4gKiBDU1MgY2xhc3NlcyBhbmQgdmlzaWJpbGl0eSBvbiBzY3JlZW4uIEl0IGlzIGFuIEFQSSBmb2N1c2VkIG9uIG11dGF0aW5nIHRoZVxuICogZGlzcGxheSBhbmQgbm90IHJlYWRpbmcgaXQgYXMgbm8gbG9naWNhbCBzdGF0ZSBzaG91bGQgYmUgZW5jb2RlZCBpbiB0aGVcbiAqIGRpc3BsYXkgb2YgZWxlbWVudHMuXG4gKi9cblxudmFyIENTU0NvcmUgPSB7XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGNsYXNzIHBhc3NlZCBpbiB0byB0aGUgZWxlbWVudCBpZiBpdCBkb2Vzbid0IGFscmVhZHkgaGF2ZSBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIHNldCB0aGUgY2xhc3Mgb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSB0aGUgQ1NTIGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fSB0aGUgZWxlbWVudCBwYXNzZWQgaW5cbiAgICovXG4gIGFkZENsYXNzOiBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgIS9cXHMvLnRlc3QoY2xhc3NOYW1lKSxcbiAgICAgICdDU1NDb3JlLmFkZENsYXNzIHRha2VzIG9ubHkgYSBzaW5nbGUgY2xhc3MgbmFtZS4gXCIlc1wiIGNvbnRhaW5zICcgK1xuICAgICAgJ211bHRpcGxlIGNsYXNzZXMuJywgY2xhc3NOYW1lXG4gICAgKSA6IGludmFyaWFudCghL1xccy8udGVzdChjbGFzc05hbWUpKSk7XG5cbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKCFDU1NDb3JlLmhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZSArICcgJyArIGNsYXNzTmFtZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGNsYXNzIHBhc3NlZCBpbiBmcm9tIHRoZSBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgdGhlIENTUyBjbGFzc05hbWVcbiAgICogQHJldHVybiB7RE9NRWxlbWVudH0gdGhlIGVsZW1lbnQgcGFzc2VkIGluXG4gICAqL1xuICByZW1vdmVDbGFzczogZnVuY3Rpb24oZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICEvXFxzLy50ZXN0KGNsYXNzTmFtZSksXG4gICAgICAnQ1NTQ29yZS5yZW1vdmVDbGFzcyB0YWtlcyBvbmx5IGEgc2luZ2xlIGNsYXNzIG5hbWUuIFwiJXNcIiBjb250YWlucyAnICtcbiAgICAgICdtdWx0aXBsZSBjbGFzc2VzLicsIGNsYXNzTmFtZVxuICAgICkgOiBpbnZhcmlhbnQoIS9cXHMvLnRlc3QoY2xhc3NOYW1lKSkpO1xuXG4gICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgfSBlbHNlIGlmIChDU1NDb3JlLmhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZVxuICAgICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBjbGFzc05hbWUgKyAnKD86XFxcXHN8JCknLCAnZycpLCAnJDEnKVxuICAgICAgICAgIC5yZXBsYWNlKC9cXHMrL2csICcgJykgLy8gbXVsdGlwbGUgc3BhY2VzIHRvIG9uZVxuICAgICAgICAgIC5yZXBsYWNlKC9eXFxzKnxcXHMqJC9nLCAnJyk7IC8vIHRyaW0gdGhlIGVuZHNcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhlbHBlciB0byBhZGQgb3IgcmVtb3ZlIGEgY2xhc3MgZnJvbSBhbiBlbGVtZW50IGJhc2VkIG9uIGEgY29uZGl0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIHRoZSBDU1MgY2xhc3NOYW1lXG4gICAqIEBwYXJhbSB7Kn0gYm9vbCBjb25kaXRpb24gdG8gd2hldGhlciB0byBhZGQgb3IgcmVtb3ZlIHRoZSBjbGFzc1xuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fSB0aGUgZWxlbWVudCBwYXNzZWQgaW5cbiAgICovXG4gIGNvbmRpdGlvbkNsYXNzOiBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUsIGJvb2wpIHtcbiAgICByZXR1cm4gKGJvb2wgPyBDU1NDb3JlLmFkZENsYXNzIDogQ1NTQ29yZS5yZW1vdmVDbGFzcykoZWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgfSxcblxuICAvKipcbiAgICogVGVzdHMgd2hldGhlciB0aGUgZWxlbWVudCBoYXMgdGhlIGNsYXNzIHNwZWNpZmllZC5cbiAgICpcbiAgICogQHBhcmFtIHtET01Ob2RlfERPTVdpbmRvd30gZWxlbWVudCB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgdGhlIENTUyBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZWxlbWVudCBoYXMgdGhlIGNsYXNzLCBmYWxzZSBpZiBub3RcbiAgICovXG4gIGhhc0NsYXNzOiBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgIS9cXHMvLnRlc3QoY2xhc3NOYW1lKSxcbiAgICAgICdDU1MuaGFzQ2xhc3MgdGFrZXMgb25seSBhIHNpbmdsZSBjbGFzcyBuYW1lLidcbiAgICApIDogaW52YXJpYW50KCEvXFxzLy50ZXN0KGNsYXNzTmFtZSkpKTtcbiAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICAgIHJldHVybiAhIWNsYXNzTmFtZSAmJiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gKCcgJyArIGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnKS5pbmRleE9mKCcgJyArIGNsYXNzTmFtZSArICcgJykgPiAtMTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU0NvcmU7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXhlY3V0aW9uRW52aXJvbm1lbnRcbiAqL1xuXG4vKmpzbGludCBldmlsOiB0cnVlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY2FuVXNlRE9NID0gISEoXG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gIHdpbmRvdy5kb2N1bWVudCAmJlxuICB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudFxuKTtcblxuLyoqXG4gKiBTaW1wbGUsIGxpZ2h0d2VpZ2h0IG1vZHVsZSBhc3Npc3Rpbmcgd2l0aCB0aGUgZGV0ZWN0aW9uIGFuZCBjb250ZXh0IG9mXG4gKiBXb3JrZXIuIEhlbHBzIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBhbmQgYWxsb3dzIGNvZGUgdG8gcmVhc29uIGFib3V0XG4gKiB3aGV0aGVyIG9yIG5vdCB0aGV5IGFyZSBpbiBhIFdvcmtlciwgZXZlbiBpZiB0aGV5IG5ldmVyIGluY2x1ZGUgdGhlIG1haW5cbiAqIGBSZWFjdFdvcmtlcmAgZGVwZW5kZW5jeS5cbiAqL1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0ge1xuXG4gIGNhblVzZURPTTogY2FuVXNlRE9NLFxuXG4gIGNhblVzZVdvcmtlcnM6IHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnLFxuXG4gIGNhblVzZUV2ZW50TGlzdGVuZXJzOlxuICAgIGNhblVzZURPTSAmJiAhISh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCB3aW5kb3cuYXR0YWNoRXZlbnQpLFxuXG4gIGNhblVzZVZpZXdwb3J0OiBjYW5Vc2VET00gJiYgISF3aW5kb3cuc2NyZWVuLFxuXG4gIGlzSW5Xb3JrZXI6ICFjYW5Vc2VET00gLy8gRm9yIG5vdywgdGhpcyBpcyB0cnVlIC0gbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQ7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIE9iamVjdC5hc3NpZ25cbiAqL1xuXG4vLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LmFzc2lnblxuXG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2VzKSB7XG4gIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gdGFyZ2V0IGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICB9XG5cbiAgdmFyIHRvID0gT2JqZWN0KHRhcmdldCk7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgZm9yICh2YXIgbmV4dEluZGV4ID0gMTsgbmV4dEluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgbmV4dEluZGV4KyspIHtcbiAgICB2YXIgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tuZXh0SW5kZXhdO1xuICAgIGlmIChuZXh0U291cmNlID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBmcm9tID0gT2JqZWN0KG5leHRTb3VyY2UpO1xuXG4gICAgLy8gV2UgZG9uJ3QgY3VycmVudGx5IHN1cHBvcnQgYWNjZXNzb3JzIG5vciBwcm94aWVzLiBUaGVyZWZvcmUgdGhpc1xuICAgIC8vIGNvcHkgY2Fubm90IHRocm93LiBJZiB3ZSBldmVyIHN1cHBvcnRlZCB0aGlzIHRoZW4gd2UgbXVzdCBoYW5kbGVcbiAgICAvLyBleGNlcHRpb25zIGFuZCBzaWRlLWVmZmVjdHMuIFdlIGRvbid0IHN1cHBvcnQgc3ltYm9scyBzbyB0aGV5IHdvbid0XG4gICAgLy8gYmUgdHJhbnNmZXJyZWQuXG5cbiAgICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuICAgICAgICB0b1trZXldID0gZnJvbVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0bztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0VHJhbnNpdGlvbkV2ZW50c1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcblxuLyoqXG4gKiBFVkVOVF9OQU1FX01BUCBpcyB1c2VkIHRvIGRldGVybWluZSB3aGljaCBldmVudCBmaXJlZCB3aGVuIGFcbiAqIHRyYW5zaXRpb24vYW5pbWF0aW9uIGVuZHMsIGJhc2VkIG9uIHRoZSBzdHlsZSBwcm9wZXJ0eSB1c2VkIHRvXG4gKiBkZWZpbmUgdGhhdCBldmVudC5cbiAqL1xudmFyIEVWRU5UX05BTUVfTUFQID0ge1xuICB0cmFuc2l0aW9uZW5kOiB7XG4gICAgJ3RyYW5zaXRpb24nOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgJ1dlYmtpdFRyYW5zaXRpb24nOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgJ01velRyYW5zaXRpb24nOiAnbW96VHJhbnNpdGlvbkVuZCcsXG4gICAgJ09UcmFuc2l0aW9uJzogJ29UcmFuc2l0aW9uRW5kJyxcbiAgICAnbXNUcmFuc2l0aW9uJzogJ01TVHJhbnNpdGlvbkVuZCdcbiAgfSxcblxuICBhbmltYXRpb25lbmQ6IHtcbiAgICAnYW5pbWF0aW9uJzogJ2FuaW1hdGlvbmVuZCcsXG4gICAgJ1dlYmtpdEFuaW1hdGlvbic6ICd3ZWJraXRBbmltYXRpb25FbmQnLFxuICAgICdNb3pBbmltYXRpb24nOiAnbW96QW5pbWF0aW9uRW5kJyxcbiAgICAnT0FuaW1hdGlvbic6ICdvQW5pbWF0aW9uRW5kJyxcbiAgICAnbXNBbmltYXRpb24nOiAnTVNBbmltYXRpb25FbmQnXG4gIH1cbn07XG5cbnZhciBlbmRFdmVudHMgPSBbXTtcblxuZnVuY3Rpb24gZGV0ZWN0RXZlbnRzKCkge1xuICB2YXIgdGVzdEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZhciBzdHlsZSA9IHRlc3RFbC5zdHlsZTtcblxuICAvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxuICAvLyB0aGUgdW4tcHJlZml4ZWQgXCJhbmltYXRpb25cIiBhbmQgXCJ0cmFuc2l0aW9uXCIgcHJvcGVydGllcyBhcmUgZGVmaW5lZCBvbiB0aGVcbiAgLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXG4gIC8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzZWFibGUsIGFuZCBpZiBub3QgcmVtb3ZlIHRoZW1cbiAgLy8gZnJvbSB0aGUgbWFwXG4gIGlmICghKCdBbmltYXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSBFVkVOVF9OQU1FX01BUC5hbmltYXRpb25lbmQuYW5pbWF0aW9uO1xuICB9XG5cbiAgaWYgKCEoJ1RyYW5zaXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSBFVkVOVF9OQU1FX01BUC50cmFuc2l0aW9uZW5kLnRyYW5zaXRpb247XG4gIH1cblxuICBmb3IgKHZhciBiYXNlRXZlbnROYW1lIGluIEVWRU5UX05BTUVfTUFQKSB7XG4gICAgdmFyIGJhc2VFdmVudHMgPSBFVkVOVF9OQU1FX01BUFtiYXNlRXZlbnROYW1lXTtcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gYmFzZUV2ZW50cykge1xuICAgICAgaWYgKHN0eWxlTmFtZSBpbiBzdHlsZSkge1xuICAgICAgICBlbmRFdmVudHMucHVzaChiYXNlRXZlbnRzW3N0eWxlTmFtZV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBkZXRlY3RFdmVudHMoKTtcbn1cblxuLy8gV2UgdXNlIHRoZSByYXcge2FkZHxyZW1vdmV9RXZlbnRMaXN0ZW5lcigpIGNhbGwgYmVjYXVzZSBFdmVudExpc3RlbmVyXG4vLyBkb2VzIG5vdCBrbm93IGhvdyB0byByZW1vdmUgZXZlbnQgbGlzdGVuZXJzIGFuZCB3ZSByZWFsbHkgc2hvdWxkXG4vLyBjbGVhbiB1cC4gQWxzbywgdGhlc2UgZXZlbnRzIGFyZSBub3QgdHJpZ2dlcmVkIGluIG9sZGVyIGJyb3dzZXJzXG4vLyBzbyB3ZSBzaG91bGQgYmUgQS1PSyBoZXJlLlxuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50TmFtZSwgZXZlbnRMaXN0ZW5lcikge1xuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudExpc3RlbmVyLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnROYW1lLCBldmVudExpc3RlbmVyKSB7XG4gIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbn1cblxudmFyIFJlYWN0VHJhbnNpdGlvbkV2ZW50cyA9IHtcbiAgYWRkRW5kRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24obm9kZSwgZXZlbnRMaXN0ZW5lcikge1xuICAgIGlmIChlbmRFdmVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBJZiBDU1MgdHJhbnNpdGlvbnMgYXJlIG5vdCBzdXBwb3J0ZWQsIHRyaWdnZXIgYW4gXCJlbmQgYW5pbWF0aW9uXCJcbiAgICAgIC8vIGV2ZW50IGltbWVkaWF0ZWx5LlxuICAgICAgd2luZG93LnNldFRpbWVvdXQoZXZlbnRMaXN0ZW5lciwgMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVuZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVuZEV2ZW50KSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGVuZEV2ZW50LCBldmVudExpc3RlbmVyKTtcbiAgICB9KTtcbiAgfSxcblxuICByZW1vdmVFbmRFdmVudExpc3RlbmVyOiBmdW5jdGlvbihub2RlLCBldmVudExpc3RlbmVyKSB7XG4gICAgaWYgKGVuZEV2ZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZW5kRXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZW5kRXZlbnQpIHtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgZW5kRXZlbnQsIGV2ZW50TGlzdGVuZXIpO1xuICAgIH0pO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VHJhbnNpdGlvbkV2ZW50cztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjeFxuICovXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIG1hcmsgc3RyaW5nIGxpdGVyYWxzIHJlcHJlc2VudGluZyBDU1MgY2xhc3MgbmFtZXNcbiAqIHNvIHRoYXQgdGhleSBjYW4gYmUgdHJhbnNmb3JtZWQgc3RhdGljYWxseS4gVGhpcyBhbGxvd3MgZm9yIG1vZHVsYXJpemF0aW9uXG4gKiBhbmQgbWluaWZpY2F0aW9uIG9mIENTUyBjbGFzcyBuYW1lcy5cbiAqXG4gKiBJbiBzdGF0aWNfdXBzdHJlYW0sIHRoaXMgZnVuY3Rpb24gaXMgYWN0dWFsbHkgaW1wbGVtZW50ZWQsIGJ1dCBpdCBzaG91bGRcbiAqIGV2ZW50dWFsbHkgYmUgcmVwbGFjZWQgd2l0aCBzb21ldGhpbmcgbW9yZSBkZXNjcmlwdGl2ZSwgYW5kIHRoZSB0cmFuc2Zvcm1cbiAqIHRoYXQgaXMgdXNlZCBpbiB0aGUgbWFpbiBzdGFjayBzaG91bGQgYmUgcG9ydGVkIGZvciB1c2UgZWxzZXdoZXJlLlxuICpcbiAqIEBwYXJhbSBzdHJpbmd8b2JqZWN0IGNsYXNzTmFtZSB0byBtb2R1bGFyaXplLCBvciBhbiBvYmplY3Qgb2Yga2V5L3ZhbHVlcy5cbiAqICAgICAgICAgICAgICAgICAgICAgIEluIHRoZSBvYmplY3QgY2FzZSwgdGhlIHZhbHVlcyBhcmUgY29uZGl0aW9ucyB0aGF0XG4gKiAgICAgICAgICAgICAgICAgICAgICBkZXRlcm1pbmUgaWYgdGhlIGNsYXNzTmFtZSBrZXlzIHNob3VsZCBiZSBpbmNsdWRlZC5cbiAqIEBwYXJhbSBbc3RyaW5nIC4uLl0gIFZhcmlhYmxlIGxpc3Qgb2YgY2xhc3NOYW1lcyBpbiB0aGUgc3RyaW5nIGNhc2UuXG4gKiBAcmV0dXJuIHN0cmluZyAgICAgICBSZW5kZXJhYmxlIHNwYWNlLXNlcGFyYXRlZCBDU1MgY2xhc3NOYW1lLlxuICovXG5mdW5jdGlvbiBjeChjbGFzc05hbWVzKSB7XG4gIGlmICh0eXBlb2YgY2xhc3NOYW1lcyA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhjbGFzc05hbWVzKS5maWx0ZXIoZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgICByZXR1cm4gY2xhc3NOYW1lc1tjbGFzc05hbWVdO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbChhcmd1bWVudHMsICcgJyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjeDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlbXB0eUZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xuZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbihhcmcpIHsgcmV0dXJuIGFyZzsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGludmFyaWFudFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICtcbiAgICAgICAgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJ1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICdJbnZhcmlhbnQgVmlvbGF0aW9uOiAnICtcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJnc1thcmdJbmRleCsrXTsgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgd2FybmluZ1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2VtcHR5RnVuY3Rpb25cIik7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICB3YXJuaW5nID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQgKSB7Zm9yICh2YXIgYXJncz1bXSwkX18wPTIsJF9fMT1hcmd1bWVudHMubGVuZ3RoOyRfXzA8JF9fMTskX18wKyspIGFyZ3MucHVzaChhcmd1bWVudHNbJF9fMF0pO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArXG4gICAgICAgICdtZXNzYWdlIGFyZ3VtZW50J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGNvbnNvbGUud2FybignV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpICB7cmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107fSkpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJpbW11dGFibGVcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiNC4wLjAtcmMuMTJcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkltbXV0YWJsZSBEYXRhIENvbGxlY3Rpb25zXCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9pbW11dGFibGUtanMuY29tXCIsXG4gIFwiYXV0aG9yXCI6IHtcbiAgICBcIm5hbWVcIjogXCJMZWUgQnlyb25cIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9sZWVieXJvblwiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQ6Ly9naXRodWIuY29tL2ltbXV0YWJsZS1qcy9pbW11dGFibGUtanMuZ2l0XCJcbiAgfSxcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9pbW11dGFibGUtanMvaW1tdXRhYmxlLWpzL2lzc3Vlc1wiXG4gIH0sXG4gIFwibWFpblwiOiBcImRpc3QvaW1tdXRhYmxlLmpzXCIsXG4gIFwibW9kdWxlXCI6IFwiZGlzdC9pbW11dGFibGUuZXMuanNcIixcbiAgXCJ0eXBpbmdzXCI6IFwiZGlzdC9pbW11dGFibGUtbm9uYW1iaWVudC5kLnRzXCIsXG4gIFwidHlwZXNjcmlwdFwiOiB7XG4gICAgXCJkZWZpbml0aW9uXCI6IFwiZGlzdC9pbW11dGFibGUuZC50c1wiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJidWlsZFwiOiBcInJ1bi1zIGJ1aWxkOipcIixcbiAgICBcImJ1aWxkOmRpc3RcIjogXCJydW4tcyBjbGVhbjpkaXN0IGJ1bmRsZTpkaXN0IGJ1bmRsZTplcyBjb3B5OmRpc3Qgc3RhdHM6ZGlzdCBwcmVwYXJlOmRpc3RcIixcbiAgICBcImJ1aWxkOnBhZ2VzXCI6IFwiZ3VscCAtLWd1bHBmaWxlIC4vcmVzb3VyY2VzL2d1bHBmaWxlLmpzIGRlZmF1bHRcIixcbiAgICBcInN0YXRzOmRpc3RcIjogXCJub2RlIC4vcmVzb3VyY2VzL2Rpc3Qtc3RhdHMuanNcIixcbiAgICBcImNsZWFuOmRpc3RcIjogXCJyaW1yYWYgZGlzdFwiLFxuICAgIFwiYnVuZGxlOmRpc3RcIjogXCJyb2xsdXAgLWMgLi9yZXNvdXJjZXMvcm9sbHVwLWNvbmZpZy5qc1wiLFxuICAgIFwiYnVuZGxlOmVzXCI6IFwicm9sbHVwIC1jIC4vcmVzb3VyY2VzL3JvbGx1cC1jb25maWctZXMuanNcIixcbiAgICBcImNvcHk6ZGlzdFwiOiBcIm5vZGUgLi9yZXNvdXJjZXMvY29weS1kaXN0LXR5cGVkZWZzLmpzXCIsXG4gICAgXCJwcmVwYXJlOmRpc3RcIjogXCIuL3Jlc291cmNlcy9wcmVwYXJlLWRpc3Quc2hcIixcbiAgICBcImZvcm1hdFwiOiBcIm5wbSBydW4gbGludDpmb3JtYXQgLS0gLS13cml0ZVwiLFxuICAgIFwibGludFwiOiBcInJ1bi1zIGxpbnQ6KlwiLFxuICAgIFwibGludDp0c1wiOiBcInRzbGludCBcXFwiX190ZXN0c19fLyoqLyoudHNcXFwiXCIsXG4gICAgXCJsaW50OmpzXCI6IFwiZXNsaW50IFxcXCJ7X190ZXN0c19fLHNyYyxwYWdlcy9zcmMscGFnZXMvbGlifS8qKi8qLmpzXFxcIlwiLFxuICAgIFwibGludDpmb3JtYXRcIjogXCJwcmV0dGllciAtLWNoZWNrIFxcXCJ7X190ZXN0c19fLHNyYyxwYWdlcy9zcmMscGFnZXMvbGliLHBlcmYscmVzb3VyY2VzfS8qKi8qe1xcXFwuanMsXFxcXC50c31cXFwiXCIsXG4gICAgXCJ0ZXN0b25seVwiOiBcIi4vcmVzb3VyY2VzL2plc3RcIixcbiAgICBcInRlc3RcIjogXCJydW4tcyBmb3JtYXQgYnVpbGQgbGludCB0ZXN0b25seSB0ZXN0OnR5cGVzXCIsXG4gICAgXCJjaGVjazpnaXQtY2xlYW5cIjogXCIuL3Jlc291cmNlcy9jaGVjay1jaGFuZ2VzXCIsXG4gICAgXCJ0ZXN0OnR5cGVzXCI6IFwicnVuLXMgdGVzdDp0eXBlczoqXCIsXG4gICAgXCJ0ZXN0OnR5cGVzOnRzXCI6IFwidHNjIC4vdHlwZS1kZWZpbml0aW9ucy9JbW11dGFibGUuZC50cyAtLWxpYiBlczIwMTUgJiYgZHRzbGludCB0eXBlLWRlZmluaXRpb25zL3RzLXRlc3RzXCIsXG4gICAgXCJ0ZXN0OnR5cGVzOmZsb3dcIjogXCJmbG93IGNoZWNrIHR5cGUtZGVmaW5pdGlvbnMvdGVzdHMgLS1pbmNsdWRlLXdhcm5pbmdzXCIsXG4gICAgXCJwZXJmXCI6IFwibm9kZSAuL3Jlc291cmNlcy9iZW5jaC5qc1wiLFxuICAgIFwic3RhcnRcIjogXCJndWxwIC0tZ3VscGZpbGUgLi9yZXNvdXJjZXMvZ3VscGZpbGUuanMgZGV2XCJcbiAgfSxcbiAgXCJwcmV0dGllclwiOiB7XG4gICAgXCJzaW5nbGVRdW90ZVwiOiB0cnVlLFxuICAgIFwidHJhaWxpbmdDb21tYVwiOiBcImVzNVwiLFxuICAgIFwic2VtaVwiOiB0cnVlLFxuICAgIFwiYXJyb3dQYXJlbnNcIjogXCJhdm9pZFwiXG4gIH0sXG4gIFwiamVzdFwiOiB7XG4gICAgXCJtb2R1bGVGaWxlRXh0ZW5zaW9uc1wiOiBbXG4gICAgICBcImpzXCIsXG4gICAgICBcInRzXCJcbiAgICBdLFxuICAgIFwidHJhbnNmb3JtXCI6IHtcbiAgICAgIFwiXi4rXFxcXC50cyRcIjogXCI8cm9vdERpcj4vcmVzb3VyY2VzL2plc3RQcmVwcm9jZXNzb3IuanNcIlxuICAgIH0sXG4gICAgXCJ0ZXN0UmVnZXhcIjogXCIvX190ZXN0c19fLy4qXFxcXC4odHN8anMpJFwiLFxuICAgIFwidW5tb2NrZWRNb2R1bGVQYXRoUGF0dGVybnNcIjogW1xuICAgICAgXCIuL25vZGVfbW9kdWxlcy9yZWFjdFwiXG4gICAgXVxuICB9LFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJiZW5jaG1hcmtcIjogXCIyLjEuNFwiLFxuICAgIFwiYnJvd3Nlci1zeW5jXCI6IFwiXjIuMjYuMTJcIixcbiAgICBcImJyb3dzZXJpZnlcIjogXCIxNi41LjJcIixcbiAgICBcImNvbG9yc1wiOiBcIjEuNC4wXCIsXG4gICAgXCJkZWxcIjogXCI2LjAuMFwiLFxuICAgIFwiZHRzbGludFwiOiBcIjQuMS4wXCIsXG4gICAgXCJlc2xpbnRcIjogXCI3LjExLjBcIixcbiAgICBcImVzbGludC1jb25maWctYWlyYm5iXCI6IFwiMTguMi4wXCIsXG4gICAgXCJlc2xpbnQtY29uZmlnLXByZXR0aWVyXCI6IFwiNi4xMi4wXCIsXG4gICAgXCJlc2xpbnQtcGx1Z2luLWltcG9ydFwiOiBcIjIuMjIuMVwiLFxuICAgIFwiZXNsaW50LXBsdWdpbi1qc3gtYTExeVwiOiBcIjYuMy4xXCIsXG4gICAgXCJlc2xpbnQtcGx1Z2luLXByZXR0aWVyXCI6IFwiMy4xLjRcIixcbiAgICBcImVzbGludC1wbHVnaW4tcmVhY3RcIjogXCI3LjIxLjRcIixcbiAgICBcImZsb3ctYmluXCI6IFwiMC44NS4wXCIsXG4gICAgXCJndWxwXCI6IFwiNC4wLjJcIixcbiAgICBcImd1bHAtY29uY2F0XCI6IFwiMi42LjFcIixcbiAgICBcImd1bHAtZmlsdGVyXCI6IFwiNi4wLjBcIixcbiAgICBcImd1bHAtaGVhZGVyXCI6IFwiMi4wLjlcIixcbiAgICBcImd1bHAtbGVzc1wiOiBcIjQuMC4xXCIsXG4gICAgXCJndWxwLXNpemVcIjogXCIzLjAuMFwiLFxuICAgIFwiZ3VscC1zb3VyY2VtYXBzXCI6IFwiMi42LjVcIixcbiAgICBcImd1bHAtdWdsaWZ5XCI6IFwiMy4wLjJcIixcbiAgICBcImd1bHAtdXRpbFwiOiBcIjMuMC44XCIsXG4gICAgXCJqYXNtaW5lLWNoZWNrXCI6IFwiMC4xLjVcIixcbiAgICBcImplc3RcIjogXCIyNi41LjJcIixcbiAgICBcIm1hcmtlZFwiOiBcIjEuMi4wXCIsXG4gICAgXCJtaWNyb3RpbWVcIjogXCIzLjAuMFwiLFxuICAgIFwibWtkaXJwXCI6IFwiMS4wLjRcIixcbiAgICBcIm5wbS1ydW4tYWxsXCI6IFwiNC4xLjVcIixcbiAgICBcInByZXR0aWVyXCI6IFwiXjIuMy4xXCIsXG4gICAgXCJyZWFjdFwiOiBcIl4wLjEyLjJcIixcbiAgICBcInJlYWN0LXJvdXRlclwiOiBcIl4wLjExLjZcIixcbiAgICBcInJlYWN0LXRvb2xzXCI6IFwiMC4xMy4zXCIsXG4gICAgXCJyaW1yYWZcIjogXCIzLjAuMlwiLFxuICAgIFwicm9sbHVwXCI6IFwiMi4yOS4wXCIsXG4gICAgXCJyb2xsdXAtcGx1Z2luLWJ1YmxlXCI6IFwiMC4xOS4yXCIsXG4gICAgXCJyb2xsdXAtcGx1Z2luLWNvbW1vbmpzXCI6IFwiOS4xLjNcIixcbiAgICBcInJvbGx1cC1wbHVnaW4tanNvblwiOiBcIjMuMC4wXCIsXG4gICAgXCJyb2xsdXAtcGx1Z2luLXN0cmlwLWJhbm5lclwiOiBcIjIuMC4wXCIsXG4gICAgXCJ0aHJvdWdoMlwiOiBcIjQuMC4yXCIsXG4gICAgXCJ0cmFuc2R1Y2Vycy1qc1wiOiBcIl4wLjQuMTc0XCIsXG4gICAgXCJ0c2xpbnRcIjogXCI1LjIwLjFcIixcbiAgICBcInR5cGVzY3JpcHRcIjogXCIzLjAuM1wiLFxuICAgIFwidWdsaWZ5LWpzXCI6IFwiMy4xMS4xXCIsXG4gICAgXCJ1Z2xpZnktc2F2ZS1saWNlbnNlXCI6IFwiMC40LjFcIixcbiAgICBcInZpbnlsLWJ1ZmZlclwiOiBcIjEuMC4xXCIsXG4gICAgXCJ2aW55bC1zb3VyY2Utc3RyZWFtXCI6IFwiMi4wLjBcIlxuICB9LFxuICBcImZpbGVzXCI6IFtcbiAgICBcImRpc3RcIixcbiAgICBcImNvbnRyaWJcIixcbiAgICBcIlJFQURNRS5tZFwiLFxuICAgIFwiTElDRU5TRVwiXG4gIF0sXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiaW1tdXRhYmxlXCIsXG4gICAgXCJwZXJzaXN0ZW50XCIsXG4gICAgXCJsYXp5XCIsXG4gICAgXCJkYXRhXCIsXG4gICAgXCJkYXRhc3RydWN0dXJlXCIsXG4gICAgXCJmdW5jdGlvbmFsXCIsXG4gICAgXCJjb2xsZWN0aW9uXCIsXG4gICAgXCJzdGF0ZWxlc3NcIixcbiAgICBcInNlcXVlbmNlXCIsXG4gICAgXCJpdGVyYXRpb25cIlxuICBdXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XCJJbW11dGFibGVcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiSW1tdXRhYmxlIGRhdGEgZW5jb3VyYWdlcyBwdXJlIGZ1bmN0aW9ucyAoZGF0YS1pbiwgZGF0YS1vdXQpIGFuZCBsZW5kcyBpdHNlbGZcXG50byBtdWNoIHNpbXBsZXIgYXBwbGljYXRpb24gZGV2ZWxvcG1lbnQgYW5kIGVuYWJsaW5nIHRlY2huaXF1ZXMgZnJvbVxcbmZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgc3VjaCBhcyBsYXp5IGV2YWx1YXRpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiV2hpbGUgZGVzaWduZWQgdG8gYnJpbmcgdGhlc2UgcG93ZXJmdWwgZnVuY3Rpb25hbCBjb25jZXB0cyB0byBKYXZhU2NyaXB0LCBpdFxcbnByZXNlbnRzIGFuIE9iamVjdC1PcmllbnRlZCBBUEkgZmFtaWxpYXIgdG8gSmF2YXNjcmlwdCBlbmdpbmVlcnMgYW5kIGNsb3NlbHlcXG5taXJyb3JpbmcgdGhhdCBvZiBBcnJheSwgTWFwLCBhbmQgU2V0LiBJdCBpcyBlYXN5IGFuZCBlZmZpY2llbnQgdG8gY29udmVydCB0b1xcbmFuZCBmcm9tIHBsYWluIEphdmFzY3JpcHQgdHlwZXMuXFxuXFxuIyMgSG93IHRvIHJlYWQgdGhlc2UgZG9jc1xcblxcbkluIG9yZGVyIHRvIGJldHRlciBleHBsYWluIHdoYXQga2luZHMgb2YgdmFsdWVzIHRoZSBJbW11dGFibGUuanMgQVBJIGV4cGVjdHNcXG5hbmQgcHJvZHVjZXMsIHRoaXMgZG9jdW1lbnRhdGlvbiBpcyBwcmVzZW50ZWQgaW4gYSBzdGF0aWNhbGx5IHR5cGVkIGRpYWxlY3Qgb2ZcXG5KYXZhU2NyaXB0IChsaWtlIFtGbG93XVtdIG9yIFtUeXBlU2NyaXB0XVtdKS4gWW91ICpkb24ndCBuZWVkKiB0byB1c2UgdGhlc2VcXG50eXBlIGNoZWNraW5nIHRvb2xzIGluIG9yZGVyIHRvIHVzZSBJbW11dGFibGUuanMsIGhvd2V2ZXIgYmVjb21pbmcgZmFtaWxpYXJcXG53aXRoIHRoZWlyIHN5bnRheCB3aWxsIGhlbHAgeW91IGdldCBhIGRlZXBlciB1bmRlcnN0YW5kaW5nIG9mIHRoaXMgQVBJLlxcblxcbioqQSBmZXcgZXhhbXBsZXMgYW5kIGhvdyB0byByZWFkIHRoZW0uKipcXG5cXG5BbGwgbWV0aG9kcyBkZXNjcmliZSB0aGUga2luZHMgb2YgZGF0YSB0aGV5IGFjY2VwdCBhbmQgdGhlIGtpbmRzIG9mIGRhdGFcXG50aGV5IHJldHVybi4gRm9yIGV4YW1wbGUgYSBmdW5jdGlvbiB3aGljaCBhY2NlcHRzIHR3byBudW1iZXJzIGFuZCByZXR1cm5zXFxuYSBudW1iZXIgd291bGQgbG9vayBsaWtlIHRoaXM6XFxuXFxuYGBganNcXG5zdW0oZmlyc3Q6IG51bWJlciwgc2Vjb25kOiBudW1iZXIpOiBudW1iZXJcXG5gYGBcXG5cXG5Tb21ldGltZXMsIG1ldGhvZHMgY2FuIGFjY2VwdCBkaWZmZXJlbnQga2luZHMgb2YgZGF0YSBvciByZXR1cm4gZGlmZmVyZW50XFxua2luZHMgb2YgZGF0YSwgYW5kIHRoaXMgaXMgZGVzY3JpYmVkIHdpdGggYSAqdHlwZSB2YXJpYWJsZSosIHdoaWNoIGlzXFxudHlwaWNhbGx5IGluIGFsbC1jYXBzLiBGb3IgZXhhbXBsZSwgYSBmdW5jdGlvbiB3aGljaCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZVxcbmtpbmQgb2YgZGF0YSBpdCB3YXMgcHJvdmlkZWQgd291bGQgbG9vayBsaWtlIHRoaXM6XFxuXFxuYGBganNcXG5pZGVudGl0eTxUPih2YWx1ZTogVCk6IFRcXG5gYGBcXG5cXG5UeXBlIHZhcmlhYmxlcyBhcmUgZGVmaW5lZCB3aXRoIGNsYXNzZXMgYW5kIHJlZmVycmVkIHRvIGluIG1ldGhvZHMuIEZvclxcbmV4YW1wbGUsIGEgY2xhc3MgdGhhdCBob2xkcyBvbnRvIGEgdmFsdWUgZm9yIHlvdSBtaWdodCBsb29rIGxpa2UgdGhpczpcXG5cXG5gYGBqc1xcbmNsYXNzIEJveDxUPiB7XFxuICBjb25zdHJ1Y3Rvcih2YWx1ZTogVClcXG4gIGdldFZhbHVlKCk6IFRcXG59XFxuYGBgXFxuXFxuSW4gb3JkZXIgdG8gbWFuaXB1bGF0ZSBJbW11dGFibGUgZGF0YSwgbWV0aG9kcyB0aGF0IHdlJ3JlIHVzZWQgdG8gYWZmZWN0aW5nXFxuYSBDb2xsZWN0aW9uIGluc3RlYWQgcmV0dXJuIGEgbmV3IENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZS4gVGhlIHR5cGVcXG5gdGhpc2AgcmVmZXJzIHRvIHRoZSBzYW1lIGtpbmQgb2YgY2xhc3MuIEZvciBleGFtcGxlLCBhIExpc3Qgd2hpY2ggcmV0dXJuc1xcbm5ldyBMaXN0cyB3aGVuIHlvdSBgcHVzaGAgYSB2YWx1ZSBvbnRvIGl0IG1pZ2h0IGxvb2sgbGlrZTpcXG5cXG5gYGBqc1xcbmNsYXNzIExpc3Q8VD4ge1xcbiAgcHVzaCh2YWx1ZTogVCk6IHRoaXNcXG59XFxuYGBgXFxuXFxuTWFueSBtZXRob2RzIGluIEltbXV0YWJsZS5qcyBhY2NlcHQgdmFsdWVzIHdoaWNoIGltcGxlbWVudCB0aGUgSmF2YVNjcmlwdFxcbltJdGVyYWJsZV1bXSBwcm90b2NvbCwgYW5kIG1pZ2h0IGFwcGVhciBsaWtlIGBJdGVyYWJsZTxzdHJpbmc+YCBmb3Igc29tZXRoaW5nXFxud2hpY2ggcmVwcmVzZW50cyBzZXF1ZW5jZSBvZiBzdHJpbmdzLiBUeXBpY2FsbHkgaW4gSmF2YVNjcmlwdCB3ZSB1c2UgcGxhaW5cXG5BcnJheXMgKGBbXWApIHdoZW4gYW4gSXRlcmFibGUgaXMgZXhwZWN0ZWQsIGJ1dCBhbHNvIGFsbCBvZiB0aGUgSW1tdXRhYmxlLmpzXFxuY29sbGVjdGlvbnMgYXJlIGl0ZXJhYmxlIHRoZW1zZWx2ZXMhXFxuXFxuRm9yIGV4YW1wbGUsIHRvIGdldCBhIHZhbHVlIGRlZXAgd2l0aGluIGEgc3RydWN0dXJlIG9mIGRhdGEsIHdlIG1pZ2h0IHVzZVxcbmBnZXRJbmAgd2hpY2ggZXhwZWN0cyBhbiBgSXRlcmFibGVgIHBhdGg6XFxuXFxuYGBgXFxuZ2V0SW4ocGF0aDogSXRlcmFibGU8c3RyaW5nIHwgbnVtYmVyPik6IHVua25vd25cXG5gYGBcXG5cXG5UbyB1c2UgdGhpcyBtZXRob2QsIHdlIGNvdWxkIHBhc3MgYW4gYXJyYXk6IGBkYXRhLmdldEluKFsgXFxcImtleVxcXCIsIDIgXSlgLlxcblxcblxcbk5vdGU6IEFsbCBleGFtcGxlcyBhcmUgcHJlc2VudGVkIGluIHRoZSBtb2Rlcm4gW0VTMjAxNV1bXSB2ZXJzaW9uIG9mXFxuSmF2YVNjcmlwdC4gVXNlIHRvb2xzIGxpa2UgQmFiZWwgdG8gc3VwcG9ydCBvbGRlciBicm93c2Vycy5cXG5cXG5Gb3IgZXhhbXBsZTpcXG5cXG5gYGBqc1xcbi8vIEVTMjAxNVxcbmNvbnN0IG1hcHBlZEZvbyA9IGZvby5tYXAoeCA9PiB4ICogeCk7XFxuLy8gRVM1XFxudmFyIG1hcHBlZEZvbyA9IGZvby5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggKiB4OyB9KTtcXG5gYGBcXG5cXG5bRVMyMDE1XTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9OZXdfaW5fSmF2YVNjcmlwdC9FQ01BU2NyaXB0XzZfc3VwcG9ydF9pbl9Nb3ppbGxhXFxuW1R5cGVTY3JpcHRdOiBodHRwczovL3d3dy50eXBlc2NyaXB0bGFuZy5vcmcvXFxuW0Zsb3ddOiBodHRwczovL2Zsb3d0eXBlLm9yZy9cXG5bSXRlcmFibGVdOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9JdGVyYXRpb25fcHJvdG9jb2xzXCIsXCJub3Rlc1wiOltdfSxcIm1vZHVsZVwiOntcIkxpc3RcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiTGlzdHMgYXJlIG9yZGVyZWQgaW5kZXhlZCBkZW5zZSBjb2xsZWN0aW9ucywgbXVjaCBsaWtlIGEgSmF2YVNjcmlwdFxcbkFycmF5LlwiLFwiZGVzY3JpcHRpb25cIjpcIkxpc3RzIGFyZSBpbW11dGFibGUgYW5kIGZ1bGx5IHBlcnNpc3RlbnQgd2l0aCBPKGxvZzMyIE4pIGdldHMgYW5kIHNldHMsXFxuYW5kIE8oMSkgcHVzaCBhbmQgcG9wLlxcblxcbkxpc3RzIGltcGxlbWVudCBEZXF1ZSwgd2l0aCBlZmZpY2llbnQgYWRkaXRpb24gYW5kIHJlbW92YWwgZnJvbSBib3RoIHRoZVxcbmVuZCAoYHB1c2hgLCBgcG9wYCkgYW5kIGJlZ2lubmluZyAoYHVuc2hpZnRgLCBgc2hpZnRgKS5cXG5cXG5Vbmxpa2UgYSBKYXZhU2NyaXB0IEFycmF5LCB0aGVyZSBpcyBubyBkaXN0aW5jdGlvbiBiZXR3ZWVuIGFuXFxuXFxcInVuc2V0XFxcIiBpbmRleCBhbmQgYW4gaW5kZXggc2V0IHRvIGB1bmRlZmluZWRgLiBgTGlzdCNmb3JFYWNoYCB2aXNpdHMgYWxsXFxuaW5kaWNlcyBmcm9tIDAgdG8gc2l6ZSwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZXkgd2VyZSBleHBsaWNpdGx5IGRlZmluZWQuXCIsXCJub3Rlc1wiOltdfSxcIm1vZHVsZVwiOntcImlzTGlzdFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYSBMaXN0XCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcbkxpc3QuaXNMaXN0KFtdKTsgLy8gZmFsc2VcXG5MaXN0LmlzTGlzdChMaXN0KCkpOyAvLyB0cnVlXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlTGlzdFwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6MTIwfV19fSxcIm9mXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDcmVhdGVzIGEgbmV3IExpc3QgY29udGFpbmluZyBgdmFsdWVzYC5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxuTGlzdC5vZigxLCAyLCAzLCA0KVxcbi8vIExpc3QgWyAxLCAyLCAzLCA0IF1cXG5gYGBcXG5cXG5Ob3RlOiBWYWx1ZXMgYXJlIG5vdCBhbHRlcmVkIG9yIGNvbnZlcnRlZCBpbiBhbnkgd2F5LlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXG5MaXN0Lm9mKHt4OjF9LCAyLCBbM10sIDQpXFxuLy8gTGlzdCBbIHsgeDogMSB9LCAyLCBbIDMgXSwgNCBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVzXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTQxfV19fX0sXCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkNyZWF0ZSBhIG5ldyBpbW11dGFibGUgTGlzdCBjb250YWluaW5nIHRoZSB2YWx1ZXMgb2YgdGhlIHByb3ZpZGVkXFxuY29sbGVjdGlvbi1saWtlLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBMaXN0YCBpcyBhIGZhY3RvcnkgZnVuY3Rpb24gYW5kIG5vdCBhIGNsYXNzLCBhbmQgZG9lcyBub3QgdXNlIHRoZVxcbmBuZXdgIGtleXdvcmQgZHVyaW5nIGNvbnN0cnVjdGlvbi5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTGlzdCwgU2V0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcblxcbmNvbnN0IGVtcHR5TGlzdCA9IExpc3QoKVxcbi8vIExpc3QgW11cXG5cXG5jb25zdCBwbGFpbkFycmF5ID0gWyAxLCAyLCAzLCA0IF1cXG5jb25zdCBsaXN0RnJvbVBsYWluQXJyYXkgPSBMaXN0KHBsYWluQXJyYXkpXFxuLy8gTGlzdCBbIDEsIDIsIDMsIDQgXVxcblxcbmNvbnN0IHBsYWluU2V0ID0gU2V0KFsgMSwgMiwgMywgNCBdKVxcbmNvbnN0IGxpc3RGcm9tUGxhaW5TZXQgPSBMaXN0KHBsYWluU2V0KVxcbi8vIExpc3QgWyAxLCAyLCAzLCA0IF1cXG5cXG5jb25zdCBhcnJheUl0ZXJhdG9yID0gcGxhaW5BcnJheVtTeW1ib2wuaXRlcmF0b3JdKClcXG5jb25zdCBsaXN0RnJvbUNvbGxlY3Rpb25BcnJheSA9IExpc3QoYXJyYXlJdGVyYXRvcilcXG4vLyBMaXN0IFsgMSwgMiwgMywgNCBdXFxuXFxubGlzdEZyb21QbGFpbkFycmF5LmVxdWFscyhsaXN0RnJvbUNvbGxlY3Rpb25BcnJheSkgLy8gdHJ1ZVxcbmxpc3RGcm9tUGxhaW5TZXQuZXF1YWxzKGxpc3RGcm9tQ29sbGVjdGlvbkFycmF5KSAvLyB0cnVlXFxubGlzdEZyb21QbGFpblNldC5lcXVhbHMobGlzdEZyb21QbGFpbkFycmF5KSAvLyB0cnVlXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJsaW5lXCI6MTc1fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjE3Nn0se1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoxNzd9XX0sXCJpbnRlcmZhY2VcIjp7XCJsaW5lXCI6MTc5LFwidHlwZVBhcmFtc1wiOltcIlRcIl0sXCJleHRlbmRzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfV0sXCJncm91cHNcIjpbe1wibWVtYmVyc1wiOntcIiNzaXplXCI6e1wibGluZVwiOjE4NH19fSx7XCJ0aXRsZVwiOlwiUGVyc2lzdGVudCBjaGFuZ2VzXCIsXCJtZW1iZXJzXCI6e1wiI3NldFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IExpc3Qgd2hpY2ggaW5jbHVkZXMgYHZhbHVlYCBhdCBgaW5kZXhgLiBJZiBgaW5kZXhgIGFscmVhZHlcXG5leGlzdHMgaW4gdGhpcyBMaXN0LCBpdCB3aWxsIGJlIHJlcGxhY2VkLlwiLFwiZGVzY3JpcHRpb25cIjpcImBpbmRleGAgbWF5IGJlIGEgbmVnYXRpdmUgbnVtYmVyLCB3aGljaCBpbmRleGVzIGJhY2sgZnJvbSB0aGUgZW5kIG9mIHRoZVxcbkxpc3QuIGB2LnNldCgtMSwgXFxcInZhbHVlXFxcIilgIHNldHMgdGhlIGxhc3QgaXRlbSBpbiB0aGUgTGlzdC5cXG5cXG5JZiBgaW5kZXhgIGxhcmdlciB0aGFuIGBzaXplYCwgdGhlIHJldHVybmVkIExpc3QncyBgc2l6ZWAgd2lsbCBiZSBsYXJnZVxcbmVub3VnaCB0byBpbmNsdWRlIHRoZSBgaW5kZXhgLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuY29uc3Qgb3JpZ2luYWxMaXN0ID0gTGlzdChbIDAgXSk7XFxuLy8gTGlzdCBbIDAgXVxcbm9yaWdpbmFsTGlzdC5zZXQoMSwgMSk7XFxuLy8gTGlzdCBbIDAsIDEgXVxcbm9yaWdpbmFsTGlzdC5zZXQoMCwgJ292ZXJ3cml0dGVuJyk7XFxuLy8gTGlzdCBbIFxcXCJvdmVyd3JpdHRlblxcXCIgXVxcbm9yaWdpbmFsTGlzdC5zZXQoMiwgMik7XFxuLy8gTGlzdCBbIDAsIHVuZGVmaW5lZCwgMiBdXFxuXFxuTGlzdCgpLnNldCg1MDAwMCwgJ3ZhbHVlJykuc2l6ZTtcXG4vLyA1MDAwMVxcbmBgYFxcblxcbk5vdGU6IGBzZXRgIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MjE3fV19LFwiI2RlbGV0ZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IExpc3Qgd2hpY2ggZXhjbHVkZXMgdGhpcyBgaW5kZXhgIGFuZCB3aXRoIGEgc2l6ZSAxIGxlc3NcXG50aGFuIHRoaXMgTGlzdC4gVmFsdWVzIGF0IGluZGljZXMgYWJvdmUgYGluZGV4YCBhcmUgc2hpZnRlZCBkb3duIGJ5IDEgdG9cXG5maWxsIHRoZSBwb3NpdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJUaGlzIGlzIHN5bm9ueW1vdXMgd2l0aCBgbGlzdC5zcGxpY2UoaW5kZXgsIDEpYC5cXG5cXG5gaW5kZXhgIG1heSBiZSBhIG5lZ2F0aXZlIG51bWJlciwgd2hpY2ggaW5kZXhlcyBiYWNrIGZyb20gdGhlIGVuZCBvZiB0aGVcXG5MaXN0LiBgdi5kZWxldGUoLTEpYCBkZWxldGVzIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIExpc3QuXFxuXFxuTm90ZTogYGRlbGV0ZWAgY2Fubm90IGJlIHNhZmVseSB1c2VkIGluIElFOFxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuTGlzdChbIDAsIDEsIDIsIDMsIDQgXSkuZGVsZXRlKDApO1xcbi8vIExpc3QgWyAxLCAyLCAzLCA0IF1cXG5gYGBcXG5cXG5TaW5jZSBgZGVsZXRlKClgIHJlLWluZGV4ZXMgdmFsdWVzLCBpdCBwcm9kdWNlcyBhIGNvbXBsZXRlIGNvcHksIHdoaWNoXFxuaGFzIGBPKE4pYCBjb21wbGV4aXR5Llxcblxcbk5vdGU6IGBkZWxldGVgICpjYW5ub3QqIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwiYWxpYXNcIixcImJvZHlcIjpcInJlbW92ZVwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6Mn19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjI0Nn1dfSxcIiNpbnNlcnRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBMaXN0IHdpdGggYHZhbHVlYCBhdCBgaW5kZXhgIHdpdGggYSBzaXplIDEgbW9yZSB0aGFuIHRoaXNcXG5MaXN0LiBWYWx1ZXMgYXQgaW5kaWNlcyBhYm92ZSBgaW5kZXhgIGFyZSBzaGlmdGVkIG92ZXIgYnkgMS5cIixcImRlc2NyaXB0aW9uXCI6XCJUaGlzIGlzIHN5bm9ueW1vdXMgd2l0aCBgbGlzdC5zcGxpY2UoaW5kZXgsIDAsIHZhbHVlKWAuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5MaXN0KFsgMCwgMSwgMiwgMywgNCBdKS5pbnNlcnQoNiwgNSlcXG4vLyBMaXN0IFsgMCwgMSwgMiwgMywgNCwgNSBdXFxuYGBgXFxuXFxuU2luY2UgYGluc2VydCgpYCByZS1pbmRleGVzIHZhbHVlcywgaXQgcHJvZHVjZXMgYSBjb21wbGV0ZSBjb3B5LCB3aGljaFxcbmhhcyBgTyhOKWAgY29tcGxleGl0eS5cXG5cXG5Ob3RlOiBgaW5zZXJ0YCAqY2Fubm90KiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MjY4fV19LFwiI2NsZWFyXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTGlzdCB3aXRoIDAgc2l6ZSBhbmQgbm8gdmFsdWVzIGluIGNvbnN0YW50IHRpbWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5MaXN0KFsgMSwgMiwgMywgNCBdKS5jbGVhcigpXFxuLy8gTGlzdCBbXVxcbmBgYFxcblxcbk5vdGU6IGBjbGVhcmAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjI4M31dfSxcIiNwdXNoXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTGlzdCB3aXRoIHRoZSBwcm92aWRlZCBgdmFsdWVzYCBhcHBlbmRlZCwgc3RhcnRpbmcgYXQgdGhpc1xcbkxpc3QncyBgc2l6ZWAuXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5MaXN0KFsgMSwgMiwgMywgNCBdKS5wdXNoKDUpXFxuLy8gTGlzdCBbIDEsIDIsIDMsIDQsIDUgXVxcbmBgYFxcblxcbk5vdGU6IGBwdXNoYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjI5OX1dfSxcIiNwb3BcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBMaXN0IHdpdGggYSBzaXplIG9uZXMgbGVzcyB0aGFuIHRoaXMgTGlzdCwgZXhjbHVkaW5nXFxudGhlIGxhc3QgaW5kZXggaW4gdGhpcyBMaXN0LlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IHRoaXMgZGlmZmVycyBmcm9tIGBBcnJheSNwb3BgIGJlY2F1c2UgaXQgcmV0dXJucyBhIG5ld1xcbkxpc3QgcmF0aGVyIHRoYW4gdGhlIHJlbW92ZWQgdmFsdWUuIFVzZSBgbGFzdCgpYCB0byBnZXQgdGhlIGxhc3QgdmFsdWVcXG5pbiB0aGlzIExpc3QuXFxuXFxuYGBganNcXG5MaXN0KFsgMSwgMiwgMywgNCBdKS5wb3AoKVxcbi8vIExpc3RbIDEsIDIsIDMgXVxcbmBgYFxcblxcbk5vdGU6IGBwb3BgIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjozMTZ9XX0sXCIjdW5zaGlmdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IExpc3Qgd2l0aCB0aGUgcHJvdmlkZWQgYHZhbHVlc2AgcHJlcGVuZGVkLCBzaGlmdGluZyBvdGhlclxcbnZhbHVlcyBhaGVhZCB0byBoaWdoZXIgaW5kaWNlcy5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbkxpc3QoWyAyLCAzLCA0XSkudW5zaGlmdCgxKTtcXG4vLyBMaXN0IFsgMSwgMiwgMywgNCBdXFxuYGBgXFxuXFxuTm90ZTogYHVuc2hpZnRgIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVzXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MzMyfV19LFwiI3NoaWZ0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTGlzdCB3aXRoIGEgc2l6ZSBvbmVzIGxlc3MgdGhhbiB0aGlzIExpc3QsIGV4Y2x1ZGluZ1xcbnRoZSBmaXJzdCBpbmRleCBpbiB0aGlzIExpc3QsIHNoaWZ0aW5nIGFsbCBvdGhlciB2YWx1ZXMgdG8gYSBsb3dlciBpbmRleC5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiB0aGlzIGRpZmZlcnMgZnJvbSBgQXJyYXkjc2hpZnRgIGJlY2F1c2UgaXQgcmV0dXJucyBhIG5ld1xcbkxpc3QgcmF0aGVyIHRoYW4gdGhlIHJlbW92ZWQgdmFsdWUuIFVzZSBgZmlyc3QoKWAgdG8gZ2V0IHRoZSBmaXJzdFxcbnZhbHVlIGluIHRoaXMgTGlzdC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbkxpc3QoWyAwLCAxLCAyLCAzLCA0IF0pLnNoaWZ0KCk7XFxuLy8gTGlzdCBbIDEsIDIsIDMsIDQgXVxcbmBgYFxcblxcbk5vdGU6IGBzaGlmdGAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjM1Mn1dfSxcIiN1cGRhdGVcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBMaXN0IHdpdGggYW4gdXBkYXRlZCB2YWx1ZSBhdCBgaW5kZXhgIHdpdGggdGhlIHJldHVyblxcbnZhbHVlIG9mIGNhbGxpbmcgYHVwZGF0ZXJgIHdpdGggdGhlIGV4aXN0aW5nIHZhbHVlLCBvciBgbm90U2V0VmFsdWVgIGlmXFxuYGluZGV4YCB3YXMgbm90IHNldC4gSWYgY2FsbGVkIHdpdGggYSBzaW5nbGUgYXJndW1lbnQsIGB1cGRhdGVyYCBpc1xcbmNhbGxlZCB3aXRoIHRoZSBMaXN0IGl0c2VsZi5cIixcImRlc2NyaXB0aW9uXCI6XCJgaW5kZXhgIG1heSBiZSBhIG5lZ2F0aXZlIG51bWJlciwgd2hpY2ggaW5kZXhlcyBiYWNrIGZyb20gdGhlIGVuZCBvZiB0aGVcXG5MaXN0LiBgdi51cGRhdGUoLTEpYCB1cGRhdGVzIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIExpc3QuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5jb25zdCBsaXN0ID0gTGlzdChbICdhJywgJ2InLCAnYycgXSlcXG5jb25zdCByZXN1bHQgPSBsaXN0LnVwZGF0ZSgyLCB2YWwgPT4gdmFsLnRvVXBwZXJDYXNlKCkpXFxuLy8gTGlzdCBbIFxcXCJhXFxcIiwgXFxcImJcXFwiLCBcXFwiQ1xcXCIgXVxcbmBgYFxcblxcblRoaXMgY2FuIGJlIHZlcnkgdXNlZnVsIGFzIGEgd2F5IHRvIFxcXCJjaGFpblxcXCIgYSBub3JtYWwgZnVuY3Rpb24gaW50byBhXFxuc2VxdWVuY2Ugb2YgbWV0aG9kcy4gUnhKUyBjYWxscyB0aGlzIFxcXCJsZXRcXFwiIGFuZCBsb2Rhc2ggY2FsbHMgaXQgXFxcInRocnVcXFwiLlxcblxcbkZvciBleGFtcGxlLCB0byBzdW0gYSBMaXN0IGFmdGVyIG1hcHBpbmcgYW5kIGZpbHRlcmluZzpcXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmZ1bmN0aW9uIHN1bShjb2xsZWN0aW9uKSB7XFxuICByZXR1cm4gY29sbGVjdGlvbi5yZWR1Y2UoKHN1bSwgeCkgPT4gc3VtICsgeCwgMClcXG59XFxuXFxuTGlzdChbIDEsIDIsIDMgXSlcXG4gIC5tYXAoeCA9PiB4ICsgMSlcXG4gIC5maWx0ZXIoeCA9PiB4ICUgMiA9PT0gMClcXG4gIC51cGRhdGUoc3VtKVxcbi8vIDZcXG5gYGBcXG5cXG5Ob3RlOiBgdXBkYXRlKGluZGV4KWAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI3VwZGF0ZWBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6Mzk2fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6Mzk3fSx7XCJ0eXBlUGFyYW1zXCI6W1wiUlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ1cGRhdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiUlwifX19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJSXCJ9LFwibGluZVwiOjM5OH1dfSxcIiNzZXRTaXplXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTGlzdCB3aXRoIHNpemUgYHNpemVgLiBJZiBgc2l6ZWAgaXMgbGVzcyB0aGFuIHRoaXNcXG5MaXN0J3Mgc2l6ZSwgdGhlIG5ldyBMaXN0IHdpbGwgZXhjbHVkZSB2YWx1ZXMgYXQgdGhlIGhpZ2hlciBpbmRpY2VzLlxcbklmIGBzaXplYCBpcyBncmVhdGVyIHRoYW4gdGhpcyBMaXN0J3Mgc2l6ZSwgdGhlIG5ldyBMaXN0IHdpbGwgaGF2ZVxcbnVuZGVmaW5lZCB2YWx1ZXMgZm9yIHRoZSBuZXdseSBhdmFpbGFibGUgaW5kaWNlcy5cIixcImRlc2NyaXB0aW9uXCI6XCJXaGVuIGJ1aWxkaW5nIGEgbmV3IExpc3QgYW5kIHRoZSBmaW5hbCBzaXplIGlzIGtub3duIHVwIGZyb250LCBgc2V0U2l6ZWBcXG51c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYHdpdGhNdXRhdGlvbnNgIG1heSByZXN1bHQgaW4gdGhlIG1vcmVcXG5wZXJmb3JtYW50IGNvbnN0cnVjdGlvbi5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwic2l6ZVwiLFwidHlwZVwiOntcImtcIjoyfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6NDEwfV19fX0se1widGl0bGVcIjpcIkRlZXAgcGVyc2lzdGVudCBjaGFuZ2VzXCIsXCJtZW1iZXJzXCI6e1wiI3NldEluXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTGlzdCBoYXZpbmcgc2V0IGB2YWx1ZWAgYXQgdGhpcyBga2V5UGF0aGAuIElmIGFueSBrZXlzIGluXFxuYGtleVBhdGhgIGRvIG5vdCBleGlzdCwgYSBuZXcgaW1tdXRhYmxlIE1hcCB3aWxsIGJlIGNyZWF0ZWQgYXQgdGhhdCBrZXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiSW5kZXggbnVtYmVycyBhcmUgdXNlZCBhcyBrZXlzIHRvIGRldGVybWluZSB0aGUgcGF0aCB0byBmb2xsb3cgaW5cXG50aGUgTGlzdC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBsaXN0ID0gTGlzdChbIDAsIDEsIDIsIExpc3QoWyAzLCA0IF0pXSlcXG5saXN0LnNldEluKFszLCAwXSwgOTk5KTtcXG4vLyBMaXN0IFsgMCwgMSwgMiwgTGlzdCBbIDk5OSwgNCBdIF1cXG5gYGBcXG5cXG5QbGFpbiBKYXZhU2NyaXB0IE9iamVjdCBvciBBcnJheXMgbWF5IGJlIG5lc3RlZCB3aXRoaW4gYW4gSW1tdXRhYmxlLmpzXFxuQ29sbGVjdGlvbiwgYW5kIHNldEluKCkgY2FuIHVwZGF0ZSB0aG9zZSB2YWx1ZXMgYXMgd2VsbCwgdHJlYXRpbmcgdGhlbVxcbmltbXV0YWJseSBieSBjcmVhdGluZyBuZXcgY29waWVzIG9mIHRob3NlIHZhbHVlcyB3aXRoIHRoZSBjaGFuZ2VzIGFwcGxpZWQuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3QgbGlzdCA9IExpc3QoWyAwLCAxLCAyLCB7IHBsYWluOiAnb2JqZWN0JyB9XSlcXG5saXN0LnNldEluKFszLCAncGxhaW4nXSwgJ3ZhbHVlJyk7XFxuLy8gTGlzdChbIDAsIDEsIDIsIHsgcGxhaW46ICd2YWx1ZScgfV0pXFxuYGBgXFxuXFxuTm90ZTogYHNldEluYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX0se1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo0NDR9XX0sXCIjZGVsZXRlSW5cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBMaXN0IGhhdmluZyByZW1vdmVkIHRoZSB2YWx1ZSBhdCB0aGlzIGBrZXlQYXRoYC4gSWYgYW55XFxua2V5cyBpbiBga2V5UGF0aGAgZG8gbm90IGV4aXN0LCBubyBjaGFuZ2Ugd2lsbCBvY2N1ci5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBsaXN0ID0gTGlzdChbIDAsIDEsIDIsIExpc3QoWyAzLCA0IF0pXSlcXG5saXN0LmRlbGV0ZUluKFszLCAwXSk7XFxuLy8gTGlzdCBbIDAsIDEsIDIsIExpc3QgWyA0IF0gXVxcbmBgYFxcblxcblBsYWluIEphdmFTY3JpcHQgT2JqZWN0IG9yIEFycmF5cyBtYXkgYmUgbmVzdGVkIHdpdGhpbiBhbiBJbW11dGFibGUuanNcXG5Db2xsZWN0aW9uLCBhbmQgcmVtb3ZlSW4oKSBjYW4gdXBkYXRlIHRob3NlIHZhbHVlcyBhcyB3ZWxsLCB0cmVhdGluZyB0aGVtXFxuaW1tdXRhYmx5IGJ5IGNyZWF0aW5nIG5ldyBjb3BpZXMgb2YgdGhvc2UgdmFsdWVzIHdpdGggdGhlIGNoYW5nZXMgYXBwbGllZC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBsaXN0ID0gTGlzdChbIDAsIDEsIDIsIHsgcGxhaW46ICdvYmplY3QnIH1dKVxcbmxpc3QucmVtb3ZlSW4oWzMsICdwbGFpbiddKTtcXG4vLyBMaXN0KFsgMCwgMSwgMiwge31dKVxcbmBgYFxcblxcbk5vdGU6IGBkZWxldGVJbmAgKmNhbm5vdCogYmUgc2FmZWx5IHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwiYWxpYXNcIixcImJvZHlcIjpcInJlbW92ZUluXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlQYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjQ3NH1dfSxcIiN1cGRhdGVJblwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJOb3RlOiBgdXBkYXRlSW5gIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cXG5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiYE1hcCN1cGRhdGVJbmBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fSx7XCJuYW1lXCI6XCJ1cGRhdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjQ4Mn0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX0se1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxN319fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo0ODN9XX0sXCIjbWVyZ2VJblwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJOb3RlOiBgbWVyZ2VJbmAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI21lcmdlSW5gXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlQYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX19LHtcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NDkwfV19LFwiI21lcmdlRGVlcEluXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIk5vdGU6IGBtZXJnZURlZXBJbmAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI21lcmdlRGVlcEluYFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5UGF0aFwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19fSx7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjQ5N31dfX19LHtcInRpdGxlXCI6XCJUcmFuc2llbnQgY2hhbmdlc1wiLFwibWVtYmVyc1wiOntcIiN3aXRoTXV0YXRpb25zXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIk5vdGU6IE5vdCBhbGwgbWV0aG9kcyBjYW4gYmUgc2FmZWx5IHVzZWQgb24gYSBtdXRhYmxlIGNvbGxlY3Rpb24gb3Igd2l0aGluXFxuYHdpdGhNdXRhdGlvbnNgISBDaGVjayB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgZWFjaCBtZXRob2QgdG8gc2VlIGlmIGl0XFxuYWxsb3dzIGJlaW5nIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI3dpdGhNdXRhdGlvbnNgXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtdXRhdG9yXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibXV0YWJsZVwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MTd9fX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NTA4fV19LFwiI2FzTXV0YWJsZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJBbiBhbHRlcm5hdGl2ZSBBUEkgZm9yIHdpdGhNdXRhdGlvbnMoKVwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IE5vdCBhbGwgbWV0aG9kcyBjYW4gYmUgc2FmZWx5IHVzZWQgb24gYSBtdXRhYmxlIGNvbGxlY3Rpb24gb3Igd2l0aGluXFxuYHdpdGhNdXRhdGlvbnNgISBDaGVjayB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgZWFjaCBtZXRob2QgdG8gc2VlIGlmIGl0XFxuYWxsb3dzIGJlaW5nIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI2FzTXV0YWJsZWBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NTE5fV19LFwiI3dhc0FsdGVyZWRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcImBNYXAjd2FzQWx0ZXJlZGBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo1MjR9XX0sXCIjYXNJbW11dGFibGVcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcImBNYXAjYXNJbW11dGFibGVgXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjUyOX1dfX19LHtcInRpdGxlXCI6XCJTZXF1ZW5jZSBhbGdvcml0aG1zXCIsXCJtZW1iZXJzXCI6e1wiI2NvbmNhdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IExpc3Qgd2l0aCBvdGhlciB2YWx1ZXMgb3IgY29sbGVjdGlvbnMgY29uY2F0ZW5hdGVkIHRvIHRoaXMgb25lLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBjb25jYXRgIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cXG5cIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcImFsaWFzXCIsXCJib2R5XCI6XCJtZXJnZVwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZXNPckNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIkNcIn1dfSx7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifV19XX0sXCJsaW5lXCI6NTQwfV19LFwiI21hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IExpc3Qgd2l0aCB2YWx1ZXMgcGFzc2VkIHRocm91Z2ggYVxcbmBtYXBwZXJgIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuTGlzdChbIDEsIDIgXSkubWFwKHggPT4gMTAgKiB4KVxcbi8vIExpc3QgWyAxMCwgMjAgXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk1cIn19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6NTU1fV19LFwiI2ZsYXRNYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRmxhdC1tYXBzIHRoZSBMaXN0LCByZXR1cm5pbmcgYSBuZXcgTGlzdC5cIixcImRlc2NyaXB0aW9uXCI6XCJTaW1pbGFyIHRvIGBsaXN0Lm1hcCguLi4pLmZsYXR0ZW4odHJ1ZSlgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjU2NX1dfSxcIiNmaWx0ZXJcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBMaXN0IHdpdGggb25seSB0aGUgdmFsdWVzIGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWBcXG5mdW5jdGlvbiByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYGZpbHRlcigpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCByZXN1bHRzIGluXFxubm90IGZpbHRlcmluZyBvdXQgYW55IHZhbHVlcy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiRlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIkZcIn1dfSxcImxpbmVcIjo1Nzd9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxN319fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NTgxfV19LFwiI3ppcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgTGlzdCBcXFwiemlwcGVkXFxcIiB3aXRoIHRoZSBwcm92aWRlZCBjb2xsZWN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIkxpa2UgYHppcFdpdGhgLCBidXQgdXNpbmcgdGhlIGRlZmF1bHQgYHppcHBlcmA6IGNyZWF0aW5nIGFuIGBBcnJheWAuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5jb25zdCBhID0gTGlzdChbIDEsIDIsIDMgXSk7XFxuY29uc3QgYiA9IExpc3QoWyA0LCA1LCA2IF0pO1xcbmNvbnN0IGMgPSBhLnppcChiKTsgLy8gTGlzdCBbIFsgMSwgNCBdLCBbIDIsIDUgXSwgWyAzLCA2IF0gXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJVXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19XX0sXCJsaW5lXCI6NjAwfSx7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiLFwiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlclwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX0se1wibmFtZVwiOlwib3RoZXIyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfSxcImxpbmVcIjo2MDF9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJsaW5lXCI6NjAyfV19LFwiI3ppcEFsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgTGlzdCBcXFwiemlwcGVkXFxcIiB3aXRoIHRoZSBwcm92aWRlZCBjb2xsZWN0aW9ucy5cIixcImRlc2NyaXB0aW9uXCI6XCJVbmxpa2UgYHppcGAsIGB6aXBBbGxgIGNvbnRpbnVlcyB6aXBwaW5nIHVudGlsIHRoZSBsb25nZXN0IGNvbGxlY3Rpb24gaXNcXG5leGhhdXN0ZWQuIE1pc3NpbmcgdmFsdWVzIGZyb20gc2hvcnRlciBjb2xsZWN0aW9ucyBhcmUgZmlsbGVkIHdpdGggYHVuZGVmaW5lZGAuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5jb25zdCBhID0gTGlzdChbIDEsIDIgXSk7XFxuY29uc3QgYiA9IExpc3QoWyAzLCA0LCA1IF0pO1xcbmNvbnN0IGMgPSBhLnppcEFsbChiKTsgLy8gTGlzdCBbIFsgMSwgMyBdLCBbIDIsIDQgXSwgWyB1bmRlZmluZWQsIDUgXSBdXFxuYGBgXFxuXFxuTm90ZTogU2luY2UgemlwQWxsIHdpbGwgcmV0dXJuIGEgY29sbGVjdGlvbiBhcyBsYXJnZSBhcyB0aGUgbGFyZ2VzdFxcbmlucHV0LCBzb21lIHJlc3VsdHMgbWF5IGNvbnRhaW4gdW5kZWZpbmVkIHZhbHVlcy4gVHlwZVNjcmlwdCBjYW5ub3RcXG5hY2NvdW50IGZvciB0aGVzZSB3aXRob3V0IGNhc2VzIChhcyBvZiB2Mi41KS5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlclwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfV19LFwibGluZVwiOjYyM30se1widHlwZVBhcmFtc1wiOltcIlVcIixcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib3RoZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19LHtcIm5hbWVcIjpcIm90aGVyMlwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XX0sXCJsaW5lXCI6NjI0fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwibGluZVwiOjYyNX1dfSxcIiN6aXBXaXRoXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBMaXN0IFxcXCJ6aXBwZWRcXFwiIHdpdGggdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb25zIGJ5IHVzaW5nIGFcXG5jdXN0b20gYHppcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5jb25zdCBhID0gTGlzdChbIDEsIDIsIDMgXSk7XFxuY29uc3QgYiA9IExpc3QoWyA0LCA1LCA2IF0pO1xcbmNvbnN0IGMgPSBhLnppcFdpdGgoKGEsIGIpID0+IGEgKyBiLCBiKTtcXG4vLyBMaXN0IFsgNSwgNywgOSBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlVcIixcIlpcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiemlwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJvdGhlclZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlpcIn19fSx7XCJuYW1lXCI6XCJvdGhlckNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifV19LFwibGluZVwiOjY0MX0se1widHlwZVBhcmFtc1wiOltcIlVcIixcIlZcIixcIlpcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiemlwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJvdGhlclZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifX0se1wibmFtZVwiOlwidGhpcmRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9fX0se1wibmFtZVwiOlwib3RoZXJDb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fSx7XCJuYW1lXCI6XCJ0aGlyZENvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifV19LFwibGluZVwiOjY0NX0se1widHlwZVBhcmFtc1wiOltcIlpcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiemlwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiYW55XCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlpcIn19fSx7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9XX0sXCJsaW5lXCI6NjUwfV19fX1dfX0sXCJNYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiSW1tdXRhYmxlIE1hcCBpcyBhbiB1bm9yZGVyZWQgQ29sbGVjdGlvbi5LZXllZCBvZiAoa2V5LCB2YWx1ZSkgcGFpcnMgd2l0aFxcbmBPKGxvZzMyIE4pYCBnZXRzIGFuZCBgTyhsb2czMiBOKWAgcGVyc2lzdGVudCBzZXRzLlwiLFwiZGVzY3JpcHRpb25cIjpcIkl0ZXJhdGlvbiBvcmRlciBvZiBhIE1hcCBpcyB1bmRlZmluZWQsIGhvd2V2ZXIgaXMgc3RhYmxlLiBNdWx0aXBsZVxcbml0ZXJhdGlvbnMgb2YgdGhlIHNhbWUgTWFwIHdpbGwgaXRlcmF0ZSBpbiB0aGUgc2FtZSBvcmRlci5cXG5cXG5NYXAncyBrZXlzIGNhbiBiZSBvZiBhbnkgdHlwZSwgYW5kIHVzZSBgSW1tdXRhYmxlLmlzYCB0byBkZXRlcm1pbmUga2V5XFxuZXF1YWxpdHkuIFRoaXMgYWxsb3dzIHRoZSB1c2Ugb2YgYW55IHZhbHVlIChpbmNsdWRpbmcgTmFOKSBhcyBhIGtleS5cXG5cXG5CZWNhdXNlIGBJbW11dGFibGUuaXNgIHJldHVybnMgZXF1YWxpdHkgYmFzZWQgb24gdmFsdWUgc2VtYW50aWNzLCBhbmRcXG5JbW11dGFibGUgY29sbGVjdGlvbnMgYXJlIHRyZWF0ZWQgYXMgdmFsdWVzLCBhbnkgSW1tdXRhYmxlIGNvbGxlY3Rpb24gbWF5XFxuYmUgdXNlZCBhcyBhIGtleS5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwLCBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXG5NYXAoKS5zZXQoTGlzdChbIDEgXSksICdsaXN0b2ZvbmUnKS5nZXQoTGlzdChbIDEgXSkpO1xcbi8vICdsaXN0b2ZvbmUnXFxuYGBgXFxuXFxuQW55IEphdmFTY3JpcHQgb2JqZWN0IG1heSBiZSB1c2VkIGFzIGEga2V5LCBob3dldmVyIHN0cmljdCBpZGVudGl0eSBpcyB1c2VkXFxudG8gZXZhbHVhdGUga2V5IGVxdWFsaXR5LiBUd28gc2ltaWxhciBsb29raW5nIG9iamVjdHMgd2lsbCByZXByZXNlbnQgdHdvXFxuZGlmZmVyZW50IGtleXMuXFxuXFxuSW1wbGVtZW50ZWQgYnkgYSBoYXNoLWFycmF5IG1hcHBlZCB0cmllLlwiLFwibm90ZXNcIjpbXX0sXCJtb2R1bGVcIjp7XCJpc01hcFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYSBNYXBcIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbk1hcC5pc01hcCh7fSkgLy8gZmFsc2VcXG5NYXAuaXNNYXAoTWFwKCkpIC8vIHRydWVcXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVNYXBcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjY5Nn1dfX19LFwiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDcmVhdGVzIGEgbmV3IEltbXV0YWJsZSBNYXAuXCIsXCJkZXNjcmlwdGlvblwiOlwiQ3JlYXRlZCB3aXRoIHRoZSBzYW1lIGtleSB2YWx1ZSBwYWlycyBhcyB0aGUgcHJvdmlkZWQgQ29sbGVjdGlvbi5LZXllZCBvclxcbkphdmFTY3JpcHQgT2JqZWN0IG9yIGV4cGVjdHMgYSBDb2xsZWN0aW9uIG9mIFtLLCBWXSB0dXBsZSBlbnRyaWVzLlxcblxcbk5vdGU6IGBNYXBgIGlzIGEgZmFjdG9yeSBmdW5jdGlvbiBhbmQgbm90IGEgY2xhc3MsIGFuZCBkb2VzIG5vdCB1c2UgdGhlXFxuYG5ld2Aga2V5d29yZCBkdXJpbmcgY29uc3RydWN0aW9uLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuTWFwKHsga2V5OiBcXFwidmFsdWVcXFwiIH0pXFxuTWFwKFsgWyBcXFwia2V5XFxcIiwgXFxcInZhbHVlXFxcIiBdIF0pXFxuYGBgXFxuXFxuS2VlcCBpbiBtaW5kLCB3aGVuIHVzaW5nIEpTIG9iamVjdHMgdG8gY29uc3RydWN0IEltbXV0YWJsZSBNYXBzLCB0aGF0XFxuSmF2YVNjcmlwdCBPYmplY3QgcHJvcGVydGllcyBhcmUgYWx3YXlzIHN0cmluZ3MsIGV2ZW4gaWYgd3JpdHRlbiBpbiBhXFxucXVvdGUtbGVzcyBzaG9ydGhhbmQsIHdoaWxlIEltbXV0YWJsZSBNYXBzIGFjY2VwdCBrZXlzIG9mIGFueSB0eXBlLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IE1hcCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5sZXQgb2JqID0geyAxOiBcXFwib25lXFxcIiB9XFxuT2JqZWN0LmtleXMob2JqKSAvLyBbIFxcXCIxXFxcIiBdXFxuYXNzZXJ0LmVxdWFsKG9ialtcXFwiMVxcXCJdLCBvYmpbMV0pIC8vIFxcXCJvbmVcXFwiID09PSBcXFwib25lXFxcIlxcblxcbmxldCBtYXAgPSBNYXAob2JqKVxcbmFzc2VydC5ub3RFcXVhbChtYXAuZ2V0KFxcXCIxXFxcIiksIG1hcC5nZXQoMSkpIC8vIFxcXCJvbmVcXFwiICE9PSB1bmRlZmluZWRcXG5gYGBcXG5cXG5Qcm9wZXJ0eSBhY2Nlc3MgZm9yIEphdmFTY3JpcHQgT2JqZWN0cyBmaXJzdCBjb252ZXJ0cyB0aGUga2V5IHRvIGEgc3RyaW5nLFxcbmJ1dCBzaW5jZSBJbW11dGFibGUgTWFwIGtleXMgY2FuIGJlIG9mIGFueSB0eXBlIHRoZSBhcmd1bWVudCB0byBgZ2V0KClgIGlzXFxubm90IGFsdGVyZWQuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktcIixcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTWFwXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjc1M30se1widHlwZVBhcmFtc1wiOltcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib2JqXCIsXCJ0eXBlXCI6e1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJNYXBcIixcImFyZ3NcIjpbe1wia1wiOjN9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjo3NTR9LHtcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCJdLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTWFwXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjc1NX0se1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTWFwXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19LFwibGluZVwiOjc1Nn1dfSxcImludGVyZmFjZVwiOntcImxpbmVcIjo3NTgsXCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiXSxcImV4dGVuZHNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XSxcImdyb3Vwc1wiOlt7XCJtZW1iZXJzXCI6e1wiI3NpemVcIjp7XCJsaW5lXCI6NzYzfX19LHtcInRpdGxlXCI6XCJQZXJzaXN0ZW50IGNoYW5nZXNcIixcIm1lbWJlcnNcIjp7XCIjc2V0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTWFwIGFsc28gY29udGFpbmluZyB0aGUgbmV3IGtleSwgdmFsdWUgcGFpci4gSWYgYW4gZXF1aXZhbGVudFxcbmtleSBhbHJlYWR5IGV4aXN0cyBpbiB0aGlzIE1hcCwgaXQgd2lsbCBiZSByZXBsYWNlZC5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG9yaWdpbmFsTWFwID0gTWFwKClcXG5jb25zdCBuZXdlck1hcCA9IG9yaWdpbmFsTWFwLnNldCgna2V5JywgJ3ZhbHVlJylcXG5jb25zdCBuZXdlc3RNYXAgPSBuZXdlck1hcC5zZXQoJ2tleScsICduZXdlciB2YWx1ZScpXFxuXFxub3JpZ2luYWxNYXBcXG4vLyBNYXAge31cXG5uZXdlck1hcFxcbi8vIE1hcCB7IFxcXCJrZXlcXFwiOiBcXFwidmFsdWVcXFwiIH1cXG5uZXdlc3RNYXBcXG4vLyBNYXAgeyBcXFwia2V5XFxcIjogXFxcIm5ld2VyIHZhbHVlXFxcIiB9XFxuYGBgXFxuXFxuTm90ZTogYHNldGAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjc4OH1dfSxcIiNkZWxldGVcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBNYXAgd2hpY2ggZXhjbHVkZXMgdGhpcyBga2V5YC5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgZGVsZXRlYCBjYW5ub3QgYmUgc2FmZWx5IHVzZWQgaW4gSUU4LCBidXQgaXMgcHJvdmlkZWQgdG8gbWlycm9yXFxudGhlIEVTNiBjb2xsZWN0aW9uIEFQSS5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG9yaWdpbmFsTWFwID0gTWFwKHtcXG4gIGtleTogJ3ZhbHVlJyxcXG4gIG90aGVyS2V5OiAnb3RoZXIgdmFsdWUnXFxufSlcXG4vLyBNYXAgeyBcXFwia2V5XFxcIjogXFxcInZhbHVlXFxcIiwgXFxcIm90aGVyS2V5XFxcIjogXFxcIm90aGVyIHZhbHVlXFxcIiB9XFxub3JpZ2luYWxNYXAuZGVsZXRlKCdvdGhlcktleScpXFxuLy8gTWFwIHsgXFxcImtleVxcXCI6IFxcXCJ2YWx1ZVxcXCIgfVxcbmBgYFxcblxcbk5vdGU6IGBkZWxldGVgIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cXG5cIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcImFsaWFzXCIsXCJib2R5XCI6XCJyZW1vdmVcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjgxMn1dfSxcIiNkZWxldGVBbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBNYXAgd2hpY2ggZXhjbHVkZXMgdGhlIHByb3ZpZGVkIGBrZXlzYC5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG5hbWVzID0gTWFwKHsgYTogXFxcIkFhcm9uXFxcIiwgYjogXFxcIkJhcnJ5XFxcIiwgYzogXFxcIkNvbm5vclxcXCIgfSlcXG5uYW1lcy5kZWxldGVBbGwoWyAnYScsICdjJyBdKVxcbi8vIE1hcCB7IFxcXCJiXFxcIjogXFxcIkJhcnJ5XFxcIiB9XFxuYGBgXFxuXFxuTm90ZTogYGRlbGV0ZUFsbGAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwiYWxpYXNcIixcImJvZHlcIjpcInJlbW92ZUFsbFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5c1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifV19fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo4MzB9XX0sXCIjY2xlYXJcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBNYXAgY29udGFpbmluZyBubyBrZXlzIG9yIHZhbHVlcy5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbk1hcCh7IGtleTogJ3ZhbHVlJyB9KS5jbGVhcigpXFxuLy8gTWFwIHt9XFxuYGBgXFxuXFxuTm90ZTogYGNsZWFyYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6ODQ1fV19LFwiI3VwZGF0ZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IE1hcCBoYXZpbmcgdXBkYXRlZCB0aGUgdmFsdWUgYXQgdGhpcyBga2V5YCB3aXRoIHRoZSByZXR1cm5cXG52YWx1ZSBvZiBjYWxsaW5nIGB1cGRhdGVyYCB3aXRoIHRoZSBleGlzdGluZyB2YWx1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJTaW1pbGFyIHRvOiBgbWFwLnNldChrZXksIHVwZGF0ZXIobWFwLmdldChrZXkpKSlgLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3QgYU1hcCA9IE1hcCh7IGtleTogJ3ZhbHVlJyB9KVxcbmNvbnN0IG5ld01hcCA9IGFNYXAudXBkYXRlKCdrZXknLCB2YWx1ZSA9PiB2YWx1ZSArIHZhbHVlKVxcbi8vIE1hcCB7IFxcXCJrZXlcXFwiOiBcXFwidmFsdWV2YWx1ZVxcXCIgfVxcbmBgYFxcblxcblRoaXMgaXMgbW9zdCBjb21tb25seSB1c2VkIHRvIGNhbGwgbWV0aG9kcyBvbiBjb2xsZWN0aW9ucyB3aXRoaW4gYVxcbnN0cnVjdHVyZSBvZiBkYXRhLiBGb3IgZXhhbXBsZSwgaW4gb3JkZXIgdG8gYC5wdXNoKClgIG9udG8gYSBuZXN0ZWQgYExpc3RgLFxcbmB1cGRhdGVgIGFuZCBgcHVzaGAgY2FuIGJlIHVzZWQgdG9nZXRoZXI6XFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTWFwLCBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmNvbnN0IGFNYXAgPSBNYXAoeyBuZXN0ZWRMaXN0OiBMaXN0KFsgMSwgMiwgMyBdKSB9KVxcbmNvbnN0IG5ld01hcCA9IGFNYXAudXBkYXRlKCduZXN0ZWRMaXN0JywgbGlzdCA9PiBsaXN0LnB1c2goNCkpXFxuLy8gTWFwIHsgXFxcIm5lc3RlZExpc3RcXFwiOiBMaXN0IFsgMSwgMiwgMywgNCBdIH1cXG5gYGBcXG5cXG5XaGVuIGEgYG5vdFNldFZhbHVlYCBpcyBwcm92aWRlZCwgaXQgaXMgcHJvdmlkZWQgdG8gdGhlIGB1cGRhdGVyYFxcbmZ1bmN0aW9uIHdoZW4gdGhlIHZhbHVlIGF0IHRoZSBrZXkgZG9lcyBub3QgZXhpc3QgaW4gdGhlIE1hcC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuY29uc3QgYU1hcCA9IE1hcCh7IGtleTogJ3ZhbHVlJyB9KVxcbmNvbnN0IG5ld01hcCA9IGFNYXAudXBkYXRlKCdub0tleScsICdubyB2YWx1ZScsIHZhbHVlID0+IHZhbHVlICsgdmFsdWUpXFxuLy8gTWFwIHsgXFxcImtleVxcXCI6IFxcXCJ2YWx1ZVxcXCIsIFxcXCJub0tleVxcXCI6IFxcXCJubyB2YWx1ZW5vIHZhbHVlXFxcIiB9XFxuYGBgXFxuXFxuSG93ZXZlciwgaWYgdGhlIGB1cGRhdGVyYCBmdW5jdGlvbiByZXR1cm5zIHRoZSBzYW1lIHZhbHVlIGl0IHdhcyBjYWxsZWRcXG53aXRoLCB0aGVuIG5vIGNoYW5nZSB3aWxsIG9jY3VyLiBUaGlzIGlzIHN0aWxsIHRydWUgaWYgYG5vdFNldFZhbHVlYFxcbmlzIHByb3ZpZGVkLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IE1hcCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5jb25zdCBhTWFwID0gTWFwKHsgYXBwbGVzOiAxMCB9KVxcbmNvbnN0IG5ld01hcCA9IGFNYXAudXBkYXRlKCdvcmFuZ2VzJywgMCwgdmFsID0+IHZhbClcXG4vLyBNYXAgeyBcXFwiYXBwbGVzXFxcIjogMTAgfVxcbmFzc2VydC5zdHJpY3RFcXVhbChuZXdNYXAsIG1hcCk7XFxuYGBgXFxuXFxuRm9yIGNvZGUgdXNpbmcgRVMyMDE1IG9yIGxhdGVyLCB1c2luZyBgbm90U2V0VmFsdWVgIGlzIGRpc2NvdXJnZWQgaW5cXG5mYXZvciBvZiBmdW5jdGlvbiBwYXJhbWV0ZXIgZGVmYXVsdCB2YWx1ZXMuIFRoaXMgaGVscHMgdG8gYXZvaWQgYW55XFxucG90ZW50aWFsIGNvbmZ1c2lvbiB3aXRoIGlkZW50aWZ5IGZ1bmN0aW9ucyBhcyBkZXNjcmliZWQgYWJvdmUuXFxuXFxuVGhlIHByZXZpb3VzIGV4YW1wbGUgYmVoYXZlcyBkaWZmZXJlbnRseSB3aGVuIHdyaXR0ZW4gd2l0aCBkZWZhdWx0IHZhbHVlczpcXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuY29uc3QgYU1hcCA9IE1hcCh7IGFwcGxlczogMTAgfSlcXG5jb25zdCBuZXdNYXAgPSBhTWFwLnVwZGF0ZSgnb3JhbmdlcycsICh2YWwgPSAwKSA9PiB2YWwpXFxuLy8gTWFwIHsgXFxcImFwcGxlc1xcXCI6IDEwLCBcXFwib3Jhbmdlc1xcXCI6IDAgfVxcbmBgYFxcblxcbklmIG5vIGtleSBpcyBwcm92aWRlZCwgdGhlbiB0aGUgYHVwZGF0ZXJgIGZ1bmN0aW9uIHJldHVybiB2YWx1ZSBpc1xcbnJldHVybmVkIGFzIHdlbGwuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmNvbnN0IGFNYXAgPSBNYXAoeyBrZXk6ICd2YWx1ZScgfSlcXG5jb25zdCByZXN1bHQgPSBhTWFwLnVwZGF0ZShhTWFwID0+IGFNYXAuZ2V0KCdrZXknKSlcXG4vLyBcXFwidmFsdWVcXFwiXFxuYGBgXFxuXFxuVGhpcyBjYW4gYmUgdmVyeSB1c2VmdWwgYXMgYSB3YXkgdG8gXFxcImNoYWluXFxcIiBhIG5vcm1hbCBmdW5jdGlvbiBpbnRvIGFcXG5zZXF1ZW5jZSBvZiBtZXRob2RzLiBSeEpTIGNhbGxzIHRoaXMgXFxcImxldFxcXCIgYW5kIGxvZGFzaCBjYWxscyBpdCBcXFwidGhydVxcXCIuXFxuXFxuRm9yIGV4YW1wbGUsIHRvIHN1bSB0aGUgdmFsdWVzIGluIGEgTWFwXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmZ1bmN0aW9uIHN1bShjb2xsZWN0aW9uKSB7XFxuICByZXR1cm4gY29sbGVjdGlvbi5yZWR1Y2UoKHN1bSwgeCkgPT4gc3VtICsgeCwgMClcXG59XFxuXFxuTWFwKHsgeDogMSwgeTogMiwgejogMyB9KVxcbiAgLm1hcCh4ID0+IHggKyAxKVxcbiAgLmZpbHRlcih4ID0+IHggJSAyID09PSAwKVxcbiAgLnVwZGF0ZShzdW0pXFxuLy8gNlxcbmBgYFxcblxcbk5vdGU6IGB1cGRhdGUoa2V5KWAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6OTQ5fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo5NTB9LHtcInR5cGVQYXJhbXNcIjpbXCJSXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJSXCJ9fX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlJcIn0sXCJsaW5lXCI6OTUxfV19LFwiI21lcmdlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTWFwIHJlc3VsdGluZyBmcm9tIG1lcmdpbmcgdGhlIHByb3ZpZGVkIENvbGxlY3Rpb25zXFxuKG9yIEpTIG9iamVjdHMpIGludG8gdGhpcyBNYXAuIEluIG90aGVyIHdvcmRzLCB0aGlzIHRha2VzIGVhY2ggZW50cnkgb2ZcXG5lYWNoIGNvbGxlY3Rpb24gYW5kIHNldHMgaXQgb24gdGhpcyBNYXAuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogVmFsdWVzIHByb3ZpZGVkIHRvIGBtZXJnZWAgYXJlIHNoYWxsb3dseSBjb252ZXJ0ZWQgYmVmb3JlIGJlaW5nXFxubWVyZ2VkLiBObyBuZXN0ZWQgdmFsdWVzIGFyZSBhbHRlcmVkLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgb25lID0gTWFwKHsgYTogMTAsIGI6IDIwLCBjOiAzMCB9KVxcbmNvbnN0IHR3byA9IE1hcCh7IGI6IDQwLCBhOiA1MCwgZDogNjAgfSlcXG5vbmUubWVyZ2UodHdvKSAvLyBNYXAgeyBcXFwiYVxcXCI6IDUwLCBcXFwiYlxcXCI6IDQwLCBcXFwiY1xcXCI6IDMwLCBcXFwiZFxcXCI6IDYwIH1cXG50d28ubWVyZ2Uob25lKSAvLyBNYXAgeyBcXFwiYlxcXCI6IDIwLCBcXFwiYVxcXCI6IDEwLCBcXFwiZFxcXCI6IDYwLCBcXFwiY1xcXCI6IDMwIH1cXG5gYGBcXG5cXG5Ob3RlOiBgbWVyZ2VgIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cXG5cIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcImFsaWFzXCIsXCJib2R5XCI6XCJjb25jYXRcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktDXCIsXCJWQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLQ1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWQ1wifV19XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJNYXBcIixcImFyZ3NcIjpbe1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJLQ1wifV19LHtcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVkNcIn1dfV19LFwibGluZVwiOjk3NH0se1widHlwZVBhcmFtc1wiOltcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjozfV19LHtcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifV19XX0sXCJsaW5lXCI6OTc1fV19LFwiI21lcmdlV2l0aFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJMaWtlIGBtZXJnZSgpYCwgYG1lcmdlV2l0aCgpYCByZXR1cm5zIGEgbmV3IE1hcCByZXN1bHRpbmcgZnJvbSBtZXJnaW5nXFxudGhlIHByb3ZpZGVkIENvbGxlY3Rpb25zIChvciBKUyBvYmplY3RzKSBpbnRvIHRoaXMgTWFwLCBidXQgdXNlcyB0aGVcXG5gbWVyZ2VyYCBmdW5jdGlvbiBmb3IgZGVhbGluZyB3aXRoIGNvbmZsaWN0cy5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG9uZSA9IE1hcCh7IGE6IDEwLCBiOiAyMCwgYzogMzAgfSlcXG5jb25zdCB0d28gPSBNYXAoeyBiOiA0MCwgYTogNTAsIGQ6IDYwIH0pXFxub25lLm1lcmdlV2l0aCgob2xkVmFsLCBuZXdWYWwpID0+IG9sZFZhbCAvIG5ld1ZhbCwgdHdvKVxcbi8vIHsgXFxcImFcXFwiOiAwLjIsIFxcXCJiXFxcIjogMC41LCBcXFwiY1xcXCI6IDMwLCBcXFwiZFxcXCI6IDYwIH1cXG50d28ubWVyZ2VXaXRoKChvbGRWYWwsIG5ld1ZhbCkgPT4gb2xkVmFsIC8gbmV3VmFsLCBvbmUpXFxuLy8geyBcXFwiYlxcXCI6IDIsIFxcXCJhXFxcIjogNSwgXFxcImRcXFwiOiA2MCwgXFxcImNcXFwiOiAzMCB9XFxuYGBgXFxuXFxuTm90ZTogYG1lcmdlV2l0aGAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtZXJnZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvbGRWYWxcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJuZXdWYWxcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX19LHtcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XX0se1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV19XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo5OTd9XX0sXCIjbWVyZ2VEZWVwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkxpa2UgYG1lcmdlKClgLCBidXQgd2hlbiB0d28gQ29sbGVjdGlvbnMgY29uZmxpY3QsIGl0IG1lcmdlcyB0aGVtIGFzIHdlbGwsXFxucmVjdXJzaW5nIGRlZXBseSB0aHJvdWdoIHRoZSBuZXN0ZWQgZGF0YS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBWYWx1ZXMgcHJvdmlkZWQgdG8gYG1lcmdlYCBhcmUgc2hhbGxvd2x5IGNvbnZlcnRlZCBiZWZvcmUgYmVpbmdcXG5tZXJnZWQuIE5vIG5lc3RlZCB2YWx1ZXMgYXJlIGFsdGVyZWQgdW5sZXNzIHRoZXkgd2lsbCBhbHNvIGJlIG1lcmdlZCBhdFxcbmEgZGVlcGVyIGxldmVsLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgb25lID0gTWFwKHsgYTogTWFwKHsgeDogMTAsIHk6IDEwIH0pLCBiOiBNYXAoeyB4OiAyMCwgeTogNTAgfSkgfSlcXG5jb25zdCB0d28gPSBNYXAoeyBhOiBNYXAoeyB4OiAyIH0pLCBiOiBNYXAoeyB5OiA1IH0pLCBjOiBNYXAoeyB6OiAzIH0pIH0pXFxub25lLm1lcmdlRGVlcCh0d28pXFxuLy8gTWFwIHtcXG4vLyAgIFxcXCJhXFxcIjogTWFwIHsgXFxcInhcXFwiOiAyLCBcXFwieVxcXCI6IDEwIH0sXFxuLy8gICBcXFwiYlxcXCI6IE1hcCB7IFxcXCJ4XFxcIjogMjAsIFxcXCJ5XFxcIjogNSB9LFxcbi8vICAgXFxcImNcXFwiOiBNYXAgeyBcXFwielxcXCI6IDMgfVxcbi8vIH1cXG5gYGBcXG5cXG5Ob3RlOiBgbWVyZ2VEZWVwYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XX0se1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV19XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxMDI1fV19LFwiI21lcmdlRGVlcFdpdGhcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiTGlrZSBgbWVyZ2VEZWVwKClgLCBidXQgd2hlbiB0d28gbm9uLUNvbGxlY3Rpb25zIGNvbmZsaWN0LCBpdCB1c2VzIHRoZVxcbmBtZXJnZXJgIGZ1bmN0aW9uIHRvIGRldGVybWluZSB0aGUgcmVzdWx0aW5nIHZhbHVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgb25lID0gTWFwKHsgYTogTWFwKHsgeDogMTAsIHk6IDEwIH0pLCBiOiBNYXAoeyB4OiAyMCwgeTogNTAgfSkgfSlcXG5jb25zdCB0d28gPSBNYXAoeyBhOiBNYXAoeyB4OiAyIH0pLCBiOiBNYXAoeyB5OiA1IH0pLCBjOiBNYXAoeyB6OiAzIH0pIH0pXFxub25lLm1lcmdlRGVlcFdpdGgoKG9sZFZhbCwgbmV3VmFsKSA9PiBvbGRWYWwgLyBuZXdWYWwsIHR3bylcXG4vLyBNYXAge1xcbi8vICAgXFxcImFcXFwiOiBNYXAgeyBcXFwieFxcXCI6IDUsIFxcXCJ5XFxcIjogMTAgfSxcXG4vLyAgIFxcXCJiXFxcIjogTWFwIHsgXFxcInhcXFwiOiAyMCwgXFxcInlcXFwiOiAxMCB9LFxcbi8vICAgXFxcImNcXFwiOiBNYXAgeyBcXFwielxcXCI6IDMgfVxcbi8vIH1cXG5gYGBcXG5cXG5Ob3RlOiBgbWVyZ2VEZWVwV2l0aGAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtZXJnZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvbGRWYWxcIixcInR5cGVcIjp7XCJrXCI6MTd9fSx7XCJuYW1lXCI6XCJuZXdWYWxcIixcInR5cGVcIjp7XCJrXCI6MTd9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19LHtcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XX0se1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV19XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxMDQ2fV19fX0se1widGl0bGVcIjpcIkRlZXAgcGVyc2lzdGVudCBjaGFuZ2VzXCIsXCJtZW1iZXJzXCI6e1wiI3NldEluXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTWFwIGhhdmluZyBzZXQgYHZhbHVlYCBhdCB0aGlzIGBrZXlQYXRoYC4gSWYgYW55IGtleXMgaW5cXG5ga2V5UGF0aGAgZG8gbm90IGV4aXN0LCBhIG5ldyBpbW11dGFibGUgTWFwIHdpbGwgYmUgY3JlYXRlZCBhdCB0aGF0IGtleS5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG9yaWdpbmFsTWFwID0gTWFwKHtcXG4gIHN1Yk9iamVjdDogTWFwKHtcXG4gICAgc3ViS2V5OiAnc3VidmFsdWUnLFxcbiAgICBzdWJTdWJPYmplY3Q6IE1hcCh7XFxuICAgICAgc3ViU3ViS2V5OiAnc3ViU3ViVmFsdWUnXFxuICAgIH0pXFxuICB9KVxcbn0pXFxuXFxuY29uc3QgbmV3TWFwID0gb3JpZ2luYWxNYXAuc2V0SW4oWydzdWJPYmplY3QnLCAnc3ViS2V5J10sICdoYSBoYSEnKVxcbi8vIE1hcCB7XFxuLy8gICBcXFwic3ViT2JqZWN0XFxcIjogTWFwIHtcXG4vLyAgICAgXFxcInN1YktleVxcXCI6IFxcXCJoYSBoYSFcXFwiLFxcbi8vICAgICBcXFwic3ViU3ViT2JqZWN0XFxcIjogTWFwIHsgXFxcInN1YlN1YktleVxcXCI6IFxcXCJzdWJTdWJWYWx1ZVxcXCIgfVxcbi8vICAgfVxcbi8vIH1cXG5cXG5jb25zdCBuZXdlck1hcCA9IG9yaWdpbmFsTWFwLnNldEluKFxcbiAgWydzdWJPYmplY3QnLCAnc3ViU3ViT2JqZWN0JywgJ3N1YlN1YktleSddLFxcbiAgJ2hhIGhhIGhhISdcXG4pXFxuLy8gTWFwIHtcXG4vLyAgIFxcXCJzdWJPYmplY3RcXFwiOiBNYXAge1xcbi8vICAgICBcXFwic3ViS2V5XFxcIjogXFxcInN1YnZhbHVlXFxcIixcXG4vLyAgICAgXFxcInN1YlN1Yk9iamVjdFxcXCI6IE1hcCB7IFxcXCJzdWJTdWJLZXlcXFwiOiBcXFwiaGEgaGEgaGEhXFxcIiB9XFxuLy8gICB9XFxuLy8gfVxcbmBgYFxcblxcblBsYWluIEphdmFTY3JpcHQgT2JqZWN0IG9yIEFycmF5cyBtYXkgYmUgbmVzdGVkIHdpdGhpbiBhbiBJbW11dGFibGUuanNcXG5Db2xsZWN0aW9uLCBhbmQgc2V0SW4oKSBjYW4gdXBkYXRlIHRob3NlIHZhbHVlcyBhcyB3ZWxsLCB0cmVhdGluZyB0aGVtXFxuaW1tdXRhYmx5IGJ5IGNyZWF0aW5nIG5ldyBjb3BpZXMgb2YgdGhvc2UgdmFsdWVzIHdpdGggdGhlIGNoYW5nZXMgYXBwbGllZC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG9yaWdpbmFsTWFwID0gTWFwKHtcXG4gIHN1Yk9iamVjdDoge1xcbiAgICBzdWJLZXk6ICdzdWJ2YWx1ZScsXFxuICAgIHN1YlN1Yk9iamVjdDoge1xcbiAgICAgIHN1YlN1YktleTogJ3N1YlN1YlZhbHVlJ1xcbiAgICB9XFxuICB9XFxufSlcXG5cXG5vcmlnaW5hbE1hcC5zZXRJbihbJ3N1Yk9iamVjdCcsICdzdWJLZXknXSwgJ2hhIGhhIScpXFxuLy8gTWFwIHtcXG4vLyAgIFxcXCJzdWJPYmplY3RcXFwiOiB7XFxuLy8gICAgIHN1YktleTogXFxcImhhIGhhIVxcXCIsXFxuLy8gICAgIHN1YlN1Yk9iamVjdDogeyBzdWJTdWJLZXk6IFxcXCJzdWJTdWJWYWx1ZVxcXCIgfVxcbi8vICAgfVxcbi8vIH1cXG5gYGBcXG5cXG5JZiBhbnkga2V5IGluIHRoZSBwYXRoIGV4aXN0cyBidXQgY2Fubm90IGJlIHVwZGF0ZWQgKHN1Y2ggYXMgYSBwcmltaXRpdmVcXG5saWtlIG51bWJlciBvciBhIGN1c3RvbSBPYmplY3QgbGlrZSBEYXRlKSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXFxuXFxuTm90ZTogYHNldEluYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX0se1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxMTIwfV19LFwiI2RlbGV0ZUluXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTWFwIGhhdmluZyByZW1vdmVkIHRoZSB2YWx1ZSBhdCB0aGlzIGBrZXlQYXRoYC4gSWYgYW55IGtleXNcXG5pbiBga2V5UGF0aGAgZG8gbm90IGV4aXN0LCBubyBjaGFuZ2Ugd2lsbCBvY2N1ci5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgZGVsZXRlSW5gIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cXG5cIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcImFsaWFzXCIsXCJib2R5XCI6XCJyZW1vdmVJblwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5UGF0aFwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxMTMwfV19LFwiI3VwZGF0ZUluXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTWFwIGhhdmluZyBhcHBsaWVkIHRoZSBgdXBkYXRlcmAgdG8gdGhlIGVudHJ5IGZvdW5kIGF0IHRoZVxcbmtleVBhdGguXCIsXCJkZXNjcmlwdGlvblwiOlwiVGhpcyBpcyBtb3N0IGNvbW1vbmx5IHVzZWQgdG8gY2FsbCBtZXRob2RzIG9uIGNvbGxlY3Rpb25zIG5lc3RlZCB3aXRoaW4gYVxcbnN0cnVjdHVyZSBvZiBkYXRhLiBGb3IgZXhhbXBsZSwgaW4gb3JkZXIgdG8gYC5wdXNoKClgIG9udG8gYSBuZXN0ZWQgYExpc3RgLFxcbmB1cGRhdGVJbmAgYW5kIGBwdXNoYCBjYW4gYmUgdXNlZCB0b2dldGhlcjpcXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwLCBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG1hcCA9IE1hcCh7IGluTWFwOiBNYXAoeyBpbkxpc3Q6IExpc3QoWyAxLCAyLCAzIF0pIH0pIH0pXFxuY29uc3QgbmV3TWFwID0gbWFwLnVwZGF0ZUluKFsnaW5NYXAnLCAnaW5MaXN0J10sIGxpc3QgPT4gbGlzdC5wdXNoKDQpKVxcbi8vIE1hcCB7IFxcXCJpbk1hcFxcXCI6IE1hcCB7IFxcXCJpbkxpc3RcXFwiOiBMaXN0IFsgMSwgMiwgMywgNCBdIH0gfVxcbmBgYFxcblxcbklmIGFueSBrZXlzIGluIGBrZXlQYXRoYCBkbyBub3QgZXhpc3QsIG5ldyBJbW11dGFibGUgYE1hcGBzIHdpbGxcXG5iZSBjcmVhdGVkIGF0IHRob3NlIGtleXMuIElmIHRoZSBga2V5UGF0aGAgZG9lcyBub3QgYWxyZWFkeSBjb250YWluIGFcXG52YWx1ZSwgdGhlIGB1cGRhdGVyYCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aXRoIGBub3RTZXRWYWx1ZWAsIGlmXFxucHJvdmlkZWQsIG90aGVyd2lzZSBgdW5kZWZpbmVkYC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxcIiB9XFxuLS0+XFxuYGBganNcXG5jb25zdCBtYXAgPSBNYXAoeyBhOiBNYXAoeyBiOiBNYXAoeyBjOiAxMCB9KSB9KSB9KVxcbmNvbnN0IG5ld01hcCA9IG1hcC51cGRhdGVJbihbJ2EnLCAnYicsICdjJ10sIHZhbCA9PiB2YWwgKiAyKVxcbi8vIE1hcCB7IFxcXCJhXFxcIjogTWFwIHsgXFxcImJcXFwiOiBNYXAgeyBcXFwiY1xcXCI6IDIwIH0gfSB9XFxuYGBgXFxuXFxuSWYgdGhlIGB1cGRhdGVyYCBmdW5jdGlvbiByZXR1cm5zIHRoZSBzYW1lIHZhbHVlIGl0IHdhcyBjYWxsZWQgd2l0aCwgdGhlblxcbm5vIGNoYW5nZSB3aWxsIG9jY3VyLiBUaGlzIGlzIHN0aWxsIHRydWUgaWYgYG5vdFNldFZhbHVlYCBpcyBwcm92aWRlZC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxcIiB9XFxuLS0+XFxuYGBganNcXG5jb25zdCBtYXAgPSBNYXAoeyBhOiBNYXAoeyBiOiBNYXAoeyBjOiAxMCB9KSB9KSB9KVxcbmNvbnN0IG5ld01hcCA9IG1hcC51cGRhdGVJbihbJ2EnLCAnYicsICd4J10sIDEwMCwgdmFsID0+IHZhbClcXG4vLyBNYXAgeyBcXFwiYVxcXCI6IE1hcCB7IFxcXCJiXFxcIjogTWFwIHsgXFxcImNcXFwiOiAxMCB9IH0gfVxcbmFzc2VydC5zdHJpY3RFcXVhbChuZXdNYXAsIGFNYXApXFxuYGBgXFxuXFxuRm9yIGNvZGUgdXNpbmcgRVMyMDE1IG9yIGxhdGVyLCB1c2luZyBgbm90U2V0VmFsdWVgIGlzIGRpc2NvdXJnZWQgaW5cXG5mYXZvciBvZiBmdW5jdGlvbiBwYXJhbWV0ZXIgZGVmYXVsdCB2YWx1ZXMuIFRoaXMgaGVscHMgdG8gYXZvaWQgYW55XFxucG90ZW50aWFsIGNvbmZ1c2lvbiB3aXRoIGlkZW50aWZ5IGZ1bmN0aW9ucyBhcyBkZXNjcmliZWQgYWJvdmUuXFxuXFxuVGhlIHByZXZpb3VzIGV4YW1wbGUgYmVoYXZlcyBkaWZmZXJlbnRseSB3aGVuIHdyaXR0ZW4gd2l0aCBkZWZhdWx0IHZhbHVlczpcXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxcIiB9XFxuLS0+XFxuYGBganNcXG5jb25zdCBtYXAgPSBNYXAoeyBhOiBNYXAoeyBiOiBNYXAoeyBjOiAxMCB9KSB9KSB9KVxcbmNvbnN0IG5ld01hcCA9IG1hcC51cGRhdGVJbihbJ2EnLCAnYicsICd4J10sICh2YWwgPSAxMDApID0+IHZhbClcXG4vLyBNYXAgeyBcXFwiYVxcXCI6IE1hcCB7IFxcXCJiXFxcIjogTWFwIHsgXFxcImNcXFwiOiAxMCwgXFxcInhcXFwiOiAxMDAgfSB9IH1cXG5gYGBcXG5cXG5QbGFpbiBKYXZhU2NyaXB0IE9iamVjdCBvciBBcnJheXMgbWF5IGJlIG5lc3RlZCB3aXRoaW4gYW4gSW1tdXRhYmxlLmpzXFxuQ29sbGVjdGlvbiwgYW5kIHVwZGF0ZUluKCkgY2FuIHVwZGF0ZSB0aG9zZSB2YWx1ZXMgYXMgd2VsbCwgdHJlYXRpbmcgdGhlbVxcbmltbXV0YWJseSBieSBjcmVhdGluZyBuZXcgY29waWVzIG9mIHRob3NlIHZhbHVlcyB3aXRoIHRoZSBjaGFuZ2VzIGFwcGxpZWQuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcXCIgfVxcbi0tPlxcbmBgYGpzXFxuY29uc3QgbWFwID0gTWFwKHsgYTogeyBiOiB7IGM6IDEwIH0gfSB9KVxcbmNvbnN0IG5ld01hcCA9IG1hcC51cGRhdGVJbihbJ2EnLCAnYicsICdjJ10sIHZhbCA9PiB2YWwgKiAyKVxcbi8vIE1hcCB7IFxcXCJhXFxcIjogeyBiOiB7IGM6IDIwIH0gfSB9XFxuYGBgXFxuXFxuSWYgYW55IGtleSBpbiB0aGUgcGF0aCBleGlzdHMgYnV0IGNhbm5vdCBiZSB1cGRhdGVkIChzdWNoIGFzIGEgcHJpbWl0aXZlXFxubGlrZSBudW1iZXIgb3IgYSBjdXN0b20gT2JqZWN0IGxpa2UgRGF0ZSksIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxcblxcbk5vdGU6IGB1cGRhdGVJbmAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlQYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX19LHtcIm5hbWVcIjpcIm5vdFNldFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX0se1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxN319fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxMjA5fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5UGF0aFwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19fSx7XCJuYW1lXCI6XCJ1cGRhdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjEyMTB9XX0sXCIjbWVyZ2VJblwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJBIGNvbWJpbmF0aW9uIG9mIGB1cGRhdGVJbmAgYW5kIGBtZXJnZWAsIHJldHVybmluZyBhIG5ldyBNYXAsIGJ1dFxcbnBlcmZvcm1pbmcgdGhlIG1lcmdlIGF0IGEgcG9pbnQgYXJyaXZlZCBhdCBieSBmb2xsb3dpbmcgdGhlIGtleVBhdGguXFxuSW4gb3RoZXIgd29yZHMsIHRoZXNlIHR3byBsaW5lcyBhcmUgZXF1aXZhbGVudDpcIixcImRlc2NyaXB0aW9uXCI6XCJgYGBqc1xcbm1hcC51cGRhdGVJbihbJ2EnLCAnYicsICdjJ10sIGFiYyA9PiBhYmMubWVyZ2UoeSkpXFxubWFwLm1lcmdlSW4oWydhJywgJ2InLCAnYyddLCB5KVxcbmBgYFxcblxcbk5vdGU6IGBtZXJnZUluYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX0se1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxMjI0fV19LFwiI21lcmdlRGVlcEluXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkEgY29tYmluYXRpb24gb2YgYHVwZGF0ZUluYCBhbmQgYG1lcmdlRGVlcGAsIHJldHVybmluZyBhIG5ldyBNYXAsIGJ1dFxcbnBlcmZvcm1pbmcgdGhlIGRlZXAgbWVyZ2UgYXQgYSBwb2ludCBhcnJpdmVkIGF0IGJ5IGZvbGxvd2luZyB0aGUga2V5UGF0aC5cXG5JbiBvdGhlciB3b3JkcywgdGhlc2UgdHdvIGxpbmVzIGFyZSBlcXVpdmFsZW50OlwiLFwiZGVzY3JpcHRpb25cIjpcImBgYGpzXFxubWFwLnVwZGF0ZUluKFsnYScsICdiJywgJ2MnXSwgYWJjID0+IGFiYy5tZXJnZURlZXAoeSkpXFxubWFwLm1lcmdlRGVlcEluKFsnYScsICdiJywgJ2MnXSwgeSlcXG5gYGBcXG5cXG5Ob3RlOiBgbWVyZ2VEZWVwSW5gIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5UGF0aFwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19fSx7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjEyMzh9XX19fSx7XCJ0aXRsZVwiOlwiVHJhbnNpZW50IGNoYW5nZXNcIixcIm1lbWJlcnNcIjp7XCIjd2l0aE11dGF0aW9uc1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJFdmVyeSB0aW1lIHlvdSBjYWxsIG9uZSBvZiB0aGUgYWJvdmUgZnVuY3Rpb25zLCBhIG5ldyBpbW11dGFibGUgTWFwIGlzXFxuY3JlYXRlZC4gSWYgYSBwdXJlIGZ1bmN0aW9uIGNhbGxzIGEgbnVtYmVyIG9mIHRoZXNlIHRvIHByb2R1Y2UgYSBmaW5hbFxcbnJldHVybiB2YWx1ZSwgdGhlbiBhIHBlbmFsdHkgb24gcGVyZm9ybWFuY2UgYW5kIG1lbW9yeSBoYXMgYmVlbiBwYWlkIGJ5XFxuY3JlYXRpbmcgYWxsIG9mIHRoZSBpbnRlcm1lZGlhdGUgaW1tdXRhYmxlIE1hcHMuXCIsXCJkZXNjcmlwdGlvblwiOlwiSWYgeW91IG5lZWQgdG8gYXBwbHkgYSBzZXJpZXMgb2YgbXV0YXRpb25zIHRvIHByb2R1Y2UgYSBuZXcgaW1tdXRhYmxlXFxuTWFwLCBgd2l0aE11dGF0aW9ucygpYCBjcmVhdGVzIGEgdGVtcG9yYXJ5IG11dGFibGUgY29weSBvZiB0aGUgTWFwIHdoaWNoXFxuY2FuIGFwcGx5IG11dGF0aW9ucyBpbiBhIGhpZ2hseSBwZXJmb3JtYW50IG1hbm5lci4gSW4gZmFjdCwgdGhpcyBpc1xcbmV4YWN0bHkgaG93IGNvbXBsZXggbXV0YXRpb25zIGxpa2UgYG1lcmdlYCBhcmUgZG9uZS5cXG5cXG5BcyBhbiBleGFtcGxlLCB0aGlzIHJlc3VsdHMgaW4gdGhlIGNyZWF0aW9uIG9mIDIsIG5vdCA0LCBuZXcgTWFwczpcXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG1hcDEgPSBNYXAoKVxcbmNvbnN0IG1hcDIgPSBtYXAxLndpdGhNdXRhdGlvbnMobWFwID0+IHtcXG4gIG1hcC5zZXQoJ2EnLCAxKS5zZXQoJ2InLCAyKS5zZXQoJ2MnLCAzKVxcbn0pXFxuYXNzZXJ0LmVxdWFsKG1hcDEuc2l6ZSwgMClcXG5hc3NlcnQuZXF1YWwobWFwMi5zaXplLCAzKVxcbmBgYFxcblxcbk5vdGU6IE5vdCBhbGwgbWV0aG9kcyBjYW4gYmUgdXNlZCBvbiBhIG11dGFibGUgY29sbGVjdGlvbiBvciB3aXRoaW5cXG5gd2l0aE11dGF0aW9uc2AhIFJlYWQgdGhlIGRvY3VtZW50YXRpb24gZm9yIGVhY2ggbWV0aG9kIHRvIHNlZSBpZiBpdFxcbmlzIHNhZmUgdG8gdXNlIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibXV0YXRvclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm11dGFibGVcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjEyNzB9XX0sXCIjYXNNdXRhYmxlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkFub3RoZXIgd2F5IHRvIGF2b2lkIGNyZWF0aW9uIG9mIGludGVybWVkaWF0ZSBJbW11dGFibGUgbWFwcyBpcyB0byBjcmVhdGVcXG5hIG11dGFibGUgY29weSBvZiB0aGlzIGNvbGxlY3Rpb24uIE11dGFibGUgY29waWVzICphbHdheXMqIHJldHVybiBgdGhpc2AsXFxuYW5kIHRodXMgc2hvdWxkbid0IGJlIHVzZWQgZm9yIGVxdWFsaXR5LiBZb3VyIGZ1bmN0aW9uIHNob3VsZCBuZXZlciByZXR1cm5cXG5hIG11dGFibGUgY29weSBvZiBhIGNvbGxlY3Rpb24sIG9ubHkgdXNlIGl0IGludGVybmFsbHkgdG8gY3JlYXRlIGEgbmV3XFxuY29sbGVjdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJJZiBwb3NzaWJsZSwgdXNlIGB3aXRoTXV0YXRpb25zYCB0byB3b3JrIHdpdGggdGVtcG9yYXJ5IG11dGFibGUgY29waWVzIGFzXFxuaXQgcHJvdmlkZXMgYW4gZWFzaWVyIHRvIHVzZSBBUEkgYW5kIGNvbnNpZGVycyBtYW55IGNvbW1vbiBvcHRpbWl6YXRpb25zLlxcblxcbk5vdGU6IGlmIHRoZSBjb2xsZWN0aW9uIGlzIGFscmVhZHkgbXV0YWJsZSwgYGFzTXV0YWJsZWAgcmV0dXJucyBpdHNlbGYuXFxuXFxuTm90ZTogTm90IGFsbCBtZXRob2RzIGNhbiBiZSB1c2VkIG9uIGEgbXV0YWJsZSBjb2xsZWN0aW9uIG9yIHdpdGhpblxcbmB3aXRoTXV0YXRpb25zYCEgUmVhZCB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgZWFjaCBtZXRob2QgdG8gc2VlIGlmIGl0XFxuaXMgc2FmZSB0byB1c2UgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI2FzSW1tdXRhYmxlYFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxMjkwfV19LFwiI3dhc0FsdGVyZWRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyB0cnVlIGlmIHRoaXMgaXMgYSBtdXRhYmxlIGNvcHkgKHNlZSBgYXNNdXRhYmxlKClgKSBhbmQgbXV0YXRpdmVcXG5hbHRlcmF0aW9ucyBoYXZlIGJlZW4gYXBwbGllZC5cXG5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiYE1hcCNhc011dGFibGVgXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6MTI5OH1dfSxcIiNhc0ltbXV0YWJsZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUaGUgeWluIHRvIGBhc011dGFibGVgJ3MgeWFuZy4gQmVjYXVzZSBpdCBhcHBsaWVzIHRvIG11dGFibGUgY29sbGVjdGlvbnMsXFxudGhpcyBvcGVyYXRpb24gaXMgKm11dGFibGUqIGFuZCBtYXkgcmV0dXJuIGl0c2VsZiAodGhvdWdoIG1heSBub3RcXG5yZXR1cm4gaXRzZWxmLCBpLmUuIGlmIHRoZSByZXN1bHQgaXMgYW4gZW1wdHkgY29sbGVjdGlvbikuIE9uY2VcXG5wZXJmb3JtZWQsIHRoZSBvcmlnaW5hbCBtdXRhYmxlIGNvcHkgbXVzdCBubyBsb25nZXIgYmUgbXV0YXRlZCBzaW5jZSBpdFxcbm1heSBiZSB0aGUgaW1tdXRhYmxlIHJlc3VsdC5cIixcImRlc2NyaXB0aW9uXCI6XCJJZiBwb3NzaWJsZSwgdXNlIGB3aXRoTXV0YXRpb25zYCB0byB3b3JrIHdpdGggdGVtcG9yYXJ5IG11dGFibGUgY29waWVzIGFzXFxuaXQgcHJvdmlkZXMgYW4gZWFzaWVyIHRvIHVzZSBBUEkgYW5kIGNvbnNpZGVycyBtYW55IGNvbW1vbiBvcHRpbWl6YXRpb25zLlxcblwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI2FzTXV0YWJsZWBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MTMxMn1dfX19LHtcInRpdGxlXCI6XCJTZXF1ZW5jZSBhbGdvcml0aG1zXCIsXCJtZW1iZXJzXCI6e1wiI21hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IE1hcCB3aXRoIHZhbHVlcyBwYXNzZWQgdGhyb3VnaCBhXFxuYG1hcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiICAgIE1hcCh7IGE6IDEsIGI6IDIgfSkubWFwKHggPT4gMTAgKiB4KVxcbiAgICAvLyBNYXAgeyBhOiAxMCwgYjogMjAgfVwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjoxMzIzfV19LFwiI21hcEtleXNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcIkNvbGxlY3Rpb24uS2V5ZWQubWFwS2V5c1wifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJNYXBcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6MTMzMX1dfSxcIiNtYXBFbnRyaWVzXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJDb2xsZWN0aW9uLktleWVkLm1hcEVudHJpZXNcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktNXCIsXCJWTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJlbnRyeVwiLFwidHlwZVwiOntcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19fSx7XCJuYW1lXCI6XCJpbmRleFwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLTVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWTVwifV19fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLTVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWTVwifV19LFwibGluZVwiOjEzMzl9XX0sXCIjZmxhdE1hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJGbGF0LW1hcHMgdGhlIE1hcCwgcmV0dXJuaW5nIGEgbmV3IE1hcC5cIixcImRlc2NyaXB0aW9uXCI6XCJTaW1pbGFyIHRvIGBkYXRhLm1hcCguLi4pLmZsYXR0ZW4odHJ1ZSlgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJLTVwiLFwiVk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS01cIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVk1cIn1dfV19fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLTVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWTVwifV19LFwibGluZVwiOjEzNDl9XX0sXCIjZmlsdGVyXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTWFwIHdpdGggb25seSB0aGUgZW50cmllcyBmb3Igd2hpY2ggdGhlIGBwcmVkaWNhdGVgXFxuZnVuY3Rpb24gcmV0dXJucyB0cnVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBmaWx0ZXIoKWAgYWx3YXlzIHJldHVybnMgYSBuZXcgaW5zdGFuY2UsIGV2ZW4gaWYgaXQgcmVzdWx0cyBpblxcbm5vdCBmaWx0ZXJpbmcgb3V0IGFueSB2YWx1ZXMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJNYXBcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJGXCJ9XX0sXCJsaW5lXCI6MTM2MX0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MTd9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjEzNjV9XX0sXCIjZmxpcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiQ29sbGVjdGlvbi5LZXllZC5mbGlwXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIktcIn1dfSxcImxpbmVcIjoxMzczfV19fX1dfX0sXCJPcmRlcmVkTWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkEgdHlwZSBvZiBNYXAgdGhhdCBoYXMgdGhlIGFkZGl0aW9uYWwgZ3VhcmFudGVlIHRoYXQgdGhlIGl0ZXJhdGlvbiBvcmRlciBvZlxcbmVudHJpZXMgd2lsbCBiZSB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSB3ZXJlIHNldCgpLlwiLFwiZGVzY3JpcHRpb25cIjpcIlRoZSBpdGVyYXRpb24gYmVoYXZpb3Igb2YgT3JkZXJlZE1hcCBpcyB0aGUgc2FtZSBhcyBuYXRpdmUgRVM2IE1hcCBhbmRcXG5KYXZhU2NyaXB0IE9iamVjdC5cXG5cXG5Ob3RlIHRoYXQgYE9yZGVyZWRNYXBgIGFyZSBtb3JlIGV4cGVuc2l2ZSB0aGFuIG5vbi1vcmRlcmVkIGBNYXBgIGFuZCBtYXlcXG5jb25zdW1lIG1vcmUgbWVtb3J5LiBgT3JkZXJlZE1hcCNzZXRgIGlzIGFtb3J0aXplZCBPKGxvZzMyIE4pLCBidXQgbm90XFxuc3RhYmxlLlwiLFwibm90ZXNcIjpbXX0sXCJtb2R1bGVcIjp7XCJpc09yZGVyZWRNYXBcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGFuIE9yZGVyZWRNYXAuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlT3JkZXJlZE1hcFwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6MTM5NH1dfX19LFwiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDcmVhdGVzIGEgbmV3IEltbXV0YWJsZSBPcmRlcmVkTWFwLlwiLFwiZGVzY3JpcHRpb25cIjpcIkNyZWF0ZWQgd2l0aCB0aGUgc2FtZSBrZXkgdmFsdWUgcGFpcnMgYXMgdGhlIHByb3ZpZGVkIENvbGxlY3Rpb24uS2V5ZWQgb3JcXG5KYXZhU2NyaXB0IE9iamVjdCBvciBleHBlY3RzIGEgQ29sbGVjdGlvbiBvZiBbSywgVl0gdHVwbGUgZW50cmllcy5cXG5cXG5UaGUgaXRlcmF0aW9uIG9yZGVyIG9mIGtleS12YWx1ZSBwYWlycyBwcm92aWRlZCB0byB0aGlzIGNvbnN0cnVjdG9yIHdpbGxcXG5iZSBwcmVzZXJ2ZWQgaW4gdGhlIE9yZGVyZWRNYXAuXFxuXFxuICAgIGxldCBuZXdPcmRlcmVkTWFwID0gT3JkZXJlZE1hcCh7a2V5OiBcXFwidmFsdWVcXFwifSlcXG4gICAgbGV0IG5ld09yZGVyZWRNYXAgPSBPcmRlcmVkTWFwKFtbXFxcImtleVxcXCIsIFxcXCJ2YWx1ZVxcXCJdXSlcXG5cXG5Ob3RlOiBgT3JkZXJlZE1hcGAgaXMgYSBmYWN0b3J5IGZ1bmN0aW9uIGFuZCBub3QgYSBjbGFzcywgYW5kIGRvZXMgbm90IHVzZVxcbnRoZSBgbmV3YCBrZXl3b3JkIGR1cmluZyBjb25zdHJ1Y3Rpb24uXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktcIixcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZE1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjoxNDEyfSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvYmpcIixcInR5cGVcIjp7XCJrXCI6NCxcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRNYXBcIixcImFyZ3NcIjpbe1wia1wiOjN9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjoxNDEzfSx7XCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiXSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRNYXBcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6MTQxNH0se1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZE1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfSxcImxpbmVcIjoxNDE1fV19LFwiaW50ZXJmYWNlXCI6e1wibGluZVwiOjE0MTcsXCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiXSxcImV4dGVuZHNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJNYXBcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dLFwiZ3JvdXBzXCI6W3tcIm1lbWJlcnNcIjp7XCIjc2l6ZVwiOntcImxpbmVcIjoxNDIyfSxcIiNzZXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBPcmRlcmVkTWFwIGFsc28gY29udGFpbmluZyB0aGUgbmV3IGtleSwgdmFsdWUgcGFpci4gSWYgYW5cXG5lcXVpdmFsZW50IGtleSBhbHJlYWR5IGV4aXN0cyBpbiB0aGlzIE9yZGVyZWRNYXAsIGl0IHdpbGwgYmUgcmVwbGFjZWRcXG53aGlsZSBtYWludGFpbmluZyB0aGUgZXhpc3Rpbmcgb3JkZXIuXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IE9yZGVyZWRNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgb3JpZ2luYWxNYXAgPSBPcmRlcmVkTWFwKHthOjEsIGI6MSwgYzoxfSlcXG5jb25zdCB1cGRhdGVkTWFwID0gb3JpZ2luYWxNYXAuc2V0KCdiJywgMilcXG5cXG5vcmlnaW5hbE1hcFxcbi8vIE9yZGVyZWRNYXAge2E6IDEsIGI6IDEsIGM6IDF9XFxudXBkYXRlZE1hcFxcbi8vIE9yZGVyZWRNYXAge2E6IDEsIGI6IDIsIGM6IDF9XFxuYGBgXFxuXFxuTm90ZTogYHNldGAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjE0NDN9XX0sXCIjbWVyZ2VcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBPcmRlcmVkTWFwIHJlc3VsdGluZyBmcm9tIG1lcmdpbmcgdGhlIHByb3ZpZGVkIENvbGxlY3Rpb25zXFxuKG9yIEpTIG9iamVjdHMpIGludG8gdGhpcyBPcmRlcmVkTWFwLiBJbiBvdGhlciB3b3JkcywgdGhpcyB0YWtlcyBlYWNoXFxuZW50cnkgb2YgZWFjaCBjb2xsZWN0aW9uIGFuZCBzZXRzIGl0IG9uIHRoaXMgT3JkZXJlZE1hcC5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBWYWx1ZXMgcHJvdmlkZWQgdG8gYG1lcmdlYCBhcmUgc2hhbGxvd2x5IGNvbnZlcnRlZCBiZWZvcmUgYmVpbmdcXG5tZXJnZWQuIE5vIG5lc3RlZCB2YWx1ZXMgYXJlIGFsdGVyZWQuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IE9yZGVyZWRNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgb25lID0gT3JkZXJlZE1hcCh7IGE6IDEwLCBiOiAyMCwgYzogMzAgfSlcXG5jb25zdCB0d28gPSBPcmRlcmVkTWFwKHsgYjogNDAsIGE6IDUwLCBkOiA2MCB9KVxcbm9uZS5tZXJnZSh0d28pIC8vIE9yZGVyZWRNYXAgeyBcXFwiYVxcXCI6IDUwLCBcXFwiYlxcXCI6IDQwLCBcXFwiY1xcXCI6IDMwLCBcXFwiZFxcXCI6IDYwIH1cXG50d28ubWVyZ2Uob25lKSAvLyBPcmRlcmVkTWFwIHsgXFxcImJcXFwiOiAyMCwgXFxcImFcXFwiOiAxMCwgXFxcImRcXFwiOiA2MCwgXFxcImNcXFwiOiAzMCB9XFxuYGBgXFxuXFxuTm90ZTogYG1lcmdlYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXFxuXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJhbGlhc1wiLFwiYm9keVwiOlwiY29uY2F0XCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJLQ1wiLFwiVkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS0NcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVkNcIn1dfV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZE1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIktDXCJ9XX0se1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWQ1wifV19XX0sXCJsaW5lXCI6MTQ2Nn0se1widHlwZVBhcmFtc1wiOltcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRNYXBcIixcImFyZ3NcIjpbe1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6M31dfSx7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIkNcIn1dfV19LFwibGluZVwiOjE0Njd9XX19fSx7XCJ0aXRsZVwiOlwiU2VxdWVuY2UgYWxnb3JpdGhtc1wiLFwibWVtYmVyc1wiOntcIiNtYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBPcmRlcmVkTWFwIHdpdGggdmFsdWVzIHBhc3NlZCB0aHJvdWdoIGFcXG5gbWFwcGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCIgICAgT3JkZXJlZE1hcCh7IGE6IDEsIGI6IDIgfSkubWFwKHggPT4gMTAgKiB4KVxcbiAgICAvLyBPcmRlcmVkTWFwIHsgXFxcImFcXFwiOiAxMCwgXFxcImJcXFwiOiAyMCB9XFxuXFxuTm90ZTogYG1hcCgpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCBwcm9kdWNlZCB0aGUgc2FtZVxcbnZhbHVlIGF0IGV2ZXJ5IHN0ZXAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk1cIn19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZE1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjoxNDgzfV19LFwiI21hcEtleXNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcIkNvbGxlY3Rpb24uS2V5ZWQubWFwS2V5c1wifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkTWFwXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjE0OTF9XX0sXCIjbWFwRW50cmllc1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiQ29sbGVjdGlvbi5LZXllZC5tYXBFbnRyaWVzXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJLTVwiLFwiVk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiZW50cnlcIixcInR5cGVcIjp7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX0se1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS01cIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVk1cIn1dfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkTWFwXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZNXCJ9XX0sXCJsaW5lXCI6MTQ5OX1dfSxcIiNmbGF0TWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkZsYXQtbWFwcyB0aGUgT3JkZXJlZE1hcCwgcmV0dXJuaW5nIGEgbmV3IE9yZGVyZWRNYXAuXCIsXCJkZXNjcmlwdGlvblwiOlwiU2ltaWxhciB0byBgZGF0YS5tYXAoLi4uKS5mbGF0dGVuKHRydWUpYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS01cIixcIlZNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZNXCJ9XX1dfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkTWFwXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZNXCJ9XX0sXCJsaW5lXCI6MTUwOX1dfSxcIiNmaWx0ZXJcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBPcmRlcmVkTWFwIHdpdGggb25seSB0aGUgZW50cmllcyBmb3Igd2hpY2ggdGhlIGBwcmVkaWNhdGVgXFxuZnVuY3Rpb24gcmV0dXJucyB0cnVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBmaWx0ZXIoKWAgYWx3YXlzIHJldHVybnMgYSBuZXcgaW5zdGFuY2UsIGV2ZW4gaWYgaXQgcmVzdWx0cyBpblxcbm5vdCBmaWx0ZXJpbmcgb3V0IGFueSB2YWx1ZXMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkTWFwXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiRlwifV19LFwibGluZVwiOjE1MjF9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxNTI1fV19LFwiI2ZsaXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcIkNvbGxlY3Rpb24uS2V5ZWQuZmxpcFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkTWFwXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifV19LFwibGluZVwiOjE1MzN9XX19fV19fSxcIlNldFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJBIENvbGxlY3Rpb24gb2YgdW5pcXVlIHZhbHVlcyB3aXRoIGBPKGxvZzMyIE4pYCBhZGRzIGFuZCBoYXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiV2hlbiBpdGVyYXRpbmcgYSBTZXQsIHRoZSBlbnRyaWVzIHdpbGwgYmUgKHZhbHVlLCB2YWx1ZSkgcGFpcnMuIEl0ZXJhdGlvblxcbm9yZGVyIG9mIGEgU2V0IGlzIHVuZGVmaW5lZCwgaG93ZXZlciBpcyBzdGFibGUuIE11bHRpcGxlIGl0ZXJhdGlvbnMgb2YgdGhlXFxuc2FtZSBTZXQgd2lsbCBpdGVyYXRlIGluIHRoZSBzYW1lIG9yZGVyLlxcblxcblNldCB2YWx1ZXMsIGxpa2UgTWFwIGtleXMsIG1heSBiZSBvZiBhbnkgdHlwZS4gRXF1YWxpdHkgaXMgZGV0ZXJtaW5lZCB1c2luZ1xcbmBJbW11dGFibGUuaXNgLCBlbmFibGluZyBTZXRzIHRvIHVuaXF1ZWx5IGluY2x1ZGUgb3RoZXIgSW1tdXRhYmxlXFxuY29sbGVjdGlvbnMsIGN1c3RvbSB2YWx1ZSB0eXBlcywgYW5kIE5hTi5cIixcIm5vdGVzXCI6W119LFwibW9kdWxlXCI6e1wiaXNTZXRcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGEgU2V0XCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlU2V0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjoxNTUzfV19fSxcIm9mXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDcmVhdGVzIGEgbmV3IFNldCBjb250YWluaW5nIGB2YWx1ZXNgLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTU1OH1dfX0sXCJmcm9tS2V5c1wiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiYFNldC5mcm9tS2V5cygpYCBjcmVhdGVzIGEgbmV3IGltbXV0YWJsZSBTZXQgY29udGFpbmluZyB0aGUga2V5cyBmcm9tXFxudGhpcyBDb2xsZWN0aW9uIG9yIEphdmFTY3JpcHQgT2JqZWN0LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6MTd9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTU2NH0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm9ialwiLFwidHlwZVwiOntcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2V0XCIsXCJhcmdzXCI6W3tcImtcIjozfV19LFwibGluZVwiOjE1NjV9XX19LFwiaW50ZXJzZWN0XCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJgU2V0LmludGVyc2VjdCgpYCBjcmVhdGVzIGEgbmV3IGltbXV0YWJsZSBTZXQgdGhhdCBpcyB0aGUgaW50ZXJzZWN0aW9uIG9mXFxuYSBjb2xsZWN0aW9uIG9mIG90aGVyIHNldHMuXCIsXCJkZXNjcmlwdGlvblwiOlwiYGBganNcXG5jb25zdCB7IFNldCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBpbnRlcnNlY3RlZCA9IFNldC5pbnRlcnNlY3QoW1xcbiAgU2V0KFsgJ2EnLCAnYicsICdjJyBdKVxcbiAgU2V0KFsgJ2MnLCAnYScsICd0JyBdKVxcbl0pXFxuLy8gU2V0IFsgXFxcImFcXFwiLCBcXFwiY1xcXCIgXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInNldHNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTU4MH1dfX0sXCJ1bmlvblwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiYFNldC51bmlvbigpYCBjcmVhdGVzIGEgbmV3IGltbXV0YWJsZSBTZXQgdGhhdCBpcyB0aGUgdW5pb24gb2YgYVxcbmNvbGxlY3Rpb24gb2Ygb3RoZXIgc2V0cy5cIixcImRlc2NyaXB0aW9uXCI6XCJgYGBqc1xcbmNvbnN0IHsgU2V0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IHVuaW9uZWQgPSBTZXQudW5pb24oW1xcbiAgU2V0KFsgJ2EnLCAnYicsICdjJyBdKVxcbiAgU2V0KFsgJ2MnLCAnYScsICd0JyBdKVxcbl0pXFxuLy8gU2V0IFsgXFxcImFcXFwiLCBcXFwiYlxcXCIsIFxcXCJjXFxcIiwgXFxcInRcXFwiIF1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzZXRzXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjE1OTV9XX19fSxcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQ3JlYXRlIGEgbmV3IGltbXV0YWJsZSBTZXQgY29udGFpbmluZyB0aGUgdmFsdWVzIG9mIHRoZSBwcm92aWRlZFxcbmNvbGxlY3Rpb24tbGlrZS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgU2V0YCBpcyBhIGZhY3RvcnkgZnVuY3Rpb24gYW5kIG5vdCBhIGNsYXNzLCBhbmQgZG9lcyBub3QgdXNlIHRoZVxcbmBuZXdgIGtleXdvcmQgZHVyaW5nIGNvbnN0cnVjdGlvbi5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXRcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwibGluZVwiOjE2MDV9LHtcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoxNjA2fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTYwN31dfSxcImludGVyZmFjZVwiOntcImxpbmVcIjoxNjA5LFwidHlwZVBhcmFtc1wiOltcIlRcIl0sXCJleHRlbmRzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5TZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19XSxcImdyb3Vwc1wiOlt7XCJtZW1iZXJzXCI6e1wiI3NpemVcIjp7XCJsaW5lXCI6MTYxNH19fSx7XCJ0aXRsZVwiOlwiUGVyc2lzdGVudCBjaGFuZ2VzXCIsXCJtZW1iZXJzXCI6e1wiI2FkZFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFNldCB3aGljaCBhbHNvIGluY2x1ZGVzIHRoaXMgdmFsdWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYGFkZGAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjE2MjN9XX0sXCIjZGVsZXRlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU2V0IHdoaWNoIGV4Y2x1ZGVzIHRoaXMgdmFsdWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYGRlbGV0ZWAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblxcbk5vdGU6IGBkZWxldGVgICoqY2Fubm90KiogYmUgc2FmZWx5IHVzZWQgaW4gSUU4LCB1c2UgYHJlbW92ZWAgaWZcXG5zdXBwb3J0aW5nIG9sZCBicm93c2Vycy5cXG5cIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcImFsaWFzXCIsXCJib2R5XCI6XCJyZW1vdmVcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MTYzNX1dfSxcIiNjbGVhclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFNldCBjb250YWluaW5nIG5vIHZhbHVlcy5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgY2xlYXJgIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxNjQzfV19LFwiI3VuaW9uXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBTZXQgaW5jbHVkaW5nIGFueSB2YWx1ZSBmcm9tIGBjb2xsZWN0aW9uc2AgdGhhdCBkb2VzIG5vdCBhbHJlYWR5XFxuZXhpc3QgaW4gdGhpcyBTZXQuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYHVuaW9uYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJhbGlhc1wiLFwiYm9keVwiOlwibWVyZ2VcIn0se1wibmFtZVwiOlwiYWxpYXNcIixcImJvZHlcIjpcImNvbmNhdFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXRcIixcImFyZ3NcIjpbe1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9XX1dfSxcImxpbmVcIjoxNjUzfV19LFwiI2ludGVyc2VjdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgU2V0IHdoaWNoIGhhcyByZW1vdmVkIGFueSB2YWx1ZXMgbm90IGFsc28gY29udGFpbmVkXFxud2l0aGluIGBjb2xsZWN0aW9uc2AuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYGludGVyc2VjdGAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxNjYzfV19LFwiI3N1YnRyYWN0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBTZXQgZXhjbHVkaW5nIGFueSB2YWx1ZXMgY29udGFpbmVkIHdpdGhpbiBgY29sbGVjdGlvbnNgLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBPcmRlcmVkU2V0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbk9yZGVyZWRTZXQoWyAxLCAyLCAzIF0pLnN1YnRyYWN0KFsxLCAzXSlcXG4vLyBPcmRlcmVkU2V0IFsyXVxcbmBgYFxcblxcbk5vdGU6IGBzdWJ0cmFjdGAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxNjc3fV19fX0se1widGl0bGVcIjpcIlRyYW5zaWVudCBjaGFuZ2VzXCIsXCJtZW1iZXJzXCI6e1wiI3dpdGhNdXRhdGlvbnNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiTm90ZTogTm90IGFsbCBtZXRob2RzIGNhbiBiZSB1c2VkIG9uIGEgbXV0YWJsZSBjb2xsZWN0aW9uIG9yIHdpdGhpblxcbmB3aXRoTXV0YXRpb25zYCEgQ2hlY2sgdGhlIGRvY3VtZW50YXRpb24gZm9yIGVhY2ggbWV0aG9kIHRvIHNlZSBpZiBpdFxcbm1lbnRpb25zIGJlaW5nIHNhZmUgdG8gdXNlIGluIGB3aXRoTXV0YXRpb25zYC5cXG5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiYE1hcCN3aXRoTXV0YXRpb25zYFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibXV0YXRvclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm11dGFibGVcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjE2ODl9XX0sXCIjYXNNdXRhYmxlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIk5vdGU6IE5vdCBhbGwgbWV0aG9kcyBjYW4gYmUgdXNlZCBvbiBhIG11dGFibGUgY29sbGVjdGlvbiBvciB3aXRoaW5cXG5gd2l0aE11dGF0aW9uc2AhIENoZWNrIHRoZSBkb2N1bWVudGF0aW9uIGZvciBlYWNoIG1ldGhvZCB0byBzZWUgaWYgaXRcXG5tZW50aW9ucyBiZWluZyBzYWZlIHRvIHVzZSBpbiBgd2l0aE11dGF0aW9uc2AuXFxuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcImBNYXAjYXNNdXRhYmxlYFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxNjk4fV19LFwiI3dhc0FsdGVyZWRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcImBNYXAjd2FzQWx0ZXJlZGBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjoxNzAzfV19LFwiI2FzSW1tdXRhYmxlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI2FzSW1tdXRhYmxlYFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxNzA4fV19fX0se1widGl0bGVcIjpcIlNlcXVlbmNlIGFsZ29yaXRobXNcIixcIm1lbWJlcnNcIjp7XCIjbWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU2V0IHdpdGggdmFsdWVzIHBhc3NlZCB0aHJvdWdoIGFcXG5gbWFwcGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCIgICAgU2V0KFsxLDJdKS5tYXAoeCA9PiAxMCAqIHgpXFxuICAgIC8vIFNldCBbMTAsMjBdXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk1cIn19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjoxNzE5fV19LFwiI2ZsYXRNYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRmxhdC1tYXBzIHRoZSBTZXQsIHJldHVybmluZyBhIG5ldyBTZXQuXCIsXCJkZXNjcmlwdGlvblwiOlwiU2ltaWxhciB0byBgc2V0Lm1hcCguLi4pLmZsYXR0ZW4odHJ1ZSlgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjE3Mjl9XX0sXCIjZmlsdGVyXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU2V0IHdpdGggb25seSB0aGUgdmFsdWVzIGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWBcXG5mdW5jdGlvbiByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYGZpbHRlcigpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCByZXN1bHRzIGluXFxubm90IGZpbHRlcmluZyBvdXQgYW55IHZhbHVlcy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiRlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJGXCJ9XX0sXCJsaW5lXCI6MTc0MX0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MTd9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjE3NDV9XX19fV19fSxcIk9yZGVyZWRTZXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQSB0eXBlIG9mIFNldCB0aGF0IGhhcyB0aGUgYWRkaXRpb25hbCBndWFyYW50ZWUgdGhhdCB0aGUgaXRlcmF0aW9uIG9yZGVyIG9mXFxudmFsdWVzIHdpbGwgYmUgdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgd2VyZSBgYWRkYGVkLlwiLFwiZGVzY3JpcHRpb25cIjpcIlRoZSBpdGVyYXRpb24gYmVoYXZpb3Igb2YgT3JkZXJlZFNldCBpcyB0aGUgc2FtZSBhcyBuYXRpdmUgRVM2IFNldC5cXG5cXG5Ob3RlIHRoYXQgYE9yZGVyZWRTZXRgIGFyZSBtb3JlIGV4cGVuc2l2ZSB0aGFuIG5vbi1vcmRlcmVkIGBTZXRgIGFuZCBtYXlcXG5jb25zdW1lIG1vcmUgbWVtb3J5LiBgT3JkZXJlZFNldCNhZGRgIGlzIGFtb3J0aXplZCBPKGxvZzMyIE4pLCBidXQgbm90XFxuc3RhYmxlLlwiLFwibm90ZXNcIjpbXX0sXCJtb2R1bGVcIjp7XCJpc09yZGVyZWRTZXRcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGFuIE9yZGVyZWRTZXQuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlT3JkZXJlZFNldFwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6MTc2N31dfX0sXCJvZlwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQ3JlYXRlcyBhIG5ldyBPcmRlcmVkU2V0IGNvbnRhaW5pbmcgYHZhbHVlc2AuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVzXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZFNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTc3Mn1dfX0sXCJmcm9tS2V5c1wiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiYE9yZGVyZWRTZXQuZnJvbUtleXMoKWAgY3JlYXRlcyBhIG5ldyBpbW11dGFibGUgT3JkZXJlZFNldCBjb250YWluaW5nXFxudGhlIGtleXMgZnJvbSB0aGlzIENvbGxlY3Rpb24gb3IgSmF2YVNjcmlwdCBPYmplY3QuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjoxN31dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZFNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTc3OH0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm9ialwiLFwidHlwZVwiOntcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZFNldFwiLFwiYXJnc1wiOlt7XCJrXCI6M31dfSxcImxpbmVcIjoxNzc5fV19fX0sXCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkNyZWF0ZSBhIG5ldyBpbW11dGFibGUgT3JkZXJlZFNldCBjb250YWluaW5nIHRoZSB2YWx1ZXMgb2YgdGhlIHByb3ZpZGVkXFxuY29sbGVjdGlvbi1saWtlLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBPcmRlcmVkU2V0YCBpcyBhIGZhY3RvcnkgZnVuY3Rpb24gYW5kIG5vdCBhIGNsYXNzLCBhbmQgZG9lcyBub3QgdXNlXFxudGhlIGBuZXdgIGtleXdvcmQgZHVyaW5nIGNvbnN0cnVjdGlvbi5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkU2V0XCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcImxpbmVcIjoxNzg5fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRTZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjE3OTB9LHtcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZFNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTc5MX1dfSxcImludGVyZmFjZVwiOntcImxpbmVcIjoxNzkzLFwidHlwZVBhcmFtc1wiOltcIlRcIl0sXCJleHRlbmRzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfV0sXCJncm91cHNcIjpbe1wibWVtYmVyc1wiOntcIiNzaXplXCI6e1wibGluZVwiOjE3OTh9LFwiI3VuaW9uXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYW4gT3JkZXJlZFNldCBpbmNsdWRpbmcgYW55IHZhbHVlIGZyb20gYGNvbGxlY3Rpb25zYCB0aGF0IGRvZXNcXG5ub3QgYWxyZWFkeSBleGlzdCBpbiB0aGlzIE9yZGVyZWRTZXQuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYHVuaW9uYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJhbGlhc1wiLFwiYm9keVwiOlwibWVyZ2VcIn0se1wibmFtZVwiOlwiYWxpYXNcIixcImJvZHlcIjpcImNvbmNhdFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkU2V0XCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifV19XX0sXCJsaW5lXCI6MTgwOH1dfX19LHtcInRpdGxlXCI6XCJTZXF1ZW5jZSBhbGdvcml0aG1zXCIsXCJtZW1iZXJzXCI6e1wiI21hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFNldCB3aXRoIHZhbHVlcyBwYXNzZWQgdGhyb3VnaCBhXFxuYG1hcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiICAgIE9yZGVyZWRTZXQoWyAxLCAyIF0pLm1hcCh4ID0+IDEwICogeClcXG4gICAgLy8gT3JkZXJlZFNldCBbMTAsIDIwXVwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRTZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjE4MjF9XX0sXCIjZmxhdE1hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJGbGF0LW1hcHMgdGhlIE9yZGVyZWRTZXQsIHJldHVybmluZyBhIG5ldyBPcmRlcmVkU2V0LlwiLFwiZGVzY3JpcHRpb25cIjpcIlNpbWlsYXIgdG8gYHNldC5tYXAoLi4uKS5mbGF0dGVuKHRydWUpYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZFNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6MTgzMX1dfSxcIiNmaWx0ZXJcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBPcmRlcmVkU2V0IHdpdGggb25seSB0aGUgdmFsdWVzIGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWBcXG5mdW5jdGlvbiByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYGZpbHRlcigpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCByZXN1bHRzIGluXFxubm90IGZpbHRlcmluZyBvdXQgYW55IHZhbHVlcy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiRlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRTZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiRlwifV19LFwibGluZVwiOjE4NDN9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxODQ3fV19LFwiI3ppcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGFuIE9yZGVyZWRTZXQgb2YgdGhlIHNhbWUgdHlwZSBcXFwiemlwcGVkXFxcIiB3aXRoIHRoZSBwcm92aWRlZFxcbmNvbGxlY3Rpb25zLlwiLFwiZGVzY3JpcHRpb25cIjpcIkxpa2UgYHppcFdpdGhgLCBidXQgdXNpbmcgdGhlIGRlZmF1bHQgYHppcHBlcmA6IGNyZWF0aW5nIGFuIGBBcnJheWAuXFxuXFxuYGBganNcXG5jb25zdCBhID0gT3JkZXJlZFNldChbIDEsIDIsIDMgXSlcXG5jb25zdCBiID0gT3JkZXJlZFNldChbIDQsIDUsIDYgXSlcXG5jb25zdCBjID0gYS56aXAoYilcXG4vLyBPcmRlcmVkU2V0IFsgWyAxLCA0IF0sIFsgMiwgNSBdLCBbIDMsIDYgXSBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlVcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib3RoZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRTZXRcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX1dfSxcImxpbmVcIjoxODY1fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiLFwiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlcjFcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19LHtcIm5hbWVcIjpcIm90aGVyMlwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZFNldFwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XX0sXCJsaW5lXCI6MTg2Nn0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6MTd9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkU2V0XCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcImxpbmVcIjoxODY3fV19LFwiI3ppcEFsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgT3JkZXJlZFNldCBvZiB0aGUgc2FtZSB0eXBlIFxcXCJ6aXBwZWRcXFwiIHdpdGggdGhlIHByb3ZpZGVkXFxuY29sbGVjdGlvbnMuXCIsXCJkZXNjcmlwdGlvblwiOlwiVW5saWtlIGB6aXBgLCBgemlwQWxsYCBjb250aW51ZXMgemlwcGluZyB1bnRpbCB0aGUgbG9uZ2VzdCBjb2xsZWN0aW9uIGlzXFxuZXhoYXVzdGVkLiBNaXNzaW5nIHZhbHVlcyBmcm9tIHNob3J0ZXIgY29sbGVjdGlvbnMgYXJlIGZpbGxlZCB3aXRoIGB1bmRlZmluZWRgLlxcblxcbmBgYGpzXFxuY29uc3QgYSA9IE9yZGVyZWRTZXQoWyAxLCAyIF0pO1xcbmNvbnN0IGIgPSBPcmRlcmVkU2V0KFsgMywgNCwgNSBdKTtcXG5jb25zdCBjID0gYS56aXBBbGwoYik7IC8vIE9yZGVyZWRTZXQgWyBbIDEsIDMgXSwgWyAyLCA0IF0sIFsgdW5kZWZpbmVkLCA1IF0gXVxcbmBgYFxcblxcbk5vdGU6IFNpbmNlIHppcEFsbCB3aWxsIHJldHVybiBhIGNvbGxlY3Rpb24gYXMgbGFyZ2UgYXMgdGhlIGxhcmdlc3RcXG5pbnB1dCwgc29tZSByZXN1bHRzIG1heSBjb250YWluIHVuZGVmaW5lZCB2YWx1ZXMuIFR5cGVTY3JpcHQgY2Fubm90XFxuYWNjb3VudCBmb3IgdGhlc2Ugd2l0aG91dCBjYXNlcyAoYXMgb2YgdjIuNSkuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlVcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib3RoZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRTZXRcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX1dfSxcImxpbmVcIjoxODg2fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiLFwiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlcjFcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19LHtcIm5hbWVcIjpcIm90aGVyMlwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZFNldFwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XX0sXCJsaW5lXCI6MTg4N30se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6MTd9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkU2V0XCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcImxpbmVcIjoxODg4fV19LFwiI3ppcFdpdGhcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhbiBPcmRlcmVkU2V0IG9mIHRoZSBzYW1lIHR5cGUgXFxcInppcHBlZFxcXCIgd2l0aCB0aGUgcHJvdmlkZWRcXG5jb2xsZWN0aW9ucyBieSB1c2luZyBhIGN1c3RvbSBgemlwcGVyYCBmdW5jdGlvbi5cXG5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiU2VxLkluZGV4ZWQuemlwV2l0aFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiLFwiWlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ6aXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIm90aGVyVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifX19LHtcIm5hbWVcIjpcIm90aGVyQ29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZFNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9XX0sXCJsaW5lXCI6MTg5Nn0se1widHlwZVBhcmFtc1wiOltcIlVcIixcIlZcIixcIlpcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiemlwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJvdGhlclZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifX0se1wibmFtZVwiOlwidGhpcmRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9fX0se1wibmFtZVwiOlwib3RoZXJDb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fSx7XCJuYW1lXCI6XCJ0aGlyZENvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRTZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifV19LFwibGluZVwiOjE5MDB9LHtcInR5cGVQYXJhbXNcIjpbXCJaXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInppcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImFueVwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9fX0se1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRTZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifV19LFwibGluZVwiOjE5MDV9XX19fV19fSxcIlN0YWNrXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlN0YWNrcyBhcmUgaW5kZXhlZCBjb2xsZWN0aW9ucyB3aGljaCBzdXBwb3J0IHZlcnkgZWZmaWNpZW50IE8oMSkgYWRkaXRpb25cXG5hbmQgcmVtb3ZhbCBmcm9tIHRoZSBmcm9udCB1c2luZyBgdW5zaGlmdCh2KWAgYW5kIGBzaGlmdCgpYC5cIixcImRlc2NyaXB0aW9uXCI6XCJGb3IgZmFtaWxpYXJpdHksIFN0YWNrIGFsc28gcHJvdmlkZXMgYHB1c2godilgLCBgcG9wKClgLCBhbmQgYHBlZWsoKWAsIGJ1dFxcbmJlIGF3YXJlIHRoYXQgdGhleSBhbHNvIG9wZXJhdGUgb24gdGhlIGZyb250IG9mIHRoZSBsaXN0LCB1bmxpa2UgTGlzdCBvclxcbmEgSmF2YVNjcmlwdCBBcnJheS5cXG5cXG5Ob3RlOiBgcmV2ZXJzZSgpYCBvciBhbnkgaW5oZXJlbnQgcmV2ZXJzZSB0cmF2ZXJzYWwgKGByZWR1Y2VSaWdodGAsXFxuYGxhc3RJbmRleE9mYCwgZXRjLikgaXMgbm90IGVmZmljaWVudCB3aXRoIGEgU3RhY2suXFxuXFxuU3RhY2sgaXMgaW1wbGVtZW50ZWQgd2l0aCBhIFNpbmdsZS1MaW5rZWQgTGlzdC5cIixcIm5vdGVzXCI6W119LFwibW9kdWxlXCI6e1wiaXNTdGFja1wiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYSBTdGFja1wiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXliZVN0YWNrXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjoxOTMxfV19fSxcIm9mXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDcmVhdGVzIGEgbmV3IFN0YWNrIGNvbnRhaW5pbmcgYHZhbHVlc2AuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVzXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU3RhY2tcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjE5MzZ9XX19fSxcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQ3JlYXRlIGEgbmV3IGltbXV0YWJsZSBTdGFjayBjb250YWluaW5nIHRoZSB2YWx1ZXMgb2YgdGhlIHByb3ZpZGVkXFxuY29sbGVjdGlvbi1saWtlLlwiLFwiZGVzY3JpcHRpb25cIjpcIlRoZSBpdGVyYXRpb24gb3JkZXIgb2YgdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb24gaXMgcHJlc2VydmVkIGluIHRoZVxcbnJlc3VsdGluZyBgU3RhY2tgLlxcblxcbk5vdGU6IGBTdGFja2AgaXMgYSBmYWN0b3J5IGZ1bmN0aW9uIGFuZCBub3QgYSBjbGFzcywgYW5kIGRvZXMgbm90IHVzZSB0aGVcXG5gbmV3YCBrZXl3b3JkIGR1cmluZyBjb25zdHJ1Y3Rpb24uXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU3RhY2tcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwibGluZVwiOjE5NDl9LHtcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU3RhY2tcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjE5NTB9LHtcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU3RhY2tcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjE5NTF9XX0sXCJpbnRlcmZhY2VcIjp7XCJsaW5lXCI6MTk1MyxcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwiZXh0ZW5kc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX1dLFwiZ3JvdXBzXCI6W3tcIm1lbWJlcnNcIjp7XCIjc2l6ZVwiOntcImxpbmVcIjoxOTU4fX19LHtcInRpdGxlXCI6XCJSZWFkaW5nIHZhbHVlc1wiLFwibWVtYmVyc1wiOntcIiNwZWVrXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkFsaWFzIGZvciBgU3RhY2suZmlyc3QoKWAuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjExfV19LFwibGluZVwiOjE5NjV9XX19fSx7XCJ0aXRsZVwiOlwiUGVyc2lzdGVudCBjaGFuZ2VzXCIsXCJtZW1iZXJzXCI6e1wiI2NsZWFyXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU3RhY2sgd2l0aCAwIHNpemUgYW5kIG5vIHZhbHVlcy5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgY2xlYXJgIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTdGFja1wiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTk3NX1dfSxcIiN1bnNoaWZ0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU3RhY2sgd2l0aCB0aGUgcHJvdmlkZWQgYHZhbHVlc2AgcHJlcGVuZGVkLCBzaGlmdGluZyBvdGhlclxcbnZhbHVlcyBhaGVhZCB0byBoaWdoZXIgaW5kaWNlcy5cIixcImRlc2NyaXB0aW9uXCI6XCJUaGlzIGlzIHZlcnkgZWZmaWNpZW50IGZvciBTdGFjay5cXG5cXG5Ob3RlOiBgdW5zaGlmdGAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZXNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTdGFja1wiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTk4NX1dfSxcIiN1bnNoaWZ0QWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkxpa2UgYFN0YWNrI3Vuc2hpZnRgLCBidXQgYWNjZXB0cyBhIGNvbGxlY3Rpb24gcmF0aGVyIHRoYW4gdmFyYXJncy5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgdW5zaGlmdEFsbGAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlN0YWNrXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoxOTkyfV19LFwiI3NoaWZ0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU3RhY2sgd2l0aCBhIHNpemUgb25lcyBsZXNzIHRoYW4gdGhpcyBTdGFjaywgZXhjbHVkaW5nXFxudGhlIGZpcnN0IGl0ZW0gaW4gdGhpcyBTdGFjaywgc2hpZnRpbmcgYWxsIG90aGVyIHZhbHVlcyB0byBhIGxvd2VyIGluZGV4LlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IHRoaXMgZGlmZmVycyBmcm9tIGBBcnJheSNzaGlmdGAgYmVjYXVzZSBpdCByZXR1cm5zIGEgbmV3XFxuU3RhY2sgcmF0aGVyIHRoYW4gdGhlIHJlbW92ZWQgdmFsdWUuIFVzZSBgZmlyc3QoKWAgb3IgYHBlZWsoKWAgdG8gZ2V0IHRoZVxcbmZpcnN0IHZhbHVlIGluIHRoaXMgU3RhY2suXFxuXFxuTm90ZTogYHNoaWZ0YCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU3RhY2tcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjIwMDR9XX0sXCIjcHVzaFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJBbGlhcyBmb3IgYFN0YWNrI3Vuc2hpZnRgIGFuZCBpcyBub3QgZXF1aXZhbGVudCB0byBgTGlzdCNwdXNoYC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVzXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU3RhY2tcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjIwMDl9XX0sXCIjcHVzaEFsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJBbGlhcyBmb3IgYFN0YWNrI3Vuc2hpZnRBbGxgLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlN0YWNrXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoyMDE0fV19LFwiI3BvcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJBbGlhcyBmb3IgYFN0YWNrI3NoaWZ0YCBhbmQgaXMgbm90IGVxdWl2YWxlbnQgdG8gYExpc3QjcG9wYC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTdGFja1wiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MjAxOX1dfX19LHtcInRpdGxlXCI6XCJUcmFuc2llbnQgY2hhbmdlc1wiLFwibWVtYmVyc1wiOntcIiN3aXRoTXV0YXRpb25zXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIk5vdGU6IE5vdCBhbGwgbWV0aG9kcyBjYW4gYmUgdXNlZCBvbiBhIG11dGFibGUgY29sbGVjdGlvbiBvciB3aXRoaW5cXG5gd2l0aE11dGF0aW9uc2AhIENoZWNrIHRoZSBkb2N1bWVudGF0aW9uIGZvciBlYWNoIG1ldGhvZCB0byBzZWUgaWYgaXRcXG5tZW50aW9ucyBiZWluZyBzYWZlIHRvIHVzZSBpbiBgd2l0aE11dGF0aW9uc2AuXFxuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcImBNYXAjd2l0aE11dGF0aW9uc2BcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm11dGF0b3JcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtdXRhYmxlXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxN319fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoyMDMxfV19LFwiI2FzTXV0YWJsZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJOb3RlOiBOb3QgYWxsIG1ldGhvZHMgY2FuIGJlIHVzZWQgb24gYSBtdXRhYmxlIGNvbGxlY3Rpb24gb3Igd2l0aGluXFxuYHdpdGhNdXRhdGlvbnNgISBDaGVjayB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgZWFjaCBtZXRob2QgdG8gc2VlIGlmIGl0XFxubWVudGlvbnMgYmVpbmcgc2FmZSB0byB1c2UgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI2FzTXV0YWJsZWBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MjA0MH1dfSxcIiN3YXNBbHRlcmVkXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI3dhc0FsdGVyZWRgXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6MjA0NX1dfSxcIiNhc0ltbXV0YWJsZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiYE1hcCNhc0ltbXV0YWJsZWBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MjA1MH1dfX19LHtcInRpdGxlXCI6XCJTZXF1ZW5jZSBhbGdvcml0aG1zXCIsXCJtZW1iZXJzXCI6e1wiI2NvbmNhdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFN0YWNrIHdpdGggb3RoZXIgY29sbGVjdGlvbnMgY29uY2F0ZW5hdGVkIHRvIHRoaXMgb25lLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlc09yQ29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifV19LHtcImtcIjo4LFwicGFyYW1cIjpcIkNcIn1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlN0YWNrXCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifV19XX0sXCJsaW5lXCI6MjA1N31dfSxcIiNtYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBTdGFjayB3aXRoIHZhbHVlcyBwYXNzZWQgdGhyb3VnaCBhXFxuYG1hcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiICAgIFN0YWNrKFsgMSwgMiBdKS5tYXAoeCA9PiAxMCAqIHgpXFxuICAgIC8vIFN0YWNrIFsgMTAsIDIwIF1cXG5cXG5Ob3RlOiBgbWFwKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHByb2R1Y2VkIHRoZSBzYW1lXFxudmFsdWUgYXQgZXZlcnkgc3RlcC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlN0YWNrXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjoyMDY5fV19LFwiI2ZsYXRNYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRmxhdC1tYXBzIHRoZSBTdGFjaywgcmV0dXJuaW5nIGEgbmV3IFN0YWNrLlwiLFwiZGVzY3JpcHRpb25cIjpcIlNpbWlsYXIgdG8gYHN0YWNrLm1hcCguLi4pLmZsYXR0ZW4odHJ1ZSlgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlN0YWNrXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjoyMDc5fV19LFwiI2ZpbHRlclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFNldCB3aXRoIG9ubHkgdGhlIHZhbHVlcyBmb3Igd2hpY2ggdGhlIGBwcmVkaWNhdGVgXFxuZnVuY3Rpb24gcmV0dXJucyB0cnVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBmaWx0ZXIoKWAgYWx3YXlzIHJldHVybnMgYSBuZXcgaW5zdGFuY2UsIGV2ZW4gaWYgaXQgcmVzdWx0cyBpblxcbm5vdCBmaWx0ZXJpbmcgb3V0IGFueSB2YWx1ZXMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJpbmRleFwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIkZcIn1dfSxcImxpbmVcIjoyMDkxfSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJpbmRleFwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MTd9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjIwOTV9XX0sXCIjemlwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBTdGFjayBcXFwiemlwcGVkXFxcIiB3aXRoIHRoZSBwcm92aWRlZCBjb2xsZWN0aW9ucy5cIixcImRlc2NyaXB0aW9uXCI6XCJMaWtlIGB6aXBXaXRoYCwgYnV0IHVzaW5nIHRoZSBkZWZhdWx0IGB6aXBwZXJgOiBjcmVhdGluZyBhbiBgQXJyYXlgLlxcblxcbmBgYGpzXFxuY29uc3QgYSA9IFN0YWNrKFsgMSwgMiwgMyBdKTtcXG5jb25zdCBiID0gU3RhY2soWyA0LCA1LCA2IF0pO1xcbmNvbnN0IGMgPSBhLnppcChiKTsgLy8gU3RhY2sgWyBbIDEsIDQgXSwgWyAyLCA1IF0sIFsgMywgNiBdIF1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlclwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU3RhY2tcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX1dfSxcImxpbmVcIjoyMTExfSx7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiLFwiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlclwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX0se1wibmFtZVwiOlwib3RoZXIyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTdGFja1wiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XX0sXCJsaW5lXCI6MjExMn0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6MTd9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTdGFja1wiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJsaW5lXCI6MjExM31dfSxcIiN6aXBBbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIFN0YWNrIFxcXCJ6aXBwZWRcXFwiIHdpdGggdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb25zLlwiLFwiZGVzY3JpcHRpb25cIjpcIlVubGlrZSBgemlwYCwgYHppcEFsbGAgY29udGludWVzIHppcHBpbmcgdW50aWwgdGhlIGxvbmdlc3QgY29sbGVjdGlvbiBpc1xcbmV4aGF1c3RlZC4gTWlzc2luZyB2YWx1ZXMgZnJvbSBzaG9ydGVyIGNvbGxlY3Rpb25zIGFyZSBmaWxsZWQgd2l0aCBgdW5kZWZpbmVkYC5cXG5cXG5gYGBqc1xcbmNvbnN0IGEgPSBTdGFjayhbIDEsIDIgXSk7XFxuY29uc3QgYiA9IFN0YWNrKFsgMywgNCwgNSBdKTtcXG5jb25zdCBjID0gYS56aXBBbGwoYik7IC8vIFN0YWNrIFsgWyAxLCAzIF0sIFsgMiwgNCBdLCBbIHVuZGVmaW5lZCwgNSBdIF1cXG5gYGBcXG5cXG5Ob3RlOiBTaW5jZSB6aXBBbGwgd2lsbCByZXR1cm4gYSBjb2xsZWN0aW9uIGFzIGxhcmdlIGFzIHRoZSBsYXJnZXN0XFxuaW5wdXQsIHNvbWUgcmVzdWx0cyBtYXkgY29udGFpbiB1bmRlZmluZWQgdmFsdWVzLiBUeXBlU2NyaXB0IGNhbm5vdFxcbmFjY291bnQgZm9yIHRoZXNlIHdpdGhvdXQgY2FzZXMgKGFzIG9mIHYyLjUpLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJVXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTdGFja1wiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfV19LFwibGluZVwiOjIxMzF9LHtcInR5cGVQYXJhbXNcIjpbXCJVXCIsXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fSx7XCJuYW1lXCI6XCJvdGhlcjJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlN0YWNrXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfSxcImxpbmVcIjoyMTMyfSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlN0YWNrXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcImxpbmVcIjoyMTMzfV19LFwiI3ppcFdpdGhcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIFN0YWNrIFxcXCJ6aXBwZWRcXFwiIHdpdGggdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb25zIGJ5IHVzaW5nIGFcXG5jdXN0b20gYHppcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiYGBganNcXG5jb25zdCBhID0gU3RhY2soWyAxLCAyLCAzIF0pO1xcbmNvbnN0IGIgPSBTdGFjayhbIDQsIDUsIDYgXSk7XFxuY29uc3QgYyA9IGEuemlwV2l0aCgoYSwgYikgPT4gYSArIGIsIGIpO1xcbi8vIFN0YWNrIFsgNSwgNywgOSBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlVcIixcIlpcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiemlwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJvdGhlclZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlpcIn19fSx7XCJuYW1lXCI6XCJvdGhlckNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlN0YWNrXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlpcIn1dfSxcImxpbmVcIjoyMTQ2fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiLFwiVlwiLFwiWlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ6aXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIm90aGVyVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9fSx7XCJuYW1lXCI6XCJ0aGlyZFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlpcIn19fSx7XCJuYW1lXCI6XCJvdGhlckNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19LHtcIm5hbWVcIjpcInRoaXJkQ29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU3RhY2tcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifV19LFwibGluZVwiOjIxNTB9LHtcInR5cGVQYXJhbXNcIjpbXCJaXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInppcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImFueVwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9fX0se1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlN0YWNrXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlpcIn1dfSxcImxpbmVcIjoyMTU1fV19fX1dfX0sXCJSYW5nZVwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIFNlcS5JbmRleGVkIG9mIG51bWJlcnMgZnJvbSBgc3RhcnRgIChpbmNsdXNpdmUpIHRvIGBlbmRgXFxuKGV4Y2x1c2l2ZSksIGJ5IGBzdGVwYCwgd2hlcmUgYHN0YXJ0YCBkZWZhdWx0cyB0byAwLCBgc3RlcGAgdG8gMSwgYW5kIGBlbmRgIHRvXFxuaW5maW5pdHkuIFdoZW4gYHN0YXJ0YCBpcyBlcXVhbCB0byBgZW5kYCwgcmV0dXJucyBlbXB0eSByYW5nZS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgUmFuZ2VgIGlzIGEgZmFjdG9yeSBmdW5jdGlvbiBhbmQgbm90IGEgY2xhc3MsIGFuZCBkb2VzIG5vdCB1c2UgdGhlXFxuYG5ld2Aga2V5d29yZCBkdXJpbmcgY29uc3RydWN0aW9uLlxcblxcbmBgYGpzXFxuY29uc3QgeyBSYW5nZSB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5SYW5nZSgpIC8vIFsgMCwgMSwgMiwgMywgLi4uIF1cXG5SYW5nZSgxMCkgLy8gWyAxMCwgMTEsIDEyLCAxMywgLi4uIF1cXG5SYW5nZSgxMCwgMTUpIC8vIFsgMTAsIDExLCAxMiwgMTMsIDE0IF1cXG5SYW5nZSgxMCwgMzAsIDUpIC8vIFsgMTAsIDE1LCAyMCwgMjUgXVxcblJhbmdlKDMwLCAxMCwgNSkgLy8gWyAzMCwgMjUsIDIwLCAxNSBdXFxuUmFuZ2UoMzAsIDMwLCA1KSAvLyBbXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzdGFydFwiLFwidHlwZVwiOntcImtcIjoyfSxcIm9wdGlvbmFsXCI6dHJ1ZX0se1wibmFtZVwiOlwiZW5kXCIsXCJ0eXBlXCI6e1wia1wiOjJ9LFwib3B0aW9uYWxcIjp0cnVlfSx7XCJuYW1lXCI6XCJzdGVwXCIsXCJ0eXBlXCI6e1wia1wiOjJ9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6Mn1dfSxcImxpbmVcIjoyMTgwfV19fSxcIlJlcGVhdFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIFNlcS5JbmRleGVkIG9mIGB2YWx1ZWAgcmVwZWF0ZWQgYHRpbWVzYCB0aW1lcy4gV2hlbiBgdGltZXNgIGlzXFxubm90IGRlZmluZWQsIHJldHVybnMgYW4gaW5maW5pdGUgYFNlcWAgb2YgYHZhbHVlYC5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgUmVwZWF0YCBpcyBhIGZhY3RvcnkgZnVuY3Rpb24gYW5kIG5vdCBhIGNsYXNzLCBhbmQgZG9lcyBub3QgdXNlIHRoZVxcbmBuZXdgIGtleXdvcmQgZHVyaW5nIGNvbnN0cnVjdGlvbi5cXG5cXG5gYGBqc1xcbmNvbnN0IHsgUmVwZWF0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcblJlcGVhdCgnZm9vJykgLy8gWyAnZm9vJywgJ2ZvbycsICdmb28nLCAuLi4gXVxcblJlcGVhdCgnYmFyJywgNCkgLy8gWyAnYmFyJywgJ2JhcicsICdiYXInLCAnYmFyJyBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJ0aW1lc1wiLFwidHlwZVwiOntcImtcIjoyfSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjIxOTZ9XX19LFwiUmVjb3JkXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkEgcmVjb3JkIGlzIHNpbWlsYXIgdG8gYSBKUyBvYmplY3QsIGJ1dCBlbmZvcmNlcyBhIHNwZWNpZmljIHNldCBvZiBhbGxvd2VkXFxuc3RyaW5nIGtleXMsIGFuZCBoYXMgZGVmYXVsdCB2YWx1ZXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiVGhlIGBSZWNvcmQoKWAgZnVuY3Rpb24gcHJvZHVjZXMgbmV3IFJlY29yZCBGYWN0b3JpZXMsIHdoaWNoIHdoZW4gY2FsbGVkXFxuY3JlYXRlIFJlY29yZCBpbnN0YW5jZXMuXFxuXFxuYGBganNcXG5jb25zdCB7IFJlY29yZCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBBQlJlY29yZCA9IFJlY29yZCh7IGE6IDEsIGI6IDIgfSlcXG5jb25zdCBteVJlY29yZCA9IEFCUmVjb3JkKHsgYjogMyB9KVxcbmBgYFxcblxcblJlY29yZHMgYWx3YXlzIGhhdmUgYSB2YWx1ZSBmb3IgdGhlIGtleXMgdGhleSBkZWZpbmUuIGByZW1vdmVgaW5nIGEga2V5XFxuZnJvbSBhIHJlY29yZCBzaW1wbHkgcmVzZXRzIGl0IHRvIHRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGF0IGtleS5cXG5cXG5gYGBqc1xcbm15UmVjb3JkLnNpemUgLy8gMlxcbm15UmVjb3JkLmdldCgnYScpIC8vIDFcXG5teVJlY29yZC5nZXQoJ2InKSAvLyAzXFxuY29uc3QgbXlSZWNvcmRXaXRob3V0QiA9IG15UmVjb3JkLnJlbW92ZSgnYicpXFxubXlSZWNvcmRXaXRob3V0Qi5nZXQoJ2InKSAvLyAyXFxubXlSZWNvcmRXaXRob3V0Qi5zaXplIC8vIDJcXG5gYGBcXG5cXG5WYWx1ZXMgcHJvdmlkZWQgdG8gdGhlIGNvbnN0cnVjdG9yIG5vdCBmb3VuZCBpbiB0aGUgUmVjb3JkIHR5cGUgd2lsbFxcbmJlIGlnbm9yZWQuIEZvciBleGFtcGxlLCBpbiB0aGlzIGNhc2UsIEFCUmVjb3JkIGlzIHByb3ZpZGVkIGEga2V5IFxcXCJ4XFxcIiBldmVuXFxudGhvdWdoIG9ubHkgXFxcImFcXFwiIGFuZCBcXFwiYlxcXCIgaGF2ZSBiZWVuIGRlZmluZWQuIFRoZSB2YWx1ZSBmb3IgXFxcInhcXFwiIHdpbGwgYmVcXG5pZ25vcmVkIGZvciB0aGlzIHJlY29yZC5cXG5cXG5gYGBqc1xcbmNvbnN0IG15UmVjb3JkID0gQUJSZWNvcmQoeyBiOiAzLCB4OiAxMCB9KVxcbm15UmVjb3JkLmdldCgneCcpIC8vIHVuZGVmaW5lZFxcbmBgYFxcblxcbkJlY2F1c2UgUmVjb3JkcyBoYXZlIGEga25vd24gc2V0IG9mIHN0cmluZyBrZXlzLCBwcm9wZXJ0eSBnZXQgYWNjZXNzIHdvcmtzXFxuYXMgZXhwZWN0ZWQsIGhvd2V2ZXIgcHJvcGVydHkgc2V0cyB3aWxsIHRocm93IGFuIEVycm9yLlxcblxcbk5vdGU6IElFOCBkb2VzIG5vdCBzdXBwb3J0IHByb3BlcnR5IGFjY2Vzcy4gT25seSB1c2UgYGdldCgpYCB3aGVuXFxuc3VwcG9ydGluZyBJRTguXFxuXFxuYGBganNcXG5teVJlY29yZC5iIC8vIDNcXG5teVJlY29yZC5iID0gNSAvLyB0aHJvd3MgRXJyb3JcXG5gYGBcXG5cXG5SZWNvcmQgVHlwZXMgY2FuIGJlIGV4dGVuZGVkIGFzIHdlbGwsIGFsbG93aW5nIGZvciBjdXN0b20gbWV0aG9kcyBvbiB5b3VyXFxuUmVjb3JkLiBUaGlzIGlzIG5vdCBhIGNvbW1vbiBwYXR0ZXJuIGluIGZ1bmN0aW9uYWwgZW52aXJvbm1lbnRzLCBidXQgaXMgaW5cXG5tYW55IEpTIHByb2dyYW1zLlxcblxcbkhvd2V2ZXIgUmVjb3JkIFR5cGVzIGFyZSBtb3JlIHJlc3RyaWN0ZWQgdGhhbiB0eXBpY2FsIEphdmFTY3JpcHQgY2xhc3Nlcy5cXG5UaGV5IGRvIG5vdCB1c2UgYSBjbGFzcyBjb25zdHJ1Y3Rvciwgd2hpY2ggYWxzbyBtZWFucyB0aGV5IGNhbm5vdCB1c2VcXG5jbGFzcyBwcm9wZXJ0aWVzIChzaW5jZSB0aG9zZSBhcmUgdGVjaG5pY2FsbHkgcGFydCBvZiBhIGNvbnN0cnVjdG9yKS5cXG5cXG5XaGlsZSBSZWNvcmQgVHlwZXMgY2FuIGJlIHN5bnRhY3RpY2FsbHkgY3JlYXRlZCB3aXRoIHRoZSBKYXZhU2NyaXB0IGBjbGFzc2BcXG5mb3JtLCB0aGUgcmVzdWx0aW5nIFJlY29yZCBmdW5jdGlvbiBpcyBhY3R1YWxseSBhIGZhY3RvcnkgZnVuY3Rpb24sIG5vdCBhXFxuY2xhc3MgY29uc3RydWN0b3IuIEV2ZW4gdGhvdWdoIFJlY29yZCBUeXBlcyBhcmUgbm90IGNsYXNzZXMsIEphdmFTY3JpcHRcXG5jdXJyZW50bHkgcmVxdWlyZXMgdGhlIHVzZSBvZiBgbmV3YCB3aGVuIGNyZWF0aW5nIG5ldyBSZWNvcmQgaW5zdGFuY2VzIGlmXFxudGhleSBhcmUgZGVmaW5lZCBhcyBhIGBjbGFzc2AuXFxuXFxuYGBgXFxuY2xhc3MgQUJSZWNvcmQgZXh0ZW5kcyBSZWNvcmQoeyBhOiAxLCBiOiAyIH0pIHtcXG4gIGdldEFCKCkge1xcbiAgICByZXR1cm4gdGhpcy5hICsgdGhpcy5iO1xcbiAgfVxcbn1cXG5cXG52YXIgbXlSZWNvcmQgPSBuZXcgQUJSZWNvcmQoe2I6IDN9KVxcbm15UmVjb3JkLmdldEFCKCkgLy8gNFxcbmBgYFxcblxcblxcbioqRmxvdyBUeXBpbmcgUmVjb3JkczoqKlxcblxcbkltbXV0YWJsZS5qcyBleHBvcnRzIHR3byBGbG93IHR5cGVzIGRlc2lnbmVkIHRvIG1ha2UgaXQgZWFzaWVyIHRvIHVzZVxcblJlY29yZHMgd2l0aCBmbG93IHR5cGVkIGNvZGUsIGBSZWNvcmRPZjxUUHJvcHM+YCBhbmQgYFJlY29yZEZhY3Rvcnk8VFByb3BzPmAuXFxuXFxuV2hlbiBkZWZpbmluZyBhIG5ldyBraW5kIG9mIFJlY29yZCBmYWN0b3J5IGZ1bmN0aW9uLCB1c2UgYSBmbG93IHR5cGUgdGhhdFxcbmRlc2NyaWJlcyB0aGUgdmFsdWVzIHRoZSByZWNvcmQgY29udGFpbnMgYWxvbmcgd2l0aCBgUmVjb3JkRmFjdG9yeTxUUHJvcHM+YC5cXG5UbyB0eXBlIGluc3RhbmNlcyBvZiB0aGUgUmVjb3JkICh3aGljaCB0aGUgZmFjdG9yeSBmdW5jdGlvbiByZXR1cm5zKSxcXG51c2UgYFJlY29yZE9mPFRQcm9wcz5gLlxcblxcblR5cGljYWxseSwgbmV3IFJlY29yZCBkZWZpbml0aW9ucyB3aWxsIGV4cG9ydCBib3RoIHRoZSBSZWNvcmQgZmFjdG9yeVxcbmZ1bmN0aW9uIGFzIHdlbGwgYXMgdGhlIFJlY29yZCBpbnN0YW5jZSB0eXBlIGZvciB1c2UgaW4gb3RoZXIgY29kZS5cXG5cXG5gYGBqc1xcbmltcG9ydCB0eXBlIHsgUmVjb3JkRmFjdG9yeSwgUmVjb3JkT2YgfSBmcm9tICdpbW11dGFibGUnO1xcblxcbi8vIFVzZSBSZWNvcmRGYWN0b3J5PFRQcm9wcz4gZm9yIGRlZmluaW5nIG5ldyBSZWNvcmQgZmFjdG9yeSBmdW5jdGlvbnMuXFxudHlwZSBQb2ludDNEUHJvcHMgPSB7IHg6IG51bWJlciwgeTogbnVtYmVyLCB6OiBudW1iZXIgfTtcXG5jb25zdCBkZWZhdWx0VmFsdWVzOiBQb2ludDNEUHJvcHMgPSB7IHg6IDAsIHk6IDAsIHo6IDAgfTtcXG5jb25zdCBtYWtlUG9pbnQzRDogUmVjb3JkRmFjdG9yeTxQb2ludDNEUHJvcHM+ID0gUmVjb3JkKGRlZmF1bHRWYWx1ZXMpO1xcbmV4cG9ydCBtYWtlUG9pbnQzRDtcXG5cXG4vLyBVc2UgUmVjb3JkT2Y8VD4gZm9yIGRlZmluaW5nIG5ldyBpbnN0YW5jZXMgb2YgdGhhdCBSZWNvcmQuXFxuZXhwb3J0IHR5cGUgUG9pbnQzRCA9IFJlY29yZE9mPFBvaW50M0RQcm9wcz47XFxuY29uc3Qgc29tZTNEUG9pbnQ6IFBvaW50M0QgPSBtYWtlUG9pbnQzRCh7IHg6IDEwLCB5OiAyMCwgejogMzAgfSk7XFxuYGBgXFxuXFxuKipGbG93IFR5cGluZyBSZWNvcmQgU3ViY2xhc3NlczoqKlxcblxcblJlY29yZHMgY2FuIGJlIHN1YmNsYXNzZWQgYXMgYSBtZWFucyB0byBhZGQgYWRkaXRpb25hbCBtZXRob2RzIHRvIFJlY29yZFxcbmluc3RhbmNlcy4gVGhpcyBpcyBnZW5lcmFsbHkgZGlzY291cmFnZWQgaW4gZmF2b3Igb2YgYSBtb3JlIGZ1bmN0aW9uYWwgQVBJLFxcbnNpbmNlIFN1YmNsYXNzZXMgaGF2ZSBzb21lIG1pbm9yIG92ZXJoZWFkLiBIb3dldmVyIHRoZSBhYmlsaXR5IHRvIGNyZWF0ZVxcbmEgcmljaCBBUEkgb24gUmVjb3JkIHR5cGVzIGNhbiBiZSBxdWl0ZSB2YWx1YWJsZS5cXG5cXG5XaGVuIHVzaW5nIEZsb3cgdG8gdHlwZSBTdWJjbGFzc2VzLCBkbyBub3QgdXNlIGBSZWNvcmRGYWN0b3J5PFRQcm9wcz5gLFxcbmluc3RlYWQgYXBwbHkgdGhlIHByb3BzIHR5cGUgd2hlbiBzdWJjbGFzc2luZzpcXG5cXG5gYGBqc1xcbnR5cGUgUGVyc29uUHJvcHMgPSB7bmFtZTogc3RyaW5nLCBhZ2U6IG51bWJlcn07XFxuY29uc3QgZGVmYXVsdFZhbHVlczogUGVyc29uUHJvcHMgPSB7bmFtZTogJ0FyaXN0b3RsZScsIGFnZTogMjQwMH07XFxuY29uc3QgUGVyc29uUmVjb3JkID0gUmVjb3JkKGRlZmF1bHRWYWx1ZXMpO1xcbmNsYXNzIFBlcnNvbiBleHRlbmRzIFBlcnNvblJlY29yZDxQZXJzb25Qcm9wcz4ge1xcbiAgZ2V0TmFtZSgpOiBzdHJpbmcge1xcbiAgICByZXR1cm4gdGhpcy5nZXQoJ25hbWUnKVxcbiAgfVxcblxcbiAgc2V0TmFtZShuYW1lOiBzdHJpbmcpOiB0aGlzIHtcXG4gICAgcmV0dXJuIHRoaXMuc2V0KCduYW1lJywgbmFtZSk7XFxuICB9XFxufVxcbmBgYFxcblxcbioqQ2hvb3NpbmcgUmVjb3JkcyB2cyBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMqKlxcblxcblJlY29yZHMgb2ZmZXIgYSBwZXJzaXN0ZW50bHkgaW1tdXRhYmxlIGFsdGVybmF0aXZlIHRvIHBsYWluIEphdmFTY3JpcHRcXG5vYmplY3RzLCBob3dldmVyIHRoZXkncmUgbm90IHJlcXVpcmVkIHRvIGJlIHVzZWQgd2l0aGluIEltbXV0YWJsZS5qc1xcbmNvbGxlY3Rpb25zLiBJbiBmYWN0LCB0aGUgZGVlcC1hY2Nlc3MgYW5kIGRlZXAtdXBkYXRpbmcgZnVuY3Rpb25zXFxubGlrZSBgZ2V0SW4oKWAgYW5kIGBzZXRJbigpYCB3b3JrIHdpdGggcGxhaW4gSmF2YVNjcmlwdCBPYmplY3RzIGFzIHdlbGwuXFxuXFxuRGVjaWRpbmcgdG8gdXNlIFJlY29yZHMgb3IgT2JqZWN0cyBpbiB5b3VyIGFwcGxpY2F0aW9uIHNob3VsZCBiZSBpbmZvcm1lZFxcbmJ5IHRoZSB0cmFkZW9mZnMgYW5kIHJlbGF0aXZlIGJlbmVmaXRzIG9mIGVhY2g6XFxuXFxuLSAqUnVudGltZSBpbW11dGFiaWxpdHkqOiBwbGFpbiBKUyBvYmplY3RzIG1heSBiZSBjYXJlZnVsbHkgdHJlYXRlZCBhc1xcbiAgaW1tdXRhYmxlLCBob3dldmVyIFJlY29yZCBpbnN0YW5jZXMgd2lsbCAqdGhyb3cqIGlmIGF0dGVtcHRlZCB0byBiZVxcbiAgbXV0YXRlZCBkaXJlY3RseS4gUmVjb3JkcyBwcm92aWRlIHRoaXMgYWRkaXRpb25hbCBndWFyYW50ZWUsIGhvd2V2ZXIgYXRcXG4gIHNvbWUgbWFyZ2luYWwgcnVudGltZSBjb3N0LiBXaGlsZSBKUyBvYmplY3RzIGFyZSBtdXRhYmxlIGJ5IG5hdHVyZSwgdGhlXFxuICB1c2Ugb2YgdHlwZS1jaGVja2luZyB0b29scyBsaWtlIFtGbG93XShodHRwczovL21lZGl1bS5jb20vQGdjYW50aS9pbW11dGFiaWxpdHktd2l0aC1mbG93LWZhYTA1MGExYWVmNClcXG4gIGNhbiBoZWxwIGdhaW4gY29uZmlkZW5jZSBpbiBjb2RlIHdyaXR0ZW4gdG8gZmF2b3IgaW1tdXRhYmlsaXR5Llxcblxcbi0gKlZhbHVlIGVxdWFsaXR5KjogUmVjb3JkcyB1c2UgdmFsdWUgZXF1YWxpdHkgd2hlbiBjb21wYXJlZCB3aXRoIGBpcygpYFxcbiAgb3IgYHJlY29yZC5lcXVhbHMoKWAuIFRoYXQgaXMsIHR3byBSZWNvcmRzIHdpdGggdGhlIHNhbWUga2V5cyBhbmQgdmFsdWVzXFxuICBhcmUgZXF1YWwuIFBsYWluIG9iamVjdHMgdXNlICpyZWZlcmVuY2UgZXF1YWxpdHkqLiBUd28gb2JqZWN0cyB3aXRoIHRoZVxcbiAgc2FtZSBrZXlzIGFuZCB2YWx1ZXMgYXJlIG5vdCBlcXVhbCBzaW5jZSB0aGV5IGFyZSBkaWZmZXJlbnQgb2JqZWN0cy5cXG4gIFRoaXMgaXMgaW1wb3J0YW50IHRvIGNvbnNpZGVyIHdoZW4gdXNpbmcgb2JqZWN0cyBhcyBrZXlzIGluIGEgYE1hcGAgb3JcXG4gIHZhbHVlcyBpbiBhIGBTZXRgLCB3aGljaCB1c2UgZXF1YWxpdHkgd2hlbiByZXRyaWV2aW5nIHZhbHVlcy5cXG5cXG4tICpBUEkgbWV0aG9kcyo6IFJlY29yZHMgaGF2ZSBhIGZ1bGwgZmVhdHVyZWQgQVBJLCB3aXRoIG1ldGhvZHMgbGlrZVxcbiAgYC5nZXRJbigpYCwgYW5kIGAuZXF1YWxzKClgLiBUaGVzZSBjYW4gbWFrZSB3b3JraW5nIHdpdGggdGhlc2UgdmFsdWVzXFxuICBlYXNpZXIsIGJ1dCBjb21lcyBhdCB0aGUgY29zdCBvZiBub3QgYWxsb3dpbmcga2V5cyB3aXRoIHRob3NlIG5hbWVzLlxcblxcbi0gKkRlZmF1bHQgdmFsdWVzKjogUmVjb3JkcyBwcm92aWRlIGRlZmF1bHQgdmFsdWVzIGZvciBldmVyeSBrZXksIHdoaWNoXFxuICBjYW4gYmUgdXNlZnVsIHdoZW4gY29uc3RydWN0aW5nIFJlY29yZHMgd2l0aCBvZnRlbiB1bmNoYW5naW5nIHZhbHVlcy5cXG4gIEhvd2V2ZXIgZGVmYXVsdCB2YWx1ZXMgY2FuIG1ha2UgdXNpbmcgRmxvdyBhbmQgVHlwZVNjcmlwdCBtb3JlIGxhYm9yaW91cy5cXG5cXG4tICpTZXJpYWxpemF0aW9uKjogUmVjb3JkcyB1c2UgYSBjdXN0b20gaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gdG9cXG4gIGVmZmljaWVudGx5IHN0b3JlIGFuZCB1cGRhdGUgdGhlaXIgdmFsdWVzLiBDb252ZXJ0aW5nIHRvIGFuZCBmcm9tIHRoaXNcXG4gIGZvcm0gaXNuJ3QgZnJlZS4gSWYgY29udmVydGluZyBSZWNvcmRzIHRvIHBsYWluIG9iamVjdHMgaXMgY29tbW9uLFxcbiAgY29uc2lkZXIgc3RpY2tpbmcgd2l0aCBwbGFpbiBvYmplY3RzIHRvIGJlZ2luIHdpdGguXCIsXCJub3Rlc1wiOltdfSxcIm1vZHVsZVwiOntcImlzUmVjb3JkXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGBtYXliZVJlY29yZGAgaXMgYW4gaW5zdGFuY2Ugb2YgYSBSZWNvcmQuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlUmVjb3JkXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjoyMzY1fV19fSxcImdldERlc2NyaXB0aXZlTmFtZVwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmVjb3JkcyBhbGxvdyBwYXNzaW5nIGEgc2Vjb25kIHBhcmFtZXRlciB0byBzdXBwbHkgYSBkZXNjcmlwdGl2ZSBuYW1lXFxudGhhdCBhcHBlYXJzIHdoZW4gY29udmVydGluZyBhIFJlY29yZCB0byBhIHN0cmluZyBvciBpbiBhbnkgZXJyb3JcXG5tZXNzYWdlcy4gQSBkZXNjcmlwdGl2ZSBuYW1lIGZvciBhbnkgcmVjb3JkIGNhbiBiZSBhY2Nlc3NlZCBieSB1c2luZyB0aGlzXFxubWV0aG9kLiBJZiBvbmUgd2FzIG5vdCBwcm92aWRlZCwgdGhlIHN0cmluZyBcXFwiUmVjb3JkXFxcIiBpcyByZXR1cm5lZC5cIixcImRlc2NyaXB0aW9uXCI6XCJgYGBqc1xcbmNvbnN0IHsgUmVjb3JkIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IFBlcnNvbiA9IFJlY29yZCh7XFxuICBuYW1lOiBudWxsXFxufSwgJ1BlcnNvbicpXFxuXFxudmFyIG1lID0gUGVyc29uKHsgbmFtZTogJ015IE5hbWUnIH0pXFxubWUudG9TdHJpbmcoKSAvLyBcXFwiUGVyc29uIHsgXFxcIm5hbWVcXFwiOiBcXFwiTXkgTmFtZVxcXCIgfVxcXCJcXG5SZWNvcmQuZ2V0RGVzY3JpcHRpdmVOYW1lKG1lKSAvLyBcXFwiUGVyc29uXFxcIlxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJyZWNvcmRcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlJlY29yZFwiLFwiYXJnc1wiOlt7XCJrXCI6NCxcIm1lbWJlcnNcIjpbXX1dfX1dLFwidHlwZVwiOntcImtcIjozfSxcImxpbmVcIjoyMzg0fV19fSxcIkZhY3RvcnlcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQSBSZWNvcmQuRmFjdG9yeSBpcyBjcmVhdGVkIGJ5IHRoZSBgUmVjb3JkKClgIGZ1bmN0aW9uLiBSZWNvcmQgaW5zdGFuY2VzXFxuYXJlIGNyZWF0ZWQgYnkgcGFzc2luZyBpdCBzb21lIG9mIHRoZSBhY2NlcHRlZCB2YWx1ZXMgZm9yIHRoYXQgUmVjb3JkXFxudHlwZTpcIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBSZWNvcmQgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxcIiB9XFxuLS0+XFxuYGBganNcXG4vLyBtYWtlUGVyc29uIGlzIGEgUmVjb3JkIEZhY3RvcnkgZnVuY3Rpb25cXG5jb25zdCBtYWtlUGVyc29uID0gUmVjb3JkKHsgbmFtZTogbnVsbCwgZmF2b3JpdGVDb2xvcjogJ3Vua25vd24nIH0pO1xcblxcbi8vIGFsYW4gaXMgYSBSZWNvcmQgaW5zdGFuY2VcXG5jb25zdCBhbGFuID0gbWFrZVBlcnNvbih7IG5hbWU6ICdBbGFuJyB9KTtcXG5gYGBcXG5cXG5Ob3RlIHRoYXQgUmVjb3JkIEZhY3RvcmllcyByZXR1cm4gYFJlY29yZDxUUHJvcHM+ICYgUmVhZG9ubHk8VFByb3BzPmAsXFxudGhpcyBhbGxvd3MgdXNlIG9mIGJvdGggdGhlIFJlY29yZCBpbnN0YW5jZSBBUEksIGFuZCBkaXJlY3QgcHJvcGVydHlcXG5hY2Nlc3Mgb24gdGhlIHJlc3VsdGluZyBpbnN0YW5jZXM6XFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgUmVjb3JkIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtjb25zdCBtYWtlUGVyc29uID0gUmVjb3JkKHsgbmFtZTogbnVsbCwgZmF2b3JpdGVDb2xvcjogJ3Vua25vd24nIH0pO2NvbnN0IGFsYW4gPSBtYWtlUGVyc29uKHsgbmFtZTogJ0FsYW4nIH0pO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuLy8gVXNlIHRoZSBSZWNvcmQgQVBJXFxuY29uc29sZS5sb2coJ1JlY29yZCBBUEk6ICcgKyBhbGFuLmdldCgnbmFtZScpKVxcblxcbi8vIE9yIGRpcmVjdCBwcm9wZXJ0eSBhY2Nlc3MgKFJlYWRvbmx5KVxcbmNvbnNvbGUubG9nKCdwcm9wZXJ0eSBhY2Nlc3M6ICcgKyBhbGFuLm5hbWUpXFxuYGBgXFxuXFxuKipGbG93IFR5cGluZyBSZWNvcmRzOioqXFxuXFxuVXNlIHRoZSBgUmVjb3JkRmFjdG9yeTxUUHJvcHM+YCBGbG93IHR5cGUgdG8gZ2V0IGhpZ2ggcXVhbGl0eSB0eXBlIGNoZWNraW5nIG9mXFxuUmVjb3JkczpcXG5cXG5gYGBqc1xcbmltcG9ydCB0eXBlIHsgUmVjb3JkRmFjdG9yeSwgUmVjb3JkT2YgfSBmcm9tICdpbW11dGFibGUnO1xcblxcbi8vIFVzZSBSZWNvcmRGYWN0b3J5PFRQcm9wcz4gZm9yIGRlZmluaW5nIG5ldyBSZWNvcmQgZmFjdG9yeSBmdW5jdGlvbnMuXFxudHlwZSBQZXJzb25Qcm9wcyA9IHsgbmFtZTogP3N0cmluZywgZmF2b3JpdGVDb2xvcjogc3RyaW5nIH07XFxuY29uc3QgbWFrZVBlcnNvbjogUmVjb3JkRmFjdG9yeTxQZXJzb25Qcm9wcz4gPSBSZWNvcmQoeyBuYW1lOiBudWxsLCBmYXZvcml0ZUNvbG9yOiAndW5rbm93bicgfSk7XFxuXFxuLy8gVXNlIFJlY29yZE9mPFQ+IGZvciBkZWZpbmluZyBuZXcgaW5zdGFuY2VzIG9mIHRoYXQgUmVjb3JkLlxcbnR5cGUgUGVyc29uID0gUmVjb3JkT2Y8UGVyc29uUHJvcHM+O1xcbmNvbnN0IGFsYW46IFBlcnNvbiA9IG1ha2VQZXJzb24oeyBuYW1lOiAnQWxhbicgfSk7XFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcIm1vZHVsZVwiOnt9LFwiaW50ZXJmYWNlXCI6e1wibGluZVwiOjI0MzYsXCJ0eXBlUGFyYW1zXCI6W1wiVFByb3BzXCJdLFwiZ3JvdXBzXCI6W3tcIm1lbWJlcnNcIjp7XCIjZGlzcGxheU5hbWVcIjp7XCJsaW5lXCI6MjQ0NH19fV19LFwiY2FsbFwiOntcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRQcm9wc1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZXNcIixcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIlBhcnRpYWxcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9XX0se1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6M30se1wia1wiOjE3fV19XX1dfSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMyxcInR5cGVzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiUmVjb3JkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRQcm9wc1wifV19LHtcImtcIjo5LFwibmFtZVwiOlwiUmVhZG9ubHlcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9XX1dfSxcImxpbmVcIjoyNDQ3fV19fX0sXCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlVubGlrZSBvdGhlciB0eXBlcyBpbiBJbW11dGFibGUuanMsIHRoZSBgUmVjb3JkKClgIGZ1bmN0aW9uIGNyZWF0ZXMgYSBuZXdcXG5SZWNvcmQgRmFjdG9yeSwgd2hpY2ggaXMgYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgUmVjb3JkIGluc3RhbmNlcy5cIixcImRlc2NyaXB0aW9uXCI6XCJTZWUgYWJvdmUgZm9yIGV4YW1wbGVzIG9mIHVzaW5nIGBSZWNvcmQoKWAuXFxuXFxuTm90ZTogYFJlY29yZGAgaXMgYSBmYWN0b3J5IGZ1bmN0aW9uIGFuZCBub3QgYSBjbGFzcywgYW5kIGRvZXMgbm90IHVzZSB0aGVcXG5gbmV3YCBrZXl3b3JkIGR1cmluZyBjb25zdHJ1Y3Rpb24uXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRQcm9wc1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJkZWZhdWx0VmFsdWVzXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9fSx7XCJuYW1lXCI6XCJuYW1lXCIsXCJ0eXBlXCI6e1wia1wiOjN9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJSZWNvcmQuRmFjdG9yeVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn1dfSxcImxpbmVcIjoyNDU5fV19LFwiaW50ZXJmYWNlXCI6e1wibGluZVwiOjI0NjEsXCJ0eXBlUGFyYW1zXCI6W1wiVFByb3BzXCJdLFwiZ3JvdXBzXCI6W3tcInRpdGxlXCI6XCJSZWFkaW5nIHZhbHVlc1wiLFwibWVtYmVyc1wiOntcIiNoYXNcIjp7XCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6MjQ2NX1dfSxcIiNnZXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm92aWRlZCBrZXksIHdoaWNoIG1heSBiZSB0aGVcXG5kZWZhdWx0IHZhbHVlIGRlZmluZWQgd2hlbiBjcmVhdGluZyB0aGUgUmVjb3JkIGZhY3RvcnkgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiSWYgdGhlIHJlcXVlc3RlZCBrZXkgaXMgbm90IGRlZmluZWQgYnkgdGhpcyBSZWNvcmQgdHlwZSwgdGhlblxcbm5vdFNldFZhbHVlIHdpbGwgYmUgcmV0dXJuZWQgaWYgcHJvdmlkZWQuIE5vdGUgdGhhdCB0aGlzIHNjZW5hcmlvIHdvdWxkXFxucHJvZHVjZSBhbiBlcnJvciB3aGVuIHVzaW5nIEZsb3cgb3IgVHlwZVNjcmlwdC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTUsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9LFwiaW5kZXhcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSxcImxpbmVcIjoyNDc1fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319LHtcIm5hbWVcIjpcIm5vdFNldFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0sXCJsaW5lXCI6MjQ3Nn1dfX19LHtcInRpdGxlXCI6XCJSZWFkaW5nIGRlZXAgdmFsdWVzXCIsXCJtZW1iZXJzXCI6e1wiI2hhc0luXCI6e1wic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5UGF0aFwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjI0ODB9XX0sXCIjZ2V0SW5cIjp7XCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlQYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX19XSxcInR5cGVcIjp7XCJrXCI6MTd9LFwibGluZVwiOjI0ODF9XX19fSx7XCJ0aXRsZVwiOlwiVmFsdWUgZXF1YWxpdHlcIixcIm1lbWJlcnNcIjp7XCIjZXF1YWxzXCI6e1wic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib3RoZXJcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjI0ODV9XX0sXCIjaGFzaENvZGVcIjp7XCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6Mn0sXCJsaW5lXCI6MjQ4Nn1dfX19LHtcInRpdGxlXCI6XCJQZXJzaXN0ZW50IGNoYW5nZXNcIixcIm1lbWJlcnNcIjp7XCIjc2V0XCI6e1wic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxNSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn0sXCJpbmRleFwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoyNDkwfV19LFwiI3VwZGF0ZVwiOntcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE1LFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRQcm9wc1wifSxcImluZGV4XCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX19XSxcInR5cGVcIjp7XCJrXCI6MTUsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9LFwiaW5kZXhcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fX19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjI0OTF9XX0sXCIjbWVyZ2VcIjp7XCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJQYXJ0aWFsXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRQcm9wc1wifV19LHtcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjN9LHtcImtcIjoxN31dfV19XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoyNDkyfV19LFwiI21lcmdlRGVlcFwiOntcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIlBhcnRpYWxcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9XX0se1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6M30se1wia1wiOjE3fV19XX1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjI0OTN9XX0sXCIjbWVyZ2VXaXRoXCI6e1wic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWVyZ2VyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib2xkVmFsXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX0se1wibmFtZVwiOlwibmV3VmFsXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjE2LFwib3BlcmF0b3JcIjpcImtleW9mXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9fX1dLFwidHlwZVwiOntcImtcIjoxN319fSx7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJQYXJ0aWFsXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRQcm9wc1wifV19LHtcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjN9LHtcImtcIjoxN31dfV19XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoyNDk1fV19LFwiI21lcmdlRGVlcFdpdGhcIjp7XCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtZXJnZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvbGRWYWxcIixcInR5cGVcIjp7XCJrXCI6MTd9fSx7XCJuYW1lXCI6XCJuZXdWYWxcIixcInR5cGVcIjp7XCJrXCI6MTd9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19LHtcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIlBhcnRpYWxcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9XX0se1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6M30se1wia1wiOjE3fV19XX1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjI0OTl9XX0sXCIjZGVsZXRlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhpcyBSZWNvcmQgdHlwZSB3aXRoIHRoZSB2YWx1ZSBmb3IgdGhlXFxuc3BlY2lmaWMga2V5IHNldCB0byBpdHMgZGVmYXVsdCB2YWx1ZS5cXG5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcImFsaWFzXCIsXCJib2R5XCI6XCJyZW1vdmVcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MjUxMH1dfSxcIiNjbGVhclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIHRoaXMgUmVjb3JkIHR5cGUgd2l0aCBhbGwgdmFsdWVzIHNldFxcbnRvIHRoZWlyIGRlZmF1bHQgdmFsdWVzLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjI1MTd9XX19fSx7XCJ0aXRsZVwiOlwiRGVlcCBwZXJzaXN0ZW50IGNoYW5nZXNcIixcIm1lbWJlcnNcIjp7XCIjc2V0SW5cIjp7XCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlQYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MjUyMX1dfSxcIiN1cGRhdGVJblwiOntcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX0se1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxN319fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoyNTIyfV19LFwiI21lcmdlSW5cIjp7XCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlQYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX19LHtcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MjUyM31dfSxcIiNtZXJnZURlZXBJblwiOntcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX0se1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoyNTI0fV19LFwiI2RlbGV0ZUluXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwiYWxpYXNcIixcImJvZHlcIjpcInJlbW92ZUluXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlQYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjI1Mjl9XX19fSx7XCJ0aXRsZVwiOlwiQ29udmVyc2lvbiB0byBKYXZhU2NyaXB0IHR5cGVzXCIsXCJtZW1iZXJzXCI6e1wiI3RvSlNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRGVlcGx5IGNvbnZlcnRzIHRoaXMgUmVjb3JkIHRvIGVxdWl2YWxlbnQgbmF0aXZlIEphdmFTY3JpcHQgT2JqZWN0LlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IFRoaXMgbWV0aG9kIG1heSBub3QgYmUgb3ZlcnJpZGRlbi4gT2JqZWN0cyB3aXRoIGN1c3RvbVxcbnNlcmlhbGl6YXRpb24gdG8gcGxhaW4gSlMgbWF5IG92ZXJyaWRlIHRvSlNPTigpIGluc3RlYWQuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX1dfSxcImxpbmVcIjoyNTQwfV19LFwiI3RvSlNPTlwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJTaGFsbG93bHkgY29udmVydHMgdGhpcyBSZWNvcmQgdG8gZXF1aXZhbGVudCBuYXRpdmUgSmF2YVNjcmlwdCBPYmplY3QuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRQcm9wc1wifSxcImxpbmVcIjoyNTQ1fV19LFwiI3RvT2JqZWN0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNoYWxsb3dseSBjb252ZXJ0cyB0aGlzIFJlY29yZCB0byBlcXVpdmFsZW50IEphdmFTY3JpcHQgT2JqZWN0LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn0sXCJsaW5lXCI6MjU1MH1dfX19LHtcInRpdGxlXCI6XCJUcmFuc2llbnQgY2hhbmdlc1wiLFwibWVtYmVyc1wiOntcIiN3aXRoTXV0YXRpb25zXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIk5vdGU6IE5vdCBhbGwgbWV0aG9kcyBjYW4gYmUgdXNlZCBvbiBhIG11dGFibGUgY29sbGVjdGlvbiBvciB3aXRoaW5cXG5gd2l0aE11dGF0aW9uc2AhIE9ubHkgYHNldGAgbWF5IGJlIHVzZWQgbXV0YXRpdmVseS5cXG5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiYE1hcCN3aXRoTXV0YXRpb25zYFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibXV0YXRvclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm11dGFibGVcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjI1NjB9XX0sXCIjYXNNdXRhYmxlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI2FzTXV0YWJsZWBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MjU2NX1dfSxcIiN3YXNBbHRlcmVkXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI3dhc0FsdGVyZWRgXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6MjU3MH1dfSxcIiNhc0ltbXV0YWJsZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiYE1hcCNhc0ltbXV0YWJsZWBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MjU3NX1dfX19LHtcInRpdGxlXCI6XCJTZXF1ZW5jZSBhbGdvcml0aG1zXCIsXCJtZW1iZXJzXCI6e1wiI3RvU2VxXCI6e1wic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjE2LFwib3BlcmF0b3JcIjpcImtleW9mXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9fSx7XCJrXCI6MTUsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9LFwiaW5kZXhcIjp7XCJrXCI6MTYsXCJvcGVyYXRvclwiOlwia2V5b2ZcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn19fV19LFwibGluZVwiOjI1Nzl9XX0sXCIjW1N5bWJvbC5pdGVyYXRvcl1cIjp7XCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlSXRlcmF0b3JcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjE2LFwib3BlcmF0b3JcIjpcImtleW9mXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9fSx7XCJrXCI6MTUsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9LFwiaW5kZXhcIjp7XCJrXCI6MTYsXCJvcGVyYXRvclwiOlwia2V5b2ZcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn19fV19XX0sXCJsaW5lXCI6MjU4MX1dfX19XX19LFwiU2VxXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcImBTZXFgIGRlc2NyaWJlcyBhIGxhenkgb3BlcmF0aW9uLCBhbGxvd2luZyB0aGVtIHRvIGVmZmljaWVudGx5IGNoYWluXFxudXNlIG9mIGFsbCB0aGUgaGlnaGVyLW9yZGVyIGNvbGxlY3Rpb24gbWV0aG9kcyAoc3VjaCBhcyBgbWFwYCBhbmQgYGZpbHRlcmApXFxuYnkgbm90IGNyZWF0aW5nIGludGVybWVkaWF0ZSBjb2xsZWN0aW9ucy5cIixcImRlc2NyaXB0aW9uXCI6XCIqKlNlcSBpcyBpbW11dGFibGUqKiDigJQgT25jZSBhIFNlcSBpcyBjcmVhdGVkLCBpdCBjYW5ub3QgYmVcXG5jaGFuZ2VkLCBhcHBlbmRlZCB0bywgcmVhcnJhbmdlZCBvciBvdGhlcndpc2UgbW9kaWZpZWQuIEluc3RlYWQsIGFueVxcbm11dGF0aXZlIG1ldGhvZCBjYWxsZWQgb24gYSBgU2VxYCB3aWxsIHJldHVybiBhIG5ldyBgU2VxYC5cXG5cXG4qKlNlcSBpcyBsYXp5Kiog4oCUIGBTZXFgIGRvZXMgYXMgbGl0dGxlIHdvcmsgYXMgbmVjZXNzYXJ5IHRvIHJlc3BvbmQgdG8gYW55XFxubWV0aG9kIGNhbGwuIFZhbHVlcyBhcmUgb2Z0ZW4gY3JlYXRlZCBkdXJpbmcgaXRlcmF0aW9uLCBpbmNsdWRpbmcgaW1wbGljaXRcXG5pdGVyYXRpb24gd2hlbiByZWR1Y2luZyBvciBjb252ZXJ0aW5nIHRvIGEgY29uY3JldGUgZGF0YSBzdHJ1Y3R1cmUgc3VjaCBhc1xcbmEgYExpc3RgIG9yIEphdmFTY3JpcHQgYEFycmF5YC5cXG5cXG5Gb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZyBwZXJmb3JtcyBubyB3b3JrLCBiZWNhdXNlIHRoZSByZXN1bHRpbmdcXG5gU2VxYCdzIHZhbHVlcyBhcmUgbmV2ZXIgaXRlcmF0ZWQ6XFxuXFxuYGBganNcXG5jb25zdCB7IFNlcSB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBvZGRTcXVhcmVzID0gU2VxKFsgMSwgMiwgMywgNCwgNSwgNiwgNywgOCBdKVxcbiAgLmZpbHRlcih4ID0+IHggJSAyICE9PSAwKVxcbiAgLm1hcCh4ID0+IHggKiB4KVxcbmBgYFxcblxcbk9uY2UgdGhlIGBTZXFgIGlzIHVzZWQsIGl0IHBlcmZvcm1zIG9ubHkgdGhlIHdvcmsgbmVjZXNzYXJ5LiBJbiB0aGlzXFxuZXhhbXBsZSwgbm8gaW50ZXJtZWRpYXRlIGFycmF5cyBhcmUgZXZlciBjcmVhdGVkLCBmaWx0ZXIgaXMgY2FsbGVkIHRocmVlXFxudGltZXMsIGFuZCBtYXAgaXMgb25seSBjYWxsZWQgb25jZTpcXG5cXG5gYGBqc1xcbm9kZFNxdWFyZXMuZ2V0KDEpOyAvLyA5XFxuYGBgXFxuXFxuQW55IGNvbGxlY3Rpb24gY2FuIGJlIGNvbnZlcnRlZCB0byBhIGxhenkgU2VxIHdpdGggYFNlcSgpYC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG1hcCA9IE1hcCh7IGE6IDEsIGI6IDIsIGM6IDMgfSlcXG5jb25zdCBsYXp5U2VxID0gU2VxKG1hcClcXG5gYGBcXG5cXG5gU2VxYCBhbGxvd3MgZm9yIHRoZSBlZmZpY2llbnQgY2hhaW5pbmcgb2Ygb3BlcmF0aW9ucywgYWxsb3dpbmcgZm9yIHRoZVxcbmV4cHJlc3Npb24gb2YgbG9naWMgdGhhdCBjYW4gb3RoZXJ3aXNlIGJlIHZlcnkgdGVkaW91czpcXG5cXG5gYGBqc1xcbmxhenlTZXFcXG4gIC5mbGlwKClcXG4gIC5tYXAoa2V5ID0+IGtleS50b1VwcGVyQ2FzZSgpKVxcbiAgLmZsaXAoKVxcbi8vIFNlcSB7IEE6IDEsIEI6IDEsIEM6IDEgfVxcbmBgYFxcblxcbkFzIHdlbGwgYXMgZXhwcmVzc2luZyBsb2dpYyB0aGF0IHdvdWxkIG90aGVyd2lzZSBzZWVtIG1lbW9yeSBvciB0aW1lXFxubGltaXRlZCwgZm9yIGV4YW1wbGUgYFJhbmdlYCBpcyBhIHNwZWNpYWwga2luZCBvZiBMYXp5IHNlcXVlbmNlLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBSYW5nZSB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5SYW5nZSgxLCBJbmZpbml0eSlcXG4gIC5za2lwKDEwMDApXFxuICAubWFwKG4gPT4gLW4pXFxuICAuZmlsdGVyKG4gPT4gbiAlIDIgPT09IDApXFxuICAudGFrZSgyKVxcbiAgLnJlZHVjZSgociwgbikgPT4gciAqIG4sIDEpXFxuLy8gMTAwNjAwOFxcbmBgYFxcblxcblNlcSBpcyBvZnRlbiB1c2VkIHRvIHByb3ZpZGUgYSByaWNoIGNvbGxlY3Rpb24gQVBJIHRvIEphdmFTY3JpcHQgT2JqZWN0LlxcblxcbmBgYGpzXFxuU2VxKHsgeDogMCwgeTogMSwgejogMiB9KS5tYXAodiA9PiB2ICogMikudG9PYmplY3QoKTtcXG4vLyB7IHg6IDAsIHk6IDIsIHo6IDQgfVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJtb2R1bGVcIjp7XCJpc1NlcVwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVTZXFgIGlzIGEgU2VxLCBpdCBpcyBub3QgYmFja2VkIGJ5IGEgY29uY3JldGVcXG5zdHJ1Y3R1cmUgc3VjaCBhcyBNYXAsIExpc3QsIG9yIFNldC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVTZXFcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjI2NzN9XX19LFwiS2V5ZWRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiYFNlcWAgd2hpY2ggcmVwcmVzZW50cyBrZXktdmFsdWUgcGFpcnMuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcIm1vZHVsZVwiOnt9LFwiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJBbHdheXMgcmV0dXJucyBhIFNlcS5LZXllZCwgaWYgaW5wdXQgaXMgbm90IGtleWVkLCBleHBlY3RzIGFuXFxuY29sbGVjdGlvbiBvZiBbSywgVl0gdHVwbGVzLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBTZXEuS2V5ZWRgIGlzIGEgY29udmVyc2lvbiBmdW5jdGlvbiBhbmQgbm90IGEgY2xhc3MsIGFuZCBkb2VzIG5vdFxcbnVzZSB0aGUgYG5ld2Aga2V5d29yZCBkdXJpbmcgY29uc3RydWN0aW9uLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjoyNjg4fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvYmpcIixcInR5cGVcIjp7XCJrXCI6NCxcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6M30se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjI2ODl9LHtcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCJdLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjI2OTB9LHtcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfSxcImxpbmVcIjoyNjkxfV19LFwiaW50ZXJmYWNlXCI6e1wibGluZVwiOjI2OTMsXCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiXSxcImV4dGVuZHNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJTZXFcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0se1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XSxcImdyb3Vwc1wiOlt7XCJtZW1iZXJzXCI6e1wiI3RvSlNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRGVlcGx5IGNvbnZlcnRzIHRoaXMgS2V5ZWQgU2VxIHRvIGVxdWl2YWxlbnQgbmF0aXZlIEphdmFTY3JpcHQgT2JqZWN0LlwiLFwiZGVzY3JpcHRpb25cIjpcIkNvbnZlcnRzIGtleXMgdG8gU3RyaW5ncy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPYmplY3RcIn0sXCJsaW5lXCI6MjY5OX1dfSxcIiN0b0pTT05cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiU2hhbGxvd2x5IGNvbnZlcnRzIHRoaXMgS2V5ZWQgU2VxIHRvIGVxdWl2YWxlbnQgbmF0aXZlIEphdmFTY3JpcHQgT2JqZWN0LlwiLFwiZGVzY3JpcHRpb25cIjpcIkNvbnZlcnRzIGtleXMgdG8gU3RyaW5ncy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV19LFwibGluZVwiOjI3MDZ9XX0sXCIjdG9BcnJheVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJTaGFsbG93bHkgY29udmVydHMgdGhpcyBjb2xsZWN0aW9uIHRvIGFuIEFycmF5LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XX0sXCJsaW5lXCI6MjcxMX1dfSxcIiN0b1NlcVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGl0c2VsZlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjI3MTZ9XX0sXCIjY29uY2F0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU2VxIHdpdGggb3RoZXIgY29sbGVjdGlvbnMgY29uY2F0ZW5hdGVkIHRvIHRoaXMgb25lLlwiLFwiZGVzY3JpcHRpb25cIjpcIkFsbCBlbnRyaWVzIHdpbGwgYmUgcHJlc2VudCBpbiB0aGUgcmVzdWx0aW5nIFNlcSwgZXZlbiBpZiB0aGV5XFxuaGF2ZSB0aGUgc2FtZSBrZXkuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktDXCIsXCJWQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLQ1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWQ1wifV19XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJLQ1wifV19LHtcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVkNcIn1dfV19LFwibGluZVwiOjI3MjR9LHtcInR5cGVQYXJhbXNcIjpbXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6NCxcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6M31dfSx7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIkNcIn1dfV19LFwibGluZVwiOjI3MjV9XX0sXCIjbWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU2VxLktleWVkIHdpdGggdmFsdWVzIHBhc3NlZCB0aHJvdWdoIGFcXG5gbWFwcGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJgYGBqc1xcbmNvbnN0IHsgU2VxIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcblNlcS5LZXllZCh7IGE6IDEsIGI6IDIgfSkubWFwKHggPT4gMTAgKiB4KVxcbi8vIFNlcSB7IFxcXCJhXFxcIjogMTAsIFxcXCJiXFxcIjogMjAgfVxcbmBgYFxcblxcbk5vdGU6IGBtYXAoKWAgYWx3YXlzIHJldHVybnMgYSBuZXcgaW5zdGFuY2UsIGV2ZW4gaWYgaXQgcHJvZHVjZWQgdGhlXFxuc2FtZSB2YWx1ZSBhdCBldmVyeSBzdGVwLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjoyNzQwfV19LFwiI21hcEtleXNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcIkNvbGxlY3Rpb24uS2V5ZWQubWFwS2V5c1wifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6Mjc0OH1dfSxcIiNtYXBFbnRyaWVzXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJDb2xsZWN0aW9uLktleWVkLm1hcEVudHJpZXNcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktNXCIsXCJWTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJlbnRyeVwiLFwidHlwZVwiOntcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19fSx7XCJuYW1lXCI6XCJpbmRleFwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLTVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWTVwifV19fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLTVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWTVwifV19LFwibGluZVwiOjI3NTZ9XX0sXCIjZmxhdE1hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJGbGF0LW1hcHMgdGhlIFNlcSwgcmV0dXJuaW5nIGEgU2VxIG9mIHRoZSBzYW1lIHR5cGUuXCIsXCJkZXNjcmlwdGlvblwiOlwiU2ltaWxhciB0byBgc2VxLm1hcCguLi4pLmZsYXR0ZW4odHJ1ZSlgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJLTVwiLFwiVk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS01cIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVk1cIn1dfV19fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLTVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWTVwifV19LFwibGluZVwiOjI3NjZ9XX0sXCIjZmlsdGVyXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU2VxIHdpdGggb25seSB0aGUgZW50cmllcyBmb3Igd2hpY2ggdGhlIGBwcmVkaWNhdGVgXFxuZnVuY3Rpb24gcmV0dXJucyB0cnVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBmaWx0ZXIoKWAgYWx3YXlzIHJldHVybnMgYSBuZXcgaW5zdGFuY2UsIGV2ZW4gaWYgaXQgcmVzdWx0cyBpblxcbm5vdCBmaWx0ZXJpbmcgb3V0IGFueSB2YWx1ZXMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJGXCJ9XX0sXCJsaW5lXCI6Mjc3OH0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MTd9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjI3ODJ9XX0sXCIjZmxpcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiQ29sbGVjdGlvbi5LZXllZC5mbGlwXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIktcIn1dfSxcImxpbmVcIjoyNzkwfV19fX1dfX0sXCJJbmRleGVkXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcImBTZXFgIHdoaWNoIHJlcHJlc2VudHMgYW4gb3JkZXJlZCBpbmRleGVkIGxpc3Qgb2YgdmFsdWVzLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJtb2R1bGVcIjp7XCJvZlwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUHJvdmlkZXMgYW4gU2VxLkluZGV4ZWQgb2YgdGhlIHZhbHVlcyBwcm92aWRlZC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZXNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MjgwMn1dfX19LFwiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJBbHdheXMgcmV0dXJucyBTZXEuSW5kZXhlZCwgZGlzY2FyZGluZyBhc3NvY2lhdGVkIGtleXMgYW5kXFxuc3VwcGx5aW5nIGluY3JlbWVudGluZyBpbmRpY2VzLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBTZXEuSW5kZXhlZGAgaXMgYSBjb252ZXJzaW9uIGZ1bmN0aW9uIGFuZCBub3QgYSBjbGFzcywgYW5kIGRvZXNcXG5ub3QgdXNlIHRoZSBgbmV3YCBrZXl3b3JkIGR1cmluZyBjb25zdHJ1Y3Rpb24uXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwibGluZVwiOjI4MTJ9LHtcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjI4MTN9LHtcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjI4MTR9XX0sXCJpbnRlcmZhY2VcIjp7XCJsaW5lXCI6MjgxNixcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwiZXh0ZW5kc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcVwiLFwiYXJnc1wiOlt7XCJrXCI6Mn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LHtcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfV0sXCJncm91cHNcIjpbe1wibWVtYmVyc1wiOntcIiN0b0pTXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkRlZXBseSBjb252ZXJ0cyB0aGlzIEluZGV4ZWQgU2VxIHRvIGVxdWl2YWxlbnQgbmF0aXZlIEphdmFTY3JpcHQgQXJyYXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwibGluZVwiOjI4MjB9XX0sXCIjdG9KU09OXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNoYWxsb3dseSBjb252ZXJ0cyB0aGlzIEluZGV4ZWQgU2VxIHRvIGVxdWl2YWxlbnQgbmF0aXZlIEphdmFTY3JpcHQgQXJyYXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjI4MjV9XX0sXCIjdG9BcnJheVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJTaGFsbG93bHkgY29udmVydHMgdGhpcyBjb2xsZWN0aW9uIHRvIGFuIEFycmF5LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoyODMwfV19LFwiI3RvU2VxXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgaXRzZWxmXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MjgzNX1dfSxcIiNjb25jYXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBTZXEgd2l0aCBvdGhlciBjb2xsZWN0aW9ucyBjb25jYXRlbmF0ZWQgdG8gdGhpcyBvbmUuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVzT3JDb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9XX0se1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9XX1dfSxcImxpbmVcIjoyODQwfV19LFwiI21hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFNlcS5JbmRleGVkIHdpdGggdmFsdWVzIHBhc3NlZCB0aHJvdWdoIGFcXG5gbWFwcGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJgYGBqc1xcbmNvbnN0IHsgU2VxIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcblNlcS5JbmRleGVkKFsgMSwgMiBdKS5tYXAoeCA9PiAxMCAqIHgpXFxuLy8gU2VxIFsgMTAsIDIwIF1cXG5gYGBcXG5cXG5Ob3RlOiBgbWFwKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHByb2R1Y2VkIHRoZVxcbnNhbWUgdmFsdWUgYXQgZXZlcnkgc3RlcC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjoyODU1fV19LFwiI2ZsYXRNYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRmxhdC1tYXBzIHRoZSBTZXEsIHJldHVybmluZyBhIGEgU2VxIG9mIHRoZSBzYW1lIHR5cGUuXCIsXCJkZXNjcmlwdGlvblwiOlwiU2ltaWxhciB0byBgc2VxLm1hcCguLi4pLmZsYXR0ZW4odHJ1ZSlgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjoyODY1fV19LFwiI2ZpbHRlclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFNlcSB3aXRoIG9ubHkgdGhlIHZhbHVlcyBmb3Igd2hpY2ggdGhlIGBwcmVkaWNhdGVgXFxuZnVuY3Rpb24gcmV0dXJucyB0cnVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBmaWx0ZXIoKWAgYWx3YXlzIHJldHVybnMgYSBuZXcgaW5zdGFuY2UsIGV2ZW4gaWYgaXQgcmVzdWx0cyBpblxcbm5vdCBmaWx0ZXJpbmcgb3V0IGFueSB2YWx1ZXMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJpbmRleFwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiRlwifV19LFwibGluZVwiOjI4Nzd9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxN319fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6Mjg4MX1dfSxcIiN6aXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIFNlcSBcXFwiemlwcGVkXFxcIiB3aXRoIHRoZSBwcm92aWRlZCBjb2xsZWN0aW9ucy5cIixcImRlc2NyaXB0aW9uXCI6XCJMaWtlIGB6aXBXaXRoYCwgYnV0IHVzaW5nIHRoZSBkZWZhdWx0IGB6aXBwZXJgOiBjcmVhdGluZyBhbiBgQXJyYXlgLlxcblxcbmBgYGpzXFxuY29uc3QgYSA9IFNlcShbIDEsIDIsIDMgXSk7XFxuY29uc3QgYiA9IFNlcShbIDQsIDUsIDYgXSk7XFxuY29uc3QgYyA9IGEuemlwKGIpOyAvLyBTZXEgWyBbIDEsIDQgXSwgWyAyLCA1IF0sIFsgMywgNiBdIF1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlclwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX1dfSxcImxpbmVcIjoyODk3fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiLFwiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlclwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX0se1wibmFtZVwiOlwib3RoZXIyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XX0sXCJsaW5lXCI6Mjg5OH0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6MTd9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJsaW5lXCI6Mjg5OX1dfSxcIiN6aXBBbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIFNlcSBcXFwiemlwcGVkXFxcIiB3aXRoIHRoZSBwcm92aWRlZCBjb2xsZWN0aW9ucy5cIixcImRlc2NyaXB0aW9uXCI6XCJVbmxpa2UgYHppcGAsIGB6aXBBbGxgIGNvbnRpbnVlcyB6aXBwaW5nIHVudGlsIHRoZSBsb25nZXN0IGNvbGxlY3Rpb24gaXNcXG5leGhhdXN0ZWQuIE1pc3NpbmcgdmFsdWVzIGZyb20gc2hvcnRlciBjb2xsZWN0aW9ucyBhcmUgZmlsbGVkIHdpdGggYHVuZGVmaW5lZGAuXFxuXFxuYGBganNcXG5jb25zdCBhID0gU2VxKFsgMSwgMiBdKTtcXG5jb25zdCBiID0gU2VxKFsgMywgNCwgNSBdKTtcXG5jb25zdCBjID0gYS56aXBBbGwoYik7IC8vIFNlcSBbIFsgMSwgMyBdLCBbIDIsIDQgXSwgWyB1bmRlZmluZWQsIDUgXSBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlVcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib3RoZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19XX0sXCJsaW5lXCI6MjkxM30se1widHlwZVBhcmFtc1wiOltcIlVcIixcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib3RoZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19LHtcIm5hbWVcIjpcIm90aGVyMlwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfV19LFwibGluZVwiOjI5MTR9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwibGluZVwiOjI5MTV9XX0sXCIjemlwV2l0aFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgU2VxIFxcXCJ6aXBwZWRcXFwiIHdpdGggdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb25zIGJ5IHVzaW5nIGFcXG5jdXN0b20gYHppcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiYGBganNcXG5jb25zdCBhID0gU2VxKFsgMSwgMiwgMyBdKTtcXG5jb25zdCBiID0gU2VxKFsgNCwgNSwgNiBdKTtcXG5jb25zdCBjID0gYS56aXBXaXRoKChhLCBiKSA9PiBhICsgYiwgYik7XFxuLy8gU2VxIFsgNSwgNywgOSBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlVcIixcIlpcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiemlwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJvdGhlclZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlpcIn19fSx7XCJuYW1lXCI6XCJvdGhlckNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlpcIn1dfSxcImxpbmVcIjoyOTI4fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiLFwiVlwiLFwiWlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ6aXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIm90aGVyVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9fSx7XCJuYW1lXCI6XCJ0aGlyZFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlpcIn19fSx7XCJuYW1lXCI6XCJvdGhlckNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19LHtcIm5hbWVcIjpcInRoaXJkQ29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifV19LFwibGluZVwiOjI5MzJ9LHtcInR5cGVQYXJhbXNcIjpbXCJaXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInppcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImFueVwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9fX0se1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlpcIn1dfSxcImxpbmVcIjoyOTM3fV19fX1dfX0sXCJTZXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiYFNlcWAgd2hpY2ggcmVwcmVzZW50cyBhIHNldCBvZiB2YWx1ZXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiQmVjYXVzZSBgU2VxYCBhcmUgb2Z0ZW4gbGF6eSwgYFNlcS5TZXRgIGRvZXMgbm90IHByb3ZpZGUgdGhlIHNhbWUgZ3VhcmFudGVlXFxub2YgdmFsdWUgdW5pcXVlbmVzcyBhcyB0aGUgY29uY3JldGUgYFNldGAuXCIsXCJub3Rlc1wiOltdfSxcIm1vZHVsZVwiOntcIm9mXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgU2VxLlNldCBvZiB0aGUgcHJvdmlkZWQgdmFsdWVzXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVzXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6Mjk1NX1dfX19LFwiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJBbHdheXMgcmV0dXJucyBhIFNlcS5TZXQsIGRpc2NhcmRpbmcgYXNzb2NpYXRlZCBpbmRpY2VzIG9yIGtleXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYFNlcS5TZXRgIGlzIGEgY29udmVyc2lvbiBmdW5jdGlvbiBhbmQgbm90IGEgY2xhc3MsIGFuZCBkb2VzIG5vdFxcbnVzZSB0aGUgYG5ld2Aga2V5d29yZCBkdXJpbmcgY29uc3RydWN0aW9uLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5TZXRcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwibGluZVwiOjI5NjR9LHtcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6Mjk2NX0se1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoyOTY2fV19LFwiaW50ZXJmYWNlXCI6e1wibGluZVwiOjI5NjgsXCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcImV4dGVuZHNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJTZXFcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0se1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX1dLFwiZ3JvdXBzXCI6W3tcIm1lbWJlcnNcIjp7XCIjdG9KU1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJEZWVwbHkgY29udmVydHMgdGhpcyBTZXQgU2VxIHRvIGVxdWl2YWxlbnQgbmF0aXZlIEphdmFTY3JpcHQgQXJyYXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwibGluZVwiOjI5NzJ9XX0sXCIjdG9KU09OXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNoYWxsb3dseSBjb252ZXJ0cyB0aGlzIFNldCBTZXEgdG8gZXF1aXZhbGVudCBuYXRpdmUgSmF2YVNjcmlwdCBBcnJheS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6Mjk3N31dfSxcIiN0b0FycmF5XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNoYWxsb3dseSBjb252ZXJ0cyB0aGlzIGNvbGxlY3Rpb24gdG8gYW4gQXJyYXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjI5ODJ9XX0sXCIjdG9TZXFcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBpdHNlbGZcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoyOTg3fV19LFwiI2NvbmNhdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFNlcSB3aXRoIG90aGVyIGNvbGxlY3Rpb25zIGNvbmNhdGVuYXRlZCB0byB0aGlzIG9uZS5cIixcImRlc2NyaXB0aW9uXCI6XCJBbGwgZW50cmllcyB3aWxsIGJlIHByZXNlbnQgaW4gdGhlIHJlc3VsdGluZyBTZXEsIGV2ZW4gaWYgdGhleVxcbmFyZSBkdXBsaWNhdGVzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJVXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5TZXRcIixcImFyZ3NcIjpbe1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX1dfSxcImxpbmVcIjoyOTk1fV19LFwiI21hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFNlcS5TZXQgd2l0aCB2YWx1ZXMgcGFzc2VkIHRocm91Z2ggYVxcbmBtYXBwZXJgIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcImBgYGpzXFxuU2VxLlNldChbIDEsIDIgXSkubWFwKHggPT4gMTAgKiB4KVxcbi8vIFNlcSB7IDEwLCAyMCB9XFxuYGBgXFxuXFxuTm90ZTogYG1hcCgpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCBwcm9kdWNlZCB0aGVcXG5zYW1lIHZhbHVlIGF0IGV2ZXJ5IHN0ZXAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk1cIn19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6MzAwOX1dfSxcIiNmbGF0TWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkZsYXQtbWFwcyB0aGUgU2VxLCByZXR1cm5pbmcgYSBTZXEgb2YgdGhlIHNhbWUgdHlwZS5cIixcImRlc2NyaXB0aW9uXCI6XCJTaW1pbGFyIHRvIGBzZXEubWFwKC4uLikuZmxhdHRlbih0cnVlKWAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5TZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjMwMTl9XX0sXCIjZmlsdGVyXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU2VxIHdpdGggb25seSB0aGUgdmFsdWVzIGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWBcXG5mdW5jdGlvbiByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYGZpbHRlcigpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCByZXN1bHRzIGluXFxubm90IGZpbHRlcmluZyBvdXQgYW55IHZhbHVlcy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiRlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5TZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiRlwifV19LFwibGluZVwiOjMwMzF9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjozMDM1fV19fX1dfX19LFwiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDcmVhdGVzIGEgU2VxLlwiLFwiZGVzY3JpcHRpb25cIjpcIlJldHVybnMgYSBwYXJ0aWN1bGFyIGtpbmQgb2YgYFNlcWAgYmFzZWQgb24gdGhlIGlucHV0LlxcblxcbiAgKiBJZiBhIGBTZXFgLCB0aGF0IHNhbWUgYFNlcWAuXFxuICAqIElmIGFuIGBDb2xsZWN0aW9uYCwgYSBgU2VxYCBvZiB0aGUgc2FtZSBraW5kIChLZXllZCwgSW5kZXhlZCwgb3IgU2V0KS5cXG4gICogSWYgYW4gQXJyYXktbGlrZSwgYW4gYFNlcS5JbmRleGVkYC5cXG4gICogSWYgYW4gSXRlcmFibGUgT2JqZWN0LCBhbiBgU2VxLkluZGV4ZWRgLlxcbiAgKiBJZiBhbiBPYmplY3QsIGEgYFNlcS5LZXllZGAuXFxuXFxuTm90ZTogQW4gSXRlcmF0b3IgaXRzZWxmIHdpbGwgYmUgdHJlYXRlZCBhcyBhbiBvYmplY3QsIGJlY29taW5nIGEgYFNlcS5LZXllZGAsXFxud2hpY2ggaXMgdXN1YWxseSBub3Qgd2hhdCB5b3Ugd2FudC4gWW91IHNob3VsZCB0dXJuIHlvdXIgSXRlcmF0b3IgT2JqZWN0IGludG9cXG5hbiBpdGVyYWJsZSBvYmplY3QgYnkgZGVmaW5pbmcgYSBTeW1ib2wuaXRlcmF0b3IgKG9yIEBAaXRlcmF0b3IpIG1ldGhvZCB3aGljaFxcbnJldHVybnMgYHRoaXNgLlxcblxcbk5vdGU6IGBTZXFgIGlzIGEgY29udmVyc2lvbiBmdW5jdGlvbiBhbmQgbm90IGEgY2xhc3MsIGFuZCBkb2VzIG5vdCB1c2UgdGhlXFxuYG5ld2Aga2V5d29yZCBkdXJpbmcgY29uc3RydWN0aW9uLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJTXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInNlcVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlNcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJTXCJ9LFwibGluZVwiOjMwNjJ9LHtcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjozMDYzfSx7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MzA2NH0se1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5TZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjozMDY1fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjozMDY2fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvYmpcIixcInR5cGVcIjp7XCJrXCI6NCxcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6M30se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjMwNjd9LHtcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfSxcImxpbmVcIjozMDY4fV19LFwiaW50ZXJmYWNlXCI6e1wibGluZVwiOjMwNzAsXCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiXSxcImV4dGVuZHNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XSxcImdyb3Vwc1wiOlt7XCJtZW1iZXJzXCI6e1wiI3NpemVcIjp7XCJsaW5lXCI6MzA4Mn19fSx7XCJ0aXRsZVwiOlwiRm9yY2UgZXZhbHVhdGlvblwiLFwibWVtYmVyc1wiOntcIiNjYWNoZVJlc3VsdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJCZWNhdXNlIFNlcXVlbmNlcyBhcmUgbGF6eSBhbmQgZGVzaWduZWQgdG8gYmUgY2hhaW5lZCB0b2dldGhlciwgdGhleSBkb1xcbm5vdCBjYWNoZSB0aGVpciByZXN1bHRzLiBGb3IgZXhhbXBsZSwgdGhpcyBtYXAgZnVuY3Rpb24gaXMgY2FsbGVkIGEgdG90YWxcXG5vZiA2IHRpbWVzLCBhcyBlYWNoIGBqb2luYCBpdGVyYXRlcyB0aGUgU2VxIG9mIHRocmVlIHZhbHVlcy5cIixcImRlc2NyaXB0aW9uXCI6XCIgICAgdmFyIHNxdWFyZXMgPSBTZXEoWyAxLCAyLCAzIF0pLm1hcCh4ID0+IHggKiB4KVxcbiAgICBzcXVhcmVzLmpvaW4oKSArIHNxdWFyZXMuam9pbigpXFxuXFxuSWYgeW91IGtub3cgYSBgU2VxYCB3aWxsIGJlIHVzZWQgbXVsdGlwbGUgdGltZXMsIGl0IG1heSBiZSBtb3JlXFxuZWZmaWNpZW50IHRvIGZpcnN0IGNhY2hlIGl0IGluIG1lbW9yeS4gSGVyZSwgdGhlIG1hcCBmdW5jdGlvbiBpcyBjYWxsZWRcXG5vbmx5IDMgdGltZXMuXFxuXFxuICAgIHZhciBzcXVhcmVzID0gU2VxKFsgMSwgMiwgMyBdKS5tYXAoeCA9PiB4ICogeCkuY2FjaGVSZXN1bHQoKVxcbiAgICBzcXVhcmVzLmpvaW4oKSArIHNxdWFyZXMuam9pbigpXFxuXFxuVXNlIHRoaXMgbWV0aG9kIGp1ZGljaW91c2x5LCBhcyBpdCBtdXN0IGZ1bGx5IGV2YWx1YXRlIGEgU2VxIHdoaWNoIGNhbiBiZVxcbmEgYnVyZGVuIG9uIG1lbW9yeSBhbmQgcG9zc2libHkgcGVyZm9ybWFuY2UuXFxuXFxuTm90ZTogYWZ0ZXIgY2FsbGluZyBgY2FjaGVSZXN1bHRgLCBhIFNlcSB3aWxsIGFsd2F5cyBoYXZlIGEgYHNpemVgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjMxMDd9XX19fSx7XCJ0aXRsZVwiOlwiU2VxdWVuY2UgYWxnb3JpdGhtc1wiLFwibWVtYmVyc1wiOntcIiNtYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBTZXEgd2l0aCB2YWx1ZXMgcGFzc2VkIHRocm91Z2ggYVxcbmBtYXBwZXJgIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcImBgYGpzXFxuY29uc3QgeyBTZXEgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuU2VxKFsgMSwgMiBdKS5tYXAoeCA9PiAxMCAqIHgpXFxuLy8gU2VxIFsgMTAsIDIwIF1cXG5gYGBcXG5cXG5Ob3RlOiBgbWFwKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHByb2R1Y2VkIHRoZSBzYW1lXFxudmFsdWUgYXQgZXZlcnkgc3RlcC5cXG5Ob3RlOiB1c2VkIG9ubHkgZm9yIHNldHMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk1cIn19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjMxMjR9LHtcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjozMTQzfV19LFwiI2ZsYXRNYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRmxhdC1tYXBzIHRoZSBTZXEsIHJldHVybmluZyBhIFNlcSBvZiB0aGUgc2FtZSB0eXBlLlwiLFwiZGVzY3JpcHRpb25cIjpcIlNpbWlsYXIgdG8gYHNlcS5tYXAoLi4uKS5mbGF0dGVuKHRydWUpYC5cXG5Ob3RlOiBVc2VkIG9ubHkgZm9yIHNldHMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjozMTUzfSx7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjMxNjR9XX0sXCIjZmlsdGVyXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU2VxIHdpdGggb25seSB0aGUgdmFsdWVzIGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWBcXG5mdW5jdGlvbiByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYGZpbHRlcigpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCByZXN1bHRzIGluXFxubm90IGZpbHRlcmluZyBvdXQgYW55IHZhbHVlcy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiRlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIkZcIn1dfSxcImxpbmVcIjozMTc2fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxN319fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MzE4MH1dfX19XX19LFwiQ29sbGVjdGlvblwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUaGUgYENvbGxlY3Rpb25gIGlzIGEgc2V0IG9mIChrZXksIHZhbHVlKSBlbnRyaWVzIHdoaWNoIGNhbiBiZSBpdGVyYXRlZCwgYW5kXFxuaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBjb2xsZWN0aW9ucyBpbiBgaW1tdXRhYmxlYCwgYWxsb3dpbmcgdGhlbSB0b1xcbm1ha2UgdXNlIG9mIGFsbCB0aGUgQ29sbGVjdGlvbiBtZXRob2RzIChzdWNoIGFzIGBtYXBgIGFuZCBgZmlsdGVyYCkuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogQSBjb2xsZWN0aW9uIGlzIGFsd2F5cyBpdGVyYXRlZCBpbiB0aGUgc2FtZSBvcmRlciwgaG93ZXZlciB0aGF0IG9yZGVyXFxubWF5IG5vdCBhbHdheXMgYmUgd2VsbCBkZWZpbmVkLCBhcyBpcyB0aGUgY2FzZSBmb3IgdGhlIGBNYXBgIGFuZCBgU2V0YC5cXG5cXG5Db2xsZWN0aW9uIGlzIHRoZSBhYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBjb25jcmV0ZSBkYXRhIHN0cnVjdHVyZXMuIEl0XFxuY2Fubm90IGJlIGNvbnN0cnVjdGVkIGRpcmVjdGx5LlxcblxcbkltcGxlbWVudGF0aW9ucyBzaG91bGQgZXh0ZW5kIG9uZSBvZiB0aGUgc3ViY2xhc3NlcywgYENvbGxlY3Rpb24uS2V5ZWRgLFxcbmBDb2xsZWN0aW9uLkluZGV4ZWRgLCBvciBgQ29sbGVjdGlvbi5TZXRgLlwiLFwibm90ZXNcIjpbXX0sXCJtb2R1bGVcIjp7XCJLZXllZFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJLZXllZCBDb2xsZWN0aW9ucyBoYXZlIGRpc2NyZXRlIGtleXMgdGllZCB0byBlYWNoIHZhbHVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIldoZW4gaXRlcmF0aW5nIGBDb2xsZWN0aW9uLktleWVkYCwgZWFjaCBpdGVyYXRpb24gd2lsbCB5aWVsZCBhIGBbSywgVl1gXFxudHVwbGUsIGluIG90aGVyIHdvcmRzLCBgQ29sbGVjdGlvbiNlbnRyaWVzYCBpcyB0aGUgZGVmYXVsdCBpdGVyYXRvciBmb3JcXG5LZXllZCBDb2xsZWN0aW9ucy5cIixcIm5vdGVzXCI6W119LFwibW9kdWxlXCI6e30sXCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkNyZWF0ZXMgYSBDb2xsZWN0aW9uLktleWVkXCIsXCJkZXNjcmlwdGlvblwiOlwiU2ltaWxhciB0byBgQ29sbGVjdGlvbigpYCwgaG93ZXZlciBpdCBleHBlY3RzIGNvbGxlY3Rpb24tbGlrZXMgb2YgW0ssIFZdXFxudHVwbGVzIGlmIG5vdCBjb25zdHJ1Y3RlZCBmcm9tIGEgQ29sbGVjdGlvbi5LZXllZCBvciBKUyBPYmplY3QuXFxuXFxuTm90ZTogYENvbGxlY3Rpb24uS2V5ZWRgIGlzIGEgY29udmVyc2lvbiBmdW5jdGlvbiBhbmQgbm90IGEgY2xhc3MsIGFuZFxcbmRvZXMgbm90IHVzZSB0aGUgYG5ld2Aga2V5d29yZCBkdXJpbmcgY29uc3RydWN0aW9uLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6MzI0MX0se1widHlwZVBhcmFtc1wiOltcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib2JqXCIsXCJ0eXBlXCI6e1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjozfSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6MzI0Mn1dfSxcImludGVyZmFjZVwiOntcImxpbmVcIjozMjQ0LFwidHlwZVBhcmFtc1wiOltcIktcIixcIlZcIl0sXCJleHRlbmRzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfV0sXCJncm91cHNcIjpbe1wibWVtYmVyc1wiOntcIiN0b0pTXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkRlZXBseSBjb252ZXJ0cyB0aGlzIEtleWVkIGNvbGxlY3Rpb24gdG8gZXF1aXZhbGVudCBuYXRpdmUgSmF2YVNjcmlwdCBPYmplY3QuXCIsXCJkZXNjcmlwdGlvblwiOlwiQ29udmVydHMga2V5cyB0byBTdHJpbmdzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9iamVjdFwifSxcImxpbmVcIjozMjUwfV19LFwiI3RvSlNPTlwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJTaGFsbG93bHkgY29udmVydHMgdGhpcyBLZXllZCBjb2xsZWN0aW9uIHRvIGVxdWl2YWxlbnQgbmF0aXZlIEphdmFTY3JpcHQgT2JqZWN0LlwiLFwiZGVzY3JpcHRpb25cIjpcIkNvbnZlcnRzIGtleXMgdG8gU3RyaW5ncy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV19LFwibGluZVwiOjMyNTd9XX0sXCIjdG9BcnJheVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJTaGFsbG93bHkgY29udmVydHMgdGhpcyBjb2xsZWN0aW9uIHRvIGFuIEFycmF5LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XX0sXCJsaW5lXCI6MzI2Mn1dfSxcIiN0b1NlcVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIFNlcS5LZXllZC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6MzI2OH1dfX19LHtcInRpdGxlXCI6XCJTZXF1ZW5jZSBmdW5jdGlvbnNcIixcIm1lbWJlcnNcIjp7XCIjZmxpcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24uS2V5ZWQgb2YgdGhlIHNhbWUgdHlwZSB3aGVyZSB0aGUga2V5cyBhbmQgdmFsdWVzXFxuaGF2ZSBiZWVuIGZsaXBwZWQuXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IE1hcCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5NYXAoeyBhOiAneicsIGI6ICd5JyB9KS5mbGlwKClcXG4vLyBNYXAgeyBcXFwielxcXCI6IFxcXCJhXFxcIiwgXFxcInlcXFwiOiBcXFwiYlxcXCIgfVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9XX0sXCJsaW5lXCI6MzI4NH1dfSxcIiNjb25jYXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIHdpdGggb3RoZXIgY29sbGVjdGlvbnMgY29uY2F0ZW5hdGVkIHRvIHRoaXMgb25lLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJLQ1wiLFwiVkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS0NcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVkNcIn1dfV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIktDXCJ9XX0se1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWQ1wifV19XX0sXCJsaW5lXCI6MzI4OX0se1widHlwZVBhcmFtc1wiOltcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6M31dfSx7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIkNcIn1dfV19LFwibGluZVwiOjMyOTB9XX0sXCIjbWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbi5LZXllZCB3aXRoIHZhbHVlcyBwYXNzZWQgdGhyb3VnaCBhXFxuYG1hcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiYGBganNcXG5jb25zdCB7IENvbGxlY3Rpb24gfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuQ29sbGVjdGlvbi5LZXllZCh7IGE6IDEsIGI6IDIgfSkubWFwKHggPT4gMTAgKiB4KVxcbi8vIFNlcSB7IFxcXCJhXFxcIjogMTAsIFxcXCJiXFxcIjogMjAgfVxcbmBgYFxcblxcbk5vdGU6IGBtYXAoKWAgYWx3YXlzIHJldHVybnMgYSBuZXcgaW5zdGFuY2UsIGV2ZW4gaWYgaXQgcHJvZHVjZWQgdGhlXFxuc2FtZSB2YWx1ZSBhdCBldmVyeSBzdGVwLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6MzMwNX1dfSxcIiNtYXBLZXlzXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbi5LZXllZCBvZiB0aGUgc2FtZSB0eXBlIHdpdGgga2V5cyBwYXNzZWQgdGhyb3VnaFxcbmEgYG1hcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IE1hcCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5NYXAoeyBhOiAxLCBiOiAyIH0pLm1hcEtleXMoeCA9PiB4LnRvVXBwZXJDYXNlKCkpXFxuLy8gTWFwIHsgXFxcIkFcXFwiOiAxLCBcXFwiQlxcXCI6IDIgfVxcbmBgYFxcblxcbk5vdGU6IGBtYXBLZXlzKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHByb2R1Y2VkXFxudGhlIHNhbWUga2V5IGF0IGV2ZXJ5IHN0ZXAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk1cIn19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjozMzI0fV19LFwiI21hcEVudHJpZXNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uLktleWVkIG9mIHRoZSBzYW1lIHR5cGUgd2l0aCBlbnRyaWVzXFxuKFtrZXksIHZhbHVlXSB0dXBsZXMpIHBhc3NlZCB0aHJvdWdoIGEgYG1hcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IE1hcCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5NYXAoeyBhOiAxLCBiOiAyIH0pXFxuICAubWFwRW50cmllcygoWyBrLCB2IF0pID0+IFsgay50b1VwcGVyQ2FzZSgpLCB2ICogMiBdKVxcbi8vIE1hcCB7IFxcXCJBXFxcIjogMiwgXFxcIkJcXFwiOiA0IH1cXG5gYGBcXG5cXG5Ob3RlOiBgbWFwRW50cmllcygpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCBwcm9kdWNlZFxcbnRoZSBzYW1lIGVudHJ5IGF0IGV2ZXJ5IHN0ZXAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktNXCIsXCJWTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJlbnRyeVwiLFwidHlwZVwiOntcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19fSx7XCJuYW1lXCI6XCJpbmRleFwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLTVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWTVwifV19fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS01cIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVk1cIn1dfSxcImxpbmVcIjozMzQ0fV19LFwiI2ZsYXRNYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRmxhdC1tYXBzIHRoZSBDb2xsZWN0aW9uLCByZXR1cm5pbmcgYSBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUuXCIsXCJkZXNjcmlwdGlvblwiOlwiU2ltaWxhciB0byBgY29sbGVjdGlvbi5tYXAoLi4uKS5mbGF0dGVuKHRydWUpYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS01cIixcIlZNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZNXCJ9XX1dfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZNXCJ9XX0sXCJsaW5lXCI6MzM1NH1dfSxcIiNmaWx0ZXJcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIHdpdGggb25seSB0aGUgdmFsdWVzIGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWBcXG5mdW5jdGlvbiByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYGZpbHRlcigpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCByZXN1bHRzIGluXFxubm90IGZpbHRlcmluZyBvdXQgYW55IHZhbHVlcy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiRlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJGXCJ9XX0sXCJsaW5lXCI6MzM2Nn0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MTd9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjMzNzB9XX0sXCIjW1N5bWJvbC5pdGVyYXRvcl1cIjp7XCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlSXRlcmF0b3JcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfSxcImxpbmVcIjozMzc1fV19fX1dfX0sXCJJbmRleGVkXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkluZGV4ZWQgQ29sbGVjdGlvbnMgaGF2ZSBpbmNyZW1lbnRpbmcgbnVtZXJpYyBrZXlzLiBUaGV5IGV4aGliaXRcXG5zbGlnaHRseSBkaWZmZXJlbnQgYmVoYXZpb3IgdGhhbiBgQ29sbGVjdGlvbi5LZXllZGAgZm9yIHNvbWUgbWV0aG9kcyBpbiBvcmRlclxcbnRvIGJldHRlciBtaXJyb3IgdGhlIGJlaGF2aW9yIG9mIEphdmFTY3JpcHQncyBgQXJyYXlgLCBhbmQgYWRkIG1ldGhvZHNcXG53aGljaCBkbyBub3QgbWFrZSBzZW5zZSBvbiBub24taW5kZXhlZCBDb2xsZWN0aW9ucyBzdWNoIGFzIGBpbmRleE9mYC5cIixcImRlc2NyaXB0aW9uXCI6XCJVbmxpa2UgSmF2YVNjcmlwdCBhcnJheXMsIGBDb2xsZWN0aW9uLkluZGV4ZWRgcyBhcmUgYWx3YXlzIGRlbnNlLiBcXFwiVW5zZXRcXFwiXFxuaW5kaWNlcyBhbmQgYHVuZGVmaW5lZGAgaW5kaWNlcyBhcmUgaW5kaXN0aW5ndWlzaGFibGUsIGFuZCBhbGwgaW5kaWNlcyBmcm9tXFxuMCB0byBgc2l6ZWAgYXJlIHZpc2l0ZWQgd2hlbiBpdGVyYXRlZC5cXG5cXG5BbGwgQ29sbGVjdGlvbi5JbmRleGVkIG1ldGhvZHMgcmV0dXJuIHJlLWluZGV4ZWQgQ29sbGVjdGlvbnMuIEluIG90aGVyIHdvcmRzLFxcbmluZGljZXMgYWx3YXlzIHN0YXJ0IGF0IDAgYW5kIGluY3JlbWVudCB1bnRpbCBzaXplLiBJZiB5b3Ugd2lzaCB0b1xcbnByZXNlcnZlIGluZGljZXMsIHVzaW5nIHRoZW0gYXMga2V5cywgY29udmVydCB0byBhIENvbGxlY3Rpb24uS2V5ZWQgYnlcXG5jYWxsaW5nIGB0b0tleWVkU2VxYC5cIixcIm5vdGVzXCI6W119LFwibW9kdWxlXCI6e30sXCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkNyZWF0ZXMgYSBuZXcgQ29sbGVjdGlvbi5JbmRleGVkLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBDb2xsZWN0aW9uLkluZGV4ZWRgIGlzIGEgY29udmVyc2lvbiBmdW5jdGlvbiBhbmQgbm90IGEgY2xhc3MsIGFuZFxcbmRvZXMgbm90IHVzZSB0aGUgYG5ld2Aga2V5d29yZCBkdXJpbmcgY29uc3RydWN0aW9uLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjozNDAyfV19LFwiaW50ZXJmYWNlXCI6e1wibGluZVwiOjM0MDQsXCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcImV4dGVuZHNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoyfSx7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX1dLFwiZ3JvdXBzXCI6W3tcIm1lbWJlcnNcIjp7XCIjdG9KU1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJEZWVwbHkgY29udmVydHMgdGhpcyBJbmRleGVkIGNvbGxlY3Rpb24gdG8gZXF1aXZhbGVudCBuYXRpdmUgSmF2YVNjcmlwdCBBcnJheS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJsaW5lXCI6MzQwOH1dfSxcIiN0b0pTT05cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiU2hhbGxvd2x5IGNvbnZlcnRzIHRoaXMgSW5kZXhlZCBjb2xsZWN0aW9uIHRvIGVxdWl2YWxlbnQgbmF0aXZlIEphdmFTY3JpcHQgQXJyYXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjM0MTN9XX0sXCIjdG9BcnJheVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJTaGFsbG93bHkgY29udmVydHMgdGhpcyBjb2xsZWN0aW9uIHRvIGFuIEFycmF5LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjozNDE4fV19fX0se1widGl0bGVcIjpcIlJlYWRpbmcgdmFsdWVzXCIsXCJtZW1iZXJzXCI6e1wiI2dldFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3ZpZGVkIGluZGV4LCBvciBub3RTZXRWYWx1ZSBpZlxcbnRoZSBpbmRleCBpcyBiZXlvbmQgdGhlIGJvdW5kcyBvZiB0aGUgQ29sbGVjdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJgaW5kZXhgIG1heSBiZSBhIG5lZ2F0aXZlIG51bWJlciwgd2hpY2ggaW5kZXhlcyBiYWNrIGZyb20gdGhlIGVuZCBvZiB0aGVcXG5Db2xsZWN0aW9uLiBgcy5nZXQoLTEpYCBnZXRzIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIENvbGxlY3Rpb24uXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk5TVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJpbmRleFwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn19XSxcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifV19LFwibGluZVwiOjM0Mjl9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJpbmRleFwiLFwidHlwZVwiOntcImtcIjoyfX1dLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjExfV19LFwibGluZVwiOjM0MzB9XX19fSx7XCJ0aXRsZVwiOlwiQ29udmVyc2lvbiB0byBTZXFcIixcIm1lbWJlcnNcIjp7XCIjdG9TZXFcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBTZXEuSW5kZXhlZC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MzQzOX1dfSxcIiNmcm9tRW50cnlTZXFcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiSWYgdGhpcyBpcyBhIGNvbGxlY3Rpb24gb2YgW2tleSwgdmFsdWVdIGVudHJ5IHR1cGxlcywgaXQgd2lsbCByZXR1cm4gYVxcblNlcS5LZXllZCBvZiB0aG9zZSBlbnRyaWVzLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfSxcImxpbmVcIjozNDQ1fV19fX0se1widGl0bGVcIjpcIkNvbWJpbmF0aW9uXCIsXCJtZW1iZXJzXCI6e1wiI2ludGVycG9zZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIHdpdGggYHNlcGFyYXRvcmAgYmV0d2VlbiBlYWNoIGl0ZW1cXG5pbiB0aGlzIENvbGxlY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInNlcGFyYXRvclwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjM0NTR9XX0sXCIjaW50ZXJsZWF2ZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIHdpdGggdGhlIHByb3ZpZGVkIGBjb2xsZWN0aW9uc2BcXG5pbnRlcmxlYXZlZCBpbnRvIHRoaXMgY29sbGVjdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJUaGUgcmVzdWx0aW5nIENvbGxlY3Rpb24gaW5jbHVkZXMgdGhlIGZpcnN0IGl0ZW0gZnJvbSBlYWNoLCB0aGVuIHRoZVxcbnNlY29uZCBmcm9tIGVhY2gsIGV0Yy5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwicmVxdWlyZSgnaW1tdXRhYmxlJylcXFwifVxcbi0tPlxcbmBgYGpzXFxuY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbkxpc3QoWyAxLCAyLCAzIF0pLmludGVybGVhdmUoTGlzdChbICdBJywgJ0InLCAnQycgXSkpXFxuLy8gTGlzdCBbIDEsIFxcXCJBXFxcIiwgMiwgXFxcIkJcXFwiLCAzLCBcXFwiQ1xcXCIgXVxcbmBgYFxcblxcblRoZSBzaG9ydGVzdCBDb2xsZWN0aW9uIHN0b3BzIGludGVybGVhdmUuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbkxpc3QoWyAxLCAyLCAzIF0pLmludGVybGVhdmUoXFxuICBMaXN0KFsgJ0EnLCAnQicgXSksXFxuICBMaXN0KFsgJ1gnLCAnWScsICdaJyBdKVxcbilcXG4vLyBMaXN0IFsgMSwgXFxcIkFcXFwiLCBcXFwiWFxcXCIsIDIsIFxcXCJCXFxcIiwgXFxcIllcXFwiIF1cXG5gYGBcXG5cXG5TaW5jZSBgaW50ZXJsZWF2ZSgpYCByZS1pbmRleGVzIHZhbHVlcywgaXQgcHJvZHVjZXMgYSBjb21wbGV0ZSBjb3B5LFxcbndoaWNoIGhhcyBgTyhOKWAgY29tcGxleGl0eS5cXG5cXG5Ob3RlOiBgaW50ZXJsZWF2ZWAgKmNhbm5vdCogYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjozNDkwfV19LFwiI3NwbGljZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJTcGxpY2UgcmV0dXJucyBhIG5ldyBpbmRleGVkIENvbGxlY3Rpb24gYnkgcmVwbGFjaW5nIGEgcmVnaW9uIG9mIHRoaXNcXG5Db2xsZWN0aW9uIHdpdGggbmV3IHZhbHVlcy4gSWYgdmFsdWVzIGFyZSBub3QgcHJvdmlkZWQsIGl0IG9ubHkgc2tpcHMgdGhlXFxucmVnaW9uIHRvIGJlIHJlbW92ZWQuXCIsXCJkZXNjcmlwdGlvblwiOlwiYGluZGV4YCBtYXkgYmUgYSBuZWdhdGl2ZSBudW1iZXIsIHdoaWNoIGluZGV4ZXMgYmFjayBmcm9tIHRoZSBlbmQgb2YgdGhlXFxuQ29sbGVjdGlvbi4gYHMuc3BsaWNlKC0yKWAgc3BsaWNlcyBhZnRlciB0aGUgc2Vjb25kIHRvIGxhc3QgaXRlbS5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5MaXN0KFsgJ2EnLCAnYicsICdjJywgJ2QnIF0pLnNwbGljZSgxLCAyLCAncScsICdyJywgJ3MnKVxcbi8vIExpc3QgWyBcXFwiYVxcXCIsIFxcXCJxXFxcIiwgXFxcInJcXFwiLCBcXFwic1xcXCIsIFxcXCJkXFxcIiBdXFxuYGBgXFxuXFxuU2luY2UgYHNwbGljZSgpYCByZS1pbmRleGVzIHZhbHVlcywgaXQgcHJvZHVjZXMgYSBjb21wbGV0ZSBjb3B5LCB3aGljaFxcbmhhcyBgTyhOKWAgY29tcGxleGl0eS5cXG5cXG5Ob3RlOiBgc3BsaWNlYCAqY2Fubm90KiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcInJlbW92ZU51bVwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwidmFsdWVzXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MzUxMn1dfSxcIiN6aXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZSBcXFwiemlwcGVkXFxcIiB3aXRoIHRoZSBwcm92aWRlZFxcbmNvbGxlY3Rpb25zLlwiLFwiZGVzY3JpcHRpb25cIjpcIkxpa2UgYHppcFdpdGhgLCBidXQgdXNpbmcgdGhlIGRlZmF1bHQgYHppcHBlcmA6IGNyZWF0aW5nIGFuIGBBcnJheWAuXFxuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmNvbnN0IGEgPSBMaXN0KFsgMSwgMiwgMyBdKTtcXG5jb25zdCBiID0gTGlzdChbIDQsIDUsIDYgXSk7XFxuY29uc3QgYyA9IGEuemlwKGIpOyAvLyBMaXN0IFsgWyAxLCA0IF0sIFsgMiwgNSBdLCBbIDMsIDYgXSBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlVcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib3RoZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfV19LFwibGluZVwiOjM1MzR9LHtcInR5cGVQYXJhbXNcIjpbXCJVXCIsXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fSx7XCJuYW1lXCI6XCJvdGhlcjJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XX0sXCJsaW5lXCI6MzUzNX0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6MTd9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwibGluZVwiOjM1MzZ9XX0sXCIjemlwQWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBDb2xsZWN0aW9uIFxcXCJ6aXBwZWRcXFwiIHdpdGggdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb25zLlwiLFwiZGVzY3JpcHRpb25cIjpcIlVubGlrZSBgemlwYCwgYHppcEFsbGAgY29udGludWVzIHppcHBpbmcgdW50aWwgdGhlIGxvbmdlc3QgY29sbGVjdGlvbiBpc1xcbmV4aGF1c3RlZC4gTWlzc2luZyB2YWx1ZXMgZnJvbSBzaG9ydGVyIGNvbGxlY3Rpb25zIGFyZSBmaWxsZWQgd2l0aCBgdW5kZWZpbmVkYC5cXG5cXG5gYGBqc1xcbmNvbnN0IGEgPSBMaXN0KFsgMSwgMiBdKTtcXG5jb25zdCBiID0gTGlzdChbIDMsIDQsIDUgXSk7XFxuY29uc3QgYyA9IGEuemlwQWxsKGIpOyAvLyBMaXN0IFsgWyAxLCAzIF0sIFsgMiwgNCBdLCBbIHVuZGVmaW5lZCwgNSBdIF1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlclwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19XX0sXCJsaW5lXCI6MzU1MH0se1widHlwZVBhcmFtc1wiOltcIlVcIixcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib3RoZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19LHtcIm5hbWVcIjpcIm90aGVyMlwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfSxcImxpbmVcIjozNTUxfSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJsaW5lXCI6MzU1Mn1dfSxcIiN6aXBXaXRoXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgXFxcInppcHBlZFxcXCIgd2l0aCB0aGUgcHJvdmlkZWRcXG5jb2xsZWN0aW9ucyBieSB1c2luZyBhIGN1c3RvbSBgemlwcGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcXCIgfVxcbi0tPlxcbmBgYGpzXFxuY29uc3QgYSA9IExpc3QoWyAxLCAyLCAzIF0pO1xcbmNvbnN0IGIgPSBMaXN0KFsgNCwgNSwgNiBdKTtcXG5jb25zdCBjID0gYS56aXBXaXRoKChhLCBiKSA9PiBhICsgYiwgYik7XFxuLy8gTGlzdCBbIDUsIDcsIDkgXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJVXCIsXCJaXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInppcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwib3RoZXJWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlVcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9fX0se1wibmFtZVwiOlwib3RoZXJDb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifV19LFwibGluZVwiOjM1Njh9LHtcInR5cGVQYXJhbXNcIjpbXCJVXCIsXCJWXCIsXCJaXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInppcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwib3RoZXJWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlVcIn19LHtcIm5hbWVcIjpcInRoaXJkVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifX19LHtcIm5hbWVcIjpcIm90aGVyQ29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX0se1wibmFtZVwiOlwidGhpcmRDb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifV19LFwibGluZVwiOjM1NzJ9LHtcInR5cGVQYXJhbXNcIjpbXCJaXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInppcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImFueVwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9fX0se1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9XX0sXCJsaW5lXCI6MzU3N31dfX19LHtcInRpdGxlXCI6XCJTZWFyY2ggZm9yIHZhbHVlXCIsXCJtZW1iZXJzXCI6e1wiI2luZGV4T2ZcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggYXQgd2hpY2ggYSBnaXZlbiB2YWx1ZSBjYW4gYmUgZm91bmQgaW4gdGhlXFxuQ29sbGVjdGlvbiwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInNlYXJjaFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX1dLFwidHlwZVwiOntcImtcIjoyfSxcImxpbmVcIjozNTg5fV19LFwiI2xhc3RJbmRleE9mXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgdGhlIGxhc3QgaW5kZXggYXQgd2hpY2ggYSBnaXZlbiB2YWx1ZSBjYW4gYmUgZm91bmQgaW4gdGhlXFxuQ29sbGVjdGlvbiwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInNlYXJjaFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX1dLFwidHlwZVwiOntcImtcIjoyfSxcImxpbmVcIjozNTk1fV19LFwiI2ZpbmRJbmRleFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBpbiB0aGUgQ29sbGVjdGlvbiB3aGVyZSBhIHZhbHVlIHNhdGlzZmllcyB0aGVcXG5wcm92aWRlZCBwcmVkaWNhdGUgZnVuY3Rpb24uIE90aGVyd2lzZSAtMSBpcyByZXR1cm5lZC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJpbmRleFwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoyfSxcImxpbmVcIjozNjAxfV19LFwiI2ZpbmRMYXN0SW5kZXhcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyB0aGUgbGFzdCBpbmRleCBpbiB0aGUgQ29sbGVjdGlvbiB3aGVyZSBhIHZhbHVlIHNhdGlzZmllcyB0aGVcXG5wcm92aWRlZCBwcmVkaWNhdGUgZnVuY3Rpb24uIE90aGVyd2lzZSAtMSBpcyByZXR1cm5lZC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJpbmRleFwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoyfSxcImxpbmVcIjozNjEwfV19fX0se1widGl0bGVcIjpcIlNlcXVlbmNlIGFsZ29yaXRobXNcIixcIm1lbWJlcnNcIjp7XCIjY29uY2F0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbiB3aXRoIG90aGVyIGNvbGxlY3Rpb25zIGNvbmNhdGVuYXRlZCB0byB0aGlzIG9uZS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZXNPckNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIkNcIn1dfSx7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9XX1dfSxcImxpbmVcIjozNjIwfV19LFwiI21hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24uSW5kZXhlZCB3aXRoIHZhbHVlcyBwYXNzZWQgdGhyb3VnaCBhXFxuYG1hcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiYGBganNcXG5jb25zdCB7IENvbGxlY3Rpb24gfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuQ29sbGVjdGlvbi5JbmRleGVkKFsxLDJdKS5tYXAoeCA9PiAxMCAqIHgpXFxuLy8gU2VxIFsgMSwgMiBdXFxuYGBgXFxuXFxuTm90ZTogYG1hcCgpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCBwcm9kdWNlZCB0aGVcXG5zYW1lIHZhbHVlIGF0IGV2ZXJ5IHN0ZXAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjM2MzV9XX0sXCIjZmxhdE1hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJGbGF0LW1hcHMgdGhlIENvbGxlY3Rpb24sIHJldHVybmluZyBhIENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZS5cIixcImRlc2NyaXB0aW9uXCI6XCJTaW1pbGFyIHRvIGBjb2xsZWN0aW9uLm1hcCguLi4pLmZsYXR0ZW4odHJ1ZSlgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6MzY0NX1dfSxcIiNmaWx0ZXJcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIHdpdGggb25seSB0aGUgdmFsdWVzIGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWBcXG5mdW5jdGlvbiByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYGZpbHRlcigpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCByZXN1bHRzIGluXFxubm90IGZpbHRlcmluZyBvdXQgYW55IHZhbHVlcy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiRlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiRlwifV19LFwibGluZVwiOjM2NTd9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxN319fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MzY2MX1dfSxcIiNbU3ltYm9sLml0ZXJhdG9yXVwiOntcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVJdGVyYXRvclwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MzY2Nn1dfX19XX19LFwiU2V0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNldCBDb2xsZWN0aW9ucyBvbmx5IHJlcHJlc2VudCB2YWx1ZXMuIFRoZXkgaGF2ZSBubyBhc3NvY2lhdGVkIGtleXMgb3JcXG5pbmRpY2VzLiBEdXBsaWNhdGUgdmFsdWVzIGFyZSBwb3NzaWJsZSBpbiB0aGUgbGF6eSBgU2VxLlNldGBzLCBob3dldmVyXFxudGhlIGNvbmNyZXRlIGBTZXRgIENvbGxlY3Rpb24gZG9lcyBub3QgYWxsb3cgZHVwbGljYXRlIHZhbHVlcy5cIixcImRlc2NyaXB0aW9uXCI6XCJDb2xsZWN0aW9uIG1ldGhvZHMgb24gQ29sbGVjdGlvbi5TZXQgc3VjaCBhcyBgbWFwYCBhbmQgYGZvckVhY2hgIHdpbGwgcHJvdmlkZVxcbnRoZSB2YWx1ZSBhcyBib3RoIHRoZSBmaXJzdCBhbmQgc2Vjb25kIGFyZ3VtZW50cyB0byB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXFxuXFxuYGBganNcXG5jb25zdCB7IENvbGxlY3Rpb24gfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgc2VxID0gQ29sbGVjdGlvbi5TZXQoWyAnQScsICdCJywgJ0MnIF0pXFxuLy8gU2VxIHsgXFxcIkFcXFwiLCBcXFwiQlxcXCIsIFxcXCJDXFxcIiB9XFxuc2VxLmZvckVhY2goKHYsIGspID0+XFxuIGFzc2VydC5lcXVhbCh2LCBrKVxcbilcXG5gYGBcIixcIm5vdGVzXCI6W119LFwibW9kdWxlXCI6e30sXCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNpbWlsYXIgdG8gYENvbGxlY3Rpb24oKWAsIGJ1dCBhbHdheXMgcmV0dXJucyBhIENvbGxlY3Rpb24uU2V0LlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBDb2xsZWN0aW9uLlNldGAgaXMgYSBmYWN0b3J5IGZ1bmN0aW9uIGFuZCBub3QgYSBjbGFzcywgYW5kIGRvZXNcXG5ub3QgdXNlIHRoZSBgbmV3YCBrZXl3b3JkIGR1cmluZyBjb25zdHJ1Y3Rpb24uXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MzY5NX1dfSxcImludGVyZmFjZVwiOntcImxpbmVcIjozNjk3LFwidHlwZVBhcmFtc1wiOltcIlRcIl0sXCJleHRlbmRzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfV0sXCJncm91cHNcIjpbe1wibWVtYmVyc1wiOntcIiN0b0pTXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkRlZXBseSBjb252ZXJ0cyB0aGlzIFNldCBjb2xsZWN0aW9uIHRvIGVxdWl2YWxlbnQgbmF0aXZlIEphdmFTY3JpcHQgQXJyYXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwibGluZVwiOjM3MDF9XX0sXCIjdG9KU09OXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNoYWxsb3dseSBjb252ZXJ0cyB0aGlzIFNldCBjb2xsZWN0aW9uIHRvIGVxdWl2YWxlbnQgbmF0aXZlIEphdmFTY3JpcHQgQXJyYXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjM3MDZ9XX0sXCIjdG9BcnJheVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJTaGFsbG93bHkgY29udmVydHMgdGhpcyBjb2xsZWN0aW9uIHRvIGFuIEFycmF5LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjozNzExfV19LFwiI3RvU2VxXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgU2VxLlNldC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjozNzE3fV19fX0se1widGl0bGVcIjpcIlNlcXVlbmNlIGFsZ29yaXRobXNcIixcIm1lbWJlcnNcIjp7XCIjY29uY2F0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbiB3aXRoIG90aGVyIGNvbGxlY3Rpb25zIGNvbmNhdGVuYXRlZCB0byB0aGlzIG9uZS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfV19LFwibGluZVwiOjM3MjR9XX0sXCIjbWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbi5TZXQgd2l0aCB2YWx1ZXMgcGFzc2VkIHRocm91Z2ggYVxcbmBtYXBwZXJgIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcImBgYFxcbkNvbGxlY3Rpb24uU2V0KFsgMSwgMiBdKS5tYXAoeCA9PiAxMCAqIHgpXFxuLy8gU2VxIHsgMSwgMiB9XFxuYGBgXFxuXFxuTm90ZTogYG1hcCgpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCBwcm9kdWNlZCB0aGVcXG5zYW1lIHZhbHVlIGF0IGV2ZXJ5IHN0ZXAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk1cIn19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5TZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjM3Mzh9XX0sXCIjZmxhdE1hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJGbGF0LW1hcHMgdGhlIENvbGxlY3Rpb24sIHJldHVybmluZyBhIENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZS5cIixcImRlc2NyaXB0aW9uXCI6XCJTaW1pbGFyIHRvIGBjb2xsZWN0aW9uLm1hcCguLi4pLmZsYXR0ZW4odHJ1ZSlgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6Mzc0OH1dfSxcIiNmaWx0ZXJcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIHdpdGggb25seSB0aGUgdmFsdWVzIGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWBcXG5mdW5jdGlvbiByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYGZpbHRlcigpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCByZXN1bHRzIGluXFxubm90IGZpbHRlcmluZyBvdXQgYW55IHZhbHVlcy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiRlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIkZcIn1dfSxcImxpbmVcIjozNzYwfSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxN319fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6Mzc2NH1dfSxcIiNbU3ltYm9sLml0ZXJhdG9yXVwiOntcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVJdGVyYXRvclwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6Mzc2OX1dfX19XX19fSxcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQ3JlYXRlcyBhIENvbGxlY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiVGhlIHR5cGUgb2YgQ29sbGVjdGlvbiBjcmVhdGVkIGlzIGJhc2VkIG9uIHRoZSBpbnB1dC5cXG5cXG4gICogSWYgYW4gYENvbGxlY3Rpb25gLCB0aGF0IHNhbWUgYENvbGxlY3Rpb25gLlxcbiAgKiBJZiBhbiBBcnJheS1saWtlLCBhbiBgQ29sbGVjdGlvbi5JbmRleGVkYC5cXG4gICogSWYgYW4gT2JqZWN0IHdpdGggYW4gSXRlcmF0b3IgZGVmaW5lZCwgYW4gYENvbGxlY3Rpb24uSW5kZXhlZGAuXFxuICAqIElmIGFuIE9iamVjdCwgYW4gYENvbGxlY3Rpb24uS2V5ZWRgLlxcblxcblRoaXMgbWV0aG9kcyBmb3JjZXMgdGhlIGNvbnZlcnNpb24gb2YgT2JqZWN0cyBhbmQgU3RyaW5ncyB0byBDb2xsZWN0aW9ucy5cXG5JZiB5b3Ugd2FudCB0byBlbnN1cmUgdGhhdCBhIENvbGxlY3Rpb24gb2Ygb25lIGl0ZW0gaXMgcmV0dXJuZWQsIHVzZVxcbmBTZXEub2ZgLlxcblxcbk5vdGU6IEFuIEl0ZXJhdG9yIGl0c2VsZiB3aWxsIGJlIHRyZWF0ZWQgYXMgYW4gb2JqZWN0LCBiZWNvbWluZyBhIGBTZXEuS2V5ZWRgLFxcbndoaWNoIGlzIHVzdWFsbHkgbm90IHdoYXQgeW91IHdhbnQuIFlvdSBzaG91bGQgdHVybiB5b3VyIEl0ZXJhdG9yIE9iamVjdCBpbnRvXFxuYW4gaXRlcmFibGUgb2JqZWN0IGJ5IGRlZmluaW5nIGEgU3ltYm9sLml0ZXJhdG9yIChvciBAQGl0ZXJhdG9yKSBtZXRob2Qgd2hpY2hcXG5yZXR1cm5zIGB0aGlzYC5cXG5cXG5Ob3RlOiBgQ29sbGVjdGlvbmAgaXMgYSBjb252ZXJzaW9uIGZ1bmN0aW9uIGFuZCBub3QgYSBjbGFzcywgYW5kIGRvZXMgbm90XFxudXNlIHRoZSBgbmV3YCBrZXl3b3JkIGR1cmluZyBjb25zdHJ1Y3Rpb24uXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIklcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIklcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJJXCJ9LFwibGluZVwiOjM3OTZ9LHtcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjozNzk3fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvYmpcIixcInR5cGVcIjp7XCJrXCI6NCxcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjN9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjozNzk4fV19LFwiaW50ZXJmYWNlXCI6e1wibGluZVwiOjM4MDAsXCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiXSxcImV4dGVuZHNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJWYWx1ZU9iamVjdFwifV0sXCJncm91cHNcIjpbe1widGl0bGVcIjpcIlZhbHVlIGVxdWFsaXR5XCIsXCJtZW1iZXJzXCI6e1wiI2VxdWFsc1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIHRoaXMgYW5kIHRoZSBvdGhlciBDb2xsZWN0aW9uIGhhdmUgdmFsdWUgZXF1YWxpdHksIGFzIGRlZmluZWRcXG5ieSBgSW1tdXRhYmxlLmlzKClgLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IFRoaXMgaXMgZXF1aXZhbGVudCB0byBgSW1tdXRhYmxlLmlzKHRoaXMsIG90aGVyKWAsIGJ1dCBwcm92aWRlZCB0b1xcbmFsbG93IGZvciBjaGFpbmVkIGV4cHJlc3Npb25zLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlclwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6MzgxMX1dfSxcIiNoYXNoQ29kZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgaGFzaGVkIGlkZW50aXR5IGZvciB0aGlzIENvbGxlY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiVGhlIGBoYXNoQ29kZWAgb2YgYSBDb2xsZWN0aW9uIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHBvdGVudGlhbCBlcXVhbGl0eSxcXG5hbmQgaXMgdXNlZCB3aGVuIGFkZGluZyB0aGlzIHRvIGEgYFNldGAgb3IgYXMgYSBrZXkgaW4gYSBgTWFwYCwgZW5hYmxpbmdcXG5sb29rdXAgdmlhIGEgZGlmZmVyZW50IGluc3RhbmNlLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IFNldCwgIExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxcIiB9XFxuLS0+XFxuYGBganNcXG5jb25zdCBhID0gTGlzdChbIDEsIDIsIDMgXSk7XFxuY29uc3QgYiA9IExpc3QoWyAxLCAyLCAzIF0pO1xcbmFzc2VydC5ub3RTdHJpY3RFcXVhbChhLCBiKTsgLy8gZGlmZmVyZW50IGluc3RhbmNlc1xcbmNvbnN0IHNldCA9IFNldChbIGEgXSk7XFxuYXNzZXJ0LmVxdWFsKHNldC5oYXMoYiksIHRydWUpO1xcbmBgYFxcblxcbklmIHR3byB2YWx1ZXMgaGF2ZSB0aGUgc2FtZSBgaGFzaENvZGVgLCB0aGV5IGFyZSBbbm90IGd1YXJhbnRlZWRcXG50byBiZSBlcXVhbF1bSGFzaCBDb2xsaXNpb25dLiBJZiB0d28gdmFsdWVzIGhhdmUgZGlmZmVyZW50IGBoYXNoQ29kZWBzLFxcbnRoZXkgbXVzdCBub3QgYmUgZXF1YWwuXFxuXFxuW0hhc2ggQ29sbGlzaW9uXTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29sbGlzaW9uXyhjb21wdXRlcl9zY2llbmNlKVwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6Mn0sXCJsaW5lXCI6MzgzN31dfX19LHtcInRpdGxlXCI6XCJSZWFkaW5nIHZhbHVlc1wiLFwibWVtYmVyc1wiOntcIiNnZXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm92aWRlZCBrZXksIG9yIG5vdFNldFZhbHVlIGlmXFxudGhlIENvbGxlY3Rpb24gZG9lcyBub3QgY29udGFpbiB0aGlzIGtleS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBpdCBpcyBwb3NzaWJsZSBhIGtleSBtYXkgYmUgYXNzb2NpYXRlZCB3aXRoIGFuIGB1bmRlZmluZWRgIHZhbHVlLFxcbnNvIGlmIGBub3RTZXRWYWx1ZWAgaXMgbm90IHByb3ZpZGVkIGFuZCB0aGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLFxcbnRoYXQgZG9lcyBub3QgZ3VhcmFudGVlIHRoZSBrZXkgd2FzIG5vdCBmb3VuZC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTlNWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIm5vdFNldFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiTlNWXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn1dfSxcImxpbmVcIjozODUwfSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX1dLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjExfV19LFwibGluZVwiOjM4NTF9XX0sXCIjaGFzXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgYSBrZXkgZXhpc3RzIHdpdGhpbiB0aGlzIGBDb2xsZWN0aW9uYCwgdXNpbmcgYEltbXV0YWJsZS5pc2BcXG50byBkZXRlcm1pbmUgZXF1YWxpdHlcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjozODU3fV19LFwiI2luY2x1ZGVzXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgYSB2YWx1ZSBleGlzdHMgd2l0aGluIHRoaXMgYENvbGxlY3Rpb25gLCB1c2luZyBgSW1tdXRhYmxlLmlzYFxcbnRvIGRldGVybWluZSBlcXVhbGl0eVwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwiYWxpYXNcIixcImJvZHlcIjpcImNvbnRhaW5zXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6Mzg2NH1dfSxcIiNmaXJzdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJJbiBjYXNlIHRoZSBgQ29sbGVjdGlvbmAgaXMgbm90IGVtcHR5IHJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlXFxuYENvbGxlY3Rpb25gLlxcbkluIGNhc2UgdGhlIGBDb2xsZWN0aW9uYCBpcyBlbXB0eSByZXR1cm5zIHRoZSBvcHRpb25hbCBkZWZhdWx0XFxudmFsdWUgaWYgcHJvdmlkZWQsIGlmIG5vIGRlZmF1bHQgdmFsdWUgaXMgcHJvdmlkZWQgcmV0dXJucyB1bmRlZmluZWQuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk5TVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiTlNWXCJ9XX0sXCJsaW5lXCI6Mzg3M31dfSxcIiNsYXN0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkluIGNhc2UgdGhlIGBDb2xsZWN0aW9uYCBpcyBub3QgZW1wdHkgcmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZVxcbmBDb2xsZWN0aW9uYC5cXG5JbiBjYXNlIHRoZSBgQ29sbGVjdGlvbmAgaXMgZW1wdHkgcmV0dXJucyB0aGUgb3B0aW9uYWwgZGVmYXVsdFxcbnZhbHVlIGlmIHByb3ZpZGVkLCBpZiBubyBkZWZhdWx0IHZhbHVlIGlzIHByb3ZpZGVkIHJldHVybnMgdW5kZWZpbmVkLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJOU1ZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifV19LFwibGluZVwiOjM4ODF9XX19fSx7XCJ0aXRsZVwiOlwiUmVhZGluZyBkZWVwIHZhbHVlc1wiLFwibWVtYmVyc1wiOntcIiNnZXRJblwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRoZSB2YWx1ZSBmb3VuZCBieSBmb2xsb3dpbmcgYSBwYXRoIG9mIGtleXMgb3IgaW5kaWNlcyB0aHJvdWdoXFxubmVzdGVkIENvbGxlY3Rpb25zLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAsIExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3QgZGVlcERhdGEgPSBNYXAoeyB4OiBMaXN0KFsgTWFwKHsgeTogMTIzIH0pIF0pIH0pO1xcbmRlZXBEYXRhLmdldEluKFsneCcsIDAsICd5J10pIC8vIDEyM1xcbmBgYFxcblxcblBsYWluIEphdmFTY3JpcHQgT2JqZWN0IG9yIEFycmF5cyBtYXkgYmUgbmVzdGVkIHdpdGhpbiBhbiBJbW11dGFibGUuanNcXG5Db2xsZWN0aW9uLCBhbmQgZ2V0SW4oKSBjYW4gYWNjZXNzIHRob3NlIHZhbHVlcyBhcyB3ZWxsOlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAsIExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3QgZGVlcERhdGEgPSBNYXAoeyB4OiBbIHsgeTogMTIzIH0gXSB9KTtcXG5kZWVwRGF0YS5nZXRJbihbJ3gnLCAwLCAneSddKSAvLyAxMjNcXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwic2VhcmNoS2V5UGF0aFwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19fSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTd9LFwibGluZVwiOjM5MDZ9XX0sXCIjaGFzSW5cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiB0aGUgcmVzdWx0IG9mIGZvbGxvd2luZyBhIHBhdGggb2Yga2V5cyBvciBpbmRpY2VzIHRocm91Z2ggbmVzdGVkXFxuQ29sbGVjdGlvbnMgcmVzdWx0cyBpbiBhIHNldCB2YWx1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwic2VhcmNoS2V5UGF0aFwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjM5MTJ9XX19fSx7XCJ0aXRsZVwiOlwiUGVyc2lzdGVudCBjaGFuZ2VzXCIsXCJtZW1iZXJzXCI6e1wiI3VwZGF0ZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUaGlzIGNhbiBiZSB2ZXJ5IHVzZWZ1bCBhcyBhIHdheSB0byBcXFwiY2hhaW5cXFwiIGEgbm9ybWFsIGZ1bmN0aW9uIGludG8gYVxcbnNlcXVlbmNlIG9mIG1ldGhvZHMuIFJ4SlMgY2FsbHMgdGhpcyBcXFwibGV0XFxcIiBhbmQgbG9kYXNoIGNhbGxzIGl0IFxcXCJ0aHJ1XFxcIi5cIixcImRlc2NyaXB0aW9uXCI6XCJGb3IgZXhhbXBsZSwgdG8gc3VtIGEgU2VxIGFmdGVyIG1hcHBpbmcgYW5kIGZpbHRlcmluZzpcXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgU2VxIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcblxcbmZ1bmN0aW9uIHN1bShjb2xsZWN0aW9uKSB7XFxuICByZXR1cm4gY29sbGVjdGlvbi5yZWR1Y2UoKHN1bSwgeCkgPT4gc3VtICsgeCwgMClcXG59XFxuXFxuU2VxKFsgMSwgMiwgMyBdKVxcbiAgLm1hcCh4ID0+IHggKyAxKVxcbiAgLmZpbHRlcih4ID0+IHggJSAyID09PSAwKVxcbiAgLnVwZGF0ZShzdW0pXFxuLy8gNlxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJSXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJSXCJ9fX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlJcIn0sXCJsaW5lXCI6MzkzN31dfX19LHtcInRpdGxlXCI6XCJDb252ZXJzaW9uIHRvIEphdmFTY3JpcHQgdHlwZXNcIixcIm1lbWJlcnNcIjp7XCIjdG9KU1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJEZWVwbHkgY29udmVydHMgdGhpcyBDb2xsZWN0aW9uIHRvIGVxdWl2YWxlbnQgbmF0aXZlIEphdmFTY3JpcHQgQXJyYXkgb3IgT2JqZWN0LlwiLFwiZGVzY3JpcHRpb25cIjpcImBDb2xsZWN0aW9uLkluZGV4ZWRgLCBhbmQgYENvbGxlY3Rpb24uU2V0YCBiZWNvbWUgYEFycmF5YCwgd2hpbGVcXG5gQ29sbGVjdGlvbi5LZXllZGAgYmVjb21lIGBPYmplY3RgLCBjb252ZXJ0aW5nIGtleXMgdG8gU3RyaW5ncy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0se1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6MTd9fV19XX0sXCJsaW5lXCI6Mzk0OH1dfSxcIiN0b0pTT05cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiU2hhbGxvd2x5IGNvbnZlcnRzIHRoaXMgQ29sbGVjdGlvbiB0byBlcXVpdmFsZW50IG5hdGl2ZSBKYXZhU2NyaXB0IEFycmF5IG9yIE9iamVjdC5cIixcImRlc2NyaXB0aW9uXCI6XCJgQ29sbGVjdGlvbi5JbmRleGVkYCwgYW5kIGBDb2xsZWN0aW9uLlNldGAgYmVjb21lIGBBcnJheWAsIHdoaWxlXFxuYENvbGxlY3Rpb24uS2V5ZWRgIGJlY29tZSBgT2JqZWN0YCwgY29udmVydGluZyBrZXlzIHRvIFN0cmluZ3MuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LHtcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dfV19LFwibGluZVwiOjM5NTZ9XX0sXCIjdG9BcnJheVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJTaGFsbG93bHkgY29udmVydHMgdGhpcyBjb2xsZWN0aW9uIHRvIGFuIEFycmF5LlwiLFwiZGVzY3JpcHRpb25cIjpcImBDb2xsZWN0aW9uLkluZGV4ZWRgLCBhbmQgYENvbGxlY3Rpb24uU2V0YCBwcm9kdWNlIGFuIEFycmF5IG9mIHZhbHVlcy5cXG5gQ29sbGVjdGlvbi5LZXllZGAgcHJvZHVjZSBhbiBBcnJheSBvZiBba2V5LCB2YWx1ZV0gdHVwbGVzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSx7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XX1dfSxcImxpbmVcIjozOTY0fV19LFwiI3RvT2JqZWN0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNoYWxsb3dseSBjb252ZXJ0cyB0aGlzIENvbGxlY3Rpb24gdG8gYW4gT2JqZWN0LlwiLFwiZGVzY3JpcHRpb25cIjpcIkNvbnZlcnRzIGtleXMgdG8gU3RyaW5ncy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV19LFwibGluZVwiOjM5NzF9XX19fSx7XCJ0aXRsZVwiOlwiQ29udmVyc2lvbiB0byBDb2xsZWN0aW9uc1wiLFwibWVtYmVyc1wiOntcIiN0b01hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDb252ZXJ0cyB0aGlzIENvbGxlY3Rpb24gdG8gYSBNYXAsIFRocm93cyBpZiBrZXlzIGFyZSBub3QgaGFzaGFibGUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogVGhpcyBpcyBlcXVpdmFsZW50IHRvIGBNYXAodGhpcy50b0tleWVkU2VxKCkpYCwgYnV0IHByb3ZpZGVkXFxuZm9yIGNvbnZlbmllbmNlIGFuZCB0byBhbGxvdyBmb3IgY2hhaW5lZCBleHByZXNzaW9ucy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJNYXBcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6Mzk4Mn1dfSxcIiN0b09yZGVyZWRNYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQ29udmVydHMgdGhpcyBDb2xsZWN0aW9uIHRvIGEgTWFwLCBtYWludGFpbmluZyB0aGUgb3JkZXIgb2YgaXRlcmF0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IFRoaXMgaXMgZXF1aXZhbGVudCB0byBgT3JkZXJlZE1hcCh0aGlzLnRvS2V5ZWRTZXEoKSlgLCBidXRcXG5wcm92aWRlZCBmb3IgY29udmVuaWVuY2UgYW5kIHRvIGFsbG93IGZvciBjaGFpbmVkIGV4cHJlc3Npb25zLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRNYXBcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6Mzk5MH1dfSxcIiN0b1NldFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDb252ZXJ0cyB0aGlzIENvbGxlY3Rpb24gdG8gYSBTZXQsIGRpc2NhcmRpbmcga2V5cy4gVGhyb3dzIGlmIHZhbHVlc1xcbmFyZSBub3QgaGFzaGFibGUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogVGhpcyBpcyBlcXVpdmFsZW50IHRvIGBTZXQodGhpcylgLCBidXQgcHJvdmlkZWQgdG8gYWxsb3cgZm9yXFxuY2hhaW5lZCBleHByZXNzaW9ucy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjM5OTl9XX0sXCIjdG9PcmRlcmVkU2V0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkNvbnZlcnRzIHRoaXMgQ29sbGVjdGlvbiB0byBhIFNldCwgbWFpbnRhaW5pbmcgdGhlIG9yZGVyIG9mIGl0ZXJhdGlvbiBhbmRcXG5kaXNjYXJkaW5nIGtleXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogVGhpcyBpcyBlcXVpdmFsZW50IHRvIGBPcmRlcmVkU2V0KHRoaXMudmFsdWVTZXEoKSlgLCBidXQgcHJvdmlkZWRcXG5mb3IgY29udmVuaWVuY2UgYW5kIHRvIGFsbG93IGZvciBjaGFpbmVkIGV4cHJlc3Npb25zLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRTZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjQwMDh9XX0sXCIjdG9MaXN0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkNvbnZlcnRzIHRoaXMgQ29sbGVjdGlvbiB0byBhIExpc3QsIGRpc2NhcmRpbmcga2V5cy5cIixcImRlc2NyaXB0aW9uXCI6XCJUaGlzIGlzIHNpbWlsYXIgdG8gYExpc3QoY29sbGVjdGlvbilgLCBidXQgcHJvdmlkZWQgdG8gYWxsb3cgZm9yIGNoYWluZWRcXG5leHByZXNzaW9ucy4gSG93ZXZlciwgd2hlbiBjYWxsZWQgb24gYE1hcGAgb3Igb3RoZXIga2V5ZWQgY29sbGVjdGlvbnMsXFxuYGNvbGxlY3Rpb24udG9MaXN0KClgIGRpc2NhcmRzIHRoZSBrZXlzIGFuZCBjcmVhdGVzIGEgbGlzdCBvZiBvbmx5IHRoZVxcbnZhbHVlcywgd2hlcmVhcyBgTGlzdChjb2xsZWN0aW9uKWAgY3JlYXRlcyBhIGxpc3Qgb2YgZW50cnkgdHVwbGVzLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAsIExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxudmFyIG15TWFwID0gTWFwKHsgYTogJ0FwcGxlJywgYjogJ0JhbmFuYScgfSlcXG5MaXN0KG15TWFwKSAvLyBMaXN0IFsgWyBcXFwiYVxcXCIsIFxcXCJBcHBsZVxcXCIgXSwgWyBcXFwiYlxcXCIsIFxcXCJCYW5hbmFcXFwiIF0gXVxcbm15TWFwLnRvTGlzdCgpIC8vIExpc3QgWyBcXFwiQXBwbGVcXFwiLCBcXFwiQmFuYW5hXFxcIiBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6NDAyNn1dfSxcIiN0b1N0YWNrXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkNvbnZlcnRzIHRoaXMgQ29sbGVjdGlvbiB0byBhIFN0YWNrLCBkaXNjYXJkaW5nIGtleXMuIFRocm93cyBpZiB2YWx1ZXNcXG5hcmUgbm90IGhhc2hhYmxlLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IFRoaXMgaXMgZXF1aXZhbGVudCB0byBgU3RhY2sodGhpcylgLCBidXQgcHJvdmlkZWQgdG8gYWxsb3cgZm9yXFxuY2hhaW5lZCBleHByZXNzaW9ucy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTdGFja1wiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6NDAzNX1dfX19LHtcInRpdGxlXCI6XCJDb252ZXJzaW9uIHRvIFNlcVwiLFwibWVtYmVyc1wiOntcIiN0b1NlcVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDb252ZXJ0cyB0aGlzIENvbGxlY3Rpb24gdG8gYSBTZXEgb2YgdGhlIHNhbWUga2luZCAoaW5kZXhlZCxcXG5rZXllZCwgb3Igc2V0KS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXFcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6NDA0NH1dfSxcIiN0b0tleWVkU2VxXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBTZXEuS2V5ZWQgZnJvbSB0aGlzIENvbGxlY3Rpb24gd2hlcmUgaW5kaWNlcyBhcmUgdHJlYXRlZCBhcyBrZXlzLlwiLFwiZGVzY3JpcHRpb25cIjpcIlRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIG9wZXJhdGUgb24gYW5cXG5Db2xsZWN0aW9uLkluZGV4ZWQgYW5kIHByZXNlcnZlIHRoZSBbaW5kZXgsIHZhbHVlXSBwYWlycy5cXG5cXG5UaGUgcmV0dXJuZWQgU2VxIHdpbGwgaGF2ZSBpZGVudGljYWwgaXRlcmF0aW9uIG9yZGVyIGFzXFxudGhpcyBDb2xsZWN0aW9uLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBTZXEgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3QgaW5kZXhlZFNlcSA9IFNlcShbICdBJywgJ0InLCAnQycgXSlcXG4vLyBTZXEgWyBcXFwiQVxcXCIsIFxcXCJCXFxcIiwgXFxcIkNcXFwiIF1cXG5pbmRleGVkU2VxLmZpbHRlcih2ID0+IHYgPT09ICdCJylcXG4vLyBTZXEgWyBcXFwiQlxcXCIgXVxcbmNvbnN0IGtleWVkU2VxID0gaW5kZXhlZFNlcS50b0tleWVkU2VxKClcXG4vLyBTZXEgeyAwOiBcXFwiQVxcXCIsIDE6IFxcXCJCXFxcIiwgMjogXFxcIkNcXFwiIH1cXG5rZXllZFNlcS5maWx0ZXIodiA9PiB2ID09PSAnQicpXFxuLy8gU2VxIHsgMTogXFxcIkJcXFwiIH1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6NDA2OH1dfSxcIiN0b0luZGV4ZWRTZXFcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhbiBTZXEuSW5kZXhlZCBvZiB0aGUgdmFsdWVzIG9mIHRoaXMgQ29sbGVjdGlvbiwgZGlzY2FyZGluZyBrZXlzLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjo0MDczfV19LFwiI3RvU2V0U2VxXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBTZXEuU2V0IG9mIHRoZSB2YWx1ZXMgb2YgdGhpcyBDb2xsZWN0aW9uLCBkaXNjYXJkaW5nIGtleXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6NDA3OH1dfX19LHtcInRpdGxlXCI6XCJJdGVyYXRvcnNcIixcIm1lbWJlcnNcIjp7XCIja2V5c1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJBbiBpdGVyYXRvciBvZiB0aGlzIGBDb2xsZWN0aW9uYCdzIGtleXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogdGhpcyB3aWxsIHJldHVybiBhbiBFUzYgaXRlcmF0b3Igd2hpY2ggZG9lcyBub3Qgc3VwcG9ydFxcbkltbXV0YWJsZS5qcyBzZXF1ZW5jZSBhbGdvcml0aG1zLiBVc2UgYGtleVNlcWAgaW5zdGVhZCwgaWYgdGhpcyBpc1xcbndoYXQgeW91IHdhbnQuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVJdGVyYXRvclwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9XX0sXCJsaW5lXCI6NDA5MH1dfSxcIiN2YWx1ZXNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQW4gaXRlcmF0b3Igb2YgdGhpcyBgQ29sbGVjdGlvbmAncyB2YWx1ZXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogdGhpcyB3aWxsIHJldHVybiBhbiBFUzYgaXRlcmF0b3Igd2hpY2ggZG9lcyBub3Qgc3VwcG9ydFxcbkltbXV0YWJsZS5qcyBzZXF1ZW5jZSBhbGdvcml0aG1zLiBVc2UgYHZhbHVlU2VxYCBpbnN0ZWFkLCBpZiB0aGlzIGlzXFxud2hhdCB5b3Ugd2FudC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZUl0ZXJhdG9yXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjo0MDk5fV19LFwiI2VudHJpZXNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQW4gaXRlcmF0b3Igb2YgdGhpcyBgQ29sbGVjdGlvbmAncyBlbnRyaWVzIGFzIGBbIGtleSwgdmFsdWUgXWAgdHVwbGVzLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IHRoaXMgd2lsbCByZXR1cm4gYW4gRVM2IGl0ZXJhdG9yIHdoaWNoIGRvZXMgbm90IHN1cHBvcnRcXG5JbW11dGFibGUuanMgc2VxdWVuY2UgYWxnb3JpdGhtcy4gVXNlIGBlbnRyeVNlcWAgaW5zdGVhZCwgaWYgdGhpcyBpc1xcbndoYXQgeW91IHdhbnQuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVJdGVyYXRvclwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfV19LFwibGluZVwiOjQxMDh9XX19fSx7XCJ0aXRsZVwiOlwiQ29sbGVjdGlvbnMgKFNlcSlcIixcIm1lbWJlcnNcIjp7XCIja2V5U2VxXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU2VxLkluZGV4ZWQgb2YgdGhlIGtleXMgb2YgdGhpcyBDb2xsZWN0aW9uLFxcbmRpc2NhcmRpbmcgdmFsdWVzLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn1dfSxcImxpbmVcIjo0MTE3fV19LFwiI3ZhbHVlU2VxXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYW4gU2VxLkluZGV4ZWQgb2YgdGhlIHZhbHVlcyBvZiB0aGlzIENvbGxlY3Rpb24sIGRpc2NhcmRpbmcga2V5cy5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6NDEyMn1dfSxcIiNlbnRyeVNlcVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFNlcS5JbmRleGVkIG9mIFtrZXksIHZhbHVlXSB0dXBsZXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfSxcImxpbmVcIjo0MTI3fV19fX0se1widGl0bGVcIjpcIlNlcXVlbmNlIGFsZ29yaXRobXNcIixcIm1lbWJlcnNcIjp7XCIjbWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIHdpdGggdmFsdWVzIHBhc3NlZCB0aHJvdWdoIGFcXG5gbWFwcGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgQ29sbGVjdGlvbiB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5Db2xsZWN0aW9uKHsgYTogMSwgYjogMiB9KS5tYXAoeCA9PiAxMCAqIHgpXFxuLy8gU2VxIHsgXFxcImFcXFwiOiAxMCwgXFxcImJcXFwiOiAyMCB9XFxuYGBgXFxuXFxuTm90ZTogYG1hcCgpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCBwcm9kdWNlZCB0aGUgc2FtZVxcbnZhbHVlIGF0IGV2ZXJ5IHN0ZXAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk1cIn19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjo0MTQ2fV19LFwiI2ZpbHRlclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZSB3aXRoIG9ubHkgdGhlIGVudHJpZXMgZm9yIHdoaWNoXFxudGhlIGBwcmVkaWNhdGVgIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbk1hcCh7IGE6IDEsIGI6IDIsIGM6IDMsIGQ6IDR9KS5maWx0ZXIoeCA9PiB4ICUgMiA9PT0gMClcXG4vLyBNYXAgeyBcXFwiYlxcXCI6IDIsIFxcXCJkXFxcIjogNCB9XFxuYGBgXFxuXFxuTm90ZTogYGZpbHRlcigpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCByZXN1bHRzIGluXFxubm90IGZpbHRlcmluZyBvdXQgYW55IHZhbHVlcy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiRlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJGXCJ9XX0sXCJsaW5lXCI6NDE3M30se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MTd9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjQxNzd9XX0sXCIjZmlsdGVyTm90XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIHdpdGggb25seSB0aGUgZW50cmllcyBmb3Igd2hpY2hcXG50aGUgYHByZWRpY2F0ZWAgZnVuY3Rpb24gcmV0dXJucyBmYWxzZS5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbk1hcCh7IGE6IDEsIGI6IDIsIGM6IDMsIGQ6IDR9KS5maWx0ZXJOb3QoeCA9PiB4ICUgMiA9PT0gMClcXG4vLyBNYXAgeyBcXFwiYVxcXCI6IDEsIFxcXCJjXFxcIjogMyB9XFxuYGBgXFxuXFxuTm90ZTogYGZpbHRlck5vdCgpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCByZXN1bHRzIGluXFxubm90IGZpbHRlcmluZyBvdXQgYW55IHZhbHVlcy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo0MTk2fV19LFwiI3JldmVyc2VcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgaW4gcmV2ZXJzZSBvcmRlci5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo0MjA0fV19LFwiI3NvcnRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgd2hpY2ggaW5jbHVkZXMgdGhlIHNhbWUgZW50cmllcyxcXG5zdGFibHkgc29ydGVkIGJ5IHVzaW5nIGEgYGNvbXBhcmF0b3JgLlwiLFwiZGVzY3JpcHRpb25cIjpcIklmIGEgYGNvbXBhcmF0b3JgIGlzIG5vdCBwcm92aWRlZCwgYSBkZWZhdWx0IGNvbXBhcmF0b3IgdXNlcyBgPGAgYW5kIGA+YC5cXG5cXG5gY29tcGFyYXRvcih2YWx1ZUEsIHZhbHVlQilgOlxcblxcbiAgKiBSZXR1cm5zIGAwYCBpZiB0aGUgZWxlbWVudHMgc2hvdWxkIG5vdCBiZSBzd2FwcGVkLlxcbiAgKiBSZXR1cm5zIGAtMWAgKG9yIGFueSBuZWdhdGl2ZSBudW1iZXIpIGlmIGB2YWx1ZUFgIGNvbWVzIGJlZm9yZSBgdmFsdWVCYFxcbiAgKiBSZXR1cm5zIGAxYCAob3IgYW55IHBvc2l0aXZlIG51bWJlcikgaWYgYHZhbHVlQWAgY29tZXMgYWZ0ZXIgYHZhbHVlQmBcXG4gICogSXMgcHVyZSwgaS5lLiBpdCBtdXN0IGFsd2F5cyByZXR1cm4gdGhlIHNhbWUgdmFsdWUgZm9yIHRoZSBzYW1lIHBhaXJcXG4gICAgb2YgdmFsdWVzLlxcblxcbldoZW4gc29ydGluZyBjb2xsZWN0aW9ucyB3aGljaCBoYXZlIG5vIGRlZmluZWQgb3JkZXIsIHRoZWlyIG9yZGVyZWRcXG5lcXVpdmFsZW50cyB3aWxsIGJlIHJldHVybmVkLiBlLmcuIGBtYXAuc29ydCgpYCByZXR1cm5zIE9yZGVyZWRNYXAuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IE1hcCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5NYXAoeyBcXFwiY1xcXCI6IDMsIFxcXCJhXFxcIjogMSwgXFxcImJcXFwiOiAyIH0pLnNvcnQoKGEsIGIpID0+IHtcXG4gIGlmIChhIDwgYikgeyByZXR1cm4gLTE7IH1cXG4gIGlmIChhID4gYikgeyByZXR1cm4gMTsgfVxcbiAgaWYgKGEgPT09IGIpIHsgcmV0dXJuIDA7IH1cXG59KTtcXG4vLyBPcmRlcmVkTWFwIHsgXFxcImFcXFwiOiAxLCBcXFwiYlxcXCI6IDIsIFxcXCJjXFxcIjogMyB9XFxuYGBgXFxuXFxuTm90ZTogYHNvcnQoKWAgQWx3YXlzIHJldHVybnMgYSBuZXcgaW5zdGFuY2UsIGV2ZW4gaWYgdGhlIG9yaWdpbmFsIHdhc1xcbmFscmVhZHkgc29ydGVkLlxcblxcbk5vdGU6IFRoaXMgaXMgYWx3YXlzIGFuIGVhZ2VyIG9wZXJhdGlvbi5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29tcGFyYXRvclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlQVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcInZhbHVlQlwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6Mn19LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo0MjM5fV19LFwiI3NvcnRCeVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJMaWtlIGBzb3J0YCwgYnV0IGFsc28gYWNjZXB0cyBhIGBjb21wYXJhdG9yVmFsdWVNYXBwZXJgIHdoaWNoIGFsbG93cyBmb3JcXG5zb3J0aW5nIGJ5IG1vcmUgc29waGlzdGljYXRlZCBtZWFuczpcIixcImRlc2NyaXB0aW9uXCI6XCIgICAgaGl0dGVycy5zb3J0QnkoaGl0dGVyID0+IGhpdHRlci5hdmdIaXRzKVxcblxcbk5vdGU6IGBzb3J0QnkoKWAgQWx3YXlzIHJldHVybnMgYSBuZXcgaW5zdGFuY2UsIGV2ZW4gaWYgdGhlIG9yaWdpbmFsIHdhc1xcbmFscmVhZHkgc29ydGVkLlxcblxcbk5vdGU6IFRoaXMgaXMgYWx3YXlzIGFuIGVhZ2VyIG9wZXJhdGlvbi5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb21wYXJhdG9yVmFsdWVNYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX19LHtcIm5hbWVcIjpcImNvbXBhcmF0b3JcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZUFcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZUJcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjJ9fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NDI1Mn1dfSxcIiNncm91cEJ5XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBgQ29sbGVjdGlvbi5LZXllZGAgb2YgYENvbGxlY3Rpb24uS2V5ZWRzYCwgZ3JvdXBlZCBieSB0aGUgcmV0dXJuXFxudmFsdWUgb2YgdGhlIGBncm91cGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBUaGlzIGlzIGFsd2F5cyBhbiBlYWdlciBvcGVyYXRpb24uXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IExpc3QsIE1hcCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBsaXN0T2ZNYXBzID0gTGlzdChbXFxuICBNYXAoeyB2OiAwIH0pLFxcbiAgTWFwKHsgdjogMSB9KSxcXG4gIE1hcCh7IHY6IDEgfSksXFxuICBNYXAoeyB2OiAwIH0pLFxcbiAgTWFwKHsgdjogMiB9KVxcbl0pXFxuY29uc3QgZ3JvdXBzT2ZNYXBzID0gbGlzdE9mTWFwcy5ncm91cEJ5KHggPT4geC5nZXQoJ3YnKSlcXG4vLyBNYXAge1xcbi8vICAgMDogTGlzdCBbIE1hcHsgXFxcInZcXFwiOiAwIH0sIE1hcCB7IFxcXCJ2XFxcIjogMCB9IF0sXFxuLy8gICAxOiBMaXN0IFsgTWFweyBcXFwidlxcXCI6IDEgfSwgTWFwIHsgXFxcInZcXFwiOiAxIH0gXSxcXG4vLyAgIDI6IExpc3QgWyBNYXB7IFxcXCJ2XFxcIjogMiB9IF0sXFxuLy8gfVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJHXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImdyb3VwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiR1wifX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiR1wifSx7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfSxcImxpbmVcIjo0MjgxfV19fX0se1widGl0bGVcIjpcIlNpZGUgZWZmZWN0c1wiLFwibWVtYmVyc1wiOntcIiNmb3JFYWNoXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRoZSBgc2lkZUVmZmVjdGAgaXMgZXhlY3V0ZWQgZm9yIGV2ZXJ5IGVudHJ5IGluIHRoZSBDb2xsZWN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIlVubGlrZSBgQXJyYXkjZm9yRWFjaGAsIGlmIGFueSBjYWxsIG9mIGBzaWRlRWZmZWN0YCByZXR1cm5zXFxuYGZhbHNlYCwgdGhlIGl0ZXJhdGlvbiB3aWxsIHN0b3AuIFJldHVybnMgdGhlIG51bWJlciBvZiBlbnRyaWVzIGl0ZXJhdGVkXFxuKGluY2x1ZGluZyB0aGUgbGFzdCBpdGVyYXRpb24gd2hpY2ggcmV0dXJuZWQgZmFsc2UpLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzaWRlRWZmZWN0XCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxN319fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoyfSxcImxpbmVcIjo0Mjk2fV19fX0se1widGl0bGVcIjpcIkNyZWF0aW5nIHN1YnNldHNcIixcIm1lbWJlcnNcIjp7XCIjc2xpY2VcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgcmVwcmVzZW50aW5nIGEgcG9ydGlvbiBvZiB0aGlzXFxuQ29sbGVjdGlvbiBmcm9tIHN0YXJ0IHVwIHRvIGJ1dCBub3QgaW5jbHVkaW5nIGVuZC5cIixcImRlc2NyaXB0aW9uXCI6XCJJZiBiZWdpbiBpcyBuZWdhdGl2ZSwgaXQgaXMgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgQ29sbGVjdGlvbi4gZS5nLlxcbmBzbGljZSgtMilgIHJldHVybnMgYSBDb2xsZWN0aW9uIG9mIHRoZSBsYXN0IHR3byBlbnRyaWVzLiBJZiBpdCBpcyBub3RcXG5wcm92aWRlZCB0aGUgbmV3IENvbGxlY3Rpb24gd2lsbCBiZWdpbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgQ29sbGVjdGlvbi5cXG5cXG5JZiBlbmQgaXMgbmVnYXRpdmUsIGl0IGlzIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIENvbGxlY3Rpb24uIGUuZy5cXG5gc2xpY2UoMCwgLTEpYCByZXR1cm5zIGEgQ29sbGVjdGlvbiBvZiBldmVyeXRoaW5nIGJ1dCB0aGUgbGFzdCBlbnRyeS4gSWZcXG5pdCBpcyBub3QgcHJvdmlkZWQsIHRoZSBuZXcgQ29sbGVjdGlvbiB3aWxsIGNvbnRpbnVlIHRocm91Z2ggdGhlIGVuZCBvZlxcbnRoaXMgQ29sbGVjdGlvbi5cXG5cXG5JZiB0aGUgcmVxdWVzdGVkIHNsaWNlIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGN1cnJlbnQgQ29sbGVjdGlvbiwgdGhlbiBpdFxcbndpbGwgcmV0dXJuIGl0c2VsZi5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiYmVnaW5cIixcInR5cGVcIjp7XCJrXCI6Mn0sXCJvcHRpb25hbFwiOnRydWV9LHtcIm5hbWVcIjpcImVuZFwiLFwidHlwZVwiOntcImtcIjoyfSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NDMyMH1dfSxcIiNyZXN0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIGNvbnRhaW5pbmcgYWxsIGVudHJpZXMgZXhjZXB0XFxudGhlIGZpcnN0LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjQzMjZ9XX0sXCIjYnV0TGFzdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZSBjb250YWluaW5nIGFsbCBlbnRyaWVzIGV4Y2VwdFxcbnRoZSBsYXN0LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjQzMzJ9XX0sXCIjc2tpcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZSB3aGljaCBleGNsdWRlcyB0aGUgZmlyc3QgYGFtb3VudGBcXG5lbnRyaWVzIGZyb20gdGhpcyBDb2xsZWN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJhbW91bnRcIixcInR5cGVcIjp7XCJrXCI6Mn19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjQzMzh9XX0sXCIjc2tpcExhc3RcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgd2hpY2ggZXhjbHVkZXMgdGhlIGxhc3QgYGFtb3VudGBcXG5lbnRyaWVzIGZyb20gdGhpcyBDb2xsZWN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJhbW91bnRcIixcInR5cGVcIjp7XCJrXCI6Mn19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjQzNDR9XX0sXCIjc2tpcFdoaWxlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIHdoaWNoIGluY2x1ZGVzIGVudHJpZXMgc3RhcnRpbmdcXG5mcm9tIHdoZW4gYHByZWRpY2F0ZWAgZmlyc3QgcmV0dXJucyBmYWxzZS5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5MaXN0KFsgJ2RvZycsICdmcm9nJywgJ2NhdCcsICdoYXQnLCAnZ29kJyBdKVxcbiAgLnNraXBXaGlsZSh4ID0+IHgubWF0Y2goL2cvKSlcXG4vLyBMaXN0IFsgXFxcImNhdFxcXCIsIFxcXCJoYXRcXFwiLCBcXFwiZ29kXFxcIiBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NDM1OH1dfSxcIiNza2lwVW50aWxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgd2hpY2ggaW5jbHVkZXMgZW50cmllcyBzdGFydGluZ1xcbmZyb20gd2hlbiBgcHJlZGljYXRlYCBmaXJzdCByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuTGlzdChbICdkb2cnLCAnZnJvZycsICdjYXQnLCAnaGF0JywgJ2dvZCcgXSlcXG4gIC5za2lwVW50aWwoeCA9PiB4Lm1hdGNoKC9oYXQvKSlcXG4vLyBMaXN0IFsgXFxcImhhdFxcXCIsIFxcXCJnb2RcXFwiIF1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo0Mzc1fV19LFwiI3Rha2VcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgd2hpY2ggaW5jbHVkZXMgdGhlIGZpcnN0IGBhbW91bnRgXFxuZW50cmllcyBmcm9tIHRoaXMgQ29sbGVjdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiYW1vdW50XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo0Mzg0fV19LFwiI3Rha2VMYXN0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIHdoaWNoIGluY2x1ZGVzIHRoZSBsYXN0IGBhbW91bnRgXFxuZW50cmllcyBmcm9tIHRoaXMgQ29sbGVjdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiYW1vdW50XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo0MzkwfV19LFwiI3Rha2VXaGlsZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZSB3aGljaCBpbmNsdWRlcyBlbnRyaWVzIGZyb20gdGhpc1xcbkNvbGxlY3Rpb24gYXMgbG9uZyBhcyB0aGUgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbkxpc3QoWyAnZG9nJywgJ2Zyb2cnLCAnY2F0JywgJ2hhdCcsICdnb2QnIF0pXFxuICAudGFrZVdoaWxlKHggPT4geC5tYXRjaCgvby8pKVxcbi8vIExpc3QgWyBcXFwiZG9nXFxcIiwgXFxcImZyb2dcXFwiIF1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo0NDA0fV19LFwiI3Rha2VVbnRpbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZSB3aGljaCBpbmNsdWRlcyBlbnRyaWVzIGZyb20gdGhpc1xcbkNvbGxlY3Rpb24gYXMgbG9uZyBhcyB0aGUgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZS5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5MaXN0KFsgJ2RvZycsICdmcm9nJywgJ2NhdCcsICdoYXQnLCAnZ29kJyBdKVxcbiAgLnRha2VVbnRpbCh4ID0+IHgubWF0Y2goL2F0LykpXFxuLy8gTGlzdCBbIFxcXCJkb2dcXFwiLCBcXFwiZnJvZ1xcXCIgXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjQ0MjF9XX19fSx7XCJ0aXRsZVwiOlwiQ29tYmluYXRpb25cIixcIm1lbWJlcnNcIjp7XCIjY29uY2F0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIHdpdGggb3RoZXIgdmFsdWVzIGFuZFxcbmNvbGxlY3Rpb24tbGlrZSBjb25jYXRlbmF0ZWQgdG8gdGhpcyBvbmUuXCIsXCJkZXNjcmlwdGlvblwiOlwiRm9yIFNlcXMsIGFsbCBlbnRyaWVzIHdpbGwgYmUgcHJlc2VudCBpbiB0aGUgcmVzdWx0aW5nIFNlcSwgZXZlbiBpZiB0aGV5XFxuaGF2ZSB0aGUgc2FtZSBrZXkuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlc09yQ29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19LFwibGluZVwiOjQ0MzZ9XX0sXCIjZmxhdHRlblwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJGbGF0dGVucyBuZXN0ZWQgQ29sbGVjdGlvbnMuXCIsXCJkZXNjcmlwdGlvblwiOlwiV2lsbCBkZWVwbHkgZmxhdHRlbiB0aGUgQ29sbGVjdGlvbiBieSBkZWZhdWx0LCByZXR1cm5pbmcgYSBDb2xsZWN0aW9uIG9mIHRoZVxcbnNhbWUgdHlwZSwgYnV0IGEgYGRlcHRoYCBjYW4gYmUgcHJvdmlkZWQgaW4gdGhlIGZvcm0gb2YgYSBudW1iZXIgb3JcXG5ib29sZWFuICh3aGVyZSB0cnVlIG1lYW5zIHRvIHNoYWxsb3dseSBmbGF0dGVuIG9uZSBsZXZlbCkuIEEgZGVwdGggb2YgMFxcbihvciBzaGFsbG93OiBmYWxzZSkgd2lsbCBkZWVwbHkgZmxhdHRlbi5cXG5cXG5GbGF0dGVucyBvbmx5IG90aGVycyBDb2xsZWN0aW9uLCBub3QgQXJyYXlzIG9yIE9iamVjdHMuXFxuXFxuTm90ZTogYGZsYXR0ZW4odHJ1ZSlgIG9wZXJhdGVzIG9uIENvbGxlY3Rpb248dW5rbm93biwgQ29sbGVjdGlvbjxLLCBWPj4gYW5kXFxucmV0dXJucyBDb2xsZWN0aW9uPEssIFY+XCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImRlcHRoXCIsXCJ0eXBlXCI6e1wia1wiOjJ9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19LFwibGluZVwiOjQ0NTF9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzaGFsbG93XCIsXCJ0eXBlXCI6e1wia1wiOjF9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19LFwibGluZVwiOjQ0NTJ9XX0sXCIjZmxhdE1hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJGbGF0LW1hcHMgdGhlIENvbGxlY3Rpb24sIHJldHVybmluZyBhIENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZS5cIixcImRlc2NyaXB0aW9uXCI6XCJTaW1pbGFyIHRvIGBjb2xsZWN0aW9uLm1hcCguLi4pLmZsYXR0ZW4odHJ1ZSlgLlxcblVzZWQgZm9yIERpY3Rpb25hcmllcyBvbmx5LlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjQ0NTl9LHtcInR5cGVQYXJhbXNcIjpbXCJLTVwiLFwiVk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS01cIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVk1cIn1dfV19fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS01cIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVk1cIn1dfSxcImxpbmVcIjo0NDcwfV19fX0se1widGl0bGVcIjpcIlJlZHVjaW5nIGEgdmFsdWVcIixcIm1lbWJlcnNcIjp7XCIjcmVkdWNlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJlZHVjZXMgdGhlIENvbGxlY3Rpb24gdG8gYSB2YWx1ZSBieSBjYWxsaW5nIHRoZSBgcmVkdWNlcmAgZm9yIGV2ZXJ5IGVudHJ5XFxuaW4gdGhlIENvbGxlY3Rpb24gYW5kIHBhc3NpbmcgYWxvbmcgdGhlIHJlZHVjZWQgdmFsdWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiSWYgYGluaXRpYWxSZWR1Y3Rpb25gIGlzIG5vdCBwcm92aWRlZCwgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlXFxuQ29sbGVjdGlvbiB3aWxsIGJlIHVzZWQuXFxuXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcImBBcnJheSNyZWR1Y2VgLlwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiUlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJyZWR1Y2VyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicmVkdWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiUlwifX0se1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlJcIn19fSx7XCJuYW1lXCI6XCJpbml0aWFsUmVkdWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiUlwifX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJSXCJ9LFwibGluZVwiOjQ0ODZ9LHtcInR5cGVQYXJhbXNcIjpbXCJSXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInJlZHVjZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJyZWR1Y3Rpb25cIixcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlJcIn1dfX0se1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlJcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiUlwifSxcImxpbmVcIjo0NDkxfV19LFwiI3JlZHVjZVJpZ2h0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJlZHVjZXMgdGhlIENvbGxlY3Rpb24gaW4gcmV2ZXJzZSAoZnJvbSB0aGUgcmlnaHQgc2lkZSkuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogU2ltaWxhciB0byB0aGlzLnJldmVyc2UoKS5yZWR1Y2UoKSwgYW5kIHByb3ZpZGVkIGZvciBwYXJpdHlcXG53aXRoIGBBcnJheSNyZWR1Y2VSaWdodGAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlJcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicmVkdWNlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInJlZHVjdGlvblwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlJcIn19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJSXCJ9fX0se1wibmFtZVwiOlwiaW5pdGlhbFJlZHVjdGlvblwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlJcIn19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiUlwifSxcImxpbmVcIjo0NTAxfSx7XCJ0eXBlUGFyYW1zXCI6W1wiUlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJyZWR1Y2VyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicmVkdWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJSXCJ9XX19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJSXCJ9fX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlJcIn0sXCJsaW5lXCI6NDUwNn1dfSxcIiNldmVyeVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1ZSBmb3IgYWxsIGVudHJpZXMgaW4gdGhlIENvbGxlY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo0NTEzfV19LFwiI3NvbWVcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydWUgZm9yIGFueSBlbnRyeSBpbiB0aGUgQ29sbGVjdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjQ1MjF9XX0sXCIjam9pblwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJKb2lucyB2YWx1ZXMgdG9nZXRoZXIgYXMgYSBzdHJpbmcsIGluc2VydGluZyBhIHNlcGFyYXRvciBiZXR3ZWVuIGVhY2guXFxuVGhlIGRlZmF1bHQgc2VwYXJhdG9yIGlzIGBcXFwiLFxcXCJgLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzZXBhcmF0b3JcIixcInR5cGVcIjp7XCJrXCI6M30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6M30sXCJsaW5lXCI6NDUzMH1dfSxcIiNpc0VtcHR5XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgdHJ1ZSBpZiB0aGlzIENvbGxlY3Rpb24gaW5jbHVkZXMgbm8gdmFsdWVzLlwiLFwiZGVzY3JpcHRpb25cIjpcIkZvciBzb21lIGxhenkgYFNlcWAsIGBpc0VtcHR5YCBtaWdodCBuZWVkIHRvIGl0ZXJhdGUgdG8gZGV0ZXJtaW5lXFxuZW1wdGluZXNzLiBBdCBtb3N0IG9uZSBpdGVyYXRpb24gd2lsbCBvY2N1ci5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjQ1Mzh9XX0sXCIjY291bnRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGlzIENvbGxlY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiUmVnYXJkbGVzcyBvZiBpZiB0aGlzIENvbGxlY3Rpb24gY2FuIGRlc2NyaWJlIGl0cyBzaXplIGxhemlseSAoc29tZSBTZXFzXFxuY2Fubm90KSwgdGhpcyBtZXRob2Qgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSBjb3JyZWN0IHNpemUuIEUuZy4gaXRcXG5ldmFsdWF0ZXMgYSBsYXp5IGBTZXFgIGlmIG5lY2Vzc2FyeS5cXG5cXG5JZiBgcHJlZGljYXRlYCBpcyBwcm92aWRlZCwgdGhlbiB0aGlzIHJldHVybnMgdGhlIGNvdW50IG9mIGVudHJpZXMgaW4gdGhlXFxuQ29sbGVjdGlvbiBmb3Igd2hpY2ggdGhlIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1ZS5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjJ9LFwibGluZVwiOjQ1NTB9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6Mn0sXCJsaW5lXCI6NDU1MX1dfSxcIiNjb3VudEJ5XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBgU2VxLktleWVkYCBvZiBjb3VudHMsIGdyb3VwZWQgYnkgdGhlIHJldHVybiB2YWx1ZSBvZlxcbnRoZSBgZ3JvdXBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogVGhpcyBpcyBub3QgYSBsYXp5IG9wZXJhdGlvbi5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiR1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJncm91cGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkdcIn19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTWFwXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIkdcIn0se1wia1wiOjJ9XX0sXCJsaW5lXCI6NDU2Mn1dfX19LHtcInRpdGxlXCI6XCJTZWFyY2ggZm9yIHZhbHVlXCIsXCJtZW1iZXJzXCI6e1wiI2ZpbmRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyB0aGUgZmlyc3QgdmFsdWUgZm9yIHdoaWNoIHRoZSBgcHJlZGljYXRlYCByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6MTF9XX0sXCJsaW5lXCI6NDU3M31dfSxcIiNmaW5kTGFzdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRoZSBsYXN0IHZhbHVlIGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBwcmVkaWNhdGVgIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGVudHJ5IGluIHJldmVyc2UuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6MTF9XX0sXCJsaW5lXCI6NDU4NH1dfSxcIiNmaW5kRW50cnlcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyB0aGUgZmlyc3QgW2tleSwgdmFsdWVdIGVudHJ5IGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9LHtcIm5hbWVcIjpcIm5vdFNldFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LHtcImtcIjoxMX1dfSxcImxpbmVcIjo0NTkzfV19LFwiI2ZpbmRMYXN0RW50cnlcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyB0aGUgbGFzdCBba2V5LCB2YWx1ZV0gZW50cnkgZm9yIHdoaWNoIHRoZSBgcHJlZGljYXRlYFxcbnJldHVybnMgdHJ1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgcHJlZGljYXRlYCB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBlbnRyeSBpbiByZXZlcnNlLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9LHtcIm5hbWVcIjpcIm5vdFNldFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LHtcImtcIjoxMX1dfSxcImxpbmVcIjo0NjA1fV19LFwiI2ZpbmRLZXlcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyB0aGUga2V5IGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjoxMX1dfSxcImxpbmVcIjo0NjE0fV19LFwiI2ZpbmRMYXN0S2V5XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgdGhlIGxhc3Qga2V5IGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBwcmVkaWNhdGVgIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGVudHJ5IGluIHJldmVyc2UuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjExfV19LFwibGluZVwiOjQ2MjR9XX0sXCIja2V5T2ZcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyB0aGUga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGUgc2VhcmNoIHZhbHVlLCBvciB1bmRlZmluZWQuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInNlYXJjaFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjExfV19LFwibGluZVwiOjQ2MzJ9XX0sXCIjbGFzdEtleU9mXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgdGhlIGxhc3Qga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGUgc2VhcmNoIHZhbHVlLCBvciB1bmRlZmluZWQuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInNlYXJjaFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjExfV19LFwibGluZVwiOjQ2Mzd9XX0sXCIjbWF4XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgdGhlIG1heGltdW0gdmFsdWUgaW4gdGhpcyBjb2xsZWN0aW9uLiBJZiBhbnkgdmFsdWVzIGFyZVxcbmNvbXBhcmF0aXZlbHkgZXF1aXZhbGVudCwgdGhlIGZpcnN0IG9uZSBmb3VuZCB3aWxsIGJlIHJldHVybmVkLlwiLFwiZGVzY3JpcHRpb25cIjpcIlRoZSBgY29tcGFyYXRvcmAgaXMgdXNlZCBpbiB0aGUgc2FtZSB3YXkgYXMgYENvbGxlY3Rpb24jc29ydGAuIElmIGl0IGlzIG5vdFxcbnByb3ZpZGVkLCB0aGUgZGVmYXVsdCBjb21wYXJhdG9yIGlzIGA+YC5cXG5cXG5XaGVuIHR3byB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQgZXF1aXZhbGVudCwgdGhlIGZpcnN0IGVuY291bnRlcmVkIHdpbGwgYmVcXG5yZXR1cm5lZC4gT3RoZXJ3aXNlLCBgbWF4YCB3aWxsIG9wZXJhdGUgaW5kZXBlbmRlbnQgb2YgdGhlIG9yZGVyIG9mIGlucHV0XFxuYXMgbG9uZyBhcyB0aGUgY29tcGFyYXRvciBpcyBjb21tdXRhdGl2ZS4gVGhlIGRlZmF1bHQgY29tcGFyYXRvciBgPmAgaXNcXG5jb21tdXRhdGl2ZSAqb25seSogd2hlbiB0eXBlcyBkbyBub3QgZGlmZmVyLlxcblxcbklmIGBjb21wYXJhdG9yYCByZXR1cm5zIDAgYW5kIGVpdGhlciB2YWx1ZSBpcyBOYU4sIHVuZGVmaW5lZCwgb3IgbnVsbCxcXG50aGF0IHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbXBhcmF0b3JcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZUFcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZUJcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjJ9fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjExfV19LFwibGluZVwiOjQ2NTR9XX0sXCIjbWF4QnlcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiTGlrZSBgbWF4YCwgYnV0IGFsc28gYWNjZXB0cyBhIGBjb21wYXJhdG9yVmFsdWVNYXBwZXJgIHdoaWNoIGFsbG93cyBmb3JcXG5jb21wYXJpbmcgYnkgbW9yZSBzb3BoaXN0aWNhdGVkIG1lYW5zOlwiLFwiZGVzY3JpcHRpb25cIjpcIiAgICBoaXR0ZXJzLm1heEJ5KGhpdHRlciA9PiBoaXR0ZXIuYXZnSGl0cyk7XFxuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29tcGFyYXRvclZhbHVlTWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19fSx7XCJuYW1lXCI6XCJjb21wYXJhdG9yXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVBXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwidmFsdWVCXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX1dLFwidHlwZVwiOntcImtcIjoyfX0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjoxMX1dfSxcImxpbmVcIjo0NjYzfV19LFwiI21pblwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlIGluIHRoaXMgY29sbGVjdGlvbi4gSWYgYW55IHZhbHVlcyBhcmVcXG5jb21wYXJhdGl2ZWx5IGVxdWl2YWxlbnQsIHRoZSBmaXJzdCBvbmUgZm91bmQgd2lsbCBiZSByZXR1cm5lZC5cIixcImRlc2NyaXB0aW9uXCI6XCJUaGUgYGNvbXBhcmF0b3JgIGlzIHVzZWQgaW4gdGhlIHNhbWUgd2F5IGFzIGBDb2xsZWN0aW9uI3NvcnRgLiBJZiBpdCBpcyBub3RcXG5wcm92aWRlZCwgdGhlIGRlZmF1bHQgY29tcGFyYXRvciBpcyBgPGAuXFxuXFxuV2hlbiB0d28gdmFsdWVzIGFyZSBjb25zaWRlcmVkIGVxdWl2YWxlbnQsIHRoZSBmaXJzdCBlbmNvdW50ZXJlZCB3aWxsIGJlXFxucmV0dXJuZWQuIE90aGVyd2lzZSwgYG1pbmAgd2lsbCBvcGVyYXRlIGluZGVwZW5kZW50IG9mIHRoZSBvcmRlciBvZiBpbnB1dFxcbmFzIGxvbmcgYXMgdGhlIGNvbXBhcmF0b3IgaXMgY29tbXV0YXRpdmUuIFRoZSBkZWZhdWx0IGNvbXBhcmF0b3IgYDxgIGlzXFxuY29tbXV0YXRpdmUgKm9ubHkqIHdoZW4gdHlwZXMgZG8gbm90IGRpZmZlci5cXG5cXG5JZiBgY29tcGFyYXRvcmAgcmV0dXJucyAwIGFuZCBlaXRoZXIgdmFsdWUgaXMgTmFOLCB1bmRlZmluZWQsIG9yIG51bGwsXFxudGhhdCB2YWx1ZSB3aWxsIGJlIHJldHVybmVkLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb21wYXJhdG9yXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVBXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwidmFsdWVCXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjoyfX0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjoxMX1dfSxcImxpbmVcIjo0NjgzfV19LFwiI21pbkJ5XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkxpa2UgYG1pbmAsIGJ1dCBhbHNvIGFjY2VwdHMgYSBgY29tcGFyYXRvclZhbHVlTWFwcGVyYCB3aGljaCBhbGxvd3MgZm9yXFxuY29tcGFyaW5nIGJ5IG1vcmUgc29waGlzdGljYXRlZCBtZWFuczpcIixcImRlc2NyaXB0aW9uXCI6XCIgICAgaGl0dGVycy5taW5CeShoaXR0ZXIgPT4gaGl0dGVyLmF2Z0hpdHMpO1xcblwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbXBhcmF0b3JWYWx1ZU1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fX0se1wibmFtZVwiOlwiY29tcGFyYXRvclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlQVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcInZhbHVlQlwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19XSxcInR5cGVcIjp7XCJrXCI6Mn19LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6MTF9XX0sXCJsaW5lXCI6NDY5Mn1dfX19LHtcInRpdGxlXCI6XCJDb21wYXJpc29uXCIsXCJtZW1iZXJzXCI6e1wiI2lzU3Vic2V0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgYGl0ZXJgIGluY2x1ZGVzIGV2ZXJ5IHZhbHVlIGluIHRoaXMgQ29sbGVjdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjQ3MDN9XX0sXCIjaXNTdXBlcnNldFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIHRoaXMgQ29sbGVjdGlvbiBpbmNsdWRlcyBldmVyeSB2YWx1ZSBpbiBgaXRlcmAuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo0NzA4fV19fX1dfX0sXCJWYWx1ZU9iamVjdFwiOntcImludGVyZmFjZVwiOntcImxpbmVcIjo0NzE0LFwiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRoZSBpbnRlcmZhY2UgdG8gZnVsZmlsbCB0byBxdWFsaWZ5IGFzIGEgVmFsdWUgT2JqZWN0LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJncm91cHNcIjpbe1wibWVtYmVyc1wiOntcIiNlcXVhbHNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiB0aGlzIGFuZCB0aGUgb3RoZXIgQ29sbGVjdGlvbiBoYXZlIHZhbHVlIGVxdWFsaXR5LCBhcyBkZWZpbmVkXFxuYnkgYEltbXV0YWJsZS5pcygpYC5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gYEltbXV0YWJsZS5pcyh0aGlzLCBvdGhlcilgLCBidXQgcHJvdmlkZWQgdG9cXG5hbGxvdyBmb3IgY2hhaW5lZCBleHByZXNzaW9ucy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib3RoZXJcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjQ3MjJ9XX0sXCIjaGFzaENvZGVcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQ29tcHV0ZXMgYW5kIHJldHVybnMgdGhlIGhhc2hlZCBpZGVudGl0eSBmb3IgdGhpcyBDb2xsZWN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIlRoZSBgaGFzaENvZGVgIG9mIGEgQ29sbGVjdGlvbiBpcyB1c2VkIHRvIGRldGVybWluZSBwb3RlbnRpYWwgZXF1YWxpdHksXFxuYW5kIGlzIHVzZWQgd2hlbiBhZGRpbmcgdGhpcyB0byBhIGBTZXRgIG9yIGFzIGEga2V5IGluIGEgYE1hcGAsIGVuYWJsaW5nXFxubG9va3VwIHZpYSBhIGRpZmZlcmVudCBpbnN0YW5jZS5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTGlzdCwgU2V0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXG5jb25zdCBhID0gTGlzdChbIDEsIDIsIDMgXSk7XFxuY29uc3QgYiA9IExpc3QoWyAxLCAyLCAzIF0pO1xcbmFzc2VydC5ub3RTdHJpY3RFcXVhbChhLCBiKTsgLy8gZGlmZmVyZW50IGluc3RhbmNlc1xcbmNvbnN0IHNldCA9IFNldChbIGEgXSk7XFxuYXNzZXJ0LmVxdWFsKHNldC5oYXMoYiksIHRydWUpO1xcbmBgYFxcblxcbk5vdGU6IGhhc2hDb2RlKCkgTVVTVCByZXR1cm4gYSBVaW50MzIgbnVtYmVyLiBUaGUgZWFzaWVzdCB3YXkgdG9cXG5ndWFyYW50ZWUgdGhpcyBpcyB0byByZXR1cm4gYG15SGFzaCB8IDBgIGZyb20gYSBjdXN0b20gaW1wbGVtZW50YXRpb24uXFxuXFxuSWYgdHdvIHZhbHVlcyBoYXZlIHRoZSBzYW1lIGBoYXNoQ29kZWAsIHRoZXkgYXJlIFtub3QgZ3VhcmFudGVlZFxcbnRvIGJlIGVxdWFsXVtIYXNoIENvbGxpc2lvbl0uIElmIHR3byB2YWx1ZXMgaGF2ZSBkaWZmZXJlbnQgYGhhc2hDb2RlYHMsXFxudGhleSBtdXN0IG5vdCBiZSBlcXVhbC5cXG5cXG5Ob3RlOiBgaGFzaENvZGUoKWAgaXMgbm90IGd1YXJhbnRlZWQgdG8gYWx3YXlzIGJlIGNhbGxlZCBiZWZvcmVcXG5gZXF1YWxzKClgLiBNb3N0IGJ1dCBub3QgYWxsIEltbXV0YWJsZS5qcyBjb2xsZWN0aW9ucyB1c2UgaGFzaCBjb2RlcyB0b1xcbm9yZ2FuaXplIHRoZWlyIGludGVybmFsIGRhdGEgc3RydWN0dXJlcywgd2hpbGUgYWxsIEltbXV0YWJsZS5qc1xcbmNvbGxlY3Rpb25zIHVzZSBlcXVhbGl0eSBkdXJpbmcgbG9va3Vwcy5cXG5cXG5bSGFzaCBDb2xsaXNpb25dOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2xsaXNpb25fKGNvbXB1dGVyX3NjaWVuY2UpXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoyfSxcImxpbmVcIjo0NzU1fV19fX1dfX0sXCJmcm9tSlNcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkRlZXBseSBjb252ZXJ0cyBwbGFpbiBKUyBvYmplY3RzIGFuZCBhcnJheXMgdG8gSW1tdXRhYmxlIE1hcHMgYW5kIExpc3RzLlwiLFwiZGVzY3JpcHRpb25cIjpcIklmIGEgYHJldml2ZXJgIGlzIG9wdGlvbmFsbHkgcHJvdmlkZWQsIGl0IHdpbGwgYmUgY2FsbGVkIHdpdGggZXZlcnlcXG5jb2xsZWN0aW9uIGFzIGEgU2VxIChiZWdpbm5pbmcgd2l0aCB0aGUgbW9zdCBuZXN0ZWQgY29sbGVjdGlvbnNcXG5hbmQgcHJvY2VlZGluZyB0byB0aGUgdG9wLWxldmVsIGNvbGxlY3Rpb24gaXRzZWxmKSwgYWxvbmcgd2l0aCB0aGUga2V5XFxucmVmZXJyaW5nIHRvIGVhY2ggY29sbGVjdGlvbiBhbmQgdGhlIHBhcmVudCBKUyBvYmplY3QgcHJvdmlkZWQgYXMgYHRoaXNgLlxcbkZvciB0aGUgdG9wIGxldmVsLCBvYmplY3QsIHRoZSBrZXkgd2lsbCBiZSBgXFxcIlxcXCJgLiBUaGlzIGByZXZpdmVyYCBpcyBleHBlY3RlZFxcbnRvIHJldHVybiBhIG5ldyBJbW11dGFibGUgQ29sbGVjdGlvbiwgYWxsb3dpbmcgZm9yIGN1c3RvbSBjb252ZXJzaW9ucyBmcm9tXFxuZGVlcCBKUyBvYmplY3RzLiBGaW5hbGx5LCBhIGBwYXRoYCBpcyBwcm92aWRlZCB3aGljaCBpcyB0aGUgc2VxdWVuY2Ugb2ZcXG5rZXlzIHRvIHRoaXMgdmFsdWUgZnJvbSB0aGUgc3RhcnRpbmcgdmFsdWUuXFxuXFxuYHJldml2ZXJgIGFjdHMgc2ltaWxhcmx5IHRvIHRoZSBbc2FtZSBwYXJhbWV0ZXIgaW4gYEpTT04ucGFyc2VgXVsxXS5cXG5cXG5JZiBgcmV2aXZlcmAgaXMgbm90IHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBiZWhhdmlvciB3aWxsIGNvbnZlcnQgT2JqZWN0c1xcbmludG8gTWFwcyBhbmQgQXJyYXlzIGludG8gTGlzdHMgbGlrZSBzbzpcXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgZnJvbUpTLCBpc0tleWVkIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XFxuICByZXR1cm4gaXNLZXllZCh2YWx1ZSkgPyB2YWx1ZS50b01hcCgpIDogdmFsdWUudG9MaXN0KClcXG59XFxuYGBgXFxuXFxuYGZyb21KU2AgaXMgY29uc2VydmF0aXZlIGluIGl0cyBjb252ZXJzaW9uLiBJdCB3aWxsIG9ubHkgY29udmVydFxcbmFycmF5cyB3aGljaCBwYXNzIGBBcnJheS5pc0FycmF5YCB0byBMaXN0cywgYW5kIG9ubHkgcmF3IG9iamVjdHMgKG5vIGN1c3RvbVxcbnByb3RvdHlwZSkgdG8gTWFwLlxcblxcbkFjY29yZGluZ2x5LCB0aGlzIGV4YW1wbGUgY29udmVydHMgbmF0aXZlIEpTIGRhdGEgdG8gT3JkZXJlZE1hcCBhbmQgTGlzdDpcXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgZnJvbUpTLCBpc0tleWVkIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmZyb21KUyh7IGE6IHtiOiBbMTAsIDIwLCAzMF19LCBjOiA0MH0sIGZ1bmN0aW9uIChrZXksIHZhbHVlLCBwYXRoKSB7XFxuICBjb25zb2xlLmxvZyhrZXksIHZhbHVlLCBwYXRoKVxcbiAgcmV0dXJuIGlzS2V5ZWQodmFsdWUpID8gdmFsdWUudG9PcmRlcmVkTWFwKCkgOiB2YWx1ZS50b0xpc3QoKVxcbn0pXFxuXFxuPiBcXFwiYlxcXCIsIFsgMTAsIDIwLCAzMCBdLCBbIFxcXCJhXFxcIiwgXFxcImJcXFwiIF1cXG4+IFxcXCJhXFxcIiwge2I6IFsxMCwgMjAsIDMwXX0sIFsgXFxcImFcXFwiIF1cXG4+IFxcXCJcXFwiLCB7YToge2I6IFsxMCwgMjAsIDMwXX0sIGM6IDQwfSwgW11cXG5gYGBcXG5cXG5LZWVwIGluIG1pbmQsIHdoZW4gdXNpbmcgSlMgb2JqZWN0cyB0byBjb25zdHJ1Y3QgSW1tdXRhYmxlIE1hcHMsIHRoYXRcXG5KYXZhU2NyaXB0IE9iamVjdCBwcm9wZXJ0aWVzIGFyZSBhbHdheXMgc3RyaW5ncywgZXZlbiBpZiB3cml0dGVuIGluIGFcXG5xdW90ZS1sZXNzIHNob3J0aGFuZCwgd2hpbGUgSW1tdXRhYmxlIE1hcHMgYWNjZXB0IGtleXMgb2YgYW55IHR5cGUuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IE1hcCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5sZXQgb2JqID0geyAxOiBcXFwib25lXFxcIiB9O1xcbk9iamVjdC5rZXlzKG9iaik7IC8vIFsgXFxcIjFcXFwiIF1cXG5hc3NlcnQuZXF1YWwob2JqW1xcXCIxXFxcIl0sIG9ialsxXSk7IC8vIFxcXCJvbmVcXFwiID09PSBcXFwib25lXFxcIlxcblxcbmxldCBtYXAgPSBNYXAob2JqKTtcXG5hc3NlcnQubm90RXF1YWwobWFwLmdldChcXFwiMVxcXCIpLCBtYXAuZ2V0KDEpKTsgLy8gXFxcIm9uZVxcXCIgIT09IHVuZGVmaW5lZFxcbmBgYFxcblxcblByb3BlcnR5IGFjY2VzcyBmb3IgSmF2YVNjcmlwdCBPYmplY3RzIGZpcnN0IGNvbnZlcnRzIHRoZSBrZXkgdG8gYSBzdHJpbmcsXFxuYnV0IHNpbmNlIEltbXV0YWJsZSBNYXAga2V5cyBjYW4gYmUgb2YgYW55IHR5cGUgdGhlIGFyZ3VtZW50IHRvIGBnZXQoKWAgaXNcXG5ub3QgYWx0ZXJlZC5cXG5cXG5bMV06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0pTT04vcGFyc2UjRXhhbXBsZS4zQV9Vc2luZ190aGVfcmV2aXZlcl9wYXJhbWV0ZXJcXG4gICAgIFxcXCJVc2luZyB0aGUgcmV2aXZlciBwYXJhbWV0ZXJcXFwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImpzVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fSx7XCJuYW1lXCI6XCJyZXZpdmVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjN9LHtcImtcIjoyfV19fSx7XCJuYW1lXCI6XCJzZXF1ZW5jZVwiLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6M30se1wia1wiOjE3fV19LHtcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfV19fSx7XCJuYW1lXCI6XCJwYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6M30se1wia1wiOjJ9XX1dfSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxN319LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjE3fSxcImxpbmVcIjo0ODI0fV19fSxcImlzXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJWYWx1ZSBlcXVhbGl0eSBjaGVjayB3aXRoIHNlbWFudGljcyBzaW1pbGFyIHRvIGBPYmplY3QuaXNgLCBidXQgdHJlYXRzXFxuSW1tdXRhYmxlIGBDb2xsZWN0aW9uYHMgYXMgdmFsdWVzLCBlcXVhbCBpZiB0aGUgc2Vjb25kIGBDb2xsZWN0aW9uYCBpbmNsdWRlc1xcbmVxdWl2YWxlbnQgdmFsdWVzLlwiLFwiZGVzY3JpcHRpb25cIjpcIkl0J3MgdXNlZCB0aHJvdWdob3V0IEltbXV0YWJsZSB3aGVuIGNoZWNraW5nIGZvciBlcXVhbGl0eSwgaW5jbHVkaW5nIGBNYXBgXFxua2V5IGVxdWFsaXR5IGFuZCBgU2V0YCBtZW1iZXJzaGlwLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAsIGlzIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG1hcDEgPSBNYXAoeyBhOiAxLCBiOiAxLCBjOiAxIH0pXFxuY29uc3QgbWFwMiA9IE1hcCh7IGE6IDEsIGI6IDEsIGM6IDEgfSlcXG5hc3NlcnQuZXF1YWwobWFwMSAhPT0gbWFwMiwgdHJ1ZSlcXG5hc3NlcnQuZXF1YWwoT2JqZWN0LmlzKG1hcDEsIG1hcDIpLCBmYWxzZSlcXG5hc3NlcnQuZXF1YWwoaXMobWFwMSwgbWFwMiksIHRydWUpXFxuYGBgXFxuXFxuYGlzKClgIGNvbXBhcmVzIHByaW1pdGl2ZSB0eXBlcyBsaWtlIHN0cmluZ3MgYW5kIG51bWJlcnMsIEltbXV0YWJsZS5qc1xcbmNvbGxlY3Rpb25zIGxpa2UgYE1hcGAgYW5kIGBMaXN0YCwgYnV0IGFsc28gYW55IGN1c3RvbSBvYmplY3Qgd2hpY2hcXG5pbXBsZW1lbnRzIGBWYWx1ZU9iamVjdGAgYnkgcHJvdmlkaW5nIGBlcXVhbHMoKWAgYW5kIGBoYXNoQ29kZSgpYCBtZXRob2RzLlxcblxcbk5vdGU6IFVubGlrZSBgT2JqZWN0LmlzYCwgYEltbXV0YWJsZS5pc2AgYXNzdW1lcyBgMGAgYW5kIGAtMGAgYXJlIHRoZSBzYW1lXFxudmFsdWUsIG1hdGNoaW5nIHRoZSBiZWhhdmlvciBvZiBFUzYgTWFwIGtleSBlcXVhbGl0eS5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiZmlyc3RcIixcInR5cGVcIjp7XCJrXCI6MTd9fSx7XCJuYW1lXCI6XCJzZWNvbmRcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjQ4NTh9XX19LFwiaGFzaFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVGhlIGBoYXNoKClgIGZ1bmN0aW9uIGlzIGFuIGltcG9ydGFudCBwYXJ0IG9mIGhvdyBJbW11dGFibGUgZGV0ZXJtaW5lcyBpZlxcbnR3byB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQgYW5kIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGhvdyB0byBzdG9yZSB0aG9zZVxcbnZhbHVlcy4gUHJvdmlkZWQgd2l0aCBhbnkgdmFsdWUsIGBoYXNoKClgIHdpbGwgcmV0dXJuIGEgMzEtYml0IGludGVnZXIuXCIsXCJkZXNjcmlwdGlvblwiOlwiV2hlbiBkZXNpZ25pbmcgT2JqZWN0cyB3aGljaCBtYXkgYmUgZXF1YWwsIGl0J3MgaW1wb3J0YW50IHRoYXQgd2hlbiBhXFxuYC5lcXVhbHMoKWAgbWV0aG9kIHJldHVybnMgdHJ1ZSwgdGhhdCBib3RoIHZhbHVlcyBgLmhhc2hDb2RlKClgIG1ldGhvZFxcbnJldHVybiB0aGUgc2FtZSB2YWx1ZS4gYGhhc2goKWAgbWF5IGJlIHVzZWQgdG8gcHJvZHVjZSB0aG9zZSB2YWx1ZXMuXFxuXFxuRm9yIG5vbi1JbW11dGFibGUgT2JqZWN0cyB0aGF0IGRvIG5vdCBwcm92aWRlIGEgYC5oYXNoQ29kZSgpYCBmdW5jdGlvbnNcXG4oaW5jbHVkaW5nIHBsYWluIE9iamVjdHMsIHBsYWluIEFycmF5cywgRGF0ZSBvYmplY3RzLCBldGMpLCBhIHVuaXF1ZSBoYXNoXFxudmFsdWUgd2lsbCBiZSBjcmVhdGVkIGZvciBlYWNoICppbnN0YW5jZSouIFRoYXQgaXMsIHRoZSBjcmVhdGUgaGFzaFxcbnJlcHJlc2VudHMgcmVmZXJlbnRpYWwgZXF1YWxpdHksIGFuZCBub3QgdmFsdWUgZXF1YWxpdHkgZm9yIE9iamVjdHMuIFRoaXNcXG5lbnN1cmVzIHRoYXQgaWYgdGhhdCBPYmplY3QgaXMgbXV0YXRlZCBvdmVyIHRpbWUgdGhhdCBpdHMgaGFzaCBjb2RlIHdpbGxcXG5yZW1haW4gY29uc2lzdGVudCwgYWxsb3dpbmcgT2JqZWN0cyB0byBiZSB1c2VkIGFzIGtleXMgYW5kIHZhbHVlcyBpblxcbkltbXV0YWJsZS5qcyBjb2xsZWN0aW9ucy5cXG5cXG5Ob3RlIHRoYXQgYGhhc2goKWAgYXR0ZW1wdHMgdG8gYmFsYW5jZSBiZXR3ZWVuIHNwZWVkIGFuZCBhdm9pZGluZ1xcbmNvbGxpc2lvbnMsIGhvd2V2ZXIgaXQgbWFrZXMgbm8gYXR0ZW1wdCB0byBwcm9kdWNlIHNlY3VyZSBoYXNoZXMuXFxuXFxuKk5ldyBpbiBWZXJzaW9uIDQuMCpcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjJ9LFwibGluZVwiOjQ4ODJ9XX19LFwiaXNJbW11dGFibGVcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgYG1heWJlSW1tdXRhYmxlYCBpcyBhbiBJbW11dGFibGUgQ29sbGVjdGlvbiBvciBSZWNvcmQuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogU3RpbGwgcmV0dXJucyB0cnVlIGV2ZW4gaWYgdGhlIGNvbGxlY3Rpb25zIGlzIHdpdGhpbiBhIGB3aXRoTXV0YXRpb25zKClgLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBpc0ltbXV0YWJsZSwgTWFwLCBMaXN0LCBTdGFjayB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxuaXNJbW11dGFibGUoW10pOyAvLyBmYWxzZVxcbmlzSW1tdXRhYmxlKHt9KTsgLy8gZmFsc2VcXG5pc0ltbXV0YWJsZShNYXAoKSk7IC8vIHRydWVcXG5pc0ltbXV0YWJsZShMaXN0KCkpOyAvLyB0cnVlXFxuaXNJbW11dGFibGUoU3RhY2soKSk7IC8vIHRydWVcXG5pc0ltbXV0YWJsZShNYXAoKS5hc011dGFibGUoKSk7IC8vIHRydWVcXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVJbW11dGFibGVcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjQ5MDB9XX19LFwiaXNDb2xsZWN0aW9uXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGBtYXliZUNvbGxlY3Rpb25gIGlzIGEgQ29sbGVjdGlvbiwgb3IgYW55IG9mIGl0cyBzdWJjbGFzc2VzLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBpc0NvbGxlY3Rpb24sIE1hcCwgTGlzdCwgU3RhY2sgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcbmlzQ29sbGVjdGlvbihbXSk7IC8vIGZhbHNlXFxuaXNDb2xsZWN0aW9uKHt9KTsgLy8gZmFsc2VcXG5pc0NvbGxlY3Rpb24oTWFwKCkpOyAvLyB0cnVlXFxuaXNDb2xsZWN0aW9uKExpc3QoKSk7IC8vIHRydWVcXG5pc0NvbGxlY3Rpb24oU3RhY2soKSk7IC8vIHRydWVcXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVDb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo0OTE1fV19fSxcImlzS2V5ZWRcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgYG1heWJlS2V5ZWRgIGlzIGEgQ29sbGVjdGlvbi5LZXllZCwgb3IgYW55IG9mIGl0cyBzdWJjbGFzc2VzLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBpc0tleWVkLCBNYXAsIExpc3QsIFN0YWNrIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXG5pc0tleWVkKFtdKTsgLy8gZmFsc2VcXG5pc0tleWVkKHt9KTsgLy8gZmFsc2VcXG5pc0tleWVkKE1hcCgpKTsgLy8gdHJ1ZVxcbmlzS2V5ZWQoTGlzdCgpKTsgLy8gZmFsc2VcXG5pc0tleWVkKFN0YWNrKCkpOyAvLyBmYWxzZVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXliZUtleWVkXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo0OTMwfV19fSxcImlzSW5kZXhlZFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVJbmRleGVkYCBpcyBhIENvbGxlY3Rpb24uSW5kZXhlZCwgb3IgYW55IG9mIGl0cyBzdWJjbGFzc2VzLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBpc0luZGV4ZWQsIE1hcCwgTGlzdCwgU3RhY2ssIFNldCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxuaXNJbmRleGVkKFtdKTsgLy8gZmFsc2VcXG5pc0luZGV4ZWQoe30pOyAvLyBmYWxzZVxcbmlzSW5kZXhlZChNYXAoKSk7IC8vIGZhbHNlXFxuaXNJbmRleGVkKExpc3QoKSk7IC8vIHRydWVcXG5pc0luZGV4ZWQoU3RhY2soKSk7IC8vIHRydWVcXG5pc0luZGV4ZWQoU2V0KCkpOyAvLyBmYWxzZVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXliZUluZGV4ZWRcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjQ5NDZ9XX19LFwiaXNBc3NvY2lhdGl2ZVwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVBc3NvY2lhdGl2ZWAgaXMgZWl0aGVyIGEgS2V5ZWQgb3IgSW5kZXhlZCBDb2xsZWN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBpc0Fzc29jaWF0aXZlLCBNYXAsIExpc3QsIFN0YWNrLCBTZXQgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcbmlzQXNzb2NpYXRpdmUoW10pOyAvLyBmYWxzZVxcbmlzQXNzb2NpYXRpdmUoe30pOyAvLyBmYWxzZVxcbmlzQXNzb2NpYXRpdmUoTWFwKCkpOyAvLyB0cnVlXFxuaXNBc3NvY2lhdGl2ZShMaXN0KCkpOyAvLyB0cnVlXFxuaXNBc3NvY2lhdGl2ZShTdGFjaygpKTsgLy8gdHJ1ZVxcbmlzQXNzb2NpYXRpdmUoU2V0KCkpOyAvLyBmYWxzZVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXliZUFzc29jaWF0aXZlXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo0OTYyfV19fSxcImlzT3JkZXJlZFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVPcmRlcmVkYCBpcyBhIENvbGxlY3Rpb24gd2hlcmUgaXRlcmF0aW9uIG9yZGVyIGlzIHdlbGxcXG5kZWZpbmVkLiBUcnVlIGZvciBDb2xsZWN0aW9uLkluZGV4ZWQgYXMgd2VsbCBhcyBPcmRlcmVkTWFwIGFuZCBPcmRlcmVkU2V0LlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBpc09yZGVyZWQsIE1hcCwgT3JkZXJlZE1hcCwgTGlzdCwgU2V0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXG5pc09yZGVyZWQoW10pOyAvLyBmYWxzZVxcbmlzT3JkZXJlZCh7fSk7IC8vIGZhbHNlXFxuaXNPcmRlcmVkKE1hcCgpKTsgLy8gZmFsc2VcXG5pc09yZGVyZWQoT3JkZXJlZE1hcCgpKTsgLy8gdHJ1ZVxcbmlzT3JkZXJlZChMaXN0KCkpOyAvLyB0cnVlXFxuaXNPcmRlcmVkKFNldCgpKTsgLy8gZmFsc2VcXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVPcmRlcmVkXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo0OTc5fV19fSxcImlzVmFsdWVPYmplY3RcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgYG1heWJlVmFsdWVgIGlzIGEgSmF2YVNjcmlwdCBPYmplY3Qgd2hpY2ggaGFzICpib3RoKiBgZXF1YWxzKClgXFxuYW5kIGBoYXNoQ29kZSgpYCBtZXRob2RzLlwiLFwiZGVzY3JpcHRpb25cIjpcIkFueSB0d28gaW5zdGFuY2VzIG9mICp2YWx1ZSBvYmplY3RzKiBjYW4gYmUgY29tcGFyZWQgZm9yIHZhbHVlIGVxdWFsaXR5IHdpdGhcXG5gSW1tdXRhYmxlLmlzKClgIGFuZCBjYW4gYmUgdXNlZCBhcyBrZXlzIGluIGEgYE1hcGAgb3IgbWVtYmVycyBpbiBhIGBTZXRgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXliZVZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo0OTg4fV19fSxcImlzU2VxXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGBtYXliZVNlcWAgaXMgYSBTZXEuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlU2VxXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo0OTk0fV19fSxcImlzTGlzdFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVMaXN0YCBpcyBhIExpc3QuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlTGlzdFwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6NDk5OX1dfX0sXCJpc01hcFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVNYXBgIGlzIGEgTWFwLlwiLFwiZGVzY3JpcHRpb25cIjpcIkFsc28gdHJ1ZSBmb3IgT3JkZXJlZE1hcHMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlTWFwXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo1MDA2fV19fSxcImlzT3JkZXJlZE1hcFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVPcmRlcmVkTWFwYCBpcyBhbiBPcmRlcmVkTWFwLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXliZU9yZGVyZWRNYXBcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjUwMTF9XX19LFwiaXNTdGFja1wiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVTdGFja2AgaXMgYSBTdGFjay5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVTdGFja1wiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6NTAxNn1dfX0sXCJpc1NldFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVTZXRgIGlzIGEgU2V0LlwiLFwiZGVzY3JpcHRpb25cIjpcIkFsc28gdHJ1ZSBmb3IgT3JkZXJlZFNldHMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlU2V0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo1MDIzfV19fSxcImlzT3JkZXJlZFNldFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVPcmRlcmVkU2V0YCBpcyBhbiBPcmRlcmVkU2V0LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXliZU9yZGVyZWRTZXRcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjUwMjh9XX19LFwiaXNSZWNvcmRcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgYG1heWJlUmVjb3JkYCBpcyBhIFJlY29yZC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVSZWNvcmRcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjUwMzN9XX19LFwiZ2V0XCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRoZSB2YWx1ZSB3aXRoaW4gdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb24gYXNzb2NpYXRlZCB3aXRoIHRoZVxcbnByb3ZpZGVkIGtleSwgb3Igbm90U2V0VmFsdWUgaWYgdGhlIGtleSBpcyBub3QgZGVmaW5lZCBpbiB0aGUgY29sbGVjdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJBIGZ1bmN0aW9uYWwgYWx0ZXJuYXRpdmUgdG8gYGNvbGxlY3Rpb24uZ2V0KGtleSlgIHdoaWNoIHdpbGwgYWxzbyB3b3JrIG9uXFxucGxhaW4gT2JqZWN0cyBhbmQgQXJyYXlzIGFzIGFuIGFsdGVybmF0aXZlIGZvciBgY29sbGVjdGlvbltrZXldYC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgZ2V0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmdldChbICdkb2cnLCAnZnJvZycsICdjYXQnIF0sIDIpIC8vICdmcm9nJ1xcbmdldCh7IHg6IDEyMywgeTogNDU2IH0sICd4JykgLy8gMTIzXFxuZ2V0KHsgeDogMTIzLCB5OiA0NTYgfSwgJ3onLCAnaWZOb3RTZXQnKSAvLyAnaWZOb3RTZXQnXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktcIixcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX1dLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjExfV19LFwibGluZVwiOjUwNTJ9LHtcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCIsXCJOU1ZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn19XSxcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifV19LFwibGluZVwiOjUwNTN9LHtcInR5cGVQYXJhbXNcIjpbXCJUUHJvcHNcIixcIktcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicmVjb3JkXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJSZWNvcmRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9XX19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIm5vdFNldFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxNSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn0sXCJpbmRleFwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LFwibGluZVwiOjUwNTR9LHtcInR5cGVQYXJhbXNcIjpbXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fV0sXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6MTF9XX0sXCJsaW5lXCI6NTA1NX0se1widHlwZVBhcmFtc1wiOltcIlZcIixcIk5TVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn19XSxcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifV19LFwibGluZVwiOjUwNTZ9LHtcInR5cGVQYXJhbXNcIjpbXCJDXCIsXCJLXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm9iamVjdFwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIm5vdFNldFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxNSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwiaW5kZXhcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSxcImxpbmVcIjo1MDU3fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV19fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjoxMX1dfSxcImxpbmVcIjo1MDU4fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiLFwiTlNWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6NCxcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XX19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn19XSxcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifV19LFwibGluZVwiOjUwNTl9XX19LFwiaGFzXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRydWUgaWYgdGhlIGtleSBpcyBkZWZpbmVkIGluIHRoZSBwcm92aWRlZCBjb2xsZWN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIkEgZnVuY3Rpb25hbCBhbHRlcm5hdGl2ZSB0byBgY29sbGVjdGlvbi5oYXMoa2V5KWAgd2hpY2ggd2lsbCBhbHNvIHdvcmsgd2l0aFxcbnBsYWluIE9iamVjdHMgYW5kIEFycmF5cyBhcyBhbiBhbHRlcm5hdGl2ZSBmb3JcXG5gY29sbGVjdGlvbi5oYXNPd25Qcm9wZXJ0eShrZXkpYC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgaGFzIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmhhcyhbICdkb2cnLCAnZnJvZycsICdjYXQnIF0sIDIpIC8vIHRydWVcXG5oYXMoWyAnZG9nJywgJ2Zyb2cnLCAnY2F0JyBdLCA1KSAvLyBmYWxzZVxcbmhhcyh7IHg6IDEyMywgeTogNDU2IH0sICd4JykgLy8gdHJ1ZVxcbmhhcyh7IHg6IDEyMywgeTogNDU2IH0sICd6JykgLy8gZmFsc2VcXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT2JqZWN0XCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjUwNzd9XX19LFwicmVtb3ZlXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgY29weSBvZiB0aGUgY29sbGVjdGlvbiB3aXRoIHRoZSB2YWx1ZSBhdCBrZXkgcmVtb3ZlZC5cIixcImRlc2NyaXB0aW9uXCI6XCJBIGZ1bmN0aW9uYWwgYWx0ZXJuYXRpdmUgdG8gYGNvbGxlY3Rpb24ucmVtb3ZlKGtleSlgIHdoaWNoIHdpbGwgYWxzbyB3b3JrXFxud2l0aCBwbGFpbiBPYmplY3RzIGFuZCBBcnJheXMgYXMgYW4gYWx0ZXJuYXRpdmUgZm9yXFxuYGRlbGV0ZSBjb2xsZWN0aW9uQ29weVtrZXldYC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgcmVtb3ZlIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG9yaWdpbmFsQXJyYXkgPSBbICdkb2cnLCAnZnJvZycsICdjYXQnIF1cXG5yZW1vdmUob3JpZ2luYWxBcnJheSwgMSkgLy8gWyAnZG9nJywgJ2NhdCcgXVxcbmNvbnNvbGUubG9nKG9yaWdpbmFsQXJyYXkpIC8vIFsgJ2RvZycsICdmcm9nJywgJ2NhdCcgXVxcbmNvbnN0IG9yaWdpbmFsT2JqZWN0ID0geyB4OiAxMjMsIHk6IDQ1NiB9XFxucmVtb3ZlKG9yaWdpbmFsT2JqZWN0LCAneCcpIC8vIHsgeTogNDU2IH1cXG5jb25zb2xlLmxvZyhvcmlnaW5hbE9iamVjdCkgLy8geyB4OiAxMjMsIHk6IDQ1NiB9XFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktcIixcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUwOTd9LHtcInR5cGVQYXJhbXNcIjpbXCJUUHJvcHNcIixcIkNcIixcIktcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUwOTh9LHtcInR5cGVQYXJhbXNcIjpbXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6Mn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUwOTl9LHtcInR5cGVQYXJhbXNcIjpbXCJDXCIsXCJLXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjo1MTAwfSx7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiLFwiS1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJsaW5lXCI6NTEwMX1dfX0sXCJzZXRcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBjb3B5IG9mIHRoZSBjb2xsZWN0aW9uIHdpdGggdGhlIHZhbHVlIGF0IGtleSBzZXQgdG8gdGhlIHByb3ZpZGVkXFxudmFsdWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiQSBmdW5jdGlvbmFsIGFsdGVybmF0aXZlIHRvIGBjb2xsZWN0aW9uLnNldChrZXksIHZhbHVlKWAgd2hpY2ggd2lsbCBhbHNvXFxud29yayB3aXRoIHBsYWluIE9iamVjdHMgYW5kIEFycmF5cyBhcyBhbiBhbHRlcm5hdGl2ZSBmb3JcXG5gY29sbGVjdGlvbkNvcHlba2V5XSA9IHZhbHVlYC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgc2V0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG9yaWdpbmFsQXJyYXkgPSBbICdkb2cnLCAnZnJvZycsICdjYXQnIF1cXG5zZXQob3JpZ2luYWxBcnJheSwgMSwgJ2NvdycpIC8vIFsgJ2RvZycsICdjb3cnLCAnY2F0JyBdXFxuY29uc29sZS5sb2cob3JpZ2luYWxBcnJheSkgLy8gWyAnZG9nJywgJ2Zyb2cnLCAnY2F0JyBdXFxuY29uc3Qgb3JpZ2luYWxPYmplY3QgPSB7IHg6IDEyMywgeTogNDU2IH1cXG5zZXQob3JpZ2luYWxPYmplY3QsICd4JywgNzg5KSAvLyB7IHg6IDc4OSwgeTogNDU2IH1cXG5jb25zb2xlLmxvZyhvcmlnaW5hbE9iamVjdCkgLy8geyB4OiAxMjMsIHk6IDQ1NiB9XFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktcIixcIlZcIixcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJsaW5lXCI6NTEyMn0se1widHlwZVBhcmFtc1wiOltcIlRQcm9wc1wiLFwiQ1wiLFwiS1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJyZWNvcmRcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxNSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn0sXCJpbmRleFwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjo1MTIzfSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiLFwiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUxMjR9LHtcInR5cGVQYXJhbXNcIjpbXCJDXCIsXCJLXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm9iamVjdFwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE1LFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJpbmRleFwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjo1MTI1fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiLFwiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUxMjZ9XX19LFwidXBkYXRlXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgY29weSBvZiB0aGUgY29sbGVjdGlvbiB3aXRoIHRoZSB2YWx1ZSBhdCBrZXkgc2V0IHRvIHRoZSByZXN1bHQgb2ZcXG5wcm92aWRpbmcgdGhlIGV4aXN0aW5nIHZhbHVlIHRvIHRoZSB1cGRhdGluZyBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJBIGZ1bmN0aW9uYWwgYWx0ZXJuYXRpdmUgdG8gYGNvbGxlY3Rpb24udXBkYXRlKGtleSwgZm4pYCB3aGljaCB3aWxsIGFsc29cXG53b3JrIHdpdGggcGxhaW4gT2JqZWN0cyBhbmQgQXJyYXlzIGFzIGFuIGFsdGVybmF0aXZlIGZvclxcbmBjb2xsZWN0aW9uQ29weVtrZXldID0gZm4oY29sbGVjdGlvbltrZXldKWAuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IHVwZGF0ZSB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBvcmlnaW5hbEFycmF5ID0gWyAnZG9nJywgJ2Zyb2cnLCAnY2F0JyBdXFxudXBkYXRlKG9yaWdpbmFsQXJyYXksIDEsIHZhbCA9PiB2YWwudG9VcHBlckNhc2UoKSkgLy8gWyAnZG9nJywgJ0ZST0cnLCAnY2F0JyBdXFxuY29uc29sZS5sb2cob3JpZ2luYWxBcnJheSkgLy8gWyAnZG9nJywgJ2Zyb2cnLCAnY2F0JyBdXFxuY29uc3Qgb3JpZ2luYWxPYmplY3QgPSB7IHg6IDEyMywgeTogNDU2IH1cXG51cGRhdGUob3JpZ2luYWxPYmplY3QsICd4JywgdmFsID0+IHZhbCAqIDYpIC8vIHsgeDogNzM4LCB5OiA0NTYgfVxcbmNvbnNvbGUubG9nKG9yaWdpbmFsT2JqZWN0KSAvLyB7IHg6IDEyMywgeTogNDU2IH1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiLFwiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjo1MTQ3fSx7XCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiLFwiQ1wiLFwiTlNWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifX0se1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn1dfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjo1MTQ4fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVFByb3BzXCIsXCJDXCIsXCJLXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInJlY29yZFwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxNSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn0sXCJpbmRleFwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjE1LFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRQcm9wc1wifSxcImluZGV4XCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX19fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjo1MTQ5fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVFByb3BzXCIsXCJDXCIsXCJLXCIsXCJOU1ZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicmVjb3JkXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn19LHtcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjoxNSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn0sXCJpbmRleFwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjE1LFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRQcm9wc1wifSxcImluZGV4XCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX19fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjo1MTUwfSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6NTE1MX0se1widHlwZVBhcmFtc1wiOltcIlZcIixcIk5TVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn19LHtcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiTlNWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjUxNTJ9LHtcInR5cGVQYXJhbXNcIjpbXCJDXCIsXCJLXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm9iamVjdFwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxNSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwiaW5kZXhcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fX1dLFwidHlwZVwiOntcImtcIjoxNSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwiaW5kZXhcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fX19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUxNTN9LHtcInR5cGVQYXJhbXNcIjpbXCJDXCIsXCJLXCIsXCJOU1ZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib2JqZWN0XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn19LHtcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjoxNSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwiaW5kZXhcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn1dfX1dLFwidHlwZVwiOntcImtcIjoxNSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwiaW5kZXhcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fX19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUxNTR9LHtcInR5cGVQYXJhbXNcIjpbXCJWXCIsXCJDXCIsXCJLXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJ1cGRhdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX19XSxcInR5cGVcIjp7XCJrXCI6NCxcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XX0sXCJsaW5lXCI6NTE1NX0se1widHlwZVBhcmFtc1wiOltcIlZcIixcIkNcIixcIktcIixcIk5TVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn19LHtcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiTlNWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fX1dLFwidHlwZVwiOntcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dfSxcImxpbmVcIjo1MTU2fV19fSxcImdldEluXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRoZSB2YWx1ZSBhdCB0aGUgcHJvdmlkZWQga2V5IHBhdGggc3RhcnRpbmcgYXQgdGhlIHByb3ZpZGVkXFxuY29sbGVjdGlvbiwgb3Igbm90U2V0VmFsdWUgaWYgdGhlIGtleSBwYXRoIGlzIG5vdCBkZWZpbmVkLlwiLFwiZGVzY3JpcHRpb25cIjpcIkEgZnVuY3Rpb25hbCBhbHRlcm5hdGl2ZSB0byBgY29sbGVjdGlvbi5nZXRJbihrZXlwYXRoKWAgd2hpY2ggd2lsbCBhbHNvXFxud29yayB3aXRoIHBsYWluIE9iamVjdHMgYW5kIEFycmF5cy5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgZ2V0SW4gfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuZ2V0SW4oeyB4OiB7IHk6IHsgejogMTIzIH19fSwgWyd4JywgJ3knLCAneiddKSAvLyAxMjNcXG5nZXRJbih7IHg6IHsgeTogeyB6OiAxMjMgfX19LCBbJ3gnLCAncScsICdwJ10sICdpZk5vdFNldCcpIC8vICdpZk5vdFNldCdcXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjoxN319LHtcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fSxcImxpbmVcIjo1MTcyfV19fSxcImhhc0luXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRydWUgaWYgdGhlIGtleSBwYXRoIGlzIGRlZmluZWQgaW4gdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiQSBmdW5jdGlvbmFsIGFsdGVybmF0aXZlIHRvIGBjb2xsZWN0aW9uLmhhc0luKGtleXBhdGgpYCB3aGljaCB3aWxsIGFsc29cXG53b3JrIHdpdGggcGxhaW4gT2JqZWN0cyBhbmQgQXJyYXlzLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBoYXNJbiB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5oYXNJbih7IHg6IHsgeTogeyB6OiAxMjMgfX19LCBbJ3gnLCAneScsICd6J10pIC8vIHRydWVcXG5oYXNJbih7IHg6IHsgeTogeyB6OiAxMjMgfX19LCBbJ3gnLCAncScsICdwJ10pIC8vIGZhbHNlXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6MTd9fSx7XCJuYW1lXCI6XCJrZXlQYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX19XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6NTE4N31dfX0sXCJyZW1vdmVJblwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIGNvcHkgb2YgdGhlIGNvbGxlY3Rpb24gd2l0aCB0aGUgdmFsdWUgYXQgdGhlIGtleSBwYXRoIHJlbW92ZWQuXCIsXCJkZXNjcmlwdGlvblwiOlwiQSBmdW5jdGlvbmFsIGFsdGVybmF0aXZlIHRvIGBjb2xsZWN0aW9uLnJlbW92ZUluKGtleXBhdGgpYCB3aGljaCB3aWxsIGFsc29cXG53b3JrIHdpdGggcGxhaW4gT2JqZWN0cyBhbmQgQXJyYXlzLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyByZW1vdmVJbiB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBvcmlnaW5hbCA9IHsgeDogeyB5OiB7IHo6IDEyMyB9fX1cXG5yZW1vdmVJbihvcmlnaW5hbCwgWyd4JywgJ3knLCAneiddKSAvLyB7IHg6IHsgeToge319fVxcbmNvbnNvbGUubG9nKG9yaWdpbmFsKSAvLyB7IHg6IHsgeTogeyB6OiAxMjMgfX19XFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJsaW5lXCI6NTIwM31dfX0sXCJzZXRJblwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIGNvcHkgb2YgdGhlIGNvbGxlY3Rpb24gd2l0aCB0aGUgdmFsdWUgYXQgdGhlIGtleSBwYXRoIHNldCB0byB0aGVcXG5wcm92aWRlZCB2YWx1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJBIGZ1bmN0aW9uYWwgYWx0ZXJuYXRpdmUgdG8gYGNvbGxlY3Rpb24uc2V0SW4oa2V5cGF0aClgIHdoaWNoIHdpbGwgYWxzb1xcbndvcmsgd2l0aCBwbGFpbiBPYmplY3RzIGFuZCBBcnJheXMuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IHNldEluIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG9yaWdpbmFsID0geyB4OiB7IHk6IHsgejogMTIzIH19fVxcbnNldEluKG9yaWdpbmFsLCBbJ3gnLCAneScsICd6J10sIDQ1NikgLy8geyB4OiB7IHk6IHsgejogNDU2IH19fVxcbmNvbnNvbGUubG9nKG9yaWdpbmFsKSAvLyB7IHg6IHsgeTogeyB6OiAxMjMgfX19XFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX0se1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjo1MjIwfV19fSxcInVwZGF0ZUluXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgY29weSBvZiB0aGUgY29sbGVjdGlvbiB3aXRoIHRoZSB2YWx1ZSBhdCBrZXkgcGF0aCBzZXQgdG8gdGhlXFxucmVzdWx0IG9mIHByb3ZpZGluZyB0aGUgZXhpc3RpbmcgdmFsdWUgdG8gdGhlIHVwZGF0aW5nIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIkEgZnVuY3Rpb25hbCBhbHRlcm5hdGl2ZSB0byBgY29sbGVjdGlvbi51cGRhdGVJbihrZXlwYXRoKWAgd2hpY2ggd2lsbCBhbHNvXFxud29yayB3aXRoIHBsYWluIE9iamVjdHMgYW5kIEFycmF5cy5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgdXBkYXRlSW4gfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgb3JpZ2luYWwgPSB7IHg6IHsgeTogeyB6OiAxMjMgfX19XFxudXBkYXRlSW4ob3JpZ2luYWwsIFsneCcsICd5JywgJ3onXSwgdmFsID0+IHZhbCAqIDYpIC8vIHsgeDogeyB5OiB7IHo6IDczOCB9fX1cXG5jb25zb2xlLmxvZyhvcmlnaW5hbCkgLy8geyB4OiB7IHk6IHsgejogMTIzIH19fVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJrZXlQYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX19LHtcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MTd9fX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJsaW5lXCI6NTIzN30se1widHlwZVBhcmFtc1wiOltcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fSx7XCJuYW1lXCI6XCJ1cGRhdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUyMzh9XX19LFwibWVyZ2VcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBjb3B5IG9mIHRoZSBjb2xsZWN0aW9uIHdpdGggdGhlIHJlbWFpbmluZyBjb2xsZWN0aW9ucyBtZXJnZWQgaW4uXCIsXCJkZXNjcmlwdGlvblwiOlwiQSBmdW5jdGlvbmFsIGFsdGVybmF0aXZlIHRvIGBjb2xsZWN0aW9uLm1lcmdlKClgIHdoaWNoIHdpbGwgYWxzbyB3b3JrIHdpdGhcXG5wbGFpbiBPYmplY3RzIGFuZCBBcnJheXMuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IG1lcmdlIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG9yaWdpbmFsID0geyB4OiAxMjMsIHk6IDQ1NiB9XFxubWVyZ2Uob3JpZ2luYWwsIHsgeTogNzg5LCB6OiAnYWJjJyB9KSAvLyB7IHg6IDEyMywgeTogNzg5LCB6OiAnYWJjJyB9XFxuY29uc29sZS5sb2cob3JpZ2luYWwpIC8vIHsgeDogMTIzLCB5OiA0NTYgfVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0se1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfV19LHtcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX1dfV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJsaW5lXCI6NTI1NH1dfX0sXCJtZXJnZVdpdGhcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBjb3B5IG9mIHRoZSBjb2xsZWN0aW9uIHdpdGggdGhlIHJlbWFpbmluZyBjb2xsZWN0aW9ucyBtZXJnZWQgaW4sXFxuY2FsbGluZyB0aGUgYG1lcmdlcmAgZnVuY3Rpb24gd2hlbmV2ZXIgYW4gZXhpc3RpbmcgdmFsdWUgaXMgZW5jb3VudGVyZWQuXCIsXCJkZXNjcmlwdGlvblwiOlwiQSBmdW5jdGlvbmFsIGFsdGVybmF0aXZlIHRvIGBjb2xsZWN0aW9uLm1lcmdlV2l0aCgpYCB3aGljaCB3aWxsIGFsc28gd29ya1xcbndpdGggcGxhaW4gT2JqZWN0cyBhbmQgQXJyYXlzLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBtZXJnZVdpdGggfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgb3JpZ2luYWwgPSB7IHg6IDEyMywgeTogNDU2IH1cXG5tZXJnZVdpdGgoXFxuICAob2xkVmFsLCBuZXdWYWwpID0+IG9sZFZhbCArIG5ld1ZhbCxcXG4gIG9yaWdpbmFsLFxcbiAgeyB5OiA3ODksIHo6ICdhYmMnIH1cXG4pIC8vIHsgeDogMTIzLCB5OiAxMjQ1LCB6OiAnYWJjJyB9XFxuY29uc29sZS5sb2cob3JpZ2luYWwpIC8vIHsgeDogMTIzLCB5OiA0NTYgfVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1lcmdlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm9sZFZhbFwiLFwidHlwZVwiOntcImtcIjoxN319LHtcIm5hbWVcIjpcIm5ld1ZhbFwiLFwidHlwZVwiOntcImtcIjoxN319LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MTd9fX0se1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSx7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19XX0se1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6MTd9fV19XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjo1Mjc4fV19fSxcIm1lcmdlRGVlcFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIGNvcHkgb2YgdGhlIGNvbGxlY3Rpb24gd2l0aCB0aGUgcmVtYWluaW5nIGNvbGxlY3Rpb25zIG1lcmdlZCBpblxcbmRlZXBseSAocmVjdXJzaXZlbHkpLlwiLFwiZGVzY3JpcHRpb25cIjpcIkEgZnVuY3Rpb25hbCBhbHRlcm5hdGl2ZSB0byBgY29sbGVjdGlvbi5tZXJnZURlZXAoKWAgd2hpY2ggd2lsbCBhbHNvIHdvcmtcXG53aXRoIHBsYWluIE9iamVjdHMgYW5kIEFycmF5cy5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgbWVyZ2VEZWVwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG9yaWdpbmFsID0geyB4OiB7IHk6IDEyMyB9fVxcbm1lcmdlRGVlcChvcmlnaW5hbCwgeyB4OiB7IHo6IDQ1NiB9fSkgLy8geyB4OiB7IHk6IDEyMywgejogNDU2IH19XFxuY29uc29sZS5sb2cob3JpZ2luYWwpIC8vIHsgeDogeyB5OiAxMjMgfX1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LHtcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjE3fSx7XCJrXCI6MTd9XX1dfSx7XCJrXCI6NCxcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjoxN319XX1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUyOTl9XX19LFwibWVyZ2VEZWVwV2l0aFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIGNvcHkgb2YgdGhlIGNvbGxlY3Rpb24gd2l0aCB0aGUgcmVtYWluaW5nIGNvbGxlY3Rpb25zIG1lcmdlZCBpblxcbmRlZXBseSAocmVjdXJzaXZlbHkpLCBjYWxsaW5nIHRoZSBgbWVyZ2VyYCBmdW5jdGlvbiB3aGVuZXZlciBhbiBleGlzdGluZ1xcbnZhbHVlIGlzIGVuY291bnRlcmVkLlwiLFwiZGVzY3JpcHRpb25cIjpcIkEgZnVuY3Rpb25hbCBhbHRlcm5hdGl2ZSB0byBgY29sbGVjdGlvbi5tZXJnZURlZXBXaXRoKClgIHdoaWNoIHdpbGwgYWxzb1xcbndvcmsgd2l0aCBwbGFpbiBPYmplY3RzIGFuZCBBcnJheXMuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IG1lcmdlRGVlcFdpdGggfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgb3JpZ2luYWwgPSB7IHg6IHsgeTogMTIzIH19XFxubWVyZ2VEZWVwV2l0aChcXG4gIChvbGRWYWwsIG5ld1ZhbCkgPT4gb2xkVmFsICsgbmV3VmFsLFxcbiAgb3JpZ2luYWwsXFxuICB7IHg6IHsgeTogNDU2IH19XFxuKSAvLyB7IHg6IHsgeTogNTc5IH19XFxuY29uc29sZS5sb2cob3JpZ2luYWwpIC8vIHsgeDogeyB5OiAxMjMgfX1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtZXJnZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvbGRWYWxcIixcInR5cGVcIjp7XCJrXCI6MTd9fSx7XCJuYW1lXCI6XCJuZXdWYWxcIixcInR5cGVcIjp7XCJrXCI6MTd9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19LHtcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0se1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfV19LHtcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX1dfV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJsaW5lXCI6NTMyNH1dfX19fSxcImltbXV0YWJsZVwiOntcIm1vZHVsZVwiOnt9fX0iLCJ2YXIgVHlwZUtpbmQgPSB7XG4gIEFueTogMCxcblxuICBCb29sZWFuOiAxLFxuICBOdW1iZXI6IDIsXG4gIFN0cmluZzogMyxcbiAgT2JqZWN0OiA0LFxuICBBcnJheTogNSxcbiAgTmV2ZXI6IDYsXG4gIEZ1bmN0aW9uOiA3LFxuXG4gIFBhcmFtOiA4LFxuICBUeXBlOiA5LFxuXG4gIFRoaXM6IDEwLFxuICBVbmRlZmluZWQ6IDExLFxuICBVbmlvbjogMTIsXG4gIEludGVyc2VjdGlvbjogMTMsXG4gIFR1cGxlOiAxNCxcbiAgSW5kZXhlZDogMTUsXG4gIE9wZXJhdG9yOiAxNixcblxuICBVbmtub3duOiAxNyxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZUtpbmQ7XG4iLCJ2YXIgJF9fMD0gICAgcmVxdWlyZSgnLi4vLi4vJyksU2VxPSRfXzAuU2VxO1xuLy8gTm90ZTogaW50ZW50aW9uYWxseSB1c2luZyByYXcgZGVmcywgbm90IGdldFR5cGVEZWZzIHRvIGF2b2lkIGNpcmN1bGFyIHJlZi5cbnZhciBkZWZzID0gcmVxdWlyZSgnLi4vZ2VuZXJhdGVkL2ltbXV0YWJsZS5kLmpzb24nKTtcblxuZnVuY3Rpb24gY29sbGVjdE1lbWJlckdyb3VwcyhpbnRlcmZhY2VEZWYsIG9wdGlvbnMpIHtcbiAgdmFyIG1lbWJlcnMgPSB7fTtcblxuICBpZiAoaW50ZXJmYWNlRGVmKSB7XG4gICAgY29sbGVjdEZyb21EZWYoaW50ZXJmYWNlRGVmKTtcbiAgfVxuXG4gIHZhciBncm91cHMgPSB7ICcnOiBbXSB9O1xuXG4gIGlmIChvcHRpb25zLnNob3dJbkdyb3Vwcykge1xuICAgIFNlcShtZW1iZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG1lbWJlcikgIHtcbiAgICAgIChncm91cHNbbWVtYmVyLmdyb3VwXSB8fCAoZ3JvdXBzW21lbWJlci5ncm91cF0gPSBbXSkpLnB1c2gobWVtYmVyKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBncm91cHNbJyddID0gU2VxKG1lbWJlcnMpXG4gICAgICAuc29ydEJ5KGZ1bmN0aW9uKG1lbWJlcikgIHtyZXR1cm4gbWVtYmVyLm1lbWJlck5hbWU7fSlcbiAgICAgIC50b0FycmF5KCk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMuc2hvd0luaGVyaXRlZCkge1xuICAgIGdyb3VwcyA9IFNlcShncm91cHMpXG4gICAgICAubWFwKGZ1bmN0aW9uKG1lbWJlcnMpICB7cmV0dXJuIG1lbWJlcnMuZmlsdGVyKGZ1bmN0aW9uKG1lbWJlcikgIHtyZXR1cm4gIW1lbWJlci5pbmhlcml0ZWQ7fSk7fSlcbiAgICAgIC50b09iamVjdCgpO1xuICB9XG5cbiAgcmV0dXJuIGdyb3VwcztcblxuICBmdW5jdGlvbiBjb2xsZWN0RnJvbURlZihkZWYsIG5hbWUpIHtcbiAgICBkZWYuZ3JvdXBzICYmXG4gICAgICBkZWYuZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24oZykgIHtcbiAgICAgICAgU2VxKGcubWVtYmVycykuZm9yRWFjaChmdW5jdGlvbihtZW1iZXJEZWYsIG1lbWJlck5hbWUpICB7XG4gICAgICAgICAgY29sbGVjdE1lbWJlcihnLnRpdGxlIHx8ICcnLCBtZW1iZXJOYW1lLCBtZW1iZXJEZWYpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgZGVmLmV4dGVuZHMgJiZcbiAgICAgIGRlZi5leHRlbmRzLmZvckVhY2goZnVuY3Rpb24oZSkgIHtcbiAgICAgICAgdmFyIHN1cGVyTW9kdWxlID0gZGVmcy5JbW11dGFibGU7XG4gICAgICAgIGUubmFtZS5zcGxpdCgnLicpLmZvckVhY2goZnVuY3Rpb24ocGFydCkgIHtcbiAgICAgICAgICBzdXBlck1vZHVsZSA9XG4gICAgICAgICAgICBzdXBlck1vZHVsZSAmJiBzdXBlck1vZHVsZS5tb2R1bGUgJiYgc3VwZXJNb2R1bGUubW9kdWxlW3BhcnRdO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHN1cGVySW50ZXJmYWNlID0gc3VwZXJNb2R1bGUgJiYgc3VwZXJNb2R1bGUuaW50ZXJmYWNlO1xuICAgICAgICBpZiAoc3VwZXJJbnRlcmZhY2UpIHtcbiAgICAgICAgICBjb2xsZWN0RnJvbURlZihzdXBlckludGVyZmFjZSwgZS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICBmdW5jdGlvbiBjb2xsZWN0TWVtYmVyKGdyb3VwLCBtZW1iZXJOYW1lLCBtZW1iZXJEZWYpIHtcbiAgICAgIHZhciBtZW1iZXIgPSBtZW1iZXJzW21lbWJlck5hbWVdO1xuICAgICAgaWYgKG1lbWJlcikge1xuICAgICAgICBpZiAoIW1lbWJlci5pbmhlcml0ZWQpIHtcbiAgICAgICAgICBtZW1iZXIub3ZlcnJpZGVzID0geyBuYW1lOm5hbWUsIGRlZjpkZWYsIG1lbWJlckRlZjptZW1iZXJEZWYgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lbWJlci5ncm91cCAmJiBncm91cCkge1xuICAgICAgICAgIG1lbWJlci5ncm91cCA9IGdyb3VwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZW1iZXIgPSB7XG4gICAgICAgICAgZ3JvdXA6Z3JvdXAsXG4gICAgICAgICAgbWVtYmVyTmFtZTogbWVtYmVyTmFtZS5zdWJzdHIoMSksXG4gICAgICAgICAgbWVtYmVyRGVmOm1lbWJlckRlZixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRlZiAhPT0gaW50ZXJmYWNlRGVmKSB7XG4gICAgICAgICAgbWVtYmVyLmluaGVyaXRlZCA9IHsgbmFtZTpuYW1lLCBkZWY6ZGVmIH07XG4gICAgICAgIH1cbiAgICAgICAgbWVtYmVyc1ttZW1iZXJOYW1lXSA9IG1lbWJlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb2xsZWN0TWVtYmVyR3JvdXBzO1xuIiwidmFyIG1hcmtkb3duRG9jcyA9IHJlcXVpcmUoJy4vbWFya2Rvd25Eb2NzJyk7XG52YXIgZGVmcyA9IHJlcXVpcmUoJy4uL2dlbmVyYXRlZC9pbW11dGFibGUuZC5qc29uJyk7XG5cbm1hcmtkb3duRG9jcyhkZWZzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZzO1xuIiwidmFyIG1hcmtlZCA9IHJlcXVpcmUoJ21hcmtlZCcpO1xudmFyICRfXzA9ICAgIHJlcXVpcmUoJy4uLy4uLycpLFNlcT0kX18wLlNlcTtcbnZhciBwcmlzbSA9IHJlcXVpcmUoJy4vcHJpc20nKTtcbnZhciBjb2xsZWN0TWVtYmVyR3JvdXBzID0gcmVxdWlyZSgnLi9jb2xsZWN0TWVtYmVyR3JvdXBzJyk7XG4vLyBOb3RlOiBpbnRlbnRpb25hbGx5IHVzaW5nIHJhdyBkZWZzLCBub3QgZ2V0VHlwZURlZnMgdG8gYXZvaWQgY2lyY3VsYXIgcmVmLlxudmFyIGRlZnMgPSByZXF1aXJlKCcuLi9nZW5lcmF0ZWQvaW1tdXRhYmxlLmQuanNvbicpO1xuXG5mdW5jdGlvbiBjb2xsZWN0QWxsTWVtYmVyc0ZvckFsbFR5cGVzKGRlZnMpIHtcbiAgdmFyIGFsbE1lbWJlcnMgPSBuZXcgV2Vha01hcCgpO1xuICBfY29sbGVjdEFsbE1lbWJlcnNGb3JBbGxUeXBlcyhkZWZzKTtcbiAgcmV0dXJuIGFsbE1lbWJlcnM7XG4gIGZ1bmN0aW9uIF9jb2xsZWN0QWxsTWVtYmVyc0ZvckFsbFR5cGVzKGRlZnMpIHtcbiAgICBTZXEoZGVmcykuZm9yRWFjaChmdW5jdGlvbihkZWYpICB7XG4gICAgICBpZiAoZGVmLmludGVyZmFjZSkge1xuICAgICAgICB2YXIgZ3JvdXBzID0gY29sbGVjdE1lbWJlckdyb3VwcyhkZWYuaW50ZXJmYWNlLCB7XG4gICAgICAgICAgc2hvd0luaGVyaXRlZDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGFsbE1lbWJlcnMuc2V0KFxuICAgICAgICAgIGRlZi5pbnRlcmZhY2UsXG4gICAgICAgICAgU2VxLktleWVkKFxuICAgICAgICAgICAgZ3JvdXBzWycnXS5tYXAoZnVuY3Rpb24obWVtYmVyKSAge3JldHVybiBbbWVtYmVyLm1lbWJlck5hbWUsIG1lbWJlci5tZW1iZXJEZWZdO30pXG4gICAgICAgICAgKS50b09iamVjdCgpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZGVmLm1vZHVsZSkge1xuICAgICAgICBfY29sbGVjdEFsbE1lbWJlcnNGb3JBbGxUeXBlcyhkZWYubW9kdWxlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYWxsTWVtYmVycztcbiAgfVxufVxuXG52YXIgYWxsTWVtYmVycyA9IGNvbGxlY3RBbGxNZW1iZXJzRm9yQWxsVHlwZXMoZGVmcyk7XG5cbi8vIGZ1bmN0aW9ucyBjb21lIGJlZm9yZSBrZXl3b3Jkc1xucHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdrZXl3b3JkJywge1xuICB2YXI6IC9cXGIodGhpcylcXGIvZyxcbiAgJ2Jsb2NrLWtleXdvcmQnOiAvXFxiKGlmfGVsc2V8d2hpbGV8Zm9yfGZ1bmN0aW9uKVxcYi9nLFxuICBwcmltaXRpdmU6IC9cXGIodHJ1ZXxmYWxzZXxudWxsfHVuZGVmaW5lZClcXGIvZyxcbiAgZnVuY3Rpb246IHByaXNtLmxhbmd1YWdlcy5mdW5jdGlvbixcbn0pO1xuXG5wcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0Jywge1xuICBxdWFsaWZpZXI6IC9cXGJbQS1aXVthLXowLTlfXSsvZyxcbn0pO1xuXG5tYXJrZWQuc2V0T3B0aW9ucyh7XG4gIHhodG1sOiB0cnVlLFxuICBoaWdobGlnaHQ6IGZ1bmN0aW9uKGNvZGUpICB7cmV0dXJuIHByaXNtLmhpZ2hsaWdodChjb2RlLCBwcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCk7fSxcbn0pO1xuXG52YXIgcmVuZGVyZXIgPSBuZXcgbWFya2VkLlJlbmRlcmVyKCk7XG5cbmNvbnN0IHJ1bmtpdFJlZ0V4cCA9IC9ePCEtLVxccypydW5raXQ6YWN0aXZhdGUoKC58XFxuKSopLS0+KC58XFxuKSokLztcbmNvbnN0IHJ1bmtpdENvbnRleHQgPSB7IG9wdGlvbnM6ICd7fScsIGFjdGl2YXRlZDogZmFsc2UgfTtcblxucmVuZGVyZXIuaHRtbCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHJ1bmtpdFJlZ0V4cC5leGVjKHRleHQpO1xuXG4gIGlmICghcmVzdWx0KSByZXR1cm4gdGV4dDtcblxuICBydW5raXRDb250ZXh0LmFjdGl2YXRlZCA9IHRydWU7XG4gIHRyeSB7XG4gICAgcnVua2l0Q29udGV4dC5vcHRpb25zID0gcmVzdWx0WzFdID8gSlNPTi5wYXJzZShyZXN1bHRbMV0pIDoge307XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBydW5raXRDb250ZXh0Lm9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4gdGV4dDtcbn07XG5cbnJlbmRlcmVyLmNvZGUgPSBmdW5jdGlvbiAoY29kZSwgbGFuZywgZXNjYXBlZCkge1xuICBpZiAodGhpcy5vcHRpb25zLmhpZ2hsaWdodCkge1xuICAgIHZhciBvdXQgPSB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KGNvZGUsIGxhbmcpO1xuICAgIGlmIChvdXQgIT0gbnVsbCAmJiBvdXQgIT09IGNvZGUpIHtcbiAgICAgIGVzY2FwZWQgPSB0cnVlO1xuICAgICAgY29kZSA9IG91dDtcbiAgICB9XG4gIH1cblxuICBjb25zdCBydW5JdEJ1dHRvbiA9IHJ1bmtpdENvbnRleHQuYWN0aXZhdGVkXG4gICAgPyAnPGEgY2xhc3M9XCJ0cnktaXRcIiBkYXRhLW9wdGlvbnM9XCInICtcbiAgICAgIGVzY2FwZShKU09OLnN0cmluZ2lmeShydW5raXRDb250ZXh0Lm9wdGlvbnMpKSArXG4gICAgICAnXCIgb25DbGljaz1cInJ1bkl0KHRoaXMpXCI+cnVuIGl0PC9hPidcbiAgICA6ICcnO1xuXG4gIHJ1bmtpdENvbnRleHQuYWN0aXZhdGVkID0gZmFsc2U7XG4gIHJ1bmtpdENvbnRleHQub3B0aW9ucyA9ICd7fSc7XG5cbiAgcmV0dXJuIChcbiAgICAnPGNvZGUgY2xhc3M9XCJjb2RlQmxvY2tcIj4nICtcbiAgICAoZXNjYXBlZCA/IGNvZGUgOiBlc2NhcGVDb2RlKGNvZGUsIHRydWUpKSArXG4gICAgcnVuSXRCdXR0b24gK1xuICAgICc8L2NvZGU+J1xuICApO1xufTtcblxudmFyIE1FVEhPRF9SWCA9IC9eKFxcdyspKD86WyMuXShcXHcrKSk/KD86XFwoXFwpKT8kLztcbnZhciBQQVJBTV9SWCA9IC9eXFx3KyQvO1xudmFyIE1ETl9UWVBFUyA9IHtcbiAgQXJyYXk6IHRydWUsXG4gIE9iamVjdDogdHJ1ZSxcbiAgSlNPTjogdHJ1ZSxcbn07XG52YXIgTUROX0JBU0VfVVJMID1cbiAgJ2h0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzLyc7XG5cbnJlbmRlcmVyLmNvZGVzcGFuID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgcmV0dXJuICc8Y29kZT4nICsgZGVjb3JhdGVDb2RlU3Bhbih0ZXh0LCB0aGlzLm9wdGlvbnMpICsgJzwvY29kZT4nO1xufTtcblxuZnVuY3Rpb24gZGVjb3JhdGVDb2RlU3Bhbih0ZXh0LCBvcHRpb25zKSB7XG4gIHZhciBjb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0O1xuXG4gIGlmIChcbiAgICBjb250ZXh0LnNpZ25hdHVyZXMgJiZcbiAgICBQQVJBTV9SWC50ZXN0KHRleHQpICYmXG4gICAgY29udGV4dC5zaWduYXR1cmVzLnNvbWUoXG4gICAgICBmdW5jdGlvbihzaWcpICB7cmV0dXJuIHNpZy5wYXJhbXMgJiYgc2lnLnBhcmFtcy5zb21lKGZ1bmN0aW9uKHBhcmFtKSAge3JldHVybiBwYXJhbS5uYW1lID09PSB0ZXh0O30pO31cbiAgICApXG4gICkge1xuICAgIHJldHVybiAnPHNwYW4gY2xhc3M9XCJ0IHBhcmFtXCI+JyArIHRleHQgKyAnPC9zcGFuPic7XG4gIH1cblxuICB2YXIgbWV0aG9kID0gTUVUSE9EX1JYLmV4ZWModGV4dCk7XG4gIGlmIChtZXRob2QpIHtcbiAgICBtZXRob2QgPSBtZXRob2Quc2xpY2UoMSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgIGlmIChNRE5fVFlQRVNbbWV0aG9kWzBdXSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgJzxhIGhyZWY9XCInICsgTUROX0JBU0VfVVJMICsgbWV0aG9kLmpvaW4oJy8nKSArICdcIj4nICsgdGV4dCArICc8L2E+J1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgY29udGV4dC50eXBlUGF0aCAmJlxuICAgICAgIWFyckVuZHNXaXRoKGNvbnRleHQudHlwZVBhdGgsIG1ldGhvZCkgJiZcbiAgICAgICFhcnJFbmRzV2l0aChjb250ZXh0LnR5cGVQYXRoLnNsaWNlKDAsIC0xKSwgbWV0aG9kKVxuICAgICkge1xuICAgICAgdmFyIHBhdGggPSBmaW5kUGF0aChjb250ZXh0LCBtZXRob2QpO1xuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgdmFyIHJlbFBhdGggPSBjb250ZXh0LnJlbFBhdGggfHwgJyc7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgJzxhIHRhcmdldD1cIl9zZWxmXCIgaHJlZj1cIicgK1xuICAgICAgICAgIHJlbFBhdGggK1xuICAgICAgICAgICcjLycgK1xuICAgICAgICAgIHBhdGguc2xpY2UoMSkuam9pbignLycpICtcbiAgICAgICAgICAnXCI+JyArXG4gICAgICAgICAgdGV4dCArXG4gICAgICAgICAgJzwvYT4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuaGlnaGxpZ2h0KHVuZXNjYXBlQ29kZSh0ZXh0KSwgcHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQpO1xuICB9XG5cbiAgcmV0dXJuIHRleHQ7XG59XG5cbmZ1bmN0aW9uIGFyckVuZHNXaXRoKGFycjEsIGFycjIpIHtcbiAgZm9yICh2YXIgaWkgPSAxOyBpaSA8PSBhcnIyLmxlbmd0aDsgaWkrKykge1xuICAgIGlmIChhcnIyW2FycjIubGVuZ3RoIC0gaWldICE9PSBhcnIxW2FycjEubGVuZ3RoIC0gaWldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmaW5kUGF0aChjb250ZXh0LCBzZWFyY2gpIHtcbiAgdmFyIHJlbGF0aXZlID0gY29udGV4dC50eXBlUGF0aDtcblxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDw9IHJlbGF0aXZlLmxlbmd0aDsgaWkrKykge1xuICAgIHZhciBwYXRoID0gcmVsYXRpdmUuc2xpY2UoMCwgcmVsYXRpdmUubGVuZ3RoIC0gaWkpLmNvbmNhdChzZWFyY2gpO1xuICAgIGlmIChcbiAgICAgIHBhdGgucmVkdWNlKFxuICAgICAgICBmdW5jdGlvbihkZWYsIG5hbWUpIFxuICAgICAgICAgIHtyZXR1cm4gZGVmICYmXG4gICAgICAgICAgKChkZWYubW9kdWxlICYmIGRlZi5tb2R1bGVbbmFtZV0pIHx8XG4gICAgICAgICAgICAoZGVmLmludGVyZmFjZSAmJlxuICAgICAgICAgICAgICBhbGxNZW1iZXJzICYmXG4gICAgICAgICAgICAgIGFsbE1lbWJlcnMuZ2V0KGRlZi5pbnRlcmZhY2UpW25hbWVdKSB8fFxuICAgICAgICAgICAgdW5kZWZpbmVkKTt9LFxuICAgICAgICB7IG1vZHVsZTogZGVmcyB9XG4gICAgICApXG4gICAgKSB7XG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZXNjYXBlQ29kZShjb2RlKSB7XG4gIHJldHVybiBjb2RlXG4gICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcbiAgICAucmVwbGFjZSgvJy9nLCAnJiMzOTsnKTtcbn1cblxuZnVuY3Rpb24gdW5lc2NhcGVDb2RlKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGVcbiAgICAucmVwbGFjZSgvJmx0Oy9nLCAnPCcpXG4gICAgLnJlcGxhY2UoLyZndDsvZywgJz4nKVxuICAgIC5yZXBsYWNlKC8mcXVvdDsvZywgJ1wiJylcbiAgICAucmVwbGFjZSgvJiMzOTsvZywgXCInXCIpXG4gICAgLnJlcGxhY2UoLyZhbXA7L2csICcmJyk7XG59XG5cbmZ1bmN0aW9uIG1hcmtkb3duKGNvbnRlbnQsIGNvbnRleHQpIHtcbiAgY29udGV4dCB8fCAoY29udGV4dCA9IHt9KTtcbiAgcmV0dXJuIGNvbnRlbnQgPyBtYXJrZWQoY29udGVudCwgeyByZW5kZXJlcjpyZW5kZXJlciwgY29udGV4dDpjb250ZXh0IH0pIDogY29udGVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXJrZG93bjtcbiIsInZhciAkX18wPSAgICByZXF1aXJlKCcuLi8uLi8nKSxTZXE9JF9fMC5TZXE7XG52YXIgbWFya2Rvd24gPSByZXF1aXJlKCcuL21hcmtkb3duJyk7XG5cbmZ1bmN0aW9uIG1hcmtkb3duRG9jcyhkZWZzKSB7XG4gIG1hcmtkb3duVHlwZXMoZGVmcywgW10pO1xuXG4gIGZ1bmN0aW9uIG1hcmtkb3duVHlwZXModHlwZURlZnMsIHBhdGgpIHtcbiAgICBTZXEodHlwZURlZnMpLmZvckVhY2goZnVuY3Rpb24odHlwZURlZiwgdHlwZU5hbWUpICB7XG4gICAgICB2YXIgdHlwZVBhdGggPSBwYXRoLmNvbmNhdCh0eXBlTmFtZSk7XG4gICAgICBtYXJrZG93bkRvYyh0eXBlRGVmLmRvYywgeyB0eXBlUGF0aDp0eXBlUGF0aCB9KTtcbiAgICAgIHR5cGVEZWYuY2FsbCAmJlxuICAgICAgICBtYXJrZG93bkRvYyh0eXBlRGVmLmNhbGwuZG9jLCB7XG4gICAgICAgICAgdHlwZVBhdGg6dHlwZVBhdGgsXG4gICAgICAgICAgc2lnbmF0dXJlczogdHlwZURlZi5jYWxsLnNpZ25hdHVyZXMsXG4gICAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVEZWYuaW50ZXJmYWNlKSB7XG4gICAgICAgIG1hcmtkb3duRG9jKHR5cGVEZWYuaW50ZXJmYWNlLmRvYywgeyBkZWZzOmRlZnMsIHR5cGVQYXRoOnR5cGVQYXRoIH0pO1xuICAgICAgICBTZXEodHlwZURlZi5pbnRlcmZhY2UuZ3JvdXBzKS5mb3JFYWNoKGZ1bmN0aW9uKGdyb3VwKSBcbiAgICAgICAgICB7cmV0dXJuIFNlcShncm91cC5tZW1iZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG1lbWJlciwgbWVtYmVyTmFtZSkgXG4gICAgICAgICAgICB7cmV0dXJuIG1hcmtkb3duRG9jKG1lbWJlci5kb2MsIHtcbiAgICAgICAgICAgICAgdHlwZVBhdGg6IHR5cGVQYXRoLmNvbmNhdChtZW1iZXJOYW1lLnNsaWNlKDEpKSxcbiAgICAgICAgICAgICAgc2lnbmF0dXJlczogbWVtYmVyLnNpZ25hdHVyZXMsXG4gICAgICAgICAgICB9KTt9XG4gICAgICAgICAgKTt9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0eXBlRGVmLm1vZHVsZSAmJiBtYXJrZG93blR5cGVzKHR5cGVEZWYubW9kdWxlLCB0eXBlUGF0aCk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya2Rvd25Eb2MoZG9jLCBjb250ZXh0KSB7XG4gIGlmICghZG9jKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGRvYy5zeW5vcHNpcyAmJiAoZG9jLnN5bm9wc2lzID0gbWFya2Rvd24oZG9jLnN5bm9wc2lzLCBjb250ZXh0KSk7XG4gIGRvYy5kZXNjcmlwdGlvbiAmJiAoZG9jLmRlc2NyaXB0aW9uID0gbWFya2Rvd24oZG9jLmRlc2NyaXB0aW9uLCBjb250ZXh0KSk7XG4gIGRvYy5ub3RlcyAmJlxuICAgIGRvYy5ub3Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vdGUpICB7XG4gICAgICBpZiAobm90ZS5uYW1lICE9PSAnYWxpYXMnKSB7XG4gICAgICAgIG5vdGUuYm9keSA9IG1hcmtkb3duKG5vdGUuYm9keSwgY29udGV4dCk7XG4gICAgICB9XG4gICAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFya2Rvd25Eb2NzO1xuIiwiLyogZXNsaW50LWRpc2FibGUgKi9cblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1jb3JlLmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbnNlbGYgPVxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgID8gd2luZG93IC8vIGlmIGluIGJyb3dzZXJcbiAgICA6IHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZVxuICAgID8gc2VsZiAvLyBpZiBpbiB3b3JrZXJcbiAgICA6IHt9OyAvLyBpZiBpbiBub2RlIGpzXG5cbi8qKlxuICogUHJpc206IExpZ2h0d2VpZ2h0LCByb2J1c3QsIGVsZWdhbnQgc3ludGF4IGhpZ2hsaWdodGluZ1xuICogTUlUIGxpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAvXG4gKiBAYXV0aG9yIExlYSBWZXJvdSBodHRwOi8vbGVhLnZlcm91Lm1lXG4gKi9cblxudmFyIFByaXNtID0gKGZ1bmN0aW9uICgpIHtcbiAgLy8gUHJpdmF0ZSBoZWxwZXIgdmFyc1xuICB2YXIgbGFuZyA9IC9cXGJsYW5nKD86dWFnZSk/LSg/IVxcKikoXFx3KylcXGIvaTtcblxuICB2YXIgXyA9IChzZWxmLlByaXNtID0ge1xuICAgIHV0aWw6IHtcbiAgICAgIGVuY29kZTogZnVuY3Rpb24gKHRva2Vucykge1xuICAgICAgICBpZiAodG9rZW5zIGluc3RhbmNlb2YgVG9rZW4pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFRva2VuKFxuICAgICAgICAgICAgdG9rZW5zLnR5cGUsXG4gICAgICAgICAgICBfLnV0aWwuZW5jb2RlKHRva2Vucy5jb250ZW50KSxcbiAgICAgICAgICAgIHRva2Vucy5hbGlhc1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoXy51dGlsLnR5cGUodG9rZW5zKSA9PT0gJ0FycmF5Jykge1xuICAgICAgICAgIHJldHVybiB0b2tlbnMubWFwKF8udXRpbC5lbmNvZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0b2tlbnNcbiAgICAgICAgICAgIC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAgICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx1MDBhMC9nLCAnICcpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB0eXBlOiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLm1hdGNoKC9cXFtvYmplY3QgKFxcdyspXFxdLylbMV07XG4gICAgICB9LFxuXG4gICAgICAvLyBEZWVwIGNsb25lIGEgbGFuZ3VhZ2UgZGVmaW5pdGlvbiAoZS5nLiB0byBleHRlbmQgaXQpXG4gICAgICBjbG9uZTogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfLnV0aWwudHlwZShvKTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdPYmplY3QnOlxuICAgICAgICAgICAgdmFyIGNsb25lID0ge307XG5cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvKSB7XG4gICAgICAgICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBjbG9uZVtrZXldID0gXy51dGlsLmNsb25lKG9ba2V5XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXG4gICAgICAgICAgY2FzZSAnQXJyYXknOlxuICAgICAgICAgICAgcmV0dXJuIG8uc2xpY2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfSxcbiAgICB9LFxuXG4gICAgbGFuZ3VhZ2VzOiB7XG4gICAgICBleHRlbmQ6IGZ1bmN0aW9uIChpZCwgcmVkZWYpIHtcbiAgICAgICAgdmFyIGxhbmcgPSBfLnV0aWwuY2xvbmUoXy5sYW5ndWFnZXNbaWRdKTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcmVkZWYpIHtcbiAgICAgICAgICBsYW5nW2tleV0gPSByZWRlZltrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxhbmc7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEluc2VydCBhIHRva2VuIGJlZm9yZSBhbm90aGVyIHRva2VuIGluIGEgbGFuZ3VhZ2UgbGl0ZXJhbFxuICAgICAgICogQXMgdGhpcyBuZWVkcyB0byByZWNyZWF0ZSB0aGUgb2JqZWN0ICh3ZSBjYW5ub3QgYWN0dWFsbHkgaW5zZXJ0IGJlZm9yZSBrZXlzIGluIG9iamVjdCBsaXRlcmFscyksXG4gICAgICAgKiB3ZSBjYW5ub3QganVzdCBwcm92aWRlIGFuIG9iamVjdCwgd2UgbmVlZCBhbm9iamVjdCBhbmQgYSBrZXkuXG4gICAgICAgKiBAcGFyYW0gaW5zaWRlIFRoZSBrZXkgKG9yIGxhbmd1YWdlIGlkKSBvZiB0aGUgcGFyZW50XG4gICAgICAgKiBAcGFyYW0gYmVmb3JlIFRoZSBrZXkgdG8gaW5zZXJ0IGJlZm9yZS4gSWYgbm90IHByb3ZpZGVkLCB0aGUgZnVuY3Rpb24gYXBwZW5kcyBpbnN0ZWFkLlxuICAgICAgICogQHBhcmFtIGluc2VydCBPYmplY3Qgd2l0aCB0aGUga2V5L3ZhbHVlIHBhaXJzIHRvIGluc2VydFxuICAgICAgICogQHBhcmFtIHJvb3QgVGhlIG9iamVjdCB0aGF0IGNvbnRhaW5zIGBpbnNpZGVgLiBJZiBlcXVhbCB0byBQcmlzbS5sYW5ndWFnZXMsIGl0IGNhbiBiZSBvbWl0dGVkLlxuICAgICAgICovXG4gICAgICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uIChpbnNpZGUsIGJlZm9yZSwgaW5zZXJ0LCByb290KSB7XG4gICAgICAgIHJvb3QgPSByb290IHx8IF8ubGFuZ3VhZ2VzO1xuICAgICAgICB2YXIgZ3JhbW1hciA9IHJvb3RbaW5zaWRlXTtcblxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgaW5zZXJ0ID0gYXJndW1lbnRzWzFdO1xuXG4gICAgICAgICAgZm9yICh2YXIgbmV3VG9rZW4gaW4gaW5zZXJ0KSB7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0Lmhhc093blByb3BlcnR5KG5ld1Rva2VuKSkge1xuICAgICAgICAgICAgICBncmFtbWFyW25ld1Rva2VuXSA9IGluc2VydFtuZXdUb2tlbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGdyYW1tYXI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmV0ID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgdG9rZW4gaW4gZ3JhbW1hcikge1xuICAgICAgICAgIGlmIChncmFtbWFyLmhhc093blByb3BlcnR5KHRva2VuKSkge1xuICAgICAgICAgICAgaWYgKHRva2VuID09IGJlZm9yZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBuZXdUb2tlbiBpbiBpbnNlcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0Lmhhc093blByb3BlcnR5KG5ld1Rva2VuKSkge1xuICAgICAgICAgICAgICAgICAgcmV0W25ld1Rva2VuXSA9IGluc2VydFtuZXdUb2tlbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldFt0b2tlbl0gPSBncmFtbWFyW3Rva2VuXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgcmVmZXJlbmNlcyBpbiBvdGhlciBsYW5ndWFnZSBkZWZpbml0aW9uc1xuICAgICAgICBfLmxhbmd1YWdlcy5ERlMoXy5sYW5ndWFnZXMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSByb290W2luc2lkZV0gJiYga2V5ICE9IGluc2lkZSkge1xuICAgICAgICAgICAgdGhpc1trZXldID0gcmV0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIChyb290W2luc2lkZV0gPSByZXQpO1xuICAgICAgfSxcblxuICAgICAgLy8gVHJhdmVyc2UgYSBsYW5ndWFnZSBkZWZpbml0aW9uIHdpdGggRGVwdGggRmlyc3QgU2VhcmNoXG4gICAgICBERlM6IGZ1bmN0aW9uIChvLCBjYWxsYmFjaywgdHlwZSkge1xuICAgICAgICBmb3IgKHZhciBpIGluIG8pIHtcbiAgICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbChvLCBpLCBvW2ldLCB0eXBlIHx8IGkpO1xuXG4gICAgICAgICAgICBpZiAoXy51dGlsLnR5cGUob1tpXSkgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgIF8ubGFuZ3VhZ2VzLkRGUyhvW2ldLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF8udXRpbC50eXBlKG9baV0pID09PSAnQXJyYXknKSB7XG4gICAgICAgICAgICAgIF8ubGFuZ3VhZ2VzLkRGUyhvW2ldLCBjYWxsYmFjaywgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0sXG5cbiAgICBoaWdobGlnaHRBbGw6IGZ1bmN0aW9uIChhc3luYywgY2FsbGJhY2spIHtcbiAgICAgIHZhciBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICdjb2RlW2NsYXNzKj1cImxhbmd1YWdlLVwiXSwgW2NsYXNzKj1cImxhbmd1YWdlLVwiXSBjb2RlLCBjb2RlW2NsYXNzKj1cImxhbmctXCJdLCBbY2xhc3MqPVwibGFuZy1cIl0gY29kZSdcbiAgICAgICk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBlbGVtZW50OyAoZWxlbWVudCA9IGVsZW1lbnRzW2krK10pOyApIHtcbiAgICAgICAgXy5oaWdobGlnaHRFbGVtZW50KGVsZW1lbnQsIGFzeW5jID09PSB0cnVlLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGhpZ2hsaWdodEVsZW1lbnQ6IGZ1bmN0aW9uIChlbGVtZW50LCBhc3luYywgY2FsbGJhY2spIHtcbiAgICAgIC8vIEZpbmQgbGFuZ3VhZ2VcbiAgICAgIHZhciBsYW5ndWFnZSxcbiAgICAgICAgZ3JhbW1hcixcbiAgICAgICAgcGFyZW50ID0gZWxlbWVudDtcblxuICAgICAgd2hpbGUgKHBhcmVudCAmJiAhbGFuZy50ZXN0KHBhcmVudC5jbGFzc05hbWUpKSB7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGxhbmd1YWdlID0gKHBhcmVudC5jbGFzc05hbWUubWF0Y2gobGFuZykgfHwgWywgJyddKVsxXTtcbiAgICAgICAgZ3JhbW1hciA9IF8ubGFuZ3VhZ2VzW2xhbmd1YWdlXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFncmFtbWFyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IGxhbmd1YWdlIG9uIHRoZSBlbGVtZW50LCBpZiBub3QgcHJlc2VudFxuICAgICAgZWxlbWVudC5jbGFzc05hbWUgPVxuICAgICAgICBlbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKGxhbmcsICcnKS5yZXBsYWNlKC9cXHMrL2csICcgJykgK1xuICAgICAgICAnIGxhbmd1YWdlLScgK1xuICAgICAgICBsYW5ndWFnZTtcblxuICAgICAgLy8gU2V0IGxhbmd1YWdlIG9uIHRoZSBwYXJlbnQsIGZvciBzdHlsaW5nXG4gICAgICBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cbiAgICAgIGlmICgvcHJlL2kudGVzdChwYXJlbnQubm9kZU5hbWUpKSB7XG4gICAgICAgIHBhcmVudC5jbGFzc05hbWUgPVxuICAgICAgICAgIHBhcmVudC5jbGFzc05hbWUucmVwbGFjZShsYW5nLCAnJykucmVwbGFjZSgvXFxzKy9nLCAnICcpICtcbiAgICAgICAgICAnIGxhbmd1YWdlLScgK1xuICAgICAgICAgIGxhbmd1YWdlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29kZSA9IGVsZW1lbnQudGV4dENvbnRlbnQ7XG5cbiAgICAgIGlmICghY29kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBlbnYgPSB7XG4gICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZSxcbiAgICAgICAgZ3JhbW1hcjogZ3JhbW1hcixcbiAgICAgICAgY29kZTogY29kZSxcbiAgICAgIH07XG5cbiAgICAgIF8uaG9va3MucnVuKCdiZWZvcmUtaGlnaGxpZ2h0JywgZW52KTtcblxuICAgICAgaWYgKGFzeW5jICYmIHNlbGYuV29ya2VyKSB7XG4gICAgICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKF8uZmlsZW5hbWUpO1xuXG4gICAgICAgIHdvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgZW52LmhpZ2hsaWdodGVkQ29kZSA9IFRva2VuLnN0cmluZ2lmeShKU09OLnBhcnNlKGV2dC5kYXRhKSwgbGFuZ3VhZ2UpO1xuXG4gICAgICAgICAgXy5ob29rcy5ydW4oJ2JlZm9yZS1pbnNlcnQnLCBlbnYpO1xuXG4gICAgICAgICAgZW52LmVsZW1lbnQuaW5uZXJIVE1MID0gZW52LmhpZ2hsaWdodGVkQ29kZTtcblxuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoZW52LmVsZW1lbnQpO1xuICAgICAgICAgIF8uaG9va3MucnVuKCdhZnRlci1oaWdobGlnaHQnLCBlbnYpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZShcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBsYW5ndWFnZTogZW52Lmxhbmd1YWdlLFxuICAgICAgICAgICAgY29kZTogZW52LmNvZGUsXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudi5oaWdobGlnaHRlZENvZGUgPSBfLmhpZ2hsaWdodChlbnYuY29kZSwgZW52LmdyYW1tYXIsIGVudi5sYW5ndWFnZSk7XG5cbiAgICAgICAgXy5ob29rcy5ydW4oJ2JlZm9yZS1pbnNlcnQnLCBlbnYpO1xuXG4gICAgICAgIGVudi5lbGVtZW50LmlubmVySFRNTCA9IGVudi5oaWdobGlnaHRlZENvZGU7XG5cbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbChlbGVtZW50KTtcblxuICAgICAgICBfLmhvb2tzLnJ1bignYWZ0ZXItaGlnaGxpZ2h0JywgZW52KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAodGV4dCwgZ3JhbW1hciwgbGFuZ3VhZ2UpIHtcbiAgICAgIHZhciB0b2tlbnMgPSBfLnRva2VuaXplKHRleHQsIGdyYW1tYXIpO1xuICAgICAgcmV0dXJuIFRva2VuLnN0cmluZ2lmeShfLnV0aWwuZW5jb2RlKHRva2VucyksIGxhbmd1YWdlKTtcbiAgICB9LFxuXG4gICAgdG9rZW5pemU6IGZ1bmN0aW9uICh0ZXh0LCBncmFtbWFyLCBsYW5ndWFnZSkge1xuICAgICAgdmFyIFRva2VuID0gXy5Ub2tlbjtcblxuICAgICAgdmFyIHN0cmFyciA9IFt0ZXh0XTtcblxuICAgICAgdmFyIHJlc3QgPSBncmFtbWFyLnJlc3Q7XG5cbiAgICAgIGlmIChyZXN0KSB7XG4gICAgICAgIGZvciAodmFyIHRva2VuIGluIHJlc3QpIHtcbiAgICAgICAgICBncmFtbWFyW3Rva2VuXSA9IHJlc3RbdG9rZW5dO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIGdyYW1tYXIucmVzdDtcbiAgICAgIH1cblxuICAgICAgdG9rZW5sb29wOiBmb3IgKHZhciB0b2tlbiBpbiBncmFtbWFyKSB7XG4gICAgICAgIGlmICghZ3JhbW1hci5oYXNPd25Qcm9wZXJ0eSh0b2tlbikgfHwgIWdyYW1tYXJbdG9rZW5dKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGF0dGVybnMgPSBncmFtbWFyW3Rva2VuXTtcbiAgICAgICAgcGF0dGVybnMgPSBfLnV0aWwudHlwZShwYXR0ZXJucykgPT09ICdBcnJheScgPyBwYXR0ZXJucyA6IFtwYXR0ZXJuc107XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXR0ZXJucy5sZW5ndGg7ICsraikge1xuICAgICAgICAgIHZhciBwYXR0ZXJuID0gcGF0dGVybnNbal0sXG4gICAgICAgICAgICBpbnNpZGUgPSBwYXR0ZXJuLmluc2lkZSxcbiAgICAgICAgICAgIGxvb2tiZWhpbmQgPSAhIXBhdHRlcm4ubG9va2JlaGluZCxcbiAgICAgICAgICAgIGxvb2tiZWhpbmRMZW5ndGggPSAwLFxuICAgICAgICAgICAgYWxpYXMgPSBwYXR0ZXJuLmFsaWFzO1xuXG4gICAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4ucGF0dGVybiB8fCBwYXR0ZXJuO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIERvbuKAmXQgY2FjaGUgbGVuZ3RoIGFzIGl0IGNoYW5nZXMgZHVyaW5nIHRoZSBsb29wXG5cbiAgICAgICAgICAgIHZhciBzdHIgPSBzdHJhcnJbaV07XG5cbiAgICAgICAgICAgIGlmIChzdHJhcnIubGVuZ3RoID4gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIHdlbnQgdGVycmlibHkgd3JvbmcsIEFCT1JULCBBQk9SVCFcbiAgICAgICAgICAgICAgYnJlYWsgdG9rZW5sb29wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RyIGluc3RhbmNlb2YgVG9rZW4pIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhdHRlcm4ubGFzdEluZGV4ID0gMDtcblxuICAgICAgICAgICAgdmFyIG1hdGNoID0gcGF0dGVybi5leGVjKHN0cik7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICBpZiAobG9va2JlaGluZCkge1xuICAgICAgICAgICAgICAgIGxvb2tiZWhpbmRMZW5ndGggPSBtYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgZnJvbSA9IG1hdGNoLmluZGV4IC0gMSArIGxvb2tiZWhpbmRMZW5ndGgsXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaFswXS5zbGljZShsb29rYmVoaW5kTGVuZ3RoKSxcbiAgICAgICAgICAgICAgICBsZW4gPSBtYXRjaC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdG8gPSBmcm9tICsgbGVuLFxuICAgICAgICAgICAgICAgIGJlZm9yZSA9IHN0ci5zbGljZSgwLCBmcm9tICsgMSksXG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBzdHIuc2xpY2UodG8gKyAxKTtcblxuICAgICAgICAgICAgICB2YXIgYXJncyA9IFtpLCAxXTtcblxuICAgICAgICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGJlZm9yZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgd3JhcHBlZCA9IG5ldyBUb2tlbihcbiAgICAgICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgICAgICBpbnNpZGUgPyBfLnRva2VuaXplKG1hdGNoLCBpbnNpZGUpIDogbWF0Y2gsXG4gICAgICAgICAgICAgICAgYWxpYXNcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICBhcmdzLnB1c2god3JhcHBlZCk7XG5cbiAgICAgICAgICAgICAgaWYgKGFmdGVyKSB7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGFmdGVyKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkoc3RyYXJyLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cmFycjtcbiAgICB9LFxuXG4gICAgaG9va3M6IHtcbiAgICAgIGFsbDoge30sXG5cbiAgICAgIGFkZDogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBob29rcyA9IF8uaG9va3MuYWxsO1xuXG4gICAgICAgIGhvb2tzW25hbWVdID0gaG9va3NbbmFtZV0gfHwgW107XG5cbiAgICAgICAgaG9va3NbbmFtZV0ucHVzaChjYWxsYmFjayk7XG4gICAgICB9LFxuXG4gICAgICBydW46IGZ1bmN0aW9uIChuYW1lLCBlbnYpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IF8uaG9va3MuYWxsW25hbWVdO1xuXG4gICAgICAgIGlmICghY2FsbGJhY2tzIHx8ICFjYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGNhbGxiYWNrOyAoY2FsbGJhY2sgPSBjYWxsYmFja3NbaSsrXSk7ICkge1xuICAgICAgICAgIGNhbGxiYWNrKGVudik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG5cbiAgdmFyIFRva2VuID0gKF8uVG9rZW4gPSBmdW5jdGlvbiAodHlwZSwgY29udGVudCwgYWxpYXMpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgdGhpcy5hbGlhcyA9IGFsaWFzO1xuICB9KTtcblxuICBUb2tlbi5zdHJpbmdpZnkgPSBmdW5jdGlvbiAobywgbGFuZ3VhZ2UsIHBhcmVudCkge1xuICAgIGlmICh0eXBlb2YgbyA9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG87XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm4gb1xuICAgICAgICAubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIFRva2VuLnN0cmluZ2lmeShlbGVtZW50LCBsYW5ndWFnZSwgbyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKCcnKTtcbiAgICB9XG5cbiAgICB2YXIgZW52ID0ge1xuICAgICAgdHlwZTogby50eXBlLFxuICAgICAgY29udGVudDogVG9rZW4uc3RyaW5naWZ5KG8uY29udGVudCwgbGFuZ3VhZ2UsIHBhcmVudCksXG4gICAgICB0YWc6ICdzcGFuJyxcbiAgICAgIGNsYXNzZXM6IFsndG9rZW4nLCBvLnR5cGVdLFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBsYW5ndWFnZTogbGFuZ3VhZ2UsXG4gICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICB9O1xuXG4gICAgaWYgKGVudi50eXBlID09ICdjb21tZW50Jykge1xuICAgICAgZW52LmF0dHJpYnV0ZXNbJ3NwZWxsY2hlY2snXSA9ICd0cnVlJztcbiAgICB9XG5cbiAgICBpZiAoby5hbGlhcykge1xuICAgICAgdmFyIGFsaWFzZXMgPSBfLnV0aWwudHlwZShvLmFsaWFzKSA9PT0gJ0FycmF5JyA/IG8uYWxpYXMgOiBbby5hbGlhc107XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlbnYuY2xhc3NlcywgYWxpYXNlcyk7XG4gICAgfVxuXG4gICAgXy5ob29rcy5ydW4oJ3dyYXAnLCBlbnYpO1xuXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSAnJztcblxuICAgIGZvciAodmFyIG5hbWUgaW4gZW52LmF0dHJpYnV0ZXMpIHtcbiAgICAgIGF0dHJpYnV0ZXMgKz0gbmFtZSArICc9XCInICsgKGVudi5hdHRyaWJ1dGVzW25hbWVdIHx8ICcnKSArICdcIic7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgICc8JyArXG4gICAgICBlbnYudGFnICtcbiAgICAgICcgY2xhc3M9XCInICtcbiAgICAgIGVudi5jbGFzc2VzLmpvaW4oJyAnKSArXG4gICAgICAnXCIgJyArXG4gICAgICBhdHRyaWJ1dGVzICtcbiAgICAgICc+JyArXG4gICAgICBlbnYuY29udGVudCArXG4gICAgICAnPC8nICtcbiAgICAgIGVudi50YWcgK1xuICAgICAgJz4nXG4gICAgKTtcbiAgfTtcblxuICBpZiAoIXNlbGYuZG9jdW1lbnQpIHtcbiAgICBpZiAoIXNlbGYuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgLy8gaW4gTm9kZS5qc1xuICAgICAgcmV0dXJuIHNlbGYuUHJpc207XG4gICAgfVxuICAgIC8vIEluIHdvcmtlclxuICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICdtZXNzYWdlJyxcbiAgICAgIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBKU09OLnBhcnNlKGV2dC5kYXRhKSxcbiAgICAgICAgICBsYW5nID0gbWVzc2FnZS5sYW5ndWFnZSxcbiAgICAgICAgICBjb2RlID0gbWVzc2FnZS5jb2RlO1xuXG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkoXy51dGlsLmVuY29kZShfLnRva2VuaXplKGNvZGUsIF8ubGFuZ3VhZ2VzW2xhbmddKSkpXG4gICAgICAgICk7XG4gICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgIH0sXG4gICAgICBmYWxzZVxuICAgICk7XG5cbiAgICByZXR1cm4gc2VsZi5QcmlzbTtcbiAgfVxuXG4gIC8vIEdldCBjdXJyZW50IHNjcmlwdCBhbmQgaGlnaGxpZ2h0XG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG5cbiAgc2NyaXB0ID0gc2NyaXB0W3NjcmlwdC5sZW5ndGggLSAxXTtcblxuICBpZiAoc2NyaXB0KSB7XG4gICAgXy5maWxlbmFtZSA9IHNjcmlwdC5zcmM7XG5cbiAgICBpZiAoZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciAmJiAhc2NyaXB0Lmhhc0F0dHJpYnV0ZSgnZGF0YS1tYW51YWwnKSkge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIF8uaGlnaGxpZ2h0QWxsKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VsZi5QcmlzbTtcbn0pKCk7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IFByaXNtO1xufVxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLW1hcmt1cC5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5QcmlzbS5sYW5ndWFnZXMubWFya3VwID0ge1xuICBjb21tZW50OiAvPCEtLVtcXHdcXFddKj8tLT4vZyxcbiAgcHJvbG9nOiAvPFxcPy4rP1xcPz4vLFxuICBkb2N0eXBlOiAvPCFET0NUWVBFLis/Pi8sXG4gIGNkYXRhOiAvPCFcXFtDREFUQVxcW1tcXHdcXFddKj9dXT4vaSxcbiAgdGFnOiB7XG4gICAgcGF0dGVybjpcbiAgICAgIC88XFwvP1tcXHc6LV0rXFxzKig/OlxccytbXFx3Oi1dKyg/Oj0oPzooXCJ8JykoXFxcXD9bXFx3XFxXXSkqP1xcMXxbXlxccydcIj49XSspKT9cXHMqKSpcXC8/Pi9naSxcbiAgICBpbnNpZGU6IHtcbiAgICAgIHRhZzoge1xuICAgICAgICBwYXR0ZXJuOiAvXjxcXC8/W1xcdzotXSsvaSxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgcHVuY3R1YXRpb246IC9ePFxcLz8vLFxuICAgICAgICAgIG5hbWVzcGFjZTogL15bXFx3LV0rPzovLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgICdhdHRyLXZhbHVlJzoge1xuICAgICAgICBwYXR0ZXJuOiAvPSg/OignfFwiKVtcXHdcXFddKj8oXFwxKXxbXlxccz5dKykvZ2ksXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgIHB1bmN0dWF0aW9uOiAvPXw+fFwiL2csXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgcHVuY3R1YXRpb246IC9cXC8/Pi9nLFxuICAgICAgJ2F0dHItbmFtZSc6IHtcbiAgICAgICAgcGF0dGVybjogL1tcXHc6LV0rL2csXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgIG5hbWVzcGFjZTogL15bXFx3LV0rPzovLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICB9LFxuICBlbnRpdHk6IC9cXCYjP1tcXGRhLXpdezEsOH07L2dpLFxufTtcblxuLy8gUGx1Z2luIHRvIG1ha2UgZW50aXR5IHRpdGxlIHNob3cgdGhlIHJlYWwgZW50aXR5LCBpZGVhIGJ5IFJvbWFuIEtvbWFyb3ZcblByaXNtLmhvb2tzLmFkZCgnd3JhcCcsIGZ1bmN0aW9uIChlbnYpIHtcbiAgaWYgKGVudi50eXBlID09PSAnZW50aXR5Jykge1xuICAgIGVudi5hdHRyaWJ1dGVzWyd0aXRsZSddID0gZW52LmNvbnRlbnQucmVwbGFjZSgvJmFtcDsvLCAnJicpO1xuICB9XG59KTtcblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1jc3MuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuUHJpc20ubGFuZ3VhZ2VzLmNzcyA9IHtcbiAgY29tbWVudDogL1xcL1xcKltcXHdcXFddKj9cXCpcXC8vZyxcbiAgYXRydWxlOiB7XG4gICAgcGF0dGVybjogL0BbXFx3LV0rPy4qPyg7fCg/PVxccyp7KSkvZ2ksXG4gICAgaW5zaWRlOiB7XG4gICAgICBwdW5jdHVhdGlvbjogL1s7Ol0vZyxcbiAgICB9LFxuICB9LFxuICB1cmw6IC91cmxcXCgoW1wiJ10/KS4qP1xcMVxcKS9naSxcbiAgc2VsZWN0b3I6IC9bXlxce1xcfVxcc11bXlxce1xcfTtdKig/PVxccypcXHspL2csXG4gIHByb3BlcnR5OiAvKFxcYnxcXEIpW1xcdy1dKyg/PVxccyo6KS9naSxcbiAgc3RyaW5nOiAvKFwifCcpKFxcXFw/LikqP1xcMS9nLFxuICBpbXBvcnRhbnQ6IC9cXEIhaW1wb3J0YW50XFxiL2dpLFxuICBwdW5jdHVhdGlvbjogL1tcXHtcXH07Ol0vZyxcbiAgZnVuY3Rpb246IC9bLWEtejAtOV0rKD89XFwoKS9naSxcbn07XG5cbmlmIChQcmlzbS5sYW5ndWFnZXMubWFya3VwKSB7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICd0YWcnLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIHBhdHRlcm46IC88c3R5bGVbXFx3XFxXXSo/PltcXHdcXFddKj88XFwvc3R5bGU+L2dpLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgIHRhZzoge1xuICAgICAgICAgIHBhdHRlcm46IC88c3R5bGVbXFx3XFxXXSo/Pnw8XFwvc3R5bGU+L2dpLFxuICAgICAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuaW5zaWRlLFxuICAgICAgICB9LFxuICAgICAgICByZXN0OiBQcmlzbS5sYW5ndWFnZXMuY3NzLFxuICAgICAgfSxcbiAgICAgIGFsaWFzOiAnbGFuZ3VhZ2UtY3NzJyxcbiAgICB9LFxuICB9KTtcblxuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKFxuICAgICdpbnNpZGUnLFxuICAgICdhdHRyLXZhbHVlJyxcbiAgICB7XG4gICAgICAnc3R5bGUtYXR0cic6IHtcbiAgICAgICAgcGF0dGVybjogL1xccypzdHlsZT0oXCJ8JykuKz9cXDEvZ2ksXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgICdhdHRyLW5hbWUnOiB7XG4gICAgICAgICAgICBwYXR0ZXJuOiAvXlxccypzdHlsZS9naSxcbiAgICAgICAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuaW5zaWRlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHVuY3R1YXRpb246IC9eXFxzKj1cXHMqWydcIl18WydcIl1cXHMqJC8sXG4gICAgICAgICAgJ2F0dHItdmFsdWUnOiB7XG4gICAgICAgICAgICBwYXR0ZXJuOiAvLisvZ2ksXG4gICAgICAgICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5jc3MsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgYWxpYXM6ICdsYW5ndWFnZS1jc3MnLFxuICAgICAgfSxcbiAgICB9LFxuICAgIFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnXG4gICk7XG59XG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tY2xpa2UuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuUHJpc20ubGFuZ3VhZ2VzLmNsaWtlID0ge1xuICBjb21tZW50OiBbXG4gICAge1xuICAgICAgcGF0dGVybjogLyhefFteXFxcXF0pXFwvXFwqW1xcd1xcV10qP1xcKlxcLy9nLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICB9LFxuICAgIHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXlxcXFw6XSlcXC9cXC8uKj8oXFxyP1xcbnwkKS9nLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICB9LFxuICBdLFxuICBzdHJpbmc6IC8oXCJ8JykoXFxcXD8uKSo/XFwxL2csXG4gICdjbGFzcy1uYW1lJzoge1xuICAgIHBhdHRlcm46XG4gICAgICAvKCg/Oig/OmNsYXNzfGludGVyZmFjZXxleHRlbmRzfGltcGxlbWVudHN8dHJhaXR8aW5zdGFuY2VvZnxuZXcpXFxzKyl8KD86Y2F0Y2hcXHMrXFwoKSlbYS16MC05X1xcLlxcXFxdKy9naSxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgcHVuY3R1YXRpb246IC8oXFwufFxcXFwpLyxcbiAgICB9LFxuICB9LFxuICBrZXl3b3JkOlxuICAgIC9cXGIoaWZ8ZWxzZXx3aGlsZXxkb3xmb3J8cmV0dXJufGlufGluc3RhbmNlb2Z8ZnVuY3Rpb258bmV3fHRyeXx0aHJvd3xjYXRjaHxmaW5hbGx5fG51bGx8YnJlYWt8Y29udGludWUpXFxiL2csXG4gIGJvb2xlYW46IC9cXGIodHJ1ZXxmYWxzZSlcXGIvZyxcbiAgZnVuY3Rpb246IHtcbiAgICBwYXR0ZXJuOiAvW2EtejAtOV9dK1xcKC9naSxcbiAgICBpbnNpZGU6IHtcbiAgICAgIHB1bmN0dWF0aW9uOiAvXFwoLyxcbiAgICB9LFxuICB9LFxuICBudW1iZXI6IC9cXGItPygweFtcXGRBLUZhLWZdK3xcXGQqXFwuP1xcZCsoW0VlXS0/XFxkKyk/KVxcYi9nLFxuICBvcGVyYXRvcjogL1stK117MSwyfXwhfDw9P3w+PT98PXsxLDN9fCZ7MSwyfXxcXHw/XFx8fFxcP3xcXCp8XFwvfFxcfnxcXF58XFwlL2csXG4gIGlnbm9yZTogLyYobHR8Z3R8YW1wKTsvZ2ksXG4gIHB1bmN0dWF0aW9uOiAvW3t9W1xcXTsoKSwuOl0vZyxcbn07XG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tamF2YXNjcmlwdC5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5QcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NsaWtlJywge1xuICBrZXl3b3JkOlxuICAgIC9cXGIoYnJlYWt8Y2FzZXxjYXRjaHxjbGFzc3xjb25zdHxjb250aW51ZXxkZWJ1Z2dlcnxkZWZhdWx0fGRlbGV0ZXxkb3xlbHNlfGVudW18ZXhwb3J0fGV4dGVuZHN8ZmFsc2V8ZmluYWxseXxmb3J8ZnVuY3Rpb258Z2V0fGlmfGltcGxlbWVudHN8aW1wb3J0fGlufGluc3RhbmNlb2Z8aW50ZXJmYWNlfGxldHxuZXd8bnVsbHxwYWNrYWdlfHByaXZhdGV8cHJvdGVjdGVkfHB1YmxpY3xyZXR1cm58c2V0fHN0YXRpY3xzdXBlcnxzd2l0Y2h8dGhpc3x0aHJvd3x0cnVlfHRyeXx0eXBlb2Z8dmFyfHZvaWR8d2hpbGV8d2l0aHx5aWVsZClcXGIvZyxcbiAgbnVtYmVyOiAvXFxiLT8oMHhbXFxkQS1GYS1mXSt8XFxkKlxcLj9cXGQrKFtFZV0tP1xcZCspP3xOYU58LT9JbmZpbml0eSlcXGIvZyxcbn0pO1xuXG5QcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ2tleXdvcmQnLCB7XG4gIHJlZ2V4OiB7XG4gICAgcGF0dGVybjpcbiAgICAgIC8oXnxbXi9dKVxcLyg/IVxcLykoXFxbLis/XXxcXFxcLnxbXi9cXHJcXG5dKStcXC9bZ2ltXXswLDN9KD89XFxzKigkfFtcXHJcXG4sLjt9KV0pKS9nLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gIH0sXG59KTtcblxuaWYgKFByaXNtLmxhbmd1YWdlcy5tYXJrdXApIHtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya3VwJywgJ3RhZycsIHtcbiAgICBzY3JpcHQ6IHtcbiAgICAgIHBhdHRlcm46IC88c2NyaXB0W1xcd1xcV10qPz5bXFx3XFxXXSo/PFxcL3NjcmlwdD4vZ2ksXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgdGFnOiB7XG4gICAgICAgICAgcGF0dGVybjogLzxzY3JpcHRbXFx3XFxXXSo/Pnw8XFwvc2NyaXB0Pi9naSxcbiAgICAgICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLmluc2lkZSxcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdDogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQsXG4gICAgICB9LFxuICAgICAgYWxpYXM6ICdsYW5ndWFnZS1qYXZhc2NyaXB0JyxcbiAgICB9LFxuICB9KTtcbn1cblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1maWxlLWhpZ2hsaWdodC5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuICBpZiAoIXNlbGYuUHJpc20gfHwgIXNlbGYuZG9jdW1lbnQgfHwgIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgRXh0ZW5zaW9ucyA9IHtcbiAgICBqczogJ2phdmFzY3JpcHQnLFxuICAgIGh0bWw6ICdtYXJrdXAnLFxuICAgIHN2ZzogJ21hcmt1cCcsXG4gICAgeG1sOiAnbWFya3VwJyxcbiAgICBweTogJ3B5dGhvbicsXG4gICAgcmI6ICdydWJ5JyxcbiAgfTtcblxuICBBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdwcmVbZGF0YS1zcmNdJykpXG4gICAgLmZvckVhY2goZnVuY3Rpb24gKHByZSkge1xuICAgICAgdmFyIHNyYyA9IHByZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3JjJyk7XG4gICAgICB2YXIgZXh0ZW5zaW9uID0gKHNyYy5tYXRjaCgvXFwuKFxcdyspJC8pIHx8IFssICcnXSlbMV07XG4gICAgICB2YXIgbGFuZ3VhZ2UgPSBFeHRlbnNpb25zW2V4dGVuc2lvbl0gfHwgZXh0ZW5zaW9uO1xuXG4gICAgICB2YXIgY29kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NvZGUnKTtcbiAgICAgIGNvZGUuY2xhc3NOYW1lID0gJ2xhbmd1YWdlLScgKyBsYW5ndWFnZTtcblxuICAgICAgcHJlLnRleHRDb250ZW50ID0gJyc7XG5cbiAgICAgIGNvZGUudGV4dENvbnRlbnQgPSAnTG9hZGluZ+KApic7XG5cbiAgICAgIHByZS5hcHBlbmRDaGlsZChjb2RlKTtcblxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICB4aHIub3BlbignR0VUJywgc3JjLCB0cnVlKTtcblxuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09IDQpIHtcbiAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA8IDQwMCAmJiB4aHIucmVzcG9uc2VUZXh0KSB7XG4gICAgICAgICAgICBjb2RlLnRleHRDb250ZW50ID0geGhyLnJlc3BvbnNlVGV4dDtcblxuICAgICAgICAgICAgUHJpc20uaGlnaGxpZ2h0RWxlbWVudChjb2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHhoci5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgICAgICBjb2RlLnRleHRDb250ZW50ID1cbiAgICAgICAgICAgICAgJ+KcliBFcnJvciAnICtcbiAgICAgICAgICAgICAgeGhyLnN0YXR1cyArXG4gICAgICAgICAgICAgICcgd2hpbGUgZmV0Y2hpbmcgZmlsZTogJyArXG4gICAgICAgICAgICAgIHhoci5zdGF0dXNUZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlLnRleHRDb250ZW50ID0gJ+KcliBFcnJvcjogRmlsZSBkb2VzIG5vdCBleGlzdCBvciBpcyBlbXB0eSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB4aHIuc2VuZChudWxsKTtcbiAgICB9KTtcbn0pKCk7XG4iLCJnbG9iYWwucnVuSXQgPSBmdW5jdGlvbiBydW5JdChidXR0b24pIHtcbiAgaWYgKCFnbG9iYWwuUnVuS2l0KSByZXR1cm47XG5cbiAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2YXIgY29kZUVsZW1lbnQgPSBidXR0b24ucGFyZW50Tm9kZTtcbiAgdmFyIHBhcmVudCA9IGNvZGVFbGVtZW50LnBhcmVudE5vZGU7XG5cbiAgcGFyZW50Lmluc2VydEJlZm9yZShjb250YWluZXIsIGNvZGVFbGVtZW50KTtcbiAgcGFyZW50LnJlbW92ZUNoaWxkKGNvZGVFbGVtZW50KTtcbiAgY29kZUVsZW1lbnQucmVtb3ZlQ2hpbGQoYnV0dG9uKTtcblxuICBjb25zdCBvcHRpb25zID0gSlNPTi5wYXJzZSh1bmVzY2FwZShidXR0b24uZGF0YXNldC5vcHRpb25zKSk7XG5cbiAgZnVuY3Rpb24gd2l0aENvcnJlY3RWZXJzaW9uKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZS5yZXBsYWNlKFxuICAgICAgL3JlcXVpcmVcXCgnaW1tdXRhYmxlJ1xcKS9nLFxuICAgICAgXCJyZXF1aXJlKCdpbW11dGFibGVANC4wLjAtcmMuOScpXCJcbiAgICApO1xuICB9XG5cbiAgZ2xvYmFsLlJ1bktpdC5jcmVhdGVOb3RlYm9vayh7XG4gICAgZWxlbWVudDogY29udGFpbmVyLFxuICAgIG5vZGVWZXJzaW9uOiBvcHRpb25zLm5vZGVWZXJzaW9uIHx8ICcqJyxcbiAgICBwcmVhbWJsZTogd2l0aENvcnJlY3RWZXJzaW9uKFxuICAgICAgJ2NvbnN0IGFzc2VydCA9ICgnICtcbiAgICAgICAgbWFrZUFzc2VydCArXG4gICAgICAgIFwiKShyZXF1aXJlKCdpbW11dGFibGUnKSk7XCIgK1xuICAgICAgICAob3B0aW9ucy5wcmVhbWJsZSB8fCAnJylcbiAgICApLFxuICAgIHNvdXJjZTogd2l0aENvcnJlY3RWZXJzaW9uKFxuICAgICAgY29kZUVsZW1lbnQudGV4dENvbnRlbnQucmVwbGFjZSgvXFxuKD5bXlxcbl0qXFxuPykrJC9nLCAnJylcbiAgICApLFxuICAgIG1pbkhlaWdodDogJzUycHgnLFxuICAgIG9uTG9hZDogZnVuY3Rpb24gKG5vdGVib29rKSB7XG4gICAgICBub3RlYm9vay5ldmFsdWF0ZSgpO1xuICAgIH0sXG4gIH0pO1xufTtcblxuZnVuY3Rpb24gbWFrZUFzc2VydChJKSB7XG4gIHZhciBpc0l0ZXJhYmxlID0gSS5pc0l0ZXJhYmxlIHx8IEkuSXRlcmFibGUuaXNJdGVyYWJsZTtcbiAgdmFyIGh0bWwgPSAoXCJcXG4gICAgPHN0eWxlPlxcbiAgICAgICoge1xcbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xcbiAgICAgICAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG4gICAgICB9XFxuXFxuICAgICAgY29kZSB7XFxuICAgICAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcbiAgICAgICAgY29sb3I6ICM0MTgzQzQ7XFxuICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgICAgICBiYWNrZ3JvdW5kOiByZ2JhKDY1LCAxMzEsIDE5NiwgMC4xKTtcXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcXG4gICAgICAgIHBhZGRpbmc6IDJweDtcXG4gICAgfVxcblxcbiAgICAgIC5zdWNjZXNzIHtcXG4gICAgICAgIGNvbG9yOiByZ2JhKDg0LDE4NCw1NCwxLjApO1xcbiAgICAgIH1cXG5cXG4gICAgICAuc3VjY2VzczpiZWZvcmUge1xcbiAgICAgICAgY29udGVudDogXFxcIuKchVxcXCI7XFxuICAgICAgfVxcblxcbiAgICAgIC5mYWlsdXJlIHtcXG4gICAgICAgIGNvbG9yOiByZ2JhKDIyMCw0NywzMywxLjApO1xcbiAgICAgIH1cXG5cXG4gICAgICAuZmFpbHVyZSBpIHtcXG4gICAgICAgIGNvbG9yOiByZ2JhKDIxMCw0NCwzMSwxLjApO1xcbiAgICAgIH1cXG5cXG4gICAgICAuZmFpbHVyZTpiZWZvcmUge1xcbiAgICAgICAgY29udGVudDogXFxcIuKdjFxcXCI7XFxuICAgICAgfVxcbiAgICA8L3N0eWxlPlwiXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuKTtcblxuICBmdW5jdGlvbiBjb21wYXJlKGxocywgcmhzLCBzYW1lLCBpZGVudGljYWwpIHtcbiAgICB2YXIgYm90aCA9ICFpZGVudGljYWwgJiYgaXNJdGVyYWJsZShsaHMpICYmIGlzSXRlcmFibGUocmhzKTtcblxuICAgIGlmIChib3RoKSByZXR1cm4gbGhzLmVxdWFscyhyaHMpO1xuXG4gICAgcmV0dXJuIGxocyA9PT0gcmhzO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVzc2FnZShsaHMsIHJocywgc2FtZSwgaWRlbnRpY2FsKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNvbXBhcmUobGhzLCByaHMsIHNhbWUsIGlkZW50aWNhbCk7XG4gICAgdmFyIGNvbXBhcmlzb24gPSByZXN1bHRcbiAgICAgID8gaWRlbnRpY2FsXG4gICAgICAgID8gJ3N0cmljdCBlcXVhbCB0bydcbiAgICAgICAgOiAnZG9lcyBlcXVhbCdcbiAgICAgIDogaWRlbnRpY2FsXG4gICAgICA/ICdub3Qgc3RyaWN0IGVxdWFsIHRvJ1xuICAgICAgOiAnZG9lcyBub3QgZXF1YWwnO1xuICAgIHZhciBjbGFzc05hbWUgPSByZXN1bHQgPT09IHNhbWUgPyAnc3VjY2VzcycgOiAnZmFpbHVyZSc7XG4gICAgdmFyIGxoc1N0cmluZyA9IGlzSXRlcmFibGUobGhzKSA/IGxocyArICcnIDogSlNPTi5zdHJpbmdpZnkobGhzKTtcbiAgICB2YXIgcmhzU3RyaW5nID0gaXNJdGVyYWJsZShyaHMpID8gcmhzICsgJycgOiBKU09OLnN0cmluZ2lmeShyaHMpO1xuXG4gICAgcmV0dXJuIChodG1sICs9IChcIlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJcIiArIFxuY2xhc3NOYW1lICsgXCJcXFwiPlxcbiAgICAgICAgPGNvZGU+XCIgKyBcbmxoc1N0cmluZyArIFwiPC9jb2RlPlxcbiAgICAgICAgXCIgKyBcbmNvbXBhcmlzb24gKyBcIlxcbiAgICAgICAgPGNvZGU+XCIgKyBcbnJoc1N0cmluZyArIFwiPC9jb2RlPlxcbiAgICAgIDwvc3Bhbj48YnIvPlwiXG4pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVxdWFsKGxocywgcmhzKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UobGhzLCByaHMsIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gbm90RXF1YWwobGhzLCByaHMpIHtcbiAgICByZXR1cm4gbWVzc2FnZShsaHMsIHJocywgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RyaWN0RXF1YWwobGhzLCByaHMpIHtcbiAgICByZXR1cm4gbWVzc2FnZShsaHMsIHJocywgdHJ1ZSwgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChsaHMsIHJocykge1xuICAgIHJldHVybiBtZXNzYWdlKGxocywgcmhzLCBmYWxzZSwgdHJ1ZSk7XG4gIH1cblxuICByZXR1cm4geyBlcXVhbDplcXVhbCwgbm90RXF1YWw6bm90RXF1YWwsIHN0cmljdEVxdWFsOnN0cmljdEVxdWFsLCBub3RTdHJpY3RFcXVhbDpub3RTdHJpY3RFcXVhbCB9O1xufVxuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBDU1NDb3JlID0gcmVxdWlyZSgncmVhY3QvbGliL0NTU0NvcmUnKTtcbnZhciBSb3V0ZXIgPSByZXF1aXJlKCdyZWFjdC1yb3V0ZXInKTtcbnZhciAkX18wPSAgICByZXF1aXJlKCcuLi8uLi8uLi8uLi8nKSxTZXE9JF9fMC5TZXE7XG52YXIgVHlwZUtpbmQgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvVHlwZUtpbmQnKTtcbnZhciBkZWZzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL2dldFR5cGVEZWZzJyk7XG5cbnZhciBJbnRlcmZhY2VEZWYgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiSW50ZXJmYWNlRGVmXCIsXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcbiAgICB2YXIgZGVmID0gdGhpcy5wcm9wcy5kZWY7XG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCBpbnRlcmZhY2VEZWZcIn0sIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7Y2xhc3NOYW1lOiBcInQga2V5d29yZFwifSwgXCJ0eXBlIFwiKSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCB0eXBlTmFtZVwifSwgbmFtZSksIFxuICAgICAgICBkZWYudHlwZVBhcmFtcyAmJiBbXG4gICAgICAgICAgJzwnLFxuICAgICAgICAgIFNlcShkZWYudHlwZVBhcmFtcylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24odCwgaykgIFxuICAgICAgICAgICAgICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCB0eXBlUGFyYW1cIiwga2V5OiBrfSwgXG4gICAgICAgICAgICAgICAgdFxuICAgICAgICAgICAgICApO31cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5pbnRlcnBvc2UoJywgJylcbiAgICAgICAgICAgIC50b0FycmF5KCksXG4gICAgICAgICAgJz4nLFxuICAgICAgICBdLCBcbiAgICAgICAgZGVmLmV4dGVuZHMgJiYgW1xuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCBrZXl3b3JkXCJ9LCBcIiBleHRlbmRzIFwiKSxcbiAgICAgICAgICBTZXEoZGVmLmV4dGVuZHMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGUsIGkpICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVHlwZURlZiwge2tleTogaSwgdHlwZTogZX0pO30pXG4gICAgICAgICAgICAuaW50ZXJwb3NlKCcsICcpXG4gICAgICAgICAgICAudG9BcnJheSgpLFxuICAgICAgICBdLCBcbiAgICAgICAgZGVmLmltcGxlbWVudHMgJiYgW1xuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCBrZXl3b3JkXCJ9LCBcIiBpbXBsZW1lbnRzIFwiKSxcbiAgICAgICAgICBTZXEoZGVmLmltcGxlbWVudHMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGUsIGkpICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVHlwZURlZiwge2tleTogaSwgdHlwZTogZX0pO30pXG4gICAgICAgICAgICAuaW50ZXJwb3NlKCcsICcpXG4gICAgICAgICAgICAudG9BcnJheSgpLFxuICAgICAgICBdXG4gICAgICApXG4gICAgKTtcbiAgfSxcbn0pO1xuXG5leHBvcnRzLkludGVyZmFjZURlZiA9IEludGVyZmFjZURlZjtcblxudmFyIENhbGxTaWdEZWYgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiQ2FsbFNpZ0RlZlwiLFxuICByZW5kZXI6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluZm8gPSB0aGlzLnByb3BzLmluZm87XG4gICAgdmFyIG1vZHVsZSA9IHRoaXMucHJvcHMubW9kdWxlO1xuICAgIHZhciBuYW1lID0gdGhpcy5wcm9wcy5uYW1lO1xuICAgIHZhciBjYWxsU2lnID0gdGhpcy5wcm9wcy5jYWxsU2lnIHx8IHt9O1xuXG4gICAgdmFyIHNob3VsZFdyYXAgPSBjYWxsU2lnTGVuZ3RoKGluZm8sIG1vZHVsZSwgbmFtZSwgY2FsbFNpZykgPiA4MDtcblxuICAgIHJldHVybiAoXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7Y2xhc3NOYW1lOiBcInQgY2FsbFNpZ1wifSwgXG4gICAgICAgIG1vZHVsZSAmJiBbUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogXCJ0IGZuUXVhbGlmaWVyXCJ9LCBtb2R1bGUpLCAnLiddLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogXCJ0IGZuTmFtZVwifSwgbmFtZSksIFxuICAgICAgICBjYWxsU2lnLnR5cGVQYXJhbXMgJiYgW1xuICAgICAgICAgICc8JyxcbiAgICAgICAgICBTZXEoY2FsbFNpZy50eXBlUGFyYW1zKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbih0KSAge3JldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7Y2xhc3NOYW1lOiBcInQgdHlwZVBhcmFtXCJ9LCB0KTt9KVxuICAgICAgICAgICAgLmludGVycG9zZSgnLCAnKVxuICAgICAgICAgICAgLnRvQXJyYXkoKSxcbiAgICAgICAgICAnPicsXG4gICAgICAgIF0sIFxuICAgICAgICAnKCcsIFxuICAgICAgICBjYWxsU2lnICYmIGZ1bmN0aW9uUGFyYW1zKGluZm8sIGNhbGxTaWcucGFyYW1zLCBzaG91bGRXcmFwKSwgXG4gICAgICAgICcpJywgXG4gICAgICAgIGNhbGxTaWcudHlwZSAmJiBbJzogJywgUmVhY3QuY3JlYXRlRWxlbWVudChUeXBlRGVmLCB7aW5mbzogaW5mbywgdHlwZTogY2FsbFNpZy50eXBlfSldXG4gICAgICApXG4gICAgKTtcbiAgfSxcbn0pO1xuXG5leHBvcnRzLkNhbGxTaWdEZWYgPSBDYWxsU2lnRGVmO1xuXG52YXIgVHlwZURlZiA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJUeXBlRGVmXCIsXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5mbyA9IHRoaXMucHJvcHMuaW5mbztcbiAgICB2YXIgdHlwZSA9IHRoaXMucHJvcHMudHlwZTtcbiAgICB2YXIgcHJlZml4ID0gdGhpcy5wcm9wcy5wcmVmaXg7XG4gICAgc3dpdGNoICh0eXBlLmspIHtcbiAgICAgIGNhc2UgVHlwZUtpbmQuTmV2ZXI6XG4gICAgICAgIHJldHVybiB0aGlzLndyYXAoJ3ByaW1pdGl2ZScsICduZXZlcicpO1xuICAgICAgY2FzZSBUeXBlS2luZC5Bbnk6XG4gICAgICAgIHJldHVybiB0aGlzLndyYXAoJ3ByaW1pdGl2ZScsICdhbnknKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuVW5rbm93bjpcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCgncHJpbWl0aXZlJywgJ3Vua25vd24nKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuVGhpczpcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCgncHJpbWl0aXZlJywgJ3RoaXMnKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuVW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdGhpcy53cmFwKCdwcmltaXRpdmUnLCAndW5kZWZpbmVkJyk7XG4gICAgICBjYXNlIFR5cGVLaW5kLkJvb2xlYW46XG4gICAgICAgIHJldHVybiB0aGlzLndyYXAoJ3ByaW1pdGl2ZScsICdib29sZWFuJyk7XG4gICAgICBjYXNlIFR5cGVLaW5kLk51bWJlcjpcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCgncHJpbWl0aXZlJywgJ251bWJlcicpO1xuICAgICAgY2FzZSBUeXBlS2luZC5TdHJpbmc6XG4gICAgICAgIHJldHVybiB0aGlzLndyYXAoJ3ByaW1pdGl2ZScsICdzdHJpbmcnKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuVW5pb246XG4gICAgICAgIHJldHVybiB0aGlzLndyYXAoJ3VuaW9uJywgW1xuICAgICAgICAgIFNlcSh0eXBlLnR5cGVzKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbih0KSAge3JldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEZWYsIHtpbmZvOiBpbmZvLCB0eXBlOiB0fSk7fSlcbiAgICAgICAgICAgIC5pbnRlcnBvc2UoJyB8ICcpXG4gICAgICAgICAgICAudG9BcnJheSgpLFxuICAgICAgICBdKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuSW50ZXJzZWN0aW9uOlxuICAgICAgICByZXR1cm4gdGhpcy53cmFwKCdpbnRlcnNlY3Rpb24nLCBbXG4gICAgICAgICAgU2VxKHR5cGUudHlwZXMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHQpICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVHlwZURlZiwge2luZm86IGluZm8sIHR5cGU6IHR9KTt9KVxuICAgICAgICAgICAgLmludGVycG9zZSgnICYgJylcbiAgICAgICAgICAgIC50b0FycmF5KCksXG4gICAgICAgIF0pO1xuICAgICAgY2FzZSBUeXBlS2luZC5UdXBsZTpcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCgndHVwbGUnLCBbXG4gICAgICAgICAgJ1snLFxuICAgICAgICAgIFNlcSh0eXBlLnR5cGVzKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbih0KSAge3JldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEZWYsIHtpbmZvOiBpbmZvLCB0eXBlOiB0fSk7fSlcbiAgICAgICAgICAgIC5pbnRlcnBvc2UoJywgJylcbiAgICAgICAgICAgIC50b0FycmF5KCksXG4gICAgICAgICAgJ10nLFxuICAgICAgICBdKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuT2JqZWN0OlxuICAgICAgICByZXR1cm4gdGhpcy53cmFwKCdvYmplY3QnLCBbXG4gICAgICAgICAgJ3snLFxuICAgICAgICAgIFNlcSh0eXBlLm1lbWJlcnMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHQpICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtYmVyRGVmLCB7bWVtYmVyOiB0fSk7fSlcbiAgICAgICAgICAgIC5pbnRlcnBvc2UoJywgJylcbiAgICAgICAgICAgIC50b0FycmF5KCksXG4gICAgICAgICAgJ30nLFxuICAgICAgICBdKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuSW5kZXhlZDpcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCgnaW5kZXhlZCcsIFtcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEZWYsIHtpbmZvOiBpbmZvLCB0eXBlOiB0eXBlLnR5cGV9KSxcbiAgICAgICAgICAnWycsXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChUeXBlRGVmLCB7aW5mbzogaW5mbywgdHlwZTogdHlwZS5pbmRleH0pLFxuICAgICAgICAgICddJyxcbiAgICAgICAgXSk7XG4gICAgICBjYXNlIFR5cGVLaW5kLk9wZXJhdG9yOlxuICAgICAgICByZXR1cm4gdGhpcy53cmFwKCdvcGVyYXRvcicsIFtcbiAgICAgICAgICB0aGlzLndyYXAoJ3ByaW1pdGl2ZScsIHR5cGUub3BlcmF0b3IpLFxuICAgICAgICAgICcgJyxcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEZWYsIHtpbmZvOiBpbmZvLCB0eXBlOiB0eXBlLnR5cGV9KSxcbiAgICAgICAgXSk7XG4gICAgICBjYXNlIFR5cGVLaW5kLkFycmF5OlxuICAgICAgICByZXR1cm4gdGhpcy53cmFwKCdhcnJheScsIFtcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEZWYsIHtpbmZvOiBpbmZvLCB0eXBlOiB0eXBlLnR5cGV9KSxcbiAgICAgICAgICAnW10nLFxuICAgICAgICBdKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuRnVuY3Rpb246XG4gICAgICAgIHZhciBzaG91bGRXcmFwID0gKHByZWZpeCB8fCAwKSArIGZ1bmNMZW5ndGgoaW5mbywgdHlwZSkgPiA3ODtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCgnZnVuY3Rpb24nLCBbXG4gICAgICAgICAgdHlwZS50eXBlUGFyYW1zICYmIFtcbiAgICAgICAgICAgICc8JyxcbiAgICAgICAgICAgIFNlcSh0eXBlLnR5cGVQYXJhbXMpXG4gICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24odCwgaykgIFxuICAgICAgICAgICAgICAgIHtyZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogXCJ0IHR5cGVQYXJhbVwiLCBrZXk6IGt9LCBcbiAgICAgICAgICAgICAgICAgIHRcbiAgICAgICAgICAgICAgICApO31cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAuaW50ZXJwb3NlKCcsICcpXG4gICAgICAgICAgICAgIC50b0FycmF5KCksXG4gICAgICAgICAgICAnPicsXG4gICAgICAgICAgXSxcbiAgICAgICAgICAnKCcsXG4gICAgICAgICAgZnVuY3Rpb25QYXJhbXMoaW5mbywgdHlwZS5wYXJhbXMsIHNob3VsZFdyYXApLFxuICAgICAgICAgICcpID0+ICcsXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChUeXBlRGVmLCB7aW5mbzogaW5mbywgdHlwZTogdHlwZS50eXBlfSksXG4gICAgICAgIF0pO1xuICAgICAgY2FzZSBUeXBlS2luZC5QYXJhbTpcbiAgICAgICAgcmV0dXJuIGluZm8gJiYgaW5mby5wcm9wTWFwW2luZm8uZGVmaW5pbmcgKyAnPCcgKyB0eXBlLnBhcmFtXSA/IChcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEZWYsIHt0eXBlOiBpbmZvLnByb3BNYXBbaW5mby5kZWZpbmluZyArICc8JyArIHR5cGUucGFyYW1dfSlcbiAgICAgICAgKSA6IChcbiAgICAgICAgICB0aGlzLndyYXAoJ3R5cGVQYXJhbScsIHR5cGUucGFyYW0pXG4gICAgICAgICk7XG4gICAgICBjYXNlIFR5cGVLaW5kLlR5cGU6XG4gICAgICAgIHZhciBxdWFsaWZpZWRUeXBlID0gKHR5cGUucXVhbGlmaWVyIHx8IFtdKS5jb25jYXQoW3R5cGUubmFtZV0pO1xuICAgICAgICB2YXIgcXVhbGlmaWVkVHlwZU5hbWUgPSBxdWFsaWZpZWRUeXBlLmpvaW4oJy4nKTtcbiAgICAgICAgdmFyIGRlZiA9IHF1YWxpZmllZFR5cGVOYW1lXG4gICAgICAgICAgLnNwbGl0KCcuJylcbiAgICAgICAgICAucmVkdWNlKFxuICAgICAgICAgICAgZnVuY3Rpb24oZGVmLCBuYW1lKSAge3JldHVybiBkZWYgJiYgZGVmLm1vZHVsZSAmJiBkZWYubW9kdWxlW25hbWVdO30sXG4gICAgICAgICAgICBkZWZzLkltbXV0YWJsZVxuICAgICAgICAgICk7XG4gICAgICAgIHZhciB0eXBlTmFtZUVsZW1lbnQgPSBbXG4gICAgICAgICAgdHlwZS5xdWFsaWZpZXIgJiYgW1xuICAgICAgICAgICAgU2VxKHR5cGUucXVhbGlmaWVyKVxuICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHEpICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCB0eXBlUXVhbGlmaWVyXCJ9LCBxKTt9KVxuICAgICAgICAgICAgICAuaW50ZXJwb3NlKCcuJylcbiAgICAgICAgICAgICAgLnRvQXJyYXkoKSxcbiAgICAgICAgICAgICcuJyxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCB0eXBlTmFtZVwifSwgdHlwZS5uYW1lKSxcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKGRlZikge1xuICAgICAgICAgIHR5cGVOYW1lRWxlbWVudCA9IChcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLkxpbmssIHt0bzogJy8nICsgcXVhbGlmaWVkVHlwZU5hbWV9LCBcbiAgICAgICAgICAgICAgdHlwZU5hbWVFbGVtZW50XG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53cmFwKCd0eXBlJywgW1xuICAgICAgICAgIHR5cGVOYW1lRWxlbWVudCxcbiAgICAgICAgICB0eXBlLmFyZ3MgJiYgW1xuICAgICAgICAgICAgJzwnLFxuICAgICAgICAgICAgU2VxKHR5cGUuYXJncylcbiAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihhKSAge3JldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEZWYsIHtpbmZvOiBpbmZvLCB0eXBlOiBhfSk7fSlcbiAgICAgICAgICAgICAgLmludGVycG9zZSgnLCAnKVxuICAgICAgICAgICAgICAudG9BcnJheSgpLFxuICAgICAgICAgICAgJz4nLFxuICAgICAgICAgIF0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24ga2luZCAnICsgdHlwZS5rKTtcbiAgfSxcblxuICBtb3VzZU92ZXI6ZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBDU1NDb3JlLmFkZENsYXNzKHRoaXMuZ2V0RE9NTm9kZSgpLCAnb3ZlcicpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9LFxuXG4gIG1vdXNlT3V0OmZ1bmN0aW9uKCkge1xuICAgIENTU0NvcmUucmVtb3ZlQ2xhc3ModGhpcy5nZXRET01Ob2RlKCksICdvdmVyJyk7XG4gIH0sXG5cbiAgd3JhcDpmdW5jdGlvbihjbGFzc05hbWUsIGNoaWxkKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndCAnICsgY2xhc3NOYW1lLCBcbiAgICAgICAgb25Nb3VzZU92ZXI6IHRoaXMubW91c2VPdmVyLCBcbiAgICAgICAgb25Gb2N1czogdGhpcy5tb3VzZU92ZXIsIFxuICAgICAgICBvbk1vdXNlT3V0OiB0aGlzLm1vdXNlT3V0LCBcbiAgICAgICAgb25CbHVyOiB0aGlzLm1vdXNlT3V0XG4gICAgICB9LCBcbiAgICAgICAgY2hpbGRcbiAgICAgIClcbiAgICApO1xuICB9LFxufSk7XG5cbmV4cG9ydHMuVHlwZURlZiA9IFR5cGVEZWY7XG5cbnZhciBNZW1iZXJEZWYgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiTWVtYmVyRGVmXCIsXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICB2YXIgbW9kdWxlID0gdGhpcy5wcm9wcy5tb2R1bGU7XG4gICAgdmFyIG1lbWJlciA9IHRoaXMucHJvcHMubWVtYmVyO1xuICAgIHJldHVybiAoXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7Y2xhc3NOYW1lOiBcInQgbWVtYmVyXCJ9LCBcbiAgICAgICAgbW9kdWxlICYmIFtSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7Y2xhc3NOYW1lOiBcInQgZm5RdWFsaWZpZXJcIn0sIG1vZHVsZSksICcuJ10sIFxuICAgICAgICBtZW1iZXIuaW5kZXggPyAoXG4gICAgICAgICAgWydbJywgZnVuY3Rpb25QYXJhbXMobnVsbCwgbWVtYmVyLnBhcmFtcyksICddJ11cbiAgICAgICAgKSA6IChcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7Y2xhc3NOYW1lOiBcInQgbWVtYmVyTmFtZVwifSwgbWVtYmVyLm5hbWUpXG4gICAgICAgICksIFxuICAgICAgICBtZW1iZXIudHlwZSAmJiBbJzogJywgUmVhY3QuY3JlYXRlRWxlbWVudChUeXBlRGVmLCB7dHlwZTogbWVtYmVyLnR5cGV9KV1cbiAgICAgIClcbiAgICApO1xuICB9LFxufSk7XG5cbmV4cG9ydHMuTWVtYmVyRGVmID0gTWVtYmVyRGVmO1xuXG5mdW5jdGlvbiBmdW5jdGlvblBhcmFtcyhpbmZvLCBwYXJhbXMsIHNob3VsZFdyYXApIHtcbiAgdmFyIGVsZW1lbnRzID0gU2VxKHBhcmFtcylcbiAgICAubWFwKGZ1bmN0aW9uKHQpICB7cmV0dXJuIFtcbiAgICAgIHQudmFyQXJncyA/ICcuLi4nIDogbnVsbCxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCBwYXJhbVwifSwgdC5uYW1lKSxcbiAgICAgIHQub3B0aW9uYWwgPyAnPzogJyA6ICc6ICcsXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEZWYsIHtcbiAgICAgICAgcHJlZml4OiB0Lm5hbWUubGVuZ3RoICsgKHQudmFyQXJncyA/IDMgOiAwKSArICh0Lm9wdGlvbmFsID8gMyA6IDIpLCBcbiAgICAgICAgaW5mbzogaW5mbywgXG4gICAgICAgIHR5cGU6IHQudHlwZX1cbiAgICAgICksXG4gICAgXTt9KVxuICAgIC5pbnRlcnBvc2Uoc2hvdWxkV3JhcCA/IFsnLCcsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJiclwiLCBudWxsKV0gOiAnLCAnKVxuICAgIC50b0FycmF5KCk7XG4gIHJldHVybiBzaG91bGRXcmFwID8gKFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2NsYXNzTmFtZTogXCJ0IGJsb2NrUGFyYW1zXCJ9LCBlbGVtZW50cylcbiAgKSA6IChcbiAgICBlbGVtZW50c1xuICApO1xufVxuXG5mdW5jdGlvbiBjYWxsU2lnTGVuZ3RoKGluZm8sIG1vZHVsZSwgbmFtZSwgc2lnKSB7XG4gIHJldHVybiAobW9kdWxlID8gbW9kdWxlLmxlbmd0aCArIDEgOiAwKSArIG5hbWUubGVuZ3RoICsgZnVuY0xlbmd0aChpbmZvLCBzaWcpO1xufVxuXG5mdW5jdGlvbiBmdW5jTGVuZ3RoKGluZm8sIHNpZykge1xuICByZXR1cm4gKFxuICAgIChzaWcudHlwZVBhcmFtcyA/IDIgKyBzaWcudHlwZVBhcmFtcy5qb2luKCcsICcpLmxlbmd0aCA6IDApICtcbiAgICAyICtcbiAgICAoc2lnLnBhcmFtcyA/IHBhcmFtTGVuZ3RoKGluZm8sIHNpZy5wYXJhbXMpIDogMCkgK1xuICAgIChzaWcudHlwZSA/IDIgKyB0eXBlTGVuZ3RoKGluZm8sIHNpZy50eXBlKSA6IDApXG4gICk7XG59XG5cbmZ1bmN0aW9uIHBhcmFtTGVuZ3RoKGluZm8sIHBhcmFtcykge1xuICByZXR1cm4gcGFyYW1zLnJlZHVjZShcbiAgICBmdW5jdGlvbihzLCBwKSBcbiAgICAgIHtyZXR1cm4gcyArXG4gICAgICAocC52YXJBcmdzID8gMyA6IDApICtcbiAgICAgIHAubmFtZS5sZW5ndGggK1xuICAgICAgKHAub3B0aW9uYWwgPyAzIDogMikgK1xuICAgICAgdHlwZUxlbmd0aChpbmZvLCBwLnR5cGUpO30sXG4gICAgKHBhcmFtcy5sZW5ndGggLSAxKSAqIDJcbiAgKTtcbn1cblxuZnVuY3Rpb24gbWVtYmVyTGVuZ3RoKGluZm8sIG1lbWJlcnMpIHtcbiAgcmV0dXJuIG1lbWJlcnMucmVkdWNlKFxuICAgIGZ1bmN0aW9uKHMsIG0pIFxuICAgICAge3JldHVybiBzICtcbiAgICAgIChtLmluZGV4ID8gcGFyYW1MZW5ndGgoaW5mbywgbS5wYXJhbXMpICsgNCA6IG0ubmFtZSArIDIpICtcbiAgICAgIHR5cGVMZW5ndGgoaW5mbywgbS50eXBlKTt9LFxuICAgIChtZW1iZXJzLmxlbmd0aCAtIDEpICogMlxuICApO1xufVxuXG5mdW5jdGlvbiB0eXBlTGVuZ3RoKGluZm8sIHR5cGUpIHtcbiAgaWYgKCF0eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0eXBlJyk7XG4gIH1cbiAgc3dpdGNoICh0eXBlLmspIHtcbiAgICBjYXNlIFR5cGVLaW5kLk5ldmVyOlxuICAgICAgcmV0dXJuIDU7XG4gICAgY2FzZSBUeXBlS2luZC5Bbnk6XG4gICAgICByZXR1cm4gMztcbiAgICBjYXNlIFR5cGVLaW5kLlVua25vd246XG4gICAgICByZXR1cm4gNztcbiAgICBjYXNlIFR5cGVLaW5kLlRoaXM6XG4gICAgICByZXR1cm4gNDtcbiAgICBjYXNlIFR5cGVLaW5kLlVuZGVmaW5lZDpcbiAgICAgIHJldHVybiA5O1xuICAgIGNhc2UgVHlwZUtpbmQuQm9vbGVhbjpcbiAgICAgIHJldHVybiA3O1xuICAgIGNhc2UgVHlwZUtpbmQuTnVtYmVyOlxuICAgICAgcmV0dXJuIDY7XG4gICAgY2FzZSBUeXBlS2luZC5TdHJpbmc6XG4gICAgICByZXR1cm4gNjtcbiAgICBjYXNlIFR5cGVLaW5kLlVuaW9uOlxuICAgIGNhc2UgVHlwZUtpbmQuSW50ZXJzZWN0aW9uOlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgdHlwZS50eXBlcy5yZWR1Y2UoZnVuY3Rpb24ocywgdCkgIHtyZXR1cm4gcyArIHR5cGVMZW5ndGgoaW5mbywgdCk7fSwgMCkgK1xuICAgICAgICAodHlwZS50eXBlcy5sZW5ndGggLSAxKSAqIDNcbiAgICAgICk7XG4gICAgY2FzZSBUeXBlS2luZC5UdXBsZTpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDIgK1xuICAgICAgICB0eXBlLnR5cGVzLnJlZHVjZShmdW5jdGlvbihzLCB0KSAge3JldHVybiBzICsgdHlwZUxlbmd0aChpbmZvLCB0KTt9LCAwKSArXG4gICAgICAgICh0eXBlLnR5cGVzLmxlbmd0aCAtIDEpICogMlxuICAgICAgKTtcbiAgICBjYXNlIFR5cGVLaW5kLk9iamVjdDpcbiAgICAgIHJldHVybiAyICsgbWVtYmVyTGVuZ3RoKGluZm8sIHR5cGUubWVtYmVycyk7XG4gICAgY2FzZSBUeXBlS2luZC5JbmRleGVkOlxuICAgICAgcmV0dXJuIDIgKyB0eXBlTGVuZ3RoKGluZm8sIHR5cGUudHlwZSkgKyB0eXBlTGVuZ3RoKGluZm8sIHR5cGUuaW5kZXgpO1xuICAgIGNhc2UgVHlwZUtpbmQuT3BlcmF0b3I6XG4gICAgICByZXR1cm4gMSArIHR5cGUub3BlcmF0b3IubGVuZ3RoICsgdHlwZUxlbmd0aChpbmZvLCB0eXBlLnR5cGUpO1xuICAgIGNhc2UgVHlwZUtpbmQuQXJyYXk6XG4gICAgICByZXR1cm4gdHlwZUxlbmd0aChpbmZvLCB0eXBlLnR5cGUpICsgMjtcbiAgICBjYXNlIFR5cGVLaW5kLkZ1bmN0aW9uOlxuICAgICAgcmV0dXJuIDIgKyBmdW5jTGVuZ3RoKGluZm8sIHR5cGUpO1xuICAgIGNhc2UgVHlwZUtpbmQuUGFyYW06XG4gICAgICByZXR1cm4gaW5mbyAmJiBpbmZvLnByb3BNYXBbaW5mby5kZWZpbmluZyArICc8JyArIHR5cGUucGFyYW1dXG4gICAgICAgID8gdHlwZUxlbmd0aChudWxsLCBpbmZvLnByb3BNYXBbaW5mby5kZWZpbmluZyArICc8JyArIHR5cGUucGFyYW1dKVxuICAgICAgICA6IHR5cGUucGFyYW0ubGVuZ3RoO1xuICAgIGNhc2UgVHlwZUtpbmQuVHlwZTpcbiAgICAgIHJldHVybiAoXG4gICAgICAgICh0eXBlLnF1YWxpZmllciA/IDEgKyB0eXBlLnF1YWxpZmllci5qb2luKCcuJykubGVuZ3RoIDogMCkgK1xuICAgICAgICB0eXBlLm5hbWUubGVuZ3RoICtcbiAgICAgICAgKCF0eXBlLmFyZ3NcbiAgICAgICAgICA/IDBcbiAgICAgICAgICA6IHR5cGUuYXJncy5yZWR1Y2UoXG4gICAgICAgICAgICAgIGZ1bmN0aW9uKHMsIGEpICB7cmV0dXJuIHMgKyB0eXBlTGVuZ3RoKGluZm8sIGEpO30sXG4gICAgICAgICAgICAgIHR5cGUuYXJncy5sZW5ndGggKiAyXG4gICAgICAgICAgICApKVxuICAgICAgKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ1R5cGUgd2l0aCB1bmtub3duIGtpbmQgJyArIEpTT04uc3RyaW5naWZ5KHR5cGUpKTtcbn1cbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgU1ZHU2V0ID0gcmVxdWlyZSgnLi4vLi4vc3JjL1NWR1NldCcpO1xudmFyIExvZ28gPSByZXF1aXJlKCcuLi8uLi9zcmMvTG9nbycpO1xudmFyIHBhY2thZ2VKc29uID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vcGFja2FnZS5qc29uJyk7XG5cbnZhciBEb2NIZWFkZXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiRG9jSGVhZGVyXCIsXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7Y2xhc3NOYW1lOiBcImhlYWRlclwifSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2NsYXNzTmFtZTogXCJtaW5pSGVhZGVyXCJ9LCBcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtjbGFzc05hbWU6IFwibWluaUhlYWRlckNvbnRlbnRzXCJ9LCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHtocmVmOiBcIi4uL1wiLCB0YXJnZXQ6IFwiX3NlbGZcIiwgY2xhc3NOYW1lOiBcIm1pbmlMb2dvXCJ9LCBcbiAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChTVkdTZXQsIG51bGwsIFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTG9nbywge2NvbG9yOiBcIiNGQzQzNDlcIn0pLCBcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KExvZ28sIHtjb2xvcjogXCIjMkMzRTUwXCIsIGlubGluZTogdHJ1ZX0pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwge2hyZWY6IFwiLi9cIiwgdGFyZ2V0OiBcIl9zZWxmXCJ9LCBcbiAgICAgICAgICAgICAgXCJEb2NzICh2XCIsIFxuICAgICAgICAgICAgICBwYWNrYWdlSnNvbi52ZXJzaW9uLCBcIilcIlxuICAgICAgICAgICAgKSwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7aHJlZjogXCJodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy90YWdnZWQvaW1tdXRhYmxlLmpzP3NvcnQ9dm90ZXNcIn0sIFxuICAgICAgICAgICAgICBcIlF1ZXN0aW9uc1wiXG4gICAgICAgICAgICApLCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHtocmVmOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9pbW11dGFibGUtanMvaW1tdXRhYmxlLWpzL1wifSwgXCJHaXRodWJcIilcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRG9jSGVhZGVyO1xuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSb3V0ZXIgPSByZXF1aXJlKCdyZWFjdC1yb3V0ZXInKTtcbnZhciAkX18wPSAgICByZXF1aXJlKCcuLi8uLi8uLi8uLi8nKSxTZXE9JF9fMC5TZXE7XG52YXIgTWFya2Rvd24gPSByZXF1aXJlKCcuL01hcmtEb3duJyk7XG5cbnZhciBEb2NPdmVydmlldyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJEb2NPdmVydmlld1wiLFxuICByZW5kZXI6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlZiA9IHRoaXMucHJvcHMuZGVmO1xuICAgIHZhciBkb2MgPSBkZWYuZG9jO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgXG4gICAgICAgIGRvYyAmJiAoXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwgbnVsbCwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1hcmtkb3duLCB7Y29udGVudHM6IGRvYy5zeW5vcHNpc30pLCBcbiAgICAgICAgICAgIGRvYy5kZXNjcmlwdGlvbiAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KE1hcmtkb3duLCB7Y29udGVudHM6IGRvYy5kZXNjcmlwdGlvbn0pXG4gICAgICAgICAgKVxuICAgICAgICApLCBcblxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDRcIiwge2NsYXNzTmFtZTogXCJncm91cFRpdGxlXCJ9LCBcIkFQSVwiKSwgXG5cbiAgICAgICAgU2VxKGRlZi5tb2R1bGUpXG4gICAgICAgICAgLm1hcChmdW5jdGlvbih0LCBuYW1lKSAge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSAhdC5pbnRlcmZhY2UgJiYgIXQubW9kdWxlO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgdCA9IHQuY2FsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIsIHtrZXk6IG5hbWUsIGNsYXNzTmFtZTogXCJpbnRlcmZhY2VNZW1iZXJcIn0sIFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoM1wiLCB7Y2xhc3NOYW1lOiBcIm1lbWJlckxhYmVsXCJ9LCBcbiAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLkxpbmssIHt0bzogJy8nICsgbmFtZX0sIFxuICAgICAgICAgICAgICAgICAgICBuYW1lICsgKGlzRnVuY3Rpb24gPyAnKCknIDogJycpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSwgXG4gICAgICAgICAgICAgICAgdC5kb2MgJiYgKFxuICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChNYXJrZG93biwge2NsYXNzTmFtZTogXCJkZXRhaWxcIiwgY29udGVudHM6IHQuZG9jLnN5bm9wc2lzfSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAudmFsdWVTZXEoKVxuICAgICAgICAgIC50b0FycmF5KClcbiAgICAgIClcbiAgICApO1xuICB9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRG9jT3ZlcnZpZXc7XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgRG9jU2VhcmNoID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiBcIkRvY1NlYXJjaFwiLFxuICBnZXRJbml0aWFsU3RhdGU6ZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHsgZW5hYmxlZDogdHJ1ZSB9O1xuICB9LFxuICBjb21wb25lbnREaWRNb3VudDpmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgdmFyIGZpcnN0U2NyaXB0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuICAgIHNjcmlwdC5zcmMgPVxuICAgICAgJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vZG9jc2VhcmNoLmpzQDIuNS4yL2Rpc3QvY2RuL2RvY3NlYXJjaC5taW4uanMnO1xuICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgJ2xvYWQnLFxuICAgICAgZnVuY3Rpb24oKSAge1xuICAgICAgICAvLyBJbml0aWFsaXplIEFsZ29saWEgc2VhcmNoLlxuICAgICAgICBpZiAod2luZG93LmRvY3NlYXJjaCkge1xuICAgICAgICAgIHdpbmRvdy5kb2NzZWFyY2goe1xuICAgICAgICAgICAgYXBpS2V5OiAnODNmNjFmODY1ZWY0Y2I2ODJlMDQzMjQxMGMyZjc4MDknLFxuICAgICAgICAgICAgaW5kZXhOYW1lOiAnaW1tdXRhYmxlX2pzJyxcbiAgICAgICAgICAgIGlucHV0U2VsZWN0b3I6ICcjYWxnb2xpYS1kb2NzZWFyY2gnLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBlbmFibGVkOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIGZpcnN0U2NyaXB0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgZmlyc3RTY3JpcHQpO1xuXG4gICAgdmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgdmFyIGZpcnN0TGluayA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdsaW5rJylbMF07XG4gICAgbGluay5yZWwgPSAnc3R5bGVzaGVldCc7XG4gICAgbGluay5ocmVmID1cbiAgICAgICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2RvY3NlYXJjaC5qc0AyLjUuMi9kaXN0L2Nkbi9kb2NzZWFyY2gubWluLmNzcyc7XG4gICAgZmlyc3RMaW5rLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGxpbmssIGZpcnN0TGluayk7XG4gIH0sXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5lbmFibGVkID8gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImlucHV0XCIsIHtcbiAgICAgICAgaWQ6IFwiYWxnb2xpYS1kb2NzZWFyY2hcIiwgXG4gICAgICAgIGNsYXNzTmFtZTogXCJkb2NTZWFyY2hcIiwgXG4gICAgICAgIHR5cGU6IFwic2VhcmNoXCIsIFxuICAgICAgICBwbGFjZWhvbGRlcjogXCJTZWFyY2ggSW1tdXRhYmxlLmpzIERvY3VtZW50YXRpb25cIn1cbiAgICAgIClcbiAgICApIDogbnVsbDtcbiAgfSxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERvY1NlYXJjaDtcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBNYXJrRG93biA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJNYXJrRG93blwiLFxuICBzaG91bGRDb21wb25lbnRVcGRhdGU6ZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICB2YXIgaHRtbCA9IHRoaXMucHJvcHMuY29udGVudHM7XG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IHRoaXMucHJvcHMuY2xhc3NOYW1lLCBcbiAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHsgX19odG1sOiBodG1sfX1cbiAgICAgIClcbiAgICApO1xuICB9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFya0Rvd247XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0VHJhbnNpdGlvbkV2ZW50cyA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdFRyYW5zaXRpb25FdmVudHMnKTtcbnZhciBSb3V0ZXIgPSByZXF1aXJlKCdyZWFjdC1yb3V0ZXInKTtcbnZhciAkX18wPSAgICAgcmVxdWlyZSgnLi9EZWZzJyksQ2FsbFNpZ0RlZj0kX18wLkNhbGxTaWdEZWYsTWVtYmVyRGVmPSRfXzAuTWVtYmVyRGVmO1xudmFyIFBhZ2VEYXRhTWl4aW4gPSByZXF1aXJlKCcuL1BhZ2VEYXRhTWl4aW4nKTtcbnZhciBpc01vYmlsZSA9IHJlcXVpcmUoJy4vaXNNb2JpbGUnKTtcbnZhciBNYXJrRG93biA9IHJlcXVpcmUoJy4vTWFya0Rvd24nKTtcblxudmFyICRfXzE9ICAgIFJlYWN0LmFkZG9ucyxUcmFuc2l0aW9uR3JvdXA9JF9fMS5UcmFuc2l0aW9uR3JvdXA7XG5cbnZhciBNZW1iZXJEb2MgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiTWVtYmVyRG9jXCIsXG4gIG1peGluczogW1BhZ2VEYXRhTWl4aW4sIFJvdXRlci5OYXZpZ2F0aW9uXSxcblxuICBnZXRJbml0aWFsU3RhdGU6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNob3dEZXRhaWwgPSB0aGlzLnByb3BzLnNob3dEZXRhaWw7XG4gICAgcmV0dXJuIHsgZGV0YWlsOiBzaG93RGV0YWlsIH07XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6ZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuc2hvd0RldGFpbCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldERPTU5vZGUoKTtcbiAgICAgIHZhciBuYXZUeXBlID0gdGhpcy5nZXRQYWdlRGF0YSgpLnR5cGU7XG4gICAgICBpZiAobmF2VHlwZSA9PT0gJ2luaXQnIHx8IG5hdlR5cGUgPT09ICdwdXNoJykge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8od2luZG93LnNjcm9sbFgsIG9mZnNldFRvcChub2RlKSAtIEZJWEVEX0hFQURFUl9IRUlHSFQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOmZ1bmN0aW9uKG5leHRQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMuc2hvd0RldGFpbCAmJiAhdGhpcy5wcm9wcy5zaG93RGV0YWlsKSB7XG4gICAgICB0aGlzLnNjcm9sbFRvID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBkZXRhaWw6IHRydWUgfSk7XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZTpmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zY3JvbGxUbykge1xuICAgICAgdGhpcy5zY3JvbGxUbyA9IGZhbHNlO1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldERPTU5vZGUoKTtcbiAgICAgIHZhciBuYXZUeXBlID0gdGhpcy5nZXRQYWdlRGF0YSgpLnR5cGU7XG4gICAgICBpZiAobmF2VHlwZSA9PT0gJ2luaXQnIHx8IG5hdlR5cGUgPT09ICdwdXNoJykge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8od2luZG93LnNjcm9sbFgsIG9mZnNldFRvcChub2RlKSAtIEZJWEVEX0hFQURFUl9IRUlHSFQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB0b2dnbGVEZXRhaWw6ZnVuY3Rpb24oKSB7XG4gICAgLy8gTm90ZTogcmVtb3ZlZCB0aGlzIGJlY2F1c2UgaXQgZHJvcHMgdGhlIFVSTCBiYXIgb24gbW9iaWxlLCBhbmQgdGhhdCdzXG4gICAgLy8gdGhlIG9ubHkgcGxhY2UgaXQncyBjdXJyZW50bHkgYmVpbmcgdXNlZC5cbiAgICAvLyB2YXIgbWVtYmVyID0gdGhpcy5wcm9wcy5tZW1iZXI7XG4gICAgLy8gdmFyIG5hbWUgPSBtZW1iZXIubWVtYmVyTmFtZTtcbiAgICAvLyB2YXIgdHlwZU5hbWUgPSB0aGlzLnByb3BzLnBhcmVudE5hbWU7XG4gICAgLy8gdmFyIHNob3dEZXRhaWwgPSB0aGlzLnByb3BzLnNob3dEZXRhaWw7XG4gICAgLy8gaWYgKCF0aGlzLnN0YXRlLmRldGFpbCkge1xuICAgIC8vICAgdGhpcy5yZXBsYWNlV2l0aCgnLycgKyAodHlwZU5hbWUgPyB0eXBlTmFtZSArICcvJyA6ICcnKSArIG5hbWUgKTtcbiAgICAvLyB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuZGV0YWlsICYmIHNob3dEZXRhaWwpIHtcbiAgICAvLyAgIHRoaXMucmVwbGFjZVdpdGgoJy8nICsgKHR5cGVOYW1lIHx8ICcnKSApO1xuICAgIC8vIH1cbiAgICB0aGlzLnNldFN0YXRlKHsgZGV0YWlsOiAhdGhpcy5zdGF0ZS5kZXRhaWwgfSk7XG4gIH0sXG5cbiAgcmVuZGVyOmZ1bmN0aW9uKCkge1xuICAgIHZhciB0eXBlUHJvcE1hcCA9IHRoaXMucHJvcHMudHlwZVByb3BNYXA7XG4gICAgdmFyIG1lbWJlciA9IHRoaXMucHJvcHMubWVtYmVyO1xuICAgIHZhciBtb2R1bGUgPSBtZW1iZXIuaXNTdGF0aWMgPyB0aGlzLnByb3BzLnBhcmVudE5hbWUgOiBudWxsO1xuICAgIHZhciBuYW1lID0gbWVtYmVyLm1lbWJlck5hbWU7XG4gICAgdmFyIGRlZiA9IG1lbWJlci5tZW1iZXJEZWY7XG4gICAgdmFyIGRvYyA9IGRlZi5kb2MgfHwge307XG4gICAgdmFyIGlzUHJvcCA9ICFkZWYuc2lnbmF0dXJlcztcblxuICAgIHZhciB0eXBlSW5mbyA9IG1lbWJlci5pbmhlcml0ZWQgJiYge1xuICAgICAgcHJvcE1hcDogdHlwZVByb3BNYXAsXG4gICAgICBkZWZpbmluZzogbWVtYmVyLmluaGVyaXRlZC5uYW1lLFxuICAgIH07XG5cbiAgICB2YXIgc2hvd0RldGFpbCA9IGlzTW9iaWxlID8gdGhpcy5zdGF0ZS5kZXRhaWwgOiB0cnVlO1xuXG4gICAgdmFyIG1lbWJlckFuY2hvckxpbmsgPSB0aGlzLnByb3BzLnBhcmVudE5hbWUgKyAnLycgKyBuYW1lO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2NsYXNzTmFtZTogXCJpbnRlcmZhY2VNZW1iZXJcIn0sIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDNcIiwge2NsYXNzTmFtZTogXCJtZW1iZXJMYWJlbFwifSwgXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIuTGluaywge1xuICAgICAgICAgICAgdG86ICcvJyArIG1lbWJlckFuY2hvckxpbmssIFxuICAgICAgICAgICAgb25DbGljazogaXNNb2JpbGUgPyB0aGlzLnRvZ2dsZURldGFpbCA6IG51bGxcbiAgICAgICAgICB9LCBcbiAgICAgICAgICAgIChtb2R1bGUgPyBtb2R1bGUgKyAnLicgOiAnJykgKyBuYW1lICsgKGlzUHJvcCA/ICcnIDogJygpJylcbiAgICAgICAgICApXG4gICAgICAgICksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFRyYW5zaXRpb25Hcm91cCwge2NoaWxkRmFjdG9yeTogbWFrZVNsaWRlRG93bn0sIFxuICAgICAgICAgIHNob3dEZXRhaWwgJiYgKFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7a2V5OiBcImRldGFpbFwiLCBjbGFzc05hbWU6IFwiZGV0YWlsXCJ9LCBcbiAgICAgICAgICAgICAgZG9jLnN5bm9wc2lzICYmIChcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1hcmtEb3duLCB7Y2xhc3NOYW1lOiBcInN5bm9wc2lzXCIsIGNvbnRlbnRzOiBkb2Muc3lub3BzaXN9KVxuICAgICAgICAgICAgICApLCBcbiAgICAgICAgICAgICAgaXNQcm9wID8gKFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIsIHtjbGFzc05hbWU6IFwiY29kZUJsb2NrIG1lbWJlclNpZ25hdHVyZVwifSwgXG4gICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1lbWJlckRlZiwge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGU6IG1vZHVsZSwgXG4gICAgICAgICAgICAgICAgICAgIG1lbWJlcjogeyBuYW1lOm5hbWUsIHR5cGU6IGRlZi50eXBlfX1cbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImNvZGVcIiwge2NsYXNzTmFtZTogXCJjb2RlQmxvY2sgbWVtYmVyU2lnbmF0dXJlXCJ9LCBcbiAgICAgICAgICAgICAgICAgIGRlZi5zaWduYXR1cmVzLm1hcChmdW5jdGlvbihjYWxsU2lnLCBpKSAge3JldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FsbFNpZ0RlZiwge1xuICAgICAgICAgICAgICAgICAgICAgIGtleTogaSwgXG4gICAgICAgICAgICAgICAgICAgICAgaW5mbzogdHlwZUluZm8sIFxuICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZTogbW9kdWxlLCBcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLCBcbiAgICAgICAgICAgICAgICAgICAgICBjYWxsU2lnOiBjYWxsU2lnfVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAnXFxuJyxcbiAgICAgICAgICAgICAgICAgIF07fSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICksIFxuICAgICAgICAgICAgICBtZW1iZXIuaW5oZXJpdGVkICYmIChcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiLCBudWxsLCBcbiAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImluZm9IZWFkZXJcIn0sIFwiSW5oZXJpdGVkIGZyb21cIiksIFxuICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImNvZGVcIiwgbnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLkxpbmssIHt0bzogJy8nICsgbWVtYmVyLmluaGVyaXRlZC5uYW1lICsgJy8nICsgbmFtZX0sIFxuICAgICAgICAgICAgICAgICAgICAgIG1lbWJlci5pbmhlcml0ZWQubmFtZSArICcjJyArIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKSwgXG4gICAgICAgICAgICAgIG1lbWJlci5vdmVycmlkZXMgJiYgKFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIsIG51bGwsIFxuICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg0XCIsIHtjbGFzc05hbWU6IFwiaW5mb0hlYWRlclwifSwgXCJPdmVycmlkZXNcIiksIFxuICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImNvZGVcIiwgbnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLkxpbmssIHt0bzogJy8nICsgbWVtYmVyLm92ZXJyaWRlcy5uYW1lICsgJy8nICsgbmFtZX0sIFxuICAgICAgICAgICAgICAgICAgICAgIG1lbWJlci5vdmVycmlkZXMubmFtZSArICcjJyArIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKSwgXG4gICAgICAgICAgICAgIGRvYy5ub3RlcyAmJlxuICAgICAgICAgICAgICAgIGRvYy5ub3Rlcy5tYXAoZnVuY3Rpb24obm90ZSwgaSkgIFxuICAgICAgICAgICAgICAgICAge3JldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiLCB7a2V5OiBpfSwgXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImluZm9IZWFkZXJcIn0sIG5vdGUubmFtZSksIFxuICAgICAgICAgICAgICAgICAgICBub3RlLm5hbWUgPT09ICdhbGlhcycgPyAoXG4gICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImNvZGVcIiwgbnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENhbGxTaWdEZWYsIHtuYW1lOiBub3RlLmJvZHl9KVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1hcmtEb3duLCB7Y2xhc3NOYW1lOiBcImRpc2N1c3Npb25cIiwgY29udGVudHM6IG5vdGUuYm9keX0pXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICk7fVxuICAgICAgICAgICAgICAgICksIFxuICAgICAgICAgICAgICBkb2MuZGVzY3JpcHRpb24gJiYgKFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIsIG51bGwsIFxuICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg0XCIsIHtjbGFzc05hbWU6IFwiaW5mb0hlYWRlclwifSwgXG4gICAgICAgICAgICAgICAgICAgIGRvYy5kZXNjcmlwdGlvbi5zdWJzdHIoMCwgNSkgPT09ICc8Y29kZSdcbiAgICAgICAgICAgICAgICAgICAgICA/ICdFeGFtcGxlJ1xuICAgICAgICAgICAgICAgICAgICAgIDogJ0Rpc2N1c3Npb24nXG4gICAgICAgICAgICAgICAgICApLCBcbiAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFya0Rvd24sIHtjbGFzc05hbWU6IFwiZGlzY3Vzc2lvblwiLCBjb250ZW50czogZG9jLmRlc2NyaXB0aW9ufSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9LFxufSk7XG5cbmZ1bmN0aW9uIG1ha2VTbGlkZURvd24oY2hpbGQpIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2xpZGVEb3duLCBudWxsLCBjaGlsZCk7XG59XG5cbnZhciBTbGlkZURvd24gPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiU2xpZGVEb3duXCIsXG4gIGNvbXBvbmVudFdpbGxFbnRlcjpmdW5jdGlvbihkb25lKSB7XG4gICAgdGhpcy5zbGlkZShmYWxzZSwgZG9uZSk7XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbExlYXZlOmZ1bmN0aW9uKGRvbmUpIHtcbiAgICB0aGlzLnNsaWRlKHRydWUsIGRvbmUpO1xuICB9LFxuXG4gIHNsaWRlOmZ1bmN0aW9uKHNsaWRpbmdVcCwgZG9uZSkge1xuICAgIHZhciBub2RlID0gdGhpcy5nZXRET01Ob2RlKCk7XG4gICAgbm9kZS5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgdmFyIGhlaWdodCA9IGdldENvbXB1dGVkU3R5bGUobm9kZSkuaGVpZ2h0O1xuICAgIHZhciBzdGFydCA9IHNsaWRpbmdVcCA/IGhlaWdodCA6IDA7XG4gICAgdmFyIGVuZCA9IHNsaWRpbmdVcCA/IDAgOiBoZWlnaHQ7XG4gICAgbm9kZS5zdHlsZS50cmFuc2l0aW9uID0gJyc7XG4gICAgbm9kZS5zdHlsZS5oZWlnaHQgPSBzdGFydDtcbiAgICBub2RlLnN0eWxlLnRyYW5zaXRpb24gPSAnaGVpZ2h0IDAuMzVzIGVhc2UtaW4tb3V0JztcbiAgICB2YXIgZW5kTGlzdGVuZXIgPSBmdW5jdGlvbigpICB7XG4gICAgICBSZWFjdFRyYW5zaXRpb25FdmVudHMucmVtb3ZlRW5kRXZlbnRMaXN0ZW5lcihub2RlLCBlbmRMaXN0ZW5lcik7XG4gICAgICBkb25lKCk7XG4gICAgfTtcbiAgICBSZWFjdFRyYW5zaXRpb25FdmVudHMuYWRkRW5kRXZlbnRMaXN0ZW5lcihub2RlLCBlbmRMaXN0ZW5lcik7XG4gICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpICB7XG4gICAgICBub2RlLnN0eWxlLmhlaWdodCA9IGVuZDtcbiAgICB9LCAxNyk7XG4gIH0sXG5cbiAgcmVuZGVyOmZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICB9LFxufSk7XG5cbnZhciBGSVhFRF9IRUFERVJfSEVJR0hUID0gNzU7XG5cbmZ1bmN0aW9uIG9mZnNldFRvcChub2RlKSB7XG4gIHZhciB0b3AgPSAwO1xuICBkbyB7XG4gICAgdG9wICs9IG5vZGUub2Zmc2V0VG9wO1xuICB9IHdoaWxlICgobm9kZSA9IG5vZGUub2Zmc2V0UGFyZW50KSk7XG4gIHJldHVybiB0b3A7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWVtYmVyRG9jO1xuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbnRleHRUeXBlczoge1xuICAgIGdldFBhZ2VEYXRhOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtb3N0IHJlY2VudCBjaGFuZ2UgZXZlbnQuXG4gICAqL1xuICBnZXRQYWdlRGF0YTpmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LmdldFBhZ2VEYXRhKCk7XG4gIH0sXG59O1xuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSb3V0ZXIgPSByZXF1aXJlKCdyZWFjdC1yb3V0ZXInKTtcbnZhciAkX18wPSAgICAgcmVxdWlyZSgnLi4vLi4vLi4vLi4vJyksTWFwPSRfXzAuTWFwLFNlcT0kX18wLlNlcTtcbnZhciBkZWZzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL2dldFR5cGVEZWZzJyk7XG5cbnZhciBTaWRlQmFyID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiBcIlNpZGVCYXJcIixcbiAgcmVuZGVyOmZ1bmN0aW9uKCkge1xuICAgIHZhciB0eXBlID0gZGVmcy5JbW11dGFibGU7XG5cbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7Y2xhc3NOYW1lOiBcInNpZGVCYXJcIn0sIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtjbGFzc05hbWU6IFwidG9vbEJhclwifSwgXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgICBvbkNsaWNrOiB0aGlzLnByb3BzLnRvZ2dsZVNob3dJbkdyb3VwcywgXG4gICAgICAgICAgICBvbktleVByZXNzOiB0aGlzLnByb3BzLnRvZ2dsZVNob3dJbkdyb3Vwc1xuICAgICAgICAgIH0sIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogdGhpcy5wcm9wcy5zaG93SW5Hcm91cHMgJiYgJ3NlbGVjdGVkJ30sIFxuICAgICAgICAgICAgICBcIkdyb3VwZWRcIlxuICAgICAgICAgICAgKSwgXG4gICAgICAgICAgICAnIOKAoiAnLCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IHRoaXMucHJvcHMuc2hvd0luR3JvdXBzIHx8ICdzZWxlY3RlZCd9LCBcbiAgICAgICAgICAgICAgXCJBbHBoYWJldGl6ZWRcIlxuICAgICAgICAgICAgKVxuICAgICAgICAgICksIFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAgICAgb25DbGljazogdGhpcy5wcm9wcy50b2dnbGVTaG93SW5oZXJpdGVkLCBcbiAgICAgICAgICAgIG9uS2V5UHJlc3M6IHRoaXMucHJvcHMudG9nZ2xlU2hvd0luaGVyaXRlZFxuICAgICAgICAgIH0sIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogdGhpcy5wcm9wcy5zaG93SW5oZXJpdGVkICYmICdzZWxlY3RlZCd9LCBcbiAgICAgICAgICAgICAgXCJJbmhlcml0ZWRcIlxuICAgICAgICAgICAgKSwgXG4gICAgICAgICAgICAnIOKAoiAnLCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IHRoaXMucHJvcHMuc2hvd0luaGVyaXRlZCB8fCAnc2VsZWN0ZWQnfSwgXG4gICAgICAgICAgICAgIFwiRGVmaW5lZFwiXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7Y2xhc3NOYW1lOiBcInNjcm9sbENvbnRlbnRcIn0sIFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImdyb3VwVGl0bGVcIn0sIFwiQVBJXCIpLCBcbiAgICAgICAgICBTZXEodHlwZS5tb2R1bGUpXG4gICAgICAgICAgICAuZmxhdE1hcChmdW5jdGlvbih0LCBuYW1lKSAge3JldHVybiBmbGF0dGVuU3VibW9kdWxlcyhNYXAoKSwgdCwgbmFtZSk7fSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24odCwgbmFtZSkgIHtyZXR1cm4gdGhpcy5yZW5kZXJTaWRlQmFyVHlwZShuYW1lLCB0KTt9LmJpbmQodGhpcykpXG4gICAgICAgICAgICAudmFsdWVTZXEoKVxuICAgICAgICAgICAgLnRvQXJyYXkoKVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfSxcblxuICByZW5kZXJTaWRlQmFyVHlwZTpmdW5jdGlvbih0eXBlTmFtZSwgdHlwZSkge1xuICAgIHZhciBpc0ZvY3VzID0gdGhpcy5wcm9wcy5mb2N1cyA9PT0gdHlwZU5hbWU7XG4gICAgdmFyIGlzRnVuY3Rpb24gPSAhdHlwZS5pbnRlcmZhY2UgJiYgIXR5cGUubW9kdWxlO1xuICAgIHZhciBjYWxsID0gdHlwZS5jYWxsO1xuICAgIHZhciBmdW5jdGlvbnMgPSBTZXEodHlwZS5tb2R1bGUpLmZpbHRlcihmdW5jdGlvbih0KSAge3JldHVybiAhdC5pbnRlcmZhY2UgJiYgIXQubW9kdWxlO30pO1xuXG4gICAgdmFyIGxhYmVsID0gdHlwZU5hbWUgKyAoaXNGdW5jdGlvbiA/ICcoKScgOiAnJyk7XG5cbiAgICBpZiAoIWlzRm9jdXMpIHtcbiAgICAgIGxhYmVsID0gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIuTGluaywge3RvOiAnLycgKyB0eXBlTmFtZX0sIGxhYmVsKTtcbiAgICB9XG5cbiAgICB2YXIgbWVtYmVyR3JvdXBzID0gdGhpcy5wcm9wcy5tZW1iZXJHcm91cHM7XG5cbiAgICB2YXIgbWVtYmVycyA9XG4gICAgICAhaXNGb2N1cyB8fCBpc0Z1bmN0aW9uID8gbnVsbCA6IChcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7Y2xhc3NOYW1lOiBcIm1lbWJlcnNcIn0sIFxuICAgICAgICAgIGNhbGwgJiYgKFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwgbnVsbCwgXG4gICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImdyb3VwVGl0bGVcIn0sIFwiQ29uc3RydWN0aW9uXCIpLCBcbiAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCBcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlci5MaW5rLCB7dG86ICcvJyArIHR5cGVOYW1lICsgJy8nICsgdHlwZU5hbWV9LCBcbiAgICAgICAgICAgICAgICAgIHR5cGVOYW1lICsgJygpJ1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICksIFxuXG4gICAgICAgICAgZnVuY3Rpb25zLmNvdW50KCkgPiAwICYmIChcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIsIG51bGwsIFxuICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDRcIiwge2NsYXNzTmFtZTogXCJncm91cFRpdGxlXCJ9LCBcIlN0YXRpYyBNZXRob2RzXCIpLCBcbiAgICAgICAgICAgICAgZnVuY3Rpb25zXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbih0LCBuYW1lKSAgXG4gICAgICAgICAgICAgICAgICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2tleTogbmFtZX0sIFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlci5MaW5rLCB7dG86ICcvJyArIHR5cGVOYW1lICsgJy8nICsgbmFtZX0sIFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGVOYW1lICsgJy4nICsgbmFtZSArICcoKSdcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKTt9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC52YWx1ZVNlcSgpXG4gICAgICAgICAgICAgICAgLnRvQXJyYXkoKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICksIFxuXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwgbnVsbCwgXG4gICAgICAgICAgICBTZXEobWVtYmVyR3JvdXBzKVxuICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKG1lbWJlcnMsIHRpdGxlKSBcbiAgICAgICAgICAgICAgICB7cmV0dXJuIG1lbWJlcnMubGVuZ3RoID09PSAwXG4gICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgIDogU2VxKFtcbiAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDRcIiwge2tleTogdGl0bGUgfHwgJ01lbWJlcnMnLCBjbGFzc05hbWU6IFwiZ3JvdXBUaXRsZVwifSwgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSB8fCAnTWVtYmVycydcbiAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgIFNlcShtZW1iZXJzKS5tYXAoZnVuY3Rpb24obWVtYmVyKSAgXG4gICAgICAgICAgICAgICAgICAgICAgICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2tleTogbWVtYmVyLm1lbWJlck5hbWV9LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIuTGluaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiAnLycgKyB0eXBlTmFtZSArICcvJyArIG1lbWJlci5tZW1iZXJOYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lbWJlci5tZW1iZXJOYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtZW1iZXIubWVtYmVyRGVmLnNpZ25hdHVyZXMgPyAnKCknIDogJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICk7fVxuICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIF0pO31cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAuZmxhdHRlbigpXG4gICAgICAgICAgICAgIC52YWx1ZVNlcSgpXG4gICAgICAgICAgICAgIC50b0FycmF5KClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7a2V5OiB0eXBlTmFtZX0sIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDJcIiwgbnVsbCwgbGFiZWwpLCBcbiAgICAgICAgbWVtYmVyc1xuICAgICAgKVxuICAgICk7XG4gIH0sXG59KTtcblxuZnVuY3Rpb24gZmxhdHRlblN1Ym1vZHVsZXMobW9kdWxlcywgdHlwZSwgbmFtZSkge1xuICBtb2R1bGVzID0gbW9kdWxlcy5zZXQobmFtZSwgdHlwZSk7XG4gIHJldHVybiB0eXBlLm1vZHVsZVxuICAgID8gU2VxKHR5cGUubW9kdWxlKVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHQpICB7cmV0dXJuIHQuaW50ZXJmYWNlIHx8IHQubW9kdWxlO30pXG4gICAgICAgIC5yZWR1Y2UoXG4gICAgICAgICAgZnVuY3Rpb24obW9kdWxlcywgc3ViVCwgc3ViTmFtZSkgXG4gICAgICAgICAgICB7cmV0dXJuIGZsYXR0ZW5TdWJtb2R1bGVzKG1vZHVsZXMsIHN1YlQsIG5hbWUgKyAnLicgKyBzdWJOYW1lKTt9LFxuICAgICAgICAgIG1vZHVsZXNcbiAgICAgICAgKVxuICAgIDogbW9kdWxlcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaWRlQmFyO1xuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSb3V0ZXIgPSByZXF1aXJlKCdyZWFjdC1yb3V0ZXInKTtcbnZhciAkX18wPSAgICByZXF1aXJlKCcuLi8uLi8uLi8uLi8nKSxTZXE9JF9fMC5TZXE7XG52YXIgJF9fMT0gICAgIHJlcXVpcmUoJy4vRGVmcycpLEludGVyZmFjZURlZj0kX18xLkludGVyZmFjZURlZixDYWxsU2lnRGVmPSRfXzEuQ2FsbFNpZ0RlZjtcbnZhciBNZW1iZXJEb2MgPSByZXF1aXJlKCcuL01lbWJlckRvYycpO1xudmFyIGlzTW9iaWxlID0gcmVxdWlyZSgnLi9pc01vYmlsZScpO1xudmFyIFNpZGVCYXIgPSByZXF1aXJlKCcuL1NpZGVCYXInKTtcbnZhciBNYXJrRG93biA9IHJlcXVpcmUoJy4vTWFya0Rvd24nKTtcbnZhciBEb2NPdmVydmlldyA9IHJlcXVpcmUoJy4vRG9jT3ZlcnZpZXcnKTtcbnZhciBjb2xsZWN0TWVtYmVyR3JvdXBzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL2NvbGxlY3RNZW1iZXJHcm91cHMnKTtcbnZhciBUeXBlS2luZCA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9UeXBlS2luZCcpO1xudmFyIGRlZnMgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvZ2V0VHlwZURlZnMnKTtcblxudmFyIHR5cGVEZWZVUkwgPVxuICAnaHR0cHM6Ly9naXRodWIuY29tL2ltbXV0YWJsZS1qcy9pbW11dGFibGUtanMvYmxvYi9tYWluL3R5cGUtZGVmaW5pdGlvbnMvSW1tdXRhYmxlLmQudHMnO1xudmFyIGlzc3Vlc1VSTCA9ICdodHRwczovL2dpdGh1Yi5jb20vaW1tdXRhYmxlLWpzL2ltbXV0YWJsZS1qcy9pc3N1ZXMnO1xuXG52YXIgRGlzY2xhaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIChcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiLCB7Y2xhc3NOYW1lOiBcImRpc2NsYWltZXJcIn0sIFxuICAgICAgXCJUaGlzIGRvY3VtZW50YXRpb24gaXMgZ2VuZXJhdGVkIGZyb21cIiwgJyAnLCBcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHtocmVmOiB0eXBlRGVmVVJMfSwgXCJJbW11dGFibGUuZC50c1wiKSwgXCIuIFB1bGwgcmVxdWVzdHMgYW5kXCIsICcgJywgXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7aHJlZjogaXNzdWVzVVJMfSwgXCJJc3N1ZXNcIiksIFwiIHdlbGNvbWUuXCJcbiAgICApXG4gICk7XG59O1xuXG52YXIgVHlwZURvY3VtZW50YXRpb24gPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiVHlwZURvY3VtZW50YXRpb25cIixcbiAgZ2V0SW5pdGlhbFN0YXRlOmZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzaG93SW5oZXJpdGVkOiB0cnVlLFxuICAgICAgc2hvd0luR3JvdXBzOiB0cnVlLFxuICAgIH07XG4gIH0sXG5cbiAgdG9nZ2xlU2hvd0luR3JvdXBzOmZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBzaG93SW5Hcm91cHM6ICF0aGlzLnN0YXRlLnNob3dJbkdyb3VwcyB9KTtcbiAgfSxcblxuICB0b2dnbGVTaG93SW5oZXJpdGVkOmZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBzaG93SW5oZXJpdGVkOiAhdGhpcy5zdGF0ZS5zaG93SW5oZXJpdGVkIH0pO1xuICB9LFxuXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcbiAgICB2YXIgbWVtYmVyTmFtZSA9IHRoaXMucHJvcHMubWVtYmVyTmFtZTtcbiAgICB2YXIgZGVmID0gdGhpcy5wcm9wcy5kZWY7XG5cbiAgICB2YXIgbWVtYmVyR3JvdXBzID0gY29sbGVjdE1lbWJlckdyb3VwcyhkZWYgJiYgZGVmLmludGVyZmFjZSwge1xuICAgICAgc2hvd0luR3JvdXBzOiB0aGlzLnN0YXRlLnNob3dJbkdyb3VwcyxcbiAgICAgIHNob3dJbmhlcml0ZWQ6IHRoaXMuc3RhdGUuc2hvd0luaGVyaXRlZCxcbiAgICB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwsIFxuICAgICAgICBpc01vYmlsZSB8fCAoXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChTaWRlQmFyLCB7XG4gICAgICAgICAgICBmb2N1czogbmFtZSwgXG4gICAgICAgICAgICBtZW1iZXJHcm91cHM6IG1lbWJlckdyb3VwcywgXG4gICAgICAgICAgICB0b2dnbGVTaG93SW5oZXJpdGVkOiB0aGlzLnRvZ2dsZVNob3dJbmhlcml0ZWQsIFxuICAgICAgICAgICAgdG9nZ2xlU2hvd0luR3JvdXBzOiB0aGlzLnRvZ2dsZVNob3dJbkdyb3VwcywgXG4gICAgICAgICAgICBzaG93SW5Hcm91cHM6IHRoaXMuc3RhdGUuc2hvd0luR3JvdXBzLCBcbiAgICAgICAgICAgIHNob3dJbmhlcml0ZWQ6IHRoaXMuc3RhdGUuc2hvd0luaGVyaXRlZH1cbiAgICAgICAgICApXG4gICAgICAgICksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtrZXk6IG5hbWUsIGNsYXNzTmFtZTogXCJkb2NDb250ZW50c1wifSwgXG4gICAgICAgICAgIWRlZiA/IChcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTm90Rm91bmQsIG51bGwpXG4gICAgICAgICAgKSA6ICFuYW1lID8gKFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEb2NPdmVydmlldywge2RlZjogZGVmfSlcbiAgICAgICAgICApIDogIWRlZi5pbnRlcmZhY2UgJiYgIWRlZi5tb2R1bGUgPyAoXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEZ1bmN0aW9uRG9jLCB7bmFtZTogbmFtZSwgZGVmOiBkZWYuY2FsbH0pXG4gICAgICAgICAgKSA6IChcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVHlwZURvYywge1xuICAgICAgICAgICAgICBuYW1lOiBuYW1lLCBcbiAgICAgICAgICAgICAgZGVmOiBkZWYsIFxuICAgICAgICAgICAgICBtZW1iZXJOYW1lOiBtZW1iZXJOYW1lLCBcbiAgICAgICAgICAgICAgbWVtYmVyR3JvdXBzOiBtZW1iZXJHcm91cHN9XG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfSxcbn0pO1xuXG5mdW5jdGlvbiBOb3RGb3VuZCgpIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgXCJOb3QgZm91bmRcIik7XG59XG5cbnZhciBGdW5jdGlvbkRvYyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJGdW5jdGlvbkRvY1wiLFxuICByZW5kZXI6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5hbWUgPSB0aGlzLnByb3BzLm5hbWU7XG4gICAgdmFyIGRlZiA9IHRoaXMucHJvcHMuZGVmO1xuICAgIHZhciBkb2MgPSBkZWYuZG9jIHx8IHt9O1xuXG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoMVwiLCB7Y2xhc3NOYW1lOiBcInR5cGVIZWFkZXJcIn0sIG5hbWUgKyAnKCknKSwgXG4gICAgICAgIGRvYy5zeW5vcHNpcyAmJiAoXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChNYXJrRG93biwge2NsYXNzTmFtZTogXCJzeW5vcHNpc1wiLCBjb250ZW50czogZG9jLnN5bm9wc2lzfSlcbiAgICAgICAgKSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIsIHtjbGFzc05hbWU6IFwiY29kZUJsb2NrIG1lbWJlclNpZ25hdHVyZVwifSwgXG4gICAgICAgICAgZGVmLnNpZ25hdHVyZXMubWFwKGZ1bmN0aW9uKGNhbGxTaWcsIGkpICB7cmV0dXJuIFtcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FsbFNpZ0RlZiwge2tleTogaSwgbmFtZTogbmFtZSwgY2FsbFNpZzogY2FsbFNpZ30pLFxuICAgICAgICAgICAgJ1xcbicsXG4gICAgICAgICAgXTt9KVxuICAgICAgICApLCBcbiAgICAgICAgZG9jLm5vdGVzICYmXG4gICAgICAgICAgZG9jLm5vdGVzLm1hcChmdW5jdGlvbihub3RlLCBpKSAgXG4gICAgICAgICAgICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIsIHtrZXk6IGl9LCBcbiAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg0XCIsIHtjbGFzc05hbWU6IFwiaW5mb0hlYWRlclwifSwgbm90ZS5uYW1lKSwgXG4gICAgICAgICAgICAgIG5vdGUubmFtZSA9PT0gJ2FsaWFzJyA/IChcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENhbGxTaWdEZWYsIHtuYW1lOiBub3RlLmJvZHl9KVxuICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgIG5vdGUuYm9keVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO31cbiAgICAgICAgICApLCBcbiAgICAgICAgZG9jLmRlc2NyaXB0aW9uICYmIChcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiLCBudWxsLCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImluZm9IZWFkZXJcIn0sIFxuICAgICAgICAgICAgICBkb2MuZGVzY3JpcHRpb24uc3Vic3RyKDAsIDUpID09PSAnPGNvZGUnXG4gICAgICAgICAgICAgICAgPyAnRXhhbXBsZSdcbiAgICAgICAgICAgICAgICA6ICdEaXNjdXNzaW9uJ1xuICAgICAgICAgICAgKSwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1hcmtEb3duLCB7Y2xhc3NOYW1lOiBcImRpc2N1c3Npb25cIiwgY29udGVudHM6IGRvYy5kZXNjcmlwdGlvbn0pXG4gICAgICAgICAgKVxuICAgICAgICApLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEaXNjbGFpbWVyLCBudWxsKVxuICAgICAgKVxuICAgICk7XG4gIH0sXG59KTtcblxudmFyIFR5cGVEb2MgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiVHlwZURvY1wiLFxuICByZW5kZXI6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5hbWUgPSB0aGlzLnByb3BzLm5hbWU7XG4gICAgdmFyIGRlZiA9IHRoaXMucHJvcHMuZGVmO1xuICAgIHZhciBtZW1iZXJOYW1lID0gdGhpcy5wcm9wcy5tZW1iZXJOYW1lO1xuICAgIHZhciBtZW1iZXJHcm91cHMgPSB0aGlzLnByb3BzLm1lbWJlckdyb3VwcztcblxuICAgIHZhciBkb2MgPSBkZWYuZG9jIHx8IHt9O1xuICAgIHZhciBjYWxsID0gZGVmLmNhbGw7XG4gICAgdmFyIGZ1bmN0aW9ucyA9IFNlcShkZWYubW9kdWxlKS5maWx0ZXIoZnVuY3Rpb24odCkgIHtyZXR1cm4gIXQuaW50ZXJmYWNlICYmICF0Lm1vZHVsZTt9KTtcbiAgICB2YXIgdHlwZXMgPSBTZXEoZGVmLm1vZHVsZSkuZmlsdGVyKGZ1bmN0aW9uKHQpICB7cmV0dXJuIHQuaW50ZXJmYWNlIHx8IHQubW9kdWxlO30pO1xuICAgIHZhciBpbnRlcmZhY2VEZWYgPSBkZWYuaW50ZXJmYWNlO1xuICAgIHZhciB0eXBlUHJvcE1hcCA9IGdldFR5cGVQcm9wTWFwKGludGVyZmFjZURlZik7XG5cbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImgxXCIsIHtjbGFzc05hbWU6IFwidHlwZUhlYWRlclwifSwgbmFtZSksIFxuICAgICAgICBkb2Muc3lub3BzaXMgJiYgKFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFya0Rvd24sIHtjbGFzc05hbWU6IFwic3lub3BzaXNcIiwgY29udGVudHM6IGRvYy5zeW5vcHNpc30pXG4gICAgICAgICksIFxuICAgICAgICBpbnRlcmZhY2VEZWYgJiYgKFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIsIHtjbGFzc05hbWU6IFwiY29kZUJsb2NrIG1lbWJlclNpZ25hdHVyZVwifSwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEludGVyZmFjZURlZiwge25hbWU6IG5hbWUsIGRlZjogaW50ZXJmYWNlRGVmfSlcbiAgICAgICAgICApXG4gICAgICAgICksIFxuXG4gICAgICAgIGRvYy5ub3RlcyAmJlxuICAgICAgICAgIGRvYy5ub3Rlcy5tYXAoZnVuY3Rpb24obm90ZSwgaSkgIFxuICAgICAgICAgICAge3JldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiLCB7a2V5OiBpfSwgXG4gICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImluZm9IZWFkZXJcIn0sIG5vdGUubmFtZSksIFxuICAgICAgICAgICAgICBub3RlLm5hbWUgPT09ICdhbGlhcycgPyAoXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDYWxsU2lnRGVmLCB7bmFtZTogbm90ZS5ib2R5fSlcbiAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICBub3RlLmJvZHlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTt9XG4gICAgICAgICAgKSwgXG5cbiAgICAgICAgZG9jLmRlc2NyaXB0aW9uICYmIChcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiLCBudWxsLCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImluZm9IZWFkZXJcIn0sIFxuICAgICAgICAgICAgICBkb2MuZGVzY3JpcHRpb24uc3Vic3RyKDAsIDUpID09PSAnPGNvZGUnXG4gICAgICAgICAgICAgICAgPyAnRXhhbXBsZSdcbiAgICAgICAgICAgICAgICA6ICdEaXNjdXNzaW9uJ1xuICAgICAgICAgICAgKSwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1hcmtEb3duLCB7Y2xhc3NOYW1lOiBcImRpc2N1c3Npb25cIiwgY29udGVudHM6IGRvYy5kZXNjcmlwdGlvbn0pXG4gICAgICAgICAgKVxuICAgICAgICApLCBcblxuICAgICAgICB0eXBlcy5jb3VudCgpID4gMCAmJiAoXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwgbnVsbCwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDRcIiwge2NsYXNzTmFtZTogXCJncm91cFRpdGxlXCJ9LCBcIlN1Yi10eXBlc1wiKSwgXG4gICAgICAgICAgICB0eXBlc1xuICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHQsIHR5cGVOYW1lKSAgXG4gICAgICAgICAgICAgICAge3JldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtrZXk6IHR5cGVOYW1lfSwgXG4gICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlci5MaW5rLCB7XG4gICAgICAgICAgICAgICAgICAgIHRvOiAnLycgKyAobmFtZSA/IG5hbWUgKyAnLicgKyB0eXBlTmFtZSA6IHR5cGVOYW1lKVxuICAgICAgICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPyBuYW1lICsgJy4nICsgdHlwZU5hbWUgOiB0eXBlTmFtZVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7fVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIC52YWx1ZVNlcSgpXG4gICAgICAgICAgICAgIC50b0FycmF5KClcbiAgICAgICAgICApXG4gICAgICAgICksIFxuXG4gICAgICAgIGNhbGwgJiYgKFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIsIG51bGwsIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg0XCIsIHtjbGFzc05hbWU6IFwiZ3JvdXBUaXRsZVwifSwgXCJDb25zdHJ1Y3Rpb25cIiksIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChNZW1iZXJEb2MsIHtcbiAgICAgICAgICAgICAgc2hvd0RldGFpbDogbmFtZSA9PT0gbWVtYmVyTmFtZSwgXG4gICAgICAgICAgICAgIHBhcmVudE5hbWU6IG5hbWUsIFxuICAgICAgICAgICAgICBtZW1iZXI6IHtcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIG1lbWJlckRlZjogY2FsbCxcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgICksIFxuXG4gICAgICAgIGZ1bmN0aW9ucy5jb3VudCgpID4gMCAmJiAoXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwgbnVsbCwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDRcIiwge2NsYXNzTmFtZTogXCJncm91cFRpdGxlXCJ9LCBcIlN0YXRpYyBtZXRob2RzXCIpLCBcbiAgICAgICAgICAgIGZ1bmN0aW9uc1xuICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHQsIGZuTmFtZSkgIFxuICAgICAgICAgICAgICAgIHtyZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChNZW1iZXJEb2MsIHtcbiAgICAgICAgICAgICAgICAgIGtleTogZm5OYW1lLCBcbiAgICAgICAgICAgICAgICAgIHNob3dEZXRhaWw6IGZuTmFtZSA9PT0gbWVtYmVyTmFtZSwgXG4gICAgICAgICAgICAgICAgICBwYXJlbnROYW1lOiBuYW1lLCBcbiAgICAgICAgICAgICAgICAgIG1lbWJlcjoge1xuICAgICAgICAgICAgICAgICAgICBtZW1iZXJOYW1lOiBmbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG1lbWJlckRlZjogdC5jYWxsLFxuICAgICAgICAgICAgICAgICAgICBpc1N0YXRpYzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgKTt9XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgLnZhbHVlU2VxKClcbiAgICAgICAgICAgICAgLnRvQXJyYXkoKVxuICAgICAgICAgIClcbiAgICAgICAgKSwgXG5cbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwgbnVsbCwgXG4gICAgICAgICAgU2VxKG1lbWJlckdyb3VwcylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24obWVtYmVycywgdGl0bGUpIFxuICAgICAgICAgICAgICB7cmV0dXJuIG1lbWJlcnMubGVuZ3RoID09PSAwXG4gICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgOiBTZXEoW1xuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDRcIiwge2tleTogdGl0bGUgfHwgJ01lbWJlcnMnLCBjbGFzc05hbWU6IFwiZ3JvdXBUaXRsZVwifSwgXG4gICAgICAgICAgICAgICAgICAgICAgdGl0bGUgfHwgJ01lbWJlcnMnXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIFNlcShtZW1iZXJzKS5tYXAoZnVuY3Rpb24obWVtYmVyKSAgXG4gICAgICAgICAgICAgICAgICAgICAge3JldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE1lbWJlckRvYywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVByb3BNYXA6IHR5cGVQcm9wTWFwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogbWVtYmVyLm1lbWJlck5hbWUsIFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0RldGFpbDogbWVtYmVyLm1lbWJlck5hbWUgPT09IG1lbWJlck5hbWUsIFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50TmFtZTogbmFtZSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW1iZXI6IG1lbWJlcn1cbiAgICAgICAgICAgICAgICAgICAgICApO31cbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIF0pO31cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5mbGF0dGVuKClcbiAgICAgICAgICAgIC52YWx1ZVNlcSgpXG4gICAgICAgICAgICAudG9BcnJheSgpXG4gICAgICAgICksIFxuXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRGlzY2xhaW1lciwgbnVsbClcbiAgICAgIClcbiAgICApO1xuICB9LFxufSk7XG5cbi8qKlxuICogR2V0IGEgbWFwIGZyb20gc3VwZXIgdHlwZSBwYXJhbWV0ZXIgdG8gY29uY3JldGUgdHlwZSBkZWZpbml0aW9uLiBUaGlzIGlzXG4gKiB1c2VkIHdoZW4gcmVuZGVyaW5nIGluaGVyaXRlZCB0eXBlIGRlZmluaXRpb25zIHRvIGVuc3VyZSBjb250ZXh0dWFsbHlcbiAqIHJlbGV2YW50IGluZm9ybWF0aW9uLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICB0eXBlIEE8VD4gaW1wbGVtZW50cyBCPG51bWJlciwgVD5cbiAqICAgdHlwZSBCPEssIFY+IGltcGxlbWVudHMgQzxLLCBWLCBWPlxuICogICB0eXBlIEM8WCwgWSwgWj5cbiAqXG4gKiBwYXJzZSBDOlxuICogICB7fVxuICpcbiAqIHBhcnNlIEI6XG4gKiAgIHsgQzxYOiBLXG4gKiAgICAgQzxZOiBWXG4gKiAgICAgQzxaOiBWIH1cbiAqXG4gKiBwYXJzZSBBOlxuICogICB7IEI8SzogbnVtYmVyXG4gKiAgICAgQjxWOiBUXG4gKiAgICAgQzxYOiBudW1iZXJcbiAqICAgICBDPFk6IFRcbiAqICAgICBDPFo6IFQgfVxuICovXG5mdW5jdGlvbiBnZXRUeXBlUHJvcE1hcChkZWYpIHtcbiAgdmFyIG1hcCA9IHt9O1xuICBkZWYgJiZcbiAgICBkZWYuZXh0ZW5kcyAmJlxuICAgIGRlZi5leHRlbmRzLmZvckVhY2goZnVuY3Rpb24oZSkgIHtcbiAgICAgIHZhciBzdXBlck1vZHVsZSA9IGRlZnMuSW1tdXRhYmxlO1xuICAgICAgZS5uYW1lLnNwbGl0KCcuJykuZm9yRWFjaChmdW5jdGlvbihwYXJ0KSAge1xuICAgICAgICBzdXBlck1vZHVsZSA9XG4gICAgICAgICAgc3VwZXJNb2R1bGUgJiYgc3VwZXJNb2R1bGUubW9kdWxlICYmIHN1cGVyTW9kdWxlLm1vZHVsZVtwYXJ0XTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHN1cGVySW50ZXJmYWNlID0gc3VwZXJNb2R1bGUgJiYgc3VwZXJNb2R1bGUuaW50ZXJmYWNlO1xuICAgICAgaWYgKHN1cGVySW50ZXJmYWNlKSB7XG4gICAgICAgIHZhciBpbnRlcmZhY2VNYXAgPSBTZXEoc3VwZXJJbnRlcmZhY2UudHlwZVBhcmFtcylcbiAgICAgICAgICAudG9LZXllZFNlcSgpXG4gICAgICAgICAgLmZsaXAoKVxuICAgICAgICAgIC5tYXAoZnVuY3Rpb24oaSkgIHtyZXR1cm4gZS5hcmdzW2ldO30pXG4gICAgICAgICAgLnRvT2JqZWN0KCk7XG4gICAgICAgIFNlcShpbnRlcmZhY2VNYXApLmZvckVhY2goZnVuY3Rpb24odiwgaykgIHtcbiAgICAgICAgICBtYXBbZS5uYW1lICsgJzwnICsga10gPSB2O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHN1cGVyTWFwID0gZ2V0VHlwZVByb3BNYXAoc3VwZXJJbnRlcmZhY2UpO1xuICAgICAgICBTZXEoc3VwZXJNYXApLmZvckVhY2goZnVuY3Rpb24odiwgaykgIHtcbiAgICAgICAgICBtYXBba10gPSB2LmsgPT09IFR5cGVLaW5kLlBhcmFtID8gaW50ZXJmYWNlTWFwW3YucGFyYW1dIDogdjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIHJldHVybiBtYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZURvY3VtZW50YXRpb247XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9PYmplY3QuYXNzaWduJyk7XG52YXIgUm91dGVyID0gcmVxdWlyZSgncmVhY3Qtcm91dGVyJyk7XG52YXIgRG9jSGVhZGVyID0gcmVxdWlyZSgnLi9Eb2NIZWFkZXInKTtcbnZhciBEb2NTZWFyY2ggPSByZXF1aXJlKCcuL0RvY1NlYXJjaC5qcycpO1xudmFyIFR5cGVEb2N1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9UeXBlRG9jdW1lbnRhdGlvbicpO1xudmFyIGRlZnMgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvZ2V0VHlwZURlZnMnKTtcblxudmFyICRfXzA9ICAgICAgUm91dGVyLFJvdXRlPSRfXzAuUm91dGUsRGVmYXVsdFJvdXRlPSRfXzAuRGVmYXVsdFJvdXRlLFJvdXRlSGFuZGxlcj0kX18wLlJvdXRlSGFuZGxlcjtcblxucmVxdWlyZSgnLi4vLi4vLi4vbGliL3J1bmtpdC1lbWJlZCcpO1xuXG52YXIgRG9jdW1lbnRhdGlvbiA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJEb2N1bWVudGF0aW9uXCIsXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEb2NIZWFkZXIsIG51bGwpLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7Y2xhc3NOYW1lOiBcInBhZ2VCb2R5XCIsIGlkOiBcImJvZHlcIn0sIFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2NsYXNzTmFtZTogXCJjb250ZW50c1wifSwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERvY1NlYXJjaCwgbnVsbCksIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZUhhbmRsZXIsIG51bGwpXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfSxcbn0pO1xuXG52YXIgRG9jRGV0ZXJtaW5lciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJEb2NEZXRlcm1pbmVyXCIsXG4gIG1peGluczogW1JvdXRlci5TdGF0ZV0sXG5cbiAgcmVuZGVyOmZ1bmN0aW9uKCkge1xuICAgIHZhciAkX18wPSAgICAgIGRldGVybWluZURvYyh0aGlzLmdldFBhdGgoKSksZGVmPSRfXzAuZGVmLG5hbWU9JF9fMC5uYW1lLG1lbWJlck5hbWU9JF9fMC5tZW1iZXJOYW1lO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEb2N1bWVudGF0aW9uLCB7ZGVmOiBkZWYsIG5hbWU6IG5hbWUsIG1lbWJlck5hbWU6IG1lbWJlck5hbWV9KTtcbiAgfSxcbn0pO1xuXG5mdW5jdGlvbiBkZXRlcm1pbmVEb2MocGF0aCkge1xuICB2YXIgJF9fMD0gICAgcGF0aC5zcGxpdCgnLycpLG5hbWU9JF9fMFsxXSxtZW1iZXJOYW1lPSRfXzBbMl07XG5cbiAgdmFyIG5hbWVQYXRoID0gbmFtZSA/IG5hbWUuc3BsaXQoJy4nKSA6IFtdO1xuICB2YXIgZGVmID0gbmFtZVBhdGgucmVkdWNlKFxuICAgIGZ1bmN0aW9uKGRlZiwgc3ViTmFtZSkgIHtyZXR1cm4gZGVmICYmIGRlZi5tb2R1bGUgJiYgZGVmLm1vZHVsZVtzdWJOYW1lXTt9LFxuICAgIGRlZnMuSW1tdXRhYmxlXG4gICk7XG5cbiAgcmV0dXJuIHsgZGVmOmRlZiwgbmFtZTpuYW1lLCBtZW1iZXJOYW1lOm1lbWJlck5hbWUgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiZXhwb3J0c1wiLFxuICBjaGlsZENvbnRleHRUeXBlczoge1xuICAgIGdldFBhZ2VEYXRhOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB9LFxuXG4gIGdldENoaWxkQ29udGV4dDpmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0UGFnZURhdGE6IHRoaXMuZ2V0UGFnZURhdGEsXG4gICAgfTtcbiAgfSxcblxuICBnZXRQYWdlRGF0YTpmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlRGF0YTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsTW91bnQ6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxvY2F0aW9uO1xuICAgIHZhciBzY3JvbGxCZWhhdmlvcjtcblxuICAgIGlmICh3aW5kb3cuZG9jdW1lbnQpIHtcbiAgICAgIGxvY2F0aW9uID0gUm91dGVyLkhhc2hMb2NhdGlvbjtcbiAgICAgIGxvY2F0aW9uLmFkZENoYW5nZUxpc3RlbmVyKGZ1bmN0aW9uKGNoYW5nZSkgIHtcbiAgICAgICAgdGhpcy5wYWdlRGF0YSA9IGFzc2lnbih7fSwgY2hhbmdlLCBkZXRlcm1pbmVEb2MoY2hhbmdlLnBhdGgpKTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgIHRoaXMucGFnZURhdGEgPSAhd2luZG93LmRvY3VtZW50XG4gICAgICAgID8ge31cbiAgICAgICAgOiBhc3NpZ24oXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHBhdGg6IGxvY2F0aW9uLmdldEN1cnJlbnRQYXRoKCksXG4gICAgICAgICAgICAgIHR5cGU6ICdpbml0JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXRlcm1pbmVEb2MobG9jYXRpb24uZ2V0Q3VycmVudFBhdGgoKSlcbiAgICAgICAgICApO1xuXG4gICAgICBzY3JvbGxCZWhhdmlvciA9IHtcbiAgICAgICAgdXBkYXRlU2Nyb2xsUG9zaXRpb246IGZ1bmN0aW9uKHBvc2l0aW9uLCBhY3Rpb25UeXBlKSAge1xuICAgICAgICAgIHN3aXRjaCAoYWN0aW9uVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAncHVzaCc6XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFBhZ2VEYXRhKCkubWVtYmVyTmFtZVxuICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgIDogd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgICAgICAgICAgY2FzZSAncG9wJzpcbiAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5zY3JvbGxUbyhcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA/IHBvc2l0aW9uLnggOiAwLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID8gcG9zaXRpb24ueSA6IDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgUm91dGVyLmNyZWF0ZSh7XG4gICAgICByb3V0ZXM6IChcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZSwge2hhbmRsZXI6IERvY3VtZW50YXRpb24sIHBhdGg6IFwiL1wifSwgXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEZWZhdWx0Um91dGUsIHtoYW5kbGVyOiBEb2NEZXRlcm1pbmVyfSksIFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGUsIHtuYW1lOiBcInR5cGVcIiwgcGF0aDogXCIvOm5hbWVcIiwgaGFuZGxlcjogRG9jRGV0ZXJtaW5lcn0pLCBcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlLCB7XG4gICAgICAgICAgICBuYW1lOiBcIm1ldGhvZFwiLCBcbiAgICAgICAgICAgIHBhdGg6IFwiLzpuYW1lLzptZW1iZXJOYW1lXCIsIFxuICAgICAgICAgICAgaGFuZGxlcjogRG9jRGV0ZXJtaW5lcn1cbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICksXG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICBzY3JvbGxCZWhhdmlvcjogc2Nyb2xsQmVoYXZpb3IsXG4gICAgfSkucnVuKGZ1bmN0aW9uKEhhbmRsZXIpICB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgaGFuZGxlcjogSGFuZGxlciB9KTtcbiAgICAgIGlmICh3aW5kb3cuZG9jdW1lbnQpIHtcbiAgICAgICAgd2luZG93LmRvY3VtZW50LnRpdGxlID0gKHRoaXMucGFnZURhdGEubmFtZSArIFwiIOKAlCBJbW11dGFibGUuanNcIik7XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfSxcblxuICAvLyBUT0RPOiByZXBsYWNlIHRoaXMuIHRoaXMgaXMgaGFja3kgYW5kIHByb2JhYmx5IHdyb25nXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6ZnVuY3Rpb24oKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpICB7XG4gICAgICB0aGlzLnBhZ2VEYXRhLnR5cGUgPSAnJztcbiAgICB9LmJpbmQodGhpcyksIDApO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZTpmdW5jdGlvbigpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgIHtcbiAgICAgIHRoaXMucGFnZURhdGEudHlwZSA9ICcnO1xuICAgIH0uYmluZCh0aGlzKSwgMCk7XG4gIH0sXG5cbiAgcmVuZGVyOmZ1bmN0aW9uKCkge1xuICAgIHZhciBIYW5kbGVyID0gdGhpcy5zdGF0ZS5oYW5kbGVyO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEhhbmRsZXIsIG51bGwpO1xuICB9LFxufSk7XG4iLCJ2YXIgaXNNb2JpbGUgPVxuICB3aW5kb3cubWF0Y2hNZWRpYSAmJiB3aW5kb3cubWF0Y2hNZWRpYSgnKG1heC1kZXZpY2Utd2lkdGg6IDY4MHB4KScpO1xubW9kdWxlLmV4cG9ydHMgPSBmYWxzZSAmJiAhIShpc01vYmlsZSAmJiBpc01vYmlsZS5tYXRjaGVzKTtcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBMb2dvID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiBcIkxvZ29cIixcbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbiAobmV4dFByb3BzKSB7XG4gICAgcmV0dXJuIG5leHRQcm9wcy5vcGFjaXR5ICE9PSB0aGlzLnByb3BzLm9wYWNpdHk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wYWNpdHkgPSB0aGlzLnByb3BzLm9wYWNpdHk7XG4gICAgaWYgKG9wYWNpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3BhY2l0eSA9IDE7XG4gICAgfVxuICAgIHJldHVybiAhdGhpcy5wcm9wcy5pbmxpbmUgPyAoXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7ZmlsbDogdGhpcy5wcm9wcy5jb2xvciwgc3R5bGU6IHsgb3BhY2l0eTogdGhpcy5wcm9wcy5vcGFjaXR5fX0sIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7ZDogXCJNMCwwbDEzLjksMHY0MS4xSDBMMCwwelwifSksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7ZDogXCJNMTguMiwwTDI5LDBsMTAuNywxNS44TDUwLjQsMGwxMC45LDB2NDEuMUg0OC4xVjI2LjNsLTguNCwxMi4zbC04LjQtMTIuM3YxNC44SDE4LjJWMHpcIn0pLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge2Q6IFwiTTY1LjUsMGwxMC45LDBMODcsMTUuOEw5Ny43LDBsMTAuOSwwdjQxLjFIOTUuNFYyNi4zTDg3LDM4LjdsLTguNC0xMi4zdjE0LjhINjUuNVYwelwifSksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgICAgZDogXCJNMTI4LjYsNDIuMmMtMi42LDAtNC45LTAuMy03LTFjLTIuMS0wLjctMy45LTEuNi01LjQtM2MtMS41LTEuMy0yLjYtMy0zLjQtNWMtMC44LTItMS4yLTQuNC0xLjItNy4xVjBcIiArICcgJyArXG4gICAgICAgICAgXCJsMTMuMSwwdjI1LjZjMCwxLjQsMC4zLDIuNSwwLjksMy4zYzAuNiwwLjgsMS42LDEuMSwzLDEuMWMxLjQsMCwyLjQtMC40LDMtMS4xYzAuNi0wLjgsMC45LTEuOSwwLjktMy4zVjBsMTMuMiwwdjI2LjFcIiArICcgJyArXG4gICAgICAgICAgXCJjMCwyLjctMC40LDUuMS0xLjIsNy4xYy0wLjgsMi0yLDMuNy0zLjUsNWMtMS41LDEuMy0zLjMsMi4zLTUuNCwzQzEzMy41LDQxLjgsMTMxLjIsNDIuMiwxMjguNiw0Mi4yelwifVxuICAgICAgICApLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge2Q6IFwiTTE1NS40LDEwLjhoLTcuNlYwbDI4LjcsMHYxMC44aC03LjZ2MzAuM2gtMTMuNlYxMC44elwifSksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgICAgZDogXCJNMTg2LjQsMGw5LjksMGwxNS42LDQxLjFoLTEyLjlsLTEuNC0zLjdoLTEyLjVsLTEuNCwzLjdoLTEyLjlMMTg2LjQsMHogTTE5NC4xLDI4LjRsLTIuOC03LjJsLTIuOCw3LjJcIiArICcgJyArXG4gICAgICAgICAgXCJIMTk0LjF6XCJ9XG4gICAgICAgICksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgICAgZDogXCJNMjEyLjksMEwyMjksMGMyLjEsMCwzLjksMC4yLDUuNiwwLjdjMS43LDAuNSwzLjIsMS4yLDQuNCwyLjFzMi4yLDIuMSwyLjgsMy41YzAuNywxLjQsMSwzLDEsNC44XCIgKyAnICcgK1xuICAgICAgICAgIFwiYzAsMS4zLTAuMiwyLjQtMC41LDMuNGMtMC4zLDAuOS0wLjcsMS43LTEsMi4zYy0wLjUsMC43LTEsMS40LTEuNSwxLjhjMC45LDAuNiwxLjcsMS4zLDIuNSwyLjJjMC42LDAuOCwxLjIsMS44LDEuNywzXCIgKyAnICcgK1xuICAgICAgICAgIFwiYzAuNSwxLjIsMC44LDIuNywwLjgsNC40YzAsMi0wLjMsMy44LTEsNS40Yy0wLjcsMS42LTEuNywzLTMsNC4xYy0xLjMsMS4xLTIuOSwyLTQuNywyLjZjLTEuOSwwLjYtNCwwLjktNi4zLDAuOWgtMTYuOFYwelwiICsgJyAnICtcbiAgICAgICAgICAgXCJNMjMwLjIsMTIuNWMwLTEuOS0xLTIuOC0zLjEtMi44aC0xLjV2NS43aDEuNUMyMjkuMiwxNS40LDIzMC4yLDE0LjQsMjMwLjIsMTIuNXogTTIyNy4xLDMxLjRjMy4xLDAsNC43LTEuMiw0LjctMy42XCIgKyAnICcgK1xuICAgICAgICAgIFwiYzAtMi40LTEuNi0zLjYtNC43LTMuNmgtMS41djcuMkgyMjcuMXpcIn1cbiAgICAgICAgKSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtkOiBcIk0yNDguMywwTDI2MiwwdjMwLjNoMTEuM3YxMC44aC0yNVYwelwifSksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7ZDogXCJNMjc1LjMsMGwyNC4yLDB2MTAuOGgtMTEuMXY0LjZoMTAuOXYxMC4yaC0xMC45djQuN0gzMDB2MTAuOGgtMjQuN1YwelwifSlcbiAgICAgIClcbiAgICApIDogKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwge2ZpbGw6IHRoaXMucHJvcHMuY29sb3IsIHN0eWxlOiB7IG9wYWNpdHk6IHRoaXMucHJvcHMub3BhY2l0eX19LCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge2Q6IFwiTTAsMGwxMy45LDB2NDEuMUgwTDAsMHogTTcuOCwzNi4yVjQuOUg2LjJ2MzEuM0g3Ljh6XCJ9KSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgICAgICBkOiBcIk0xOC4yLDBMMjksMGwxMC43LDE1LjhMNTAuNCwwbDEwLjksMHY0MS4xSDQ4LjFWMjYuM2wtOC40LDEyLjNsLTguNC0xMi4zdjE0LjhIMTguMlYweiBNMjUuOSwzNi4yVjcuOVwiICsgJyAnICtcbiAgICAgICAgICBcIkwzOS43LDI4TDUzLjUsNy45djI4LjNoMS42VjQuOWgtMS42TDM5LjcsMjUuMkwyNS45LDQuOWgtMS42djMxLjNIMjUuOXpcIn1cbiAgICAgICAgKSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgICAgICBkOiBcIk02NS41LDBsMTAuOSwwTDg3LDE1LjhMOTcuNywwbDEwLjksMHY0MS4xSDk1LjRWMjYuM0w4NywzOC43bC04LjQtMTIuM3YxNC44SDY1LjVWMHogTTczLjIsMzYuMlY3LjlcIiArICcgJyArXG4gICAgICAgICAgXCJMODcsMjhsMTMuNy0yMC4xdjI4LjNoMS42VjQuOWgtMS42TDg3LDI1LjJMNzMuMiw0LjloLTEuNnYzMS4zSDczLjJ6XCJ9XG4gICAgICAgICksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgICAgZDogXCJNMTI4LjYsNDIuMmMtMi42LDAtNC45LTAuMy03LTFjLTIuMS0wLjctMy45LTEuNi01LjQtM2MtMS41LTEuMy0yLjYtMy0zLjQtNWMtMC44LTItMS4yLTQuNC0xLjItNy4xVjBcIiArICcgJyArXG4gICAgICAgICAgXCJsMTMuMSwwdjI1LjZjMCwxLjQsMC4zLDIuNSwwLjksMy4zYzAuNiwwLjgsMS42LDEuMSwzLDEuMWMxLjQsMCwyLjQtMC40LDMtMS4xYzAuNi0wLjgsMC45LTEuOSwwLjktMy4zVjBsMTMuMiwwdjI2LjFcIiArICcgJyArXG4gICAgICAgICAgXCJjMCwyLjctMC40LDUuMS0xLjIsNy4xYy0wLjgsMi0yLDMuNy0zLjUsNWMtMS41LDEuMy0zLjMsMi4zLTUuNCwzQzEzMy41LDQxLjgsMTMxLjIsNDIuMiwxMjguNiw0Mi4yeiBNMTI4LjYsMzQuOFwiICsgJyAnICtcbiAgICAgICAgICBcImMtNi4yLDAtOS4yLTMtOS4yLTkuMVY0LjloLTEuNnYyMC44YzAsMy41LDAuOSw2LjEsMi44LDcuOWMxLjksMS44LDQuNiwyLjcsOCwyLjdjMy41LDAsNi4yLTAuOSw4LjEtMi43YzEuOS0xLjgsMi44LTQuNSwyLjgtNy45XCIgKyAnICcgK1xuICAgICAgICAgIFwiVjQuOWgtMS43djIwLjhDMTM3LjgsMzEuNywxMzQuOCwzNC44LDEyOC42LDM0Ljh6XCJ9XG4gICAgICAgICksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7ZDogXCJNMTU1LjQsMTAuOGgtNy42VjBsMjguNywwdjEwLjhoLTcuNnYzMC4zaC0xMy42VjEwLjh6IE0xNjMsMzYuMlY2LjRoOC44VjQuOWgtMTkuMnYxLjVoOC44djI5LjhIMTYzelwifSksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgICAgZDogXCJNMTg2LjQsMGw5LjksMGwxNS42LDQxLjFoLTEyLjlsLTEuNC0zLjdoLTEyLjVsLTEuNCwzLjdoLTEyLjlMMTg2LjQsMHogTTE4MCwzNi4ybDEuMi0zLjFoMjAuM2wxLjIsMy4xXCIgKyAnICcgK1xuICAgICAgICAgIFwiaDEuN0wxOTIuNSw0LjloLTIuM2wtMTEuOSwzMS4zSDE4MHogTTE5MS4zLDYuNGw5LjYsMjUuMmgtMTkuMkwxOTEuMyw2LjR6IE0xOTQuMSwyOC40bC0yLjgtNy4ybC0yLjgsNy4ySDE5NC4xelwifVxuICAgICAgICApLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgICAgICAgIGQ6IFwiTTIxMi45LDBMMjI5LDBjMi4xLDAsMy45LDAuMiw1LjYsMC43YzEuNywwLjUsMy4yLDEuMiw0LjQsMi4xczIuMiwyLjEsMi44LDMuNWMwLjcsMS40LDEsMywxLDQuOFwiICsgJyAnICtcbiAgICAgICAgICBcImMwLDEuMy0wLjIsMi40LTAuNSwzLjRjLTAuMywwLjktMC43LDEuNy0xLDIuM2MtMC41LDAuNy0xLDEuNC0xLjUsMS44YzAuOSwwLjYsMS43LDEuMywyLjUsMi4yYzAuNiwwLjgsMS4yLDEuOCwxLjcsM1wiICsgJyAnICtcbiAgICAgICAgICBcImMwLjUsMS4yLDAuOCwyLjcsMC44LDQuNGMwLDItMC4zLDMuOC0xLDUuNGMtMC43LDEuNi0xLjcsMy0zLDQuMWMtMS4zLDEuMS0yLjksMi00LjcsMi42Yy0xLjksMC42LTQsMC45LTYuMywwLjloLTE2LjhWMHpcIiArICcgJyArXG4gICAgICAgICAgIFwiTTIyOCwzNi4yYzMuNiwwLDYuMy0wLjgsOC0yLjNjMS43LTEuNiwyLjYtMy42LDIuNi02LjJjMC0xLjctMC40LTMtMS4xLTRjLTAuNy0xLTEuNS0xLjgtMi4zLTIuNGMtMS0wLjctMi4yLTEuMS0zLjQtMS40XCIgKyAnICcgK1xuICAgICAgICAgIFwiYzEtMC4zLDEuOS0wLjcsMi43LTEuNGMwLjctMC41LDEuMy0xLjMsMS45LTIuMnMwLjgtMi4xLDAuOC0zLjVjMC0yLjYtMC44LTQuNS0yLjUtNS45Yy0xLjYtMS4zLTMuOS0yLTYuNy0yaC04Ljl2MzEuM0gyMjh6XCIgKyAnICcgK1xuICAgICAgICAgICBcIk0yMjAuNywxOS4xVjYuNGw3LjMsMGMyLjcsMCw0LjYsMC42LDUuOCwxLjhjMS4yLDEuMiwxLjgsMi43LDEuOCw0LjZjMCwxLjktMC42LDMuNC0xLjgsNC42Yy0xLjIsMS4yLTMuMSwxLjgtNS44LDEuOEgyMjAuN3pcIiArICcgJyArXG4gICAgICAgICAgIFwiTTIyMC43LDM0LjdWMjAuNmg3LjJjMS4zLDAsMi41LDAuMSwzLjUsMC40YzEuMSwwLjMsMiwwLjcsMi45LDEuMmMwLjgsMC42LDEuNSwxLjMsMS45LDIuMmMwLjUsMC45LDAuNywyLDAuNywzLjJcIiArICcgJyArXG4gICAgICAgICAgXCJjMCwyLjUtMC44LDQuMy0yLjUsNS40Yy0xLjcsMS4xLTMuOSwxLjctNi42LDEuN0gyMjAuN3ogTTIzMC4yLDEyLjVjMC0xLjktMS0yLjgtMy4xLTIuOGgtMS41djUuN2gxLjVcIiArICcgJyArXG4gICAgICAgICAgXCJDMjI5LjIsMTUuNCwyMzAuMiwxNC40LDIzMC4yLDEyLjV6IE0yMjcuMSwzMS40YzMuMSwwLDQuNy0xLjIsNC43LTMuNmMwLTIuNC0xLjYtMy42LTQuNy0zLjZoLTEuNXY3LjJIMjI3LjF6XCJ9XG4gICAgICAgICksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7ZDogXCJNMjQ4LjMsMEwyNjIsMHYzMC4zaDExLjN2MTAuOGgtMjVWMHogTTI2OS45LDM2LjJ2LTEuNWgtMTMuOFY0LjloLTEuNnYzMS4zSDI2OS45elwifSksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgICAgZDogXCJNMjc1LjMsMGwyNC4yLDB2MTAuOGgtMTEuMXY0LjZoMTAuOXYxMC4yaC0xMC45djQuN0gzMDB2MTAuOGgtMjQuN1YweiBNMjk1LjQsMzYuMnYtMS41aC0xMi4zVjIxLjJoMTEuN1wiICsgJyAnICtcbiAgICAgICAgICBcInYtMS41aC0xMS43VjYuNGgxMi4zVjQuOWgtMTMuOXYzMS4zSDI5NS40elwifVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfSxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvZ287XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgU1ZHU2V0ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiBcIlNWR1NldFwiLFxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7Y2xhc3NOYW1lOiBcInN2Z1wiLCBzdHlsZTogdGhpcy5wcm9wcy5zdHlsZSwgdmlld0JveDogXCIwIDAgMzAwIDQyLjJcIn0sIFxuICAgICAgICB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgICApXG4gICAgKTtcbiAgfSxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNWR1NldDtcbiIsIm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLkltbXV0YWJsZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLlJlYWN0O1xuIl19"}